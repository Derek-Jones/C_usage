
#ifndef _STL_FUNCTIONAL_
#define _STL_FUNCTIONAL_

namespace std
{

   // 20.3.1 base:
   template<class A, class R>
   struct unary_function
   {
      typedef A argument_type;
      typedef R result_type;
   };

   template<class A1, class A2, class R>
   struct binary_function
   {
      typedef A1 first_argument_type;
      typedef A2 second_argument_type;
      typedef R  result_type;
   };

   // 20.3.2 arithmetic operations:
   template<class T>
   struct plus : public binary_function<T, T, T>
   {
      T operator()(const T&, const T&) const;
   };

   template<class T>
   struct minus : public binary_function<T, T, T>
   {
      T operator()(const T&, const T&) const;
   };

   template<class T>
   struct multiplies : public binary_function<T, T, T>
   {
      T operator()(const T&, const T&) const;
   };

   template<class T>
   struct divides : public binary_function<T, T, T>
   {
      T operator()(const T&, const T&) const;
   };

   template<class T>
   struct modulus : public binary_function<T, T, T>
   {
      T operator()(const T&, const T&) const;
   };

   template<class T>
   struct negate : public unary_function<T, T>
   {
      T operator()(const T&) const;
   };

   // 20.3.3 comparisons:
   template<class T>
   struct equal_to : public binary_function<T, T, bool>
   {
      bool operator()(const T&, const T&) const;
   };

   template<class T>
   struct not_equal_to : public binary_function<T, T, bool>
   {
      bool operator()(const T&, const T&) const;
   };

   template<class T>
   struct greater : public binary_function<T, T, bool>
   {
      bool operator()(const T&, const T&) const;
   };

   template<class T>
   struct less : public binary_function<T, T, bool>
   {
      bool operator()(const T&, const T&) const;
   };

   template<class T>
   struct greater_equal : public binary_function<T, T, bool>
   {
      bool operator()(const T&, const T&) const;
   };

   template<class T>
   struct less_equal : public binary_function<T, T, bool>
   {
      bool operator()(const T&, const T&) const;
   };

   // 20.3.4 logical operations:
   template<class T>
   struct logical_and : public binary_function<T, T, bool>
   {
      bool operator()(const T&, const T&) const;
   };

   template<class T>
   struct logical_or : public binary_function<T, T, bool>
   {
      bool operator()(const T&, const T&) const;
   };

   template<class T>
   struct logical_not : public unary_function<T, bool>
   {
      bool operator()(const T&) const;
   };

   // 20.3.5 negators:
   template<class P>
   struct unary_negate : public unary_function<typename P::argument_type, bool>
   {
      explicit unary_negate(const P&);
      bool operator()(const typename P::argument_type&) const;
   };

   template<class P>
   unary_negate<P> not1(const P&);

   template<class P>
   struct binary_negate : public binary_function<typename P::first_argument_type,
      typename P::second_argument_type, bool>
   {
      explicit binary_negate(const P&);
      bool operator()(const typename P::first_argument_type&,
         const  typename P::second_argument_type&) const;
   };

   template<class P>
   binary_negate<P> not2(const P&);
   template<class Predicate>
   binary_negate<Predicate> not2(const Predicate&);
   
   // 20.3.6 binders:
   template<class O>
   struct binder1st : public unary_function<typename O::second_argument_type,
      typename O::result_type>
   {
   protected:
      O op;
      typename O::first_argument_type value;
   public:
      binder1st(const O&, const typename O::first_argument_type&);
      typename O::result_type operator()(const typename O::second_argument_type&) const;
   };

   template<class O, class T>
   binder1st<O> bind1st(const O&, const T&);

   template<class O>
   struct binder2nd : public unary_function<typename O::first_argument_type,
      typename O::result_type>
   {
   protected:
      O op;
      typename O::second_argument_type value;
   public:
      binder2nd(const O&, const typename O::second_argument_type&);
      typename O::result_type operator()(const typename O::first_argument_type&) const;
   };

   template<class O, class T>
   binder2nd<O> bind2nd(const O&, const T&);

   // 20.3.7 adaptors:

   template<class A, class R>
   struct pointer_to_unary_function : public unary_function<A, R>
   {
      explicit pointer_to_unary_function(R (*f)(A));
      R operator()(A) const;
   };

   template<class A, class R>
   pointer_to_unary_function<A,R> ptr_fun(R (*f)(A));

   template<class A1, class A2, class R>
   struct pointer_to_binary_function : public binary_function<A1,A2,R>
   {
      explicit pointer_to_binary_function(R (*f)(A1, A2));
      R operator()(A1, A2) const;
   };

   template<class A1, class A2, class R>
   pointer_to_binary_function<A1,A2,R> ptr_fun(R (*f)(A1, A2));

   // 20.3.8 adaptors:

   template<class S, class T>
   struct mem_fun_t : public unary_function<T*, S>
   {
      explicit mem_fun_t(S (T::*p)());
      S operator()(T*) const;
   };

   template<class S, class T, class A>
   struct mem_fun1_t : public binary_function<T*, A, S>
   {
      explicit mem_fun1_t(S (T::*p)(A));
      S operator()(T*, A) const;
   };

   template<class S, class T>
   mem_fun_t<S, T> mem_fun(S (T::*f)());

   template<class S, class T, class A>
   mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));

   template<class S, class T>
   struct mem_fun_ref_t : public unary_function<T, S>
   {
      explicit mem_fun_ref_t(S (T::*p)());
      S operator()(T&) const;
   };

   template<class S, class T, class A>
   struct mem_fun1_ref_t : public binary_function<T, A, S>
   {
      explicit mem_fun1_ref_t(S (T::*p)(A));
      S operator()(T&, A) const;
   };

   template<class S, class T>
   mem_fun_ref_t<S, T> mem_fun_ref(S (T::*f)());

   template<class S, class T, class A>
   mem_fun1_ref_t<S, T, A> mem_fun_ref(S (T::*f)(A));

   template<class S, class T>
   struct const_mem_fun_t : public unary_function<T*, S>
   {
      explicit const_mem_fun_t(S (T::*p)() const);
      S operator()(const T*) const;
   };

   template<class S, class T, class A>
   struct const_mem_fun1_t : public binary_function<T*, A, S>
   {
      explicit const_mem_fun1_t(S (T::*p)(A) const);
      S operator()(const T*, A) const;
   };

   template<class S, class T>
   const_mem_fun_t<S, T> mem_fun(S (T::*f)() const);

   template<class S, class T, class A>
   const_mem_fun1_t<S, T, A> mem_fun(S (T::*f)(A) const);

   template<class S, class T>
   struct const_mem_fun_ref_t : public unary_function<T, S>
   {
      explicit const_mem_fun_ref_t(S (T::*p)() const);
      S operator()(const T&) const;
   };

   template<class S, class T, class A>
   struct const_mem_fun1_ref_t : public binary_function<T, A, S>
   {
      explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
      S operator()(const T&, A) const;
   };

   template<class S, class T>
   const_mem_fun_ref_t<S, T> mem_fun_ref(S (T::*f)() const);

   template<class S, class T, class A>
   const_mem_fun1_ref_t<S, T, A> mem_fun_ref(S (T::*f)(A) const);

} // end namespace std

#endif

