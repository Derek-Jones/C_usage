#ifndef _ITERATOR_
#define _ITERATOR_

#include <cstddef>
//#include <iosfwd>

namespace std {

   struct input_iterator_tag {};
   struct output_iterator_tag {};
   struct forward_iterator_tag : public input_iterator_tag {};
   struct bidirectional_iterator_tag : public forward_iterator_tag {};
   struct random_access_iterator_tag : public bidirectional_iterator_tag {};

   template<class Iterator> struct iterator_traits {
      typedef typename Iterator::difference_type difference_type;
      typedef typename Iterator::value_type value_type;
      typedef typename Iterator::pointer pointer;
      typedef typename Iterator::reference reference;
      typedef typename Iterator::iterator_category iterator_category;
   };
   
   template<class T> struct iterator_traits<T*> {
      typedef ptrdiff_t difference_type;
      typedef T value_type;
      typedef T* pointer;
      typedef T& reference;
      typedef random_access_iterator_tag iterator_category;
   };

   template<class T> struct iterator_traits<const T*> {
      typedef ptrdiff_t difference_type;
      typedef T value_type;
      typedef const T* pointer;
      typedef const T& reference;
      typedef random_access_iterator_tag iterator_category;
   };

   template<class Category, class T, class Distance = ptrdiff_t,
            class Pointer = T*, class Reference = T&> struct iterator {
      typedef T value_type;
      typedef Distance difference_type;
      typedef Pointer pointer;
      typedef Reference reference;
      typedef Category iterator_category;
   };

   template<class InputIterator, class Distance>
   void
   advance(InputIterator& i, Distance n );

   template<class InputIterator>
   typename iterator_traits<InputIterator>::difference_type
   distance(InputIterator first, InputIterator last);

   template<class Iterator>
   class reverse_iterator : public
   iterator<typename iterator_traits<Iterator>::iterator_category,
            typename iterator_traits<Iterator>::value_type,
            typename iterator_traits<Iterator>::difference_type,
            typename iterator_traits<Iterator>::pointer,
            typename iterator_traits<Iterator>::reference> {
   protected:
      Iterator current;
   public:
      typedef Iterator iterator_type;
      typedef typename iterator_traits<Iterator>::difference_type difference_type;
      typedef typename iterator_traits<Iterator>::reference reference;
      typedef typename iterator_traits<Iterator>::pointer pointer;

      reverse_iterator();
      explicit reverse_iterator(Iterator x);
      template<class U> reverse_iterator(const reverse_iterator<U>& u);

      Iterator
      base() const;
      reference
      operator*() const;
      pointer
      operator->() const;

      reverse_iterator&
      operator++();
      reverse_iterator
      operator++(int);
      reverse_iterator
      operator--();
      reverse_iterator
      operator--(int);

      reverse_iterator
      operator+(difference_type n) const;
      reverse_iterator&
      operator+=(difference_type n);
      reverse_iterator
      operator-(difference_type n) const;
      reverse_iterator&
      operator-=(difference_type n);

      reference
      operator[](difference_type n) const;
   };

   template<class Iterator>
   bool
   operator==(const reverse_iterator<Iterator>& x,
              const reverse_iterator<Iterator>& y);

   template<class Iterator>
   bool
   operator<(const reverse_iterator<Iterator>& x,
             const reverse_iterator<Iterator>& y);

   template<class Iterator>
   bool
   operator!=(const reverse_iterator<Iterator>& x,
              const reverse_iterator<Iterator>& y);

   template<class Iterator>
   bool
   operator>(const reverse_iterator<Iterator>& x,
             const reverse_iterator<Iterator>& y);
   
   template<class Iterator>
   bool
   operator>=(const reverse_iterator<Iterator>& x,
              const reverse_iterator<Iterator>& y);

   template<class Iterator>
   bool
   operator<=(const reverse_iterator<Iterator>& x,
              const reverse_iterator<Iterator>& y);

   template<class Iterator>
   typename reverse_iterator<Iterator>::difference_type
   operator-(const reverse_iterator<Iterator>& x,
             const reverse_iterator<Iterator>& y);   

   template<class Iterator>
   reverse_iterator<Iterator>
   operator+(typename reverse_iterator<Iterator>::difference_type n,
             const reverse_iterator<Iterator>& x);

   template<class Container>
   class back_insert_iterator :
      public iterator<output_iterator_tag,void,void,void,void> {
   protected:
      Container* container;

   public:
      typedef Container container_type;
      explicit back_insert_iterator(Container& x);

      back_insert_iterator<Container>&
      operator=(typename Container::const_reference value);

      back_insert_iterator<Container>&
      operator*();
      back_insert_iterator<Container>&
      operator++();      
      back_insert_iterator<Container>&
      operator++(int);      
   };

   template<class Container>
   back_insert_iterator<Container>
   back_inserter(Container& x);

   template<class Container>
   class front_insert_iterator 
    : public iterator<output_iterator_tag,void,void,void,void> {
   protected:
      Container* container;

   public:
      typedef Container container_type;
      explicit front_insert_iterator(Container& x);
      front_insert_iterator<Container>&
      operator=(typename Container::const_reference value);

      front_insert_iterator<Container>&
      operator*();
      front_insert_iterator<Container>&
      operator++();
      front_insert_iterator<Container>&
      operator++(int);
   };

   template<class Container>
   front_insert_iterator<Container>
   front_inserter(Container& x);

   template<class Container>
   class insert_iterator : public iterator<output_iterator_tag,void,void,void,void> {
   protected:
      Container* container;
      typename Container::iterator iter;

   public:
      typedef Container container_type;
      insert_iterator(Container& x, typename Container::iterator i);
      insert_iterator<Container>&
      operator=(typename Container::const_reference value);

      insert_iterator<Container>& operator*();
      insert_iterator<Container>& operator++();
      insert_iterator<Container>& operator++(int);
   };

   template<class Container, class Iterator>
   insert_iterator<Container>
   inserter(Container& x, Iterator i);
} // namespace std

#include <iosfwd>
//#include <istream>

namespace std
{
   template<class T, class charT = char, class traits = char_traits<charT>,
            class Distance = ptrdiff_t>
   class istream_iterator : public iterator<input_iterator_tag, T, Distance, const T*, const T&> {
   public:
      typedef charT char_type;
      typedef traits traits_type;
      typedef basic_istream<charT, traits> istream_type;
      istream_iterator();
      istream_iterator(istream_type& s);
      istream_iterator( const istream_iterator<T,charT,traits,Distance>& x);
      ~istream_iterator();

      const T&
      operator*() const;
      const T*
      operator->() const;
      istream_iterator<T,charT,traits,Distance>&
      operator++();
      istream_iterator<T,charT,traits,Distance>&
      operator++(int);
   };

   template<class T, class charT, class traits, class Distance>
   bool
   operator==( const istream_iterator<T, charT, traits, Distance>& x,
               const istream_iterator<T, charT, traits, Distance>& y);

   template<class T, class charT, class traits, class Distance>
   bool
   operator!=( const istream_iterator<T, charT, traits, Distance>& x,
               const istream_iterator<T, charT, traits, Distance>& y);

   template<class T, class charT = char, class traits = char_traits<charT> >
   class ostream_iterator : public iterator<output_iterator_tag, void, void, void, void> {
   public:
      typedef charT char_type;
      typedef traits traits_type;
      typedef basic_ostream<charT,traits> ostream_type;
      ostream_iterator(ostream_type& s);
      ostream_iterator(ostream_type& s, const charT* delimiter);
      ostream_iterator(const ostream_iterator<T,charT,traits>& x);
      ~ostream_iterator();
      ostream_iterator<T,charT,traits>&
      operator=(const T& value);

      ostream_iterator<T,charT,traits>&
      operator*();
      ostream_iterator<T,charT,traits>&
      operator++();
      ostream_iterator<T,charT,traits>&
      operator++(int);
   };

   template<class charT, class traits/* = char_traits<charT>*/>
   class istreambuf_iterator : public iterator<input_iterator_tag, charT,
                        typename traits::off_type, charT*, charT&> {
   public:
      typedef charT char_type;
      typedef traits traits_type;
      typedef typename traits::int_type int_type;
      typedef basic_streambuf<charT,traits> streambuf_type;
      typedef basic_istream<charT,traits> istream_type;

      class proxy {
      public:
         charT operator*();
      };
      
      istreambuf_iterator() throw();
      istreambuf_iterator(istream_type& s) throw();
      istreambuf_iterator(streambuf_type* s) throw();
      istreambuf_iterator(const proxy& p) throw();
      charT
      operator*() const;
      istreambuf_iterator<charT, traits>&
      operator++();
      proxy
      operator++(int);
      bool
      equal(istreambuf_iterator& b);
   };

   template<class charT, class traits>
   bool operator==( const istreambuf_iterator<charT, traits>& a,
                    const istreambuf_iterator<charT, traits>& b);

   template<class charT, class traits>
   bool operator!=( const istreambuf_iterator<charT, traits>& a,
                    const istreambuf_iterator<charT, traits>& b);

   template <class charT, class traits/* = char_traits<charT>*/>
   class ostreambuf_iterator : public iterator<output_iterator_tag, void, void, void, void> {
   public:
      typedef charT char_type;
      typedef traits traits_type;
      typedef basic_streambuf<charT,traits> streambuf_type;
      typedef basic_ostream<charT,traits> ostream_type;

      ostreambuf_iterator(ostream_type& s) throw();
      ostreambuf_iterator(streambuf_type* s) throw();
      ostreambuf_iterator& operator=(charT c);

      ostreambuf_iterator&
      operator*();
      ostreambuf_iterator&
      operator++();
      ostreambuf_iterator&
      operator++(int);

      bool failed() const throw();
   };
}
#endif
