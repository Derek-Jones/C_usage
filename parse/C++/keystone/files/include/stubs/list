
#ifndef _STL_LIST_
#define _STL_LIST_

#include "allocator.h"
#include <iterator>

namespace std
{

   template
   <
      class T,
      class Allocator = allocator<T>
   >
   class list
   {
   public:
      // types:
      typedef typename Allocator::reference reference;
      typedef typename Allocator::const_reference const_reference;

      // non-standard, but iterators are implemented defined:
      typedef T* ListIterator;
      typedef ListIterator iterator;
      //typedef const ListIterator const_iterator;
      typedef T const* const_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      // end - impl dependent
      typedef T value_type;
      typedef Allocator allocator_type;
      typedef typename Allocator::pointer pointer;
      typedef typename Allocator::const_pointer const_pointer;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

      // 23.2.2.1, construct/copy/destroy:
      explicit list(const Allocator& = Allocator());
      explicit list(size_type, const T& = T(), const Allocator& = Allocator());
      template<class InputIter>
      list(InputIter, InputIter, const Allocator& = Allocator());
      list(const list<T, Allocator>&);
      ~list();
      list<T, Allocator>& operator=(const list<T, Allocator>&);
      template<class InputIter>
      void assign(InputIter, InputIter);
      void assign(size_type, const T&);
      allocator_type get_allocator() const;

      // iterators
      iterator begin();
      const_iterator begin() const;
      iterator end();
      const_iterator end() const;
      reverse_iterator rbegin();
      const_reverse_iterator rbegin() const;
      reverse_iterator rend();
      const_reverse_iterator rend() const;

      // 23.2.2.2, capacity:
      bool empty() const;
      size_type size() const;
      size_type max_size() const;
      void resize(size_type, T = T());

      // element access:
      reference front();
      const_reference front() const;
      reference back();
      const_reference back() const;

      // 23.2.1.3, modifiers:
      void push_front(const T&);
      void pop_front();
      void push_back(const T&);
      void pop_back();

      iterator insert(iterator, const T&);
      void insert(iterator, size_type, const T&);
      template<class InputIter>
      void insert(iterator, InputIter, InputIter);

      iterator erase(iterator);
      iterator erase(iterator, iterator);
      void swap(list<T, Allocator>&);
      void clear();

      // 23.2.2.4, list operations:
      void splice(iterator, list<T, Allocator>&);
      void splice(iterator, list<T, Allocator>&, iterator);
      void splice(iterator, list<T, Allocator>&, iterator, iterator);

      void remove(const T&);
      template<class Predicate> void remove_if(Predicate);

      void unique();
      template<class BinaryPredicate> void unique(BinaryPredicate);

      void merge(list<T, Allocator>&);
      template<class Compare> void unique(list<T, Allocator>&, Compare);

      void sort();
      template<class Compare> void sort(Compare);

      void reverse();
   };

   template<class T, class A>
   bool operator==(const list<T, A>&, const list<T, A>&);
   template<class T, class A>
   bool operator!=(const list<T, A>&, const list<T, A>&);
   template<class T, class A>
   bool operator<(const list<T, A>&, const list<T, A>&);
   template<class T, class A>
   bool operator<=(const list<T, A>&, const list<T, A>&);
   template<class T, class A>
   bool operator>(const list<T, A>&, const list<T, A>&);
   template<class T, class A>
   bool operator>=(const list<T, A>&, const list<T, A>&);

   // specialized algorithms:
   template<class T, class A>
   void swap(list<T, A>&, list<T, A>&);

} // end namespace std

#endif

