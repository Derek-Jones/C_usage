leftout != leftend ) 
channels [ INT_CONST ] ) 
channels [ INT_CONST ] ) 
channels [ INT_CONST ] ) 
dl > INT_CONST ) 
STRING ) 
strlen ( doomwaddir ) + INT_CONST + INT_CONST + INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMSFX ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST && channels [ i ] ; i v++ ) 
UNSIGNED CHAR *p ) 
volume * seperation * seperation ) 
rightvol < INT_CONST || rightvol > INT_CONST ) 
FOR ( i = INT_CONST ; NEW_LINE i < SIZEOF ( channels ) / SIZEOF ( UNSIGNED CHAR *p ) ; NEW_LINE i v++ ) 
FOR ( i = -v INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
&v fdset ) 
! waitingtofinish ) 
) 
waitingtofinish ) 
FOR ( i = INT_CONST ; i < INT_CONST && ! channels [ i ] ; i v++ ) 
__E__O__F__
__E__O__F__
wadfile , &v header , SIZEOF header ) 
header . numlumps ) 
FOR ( i = INT_CONST ; i < numlumps ; i v++ ) 
FOR ( i = INT_CONST ; i < numlumps ; i v++ ) 
FOR ( i = size ; i < paddedsize + INT_CONST ; i v++ ) 
VOID *p ) 
__E__O__F__
__E__O__F__
filename , ( VOID *p *p ) & raw ) 
pcx_t * ) 
pcx -> manufacturer != INT_CONST NEW_LINE || pcx -> version != INT_CONST NEW_LINE || pcx -> encoding != INT_CONST NEW_LINE || pcx -> bits_per_pixel != INT_CONST NEW_LINE || pcx -> xmax >= INT_CONST NEW_LINE || pcx -> ymax >= INT_CONST ) 
( pcx -> ymax + INT_CONST ) * ( pcx -> xmax + INT_CONST ) ) 
palette ) 
width ) 
FOR ( y = INT_CONST ; y <= pcx -> ymax ; y v++ , pix += pcx -> xmax + INT_CONST ) 
FOR ( x = INT_CONST ; x <= pcx -> xmax ; ) 
raw - ( byte * ) pcx > len ) 
pcx ) 
cin . pic ) 
cin . restart_sound ) 
&v cls . netchan . message , clc_stringcmd ) 
FOR ( i = INT_CONST ; i < numhnodes ; i v++ ) 
bestnode == -v INT_CONST ) 
INT_CONST * INT_CONST * INT_CONST * INT_CONST ) 
FOR ( prev = INT_CONST ; prev < INT_CONST ; prev v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
in . data [ INT_CONST ] << INT_CONST ) 
count ) 
input - in . data != in . count && input - in . data != in . count + INT_CONST ) 
&v command , INT_CONST , INT_CONST , cl . cinematic_file ) 
&v command , INT_CONST , INT_CONST , cl . cinematic_file ) 
cl . cinematicpalette , SIZEOF ( cl . cinematicpalette ) , cl . cinematic_file ) 
&v size , INT_CONST , cl . cinematic_file ) 
cl . cinematicframe + INT_CONST ) 
samples , count * cin . s_width * cin . s_channels , cl . cinematic_file ) 
count , cin . s_rate , cin . s_width , cin . s_channels , samples ) 
in ) 
cl . cinematictime <= INT_CONST ) 
cl . cinematicframe == -v INT_CONST ) 
cls . realtime - cl . cinematictime ) 
cls . key_dest == key_menu ) 
NULL ) 
! cl . cinematicpalette_active ) 
! cin . pic ) 
) 
arg , STRING ) 
name , SIZEOF ( name ) , STRING , arg ) 
name , SIZEOF ( name ) , STRING , arg ) 
) 
&v width , INT_CONST , cl . cinematic_file ) 
&v cin . s_rate , INT_CONST , cl . cinematic_file ) 
) 
STRING ) 
) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAX_PROJECTILES ; i v++ ) 
&v net_message ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( j = INT_CONST ; j < MAX_PROJECTILES ; j v++ ) 
&v ent , INT_CONST , SIZEOF ( ent ) ) 
FOR ( i = INT_CONST , pr = cl_projectiles ; i < MAX_PROJECTILES ; i v++ , pr v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
&v net_message ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
from -> origin , to -> old_origin ) 
bits & U_MODEL ) 
&v net_message ) 
MAX_PARSE_ENTITIES - INT_CONST ) 
old , state , newnum , bits ) 
state -> modelindex != ent -> current . modelindex NEW_LINE || state -> modelindex2 != ent -> current . modelindex2 NEW_LINE || state -> modelindex3 != ent -> current . modelindex3 NEW_LINE || state -> modelindex4 != ent -> current . modelindex4 NEW_LINE || abs ( state -> origin [ INT_CONST ] - ent -> current . origin [ INT_CONST ] ) > INT_CONST NEW_LINE || abs ( state -> origin [ INT_CONST ] - ent -> current . origin [ INT_CONST ] ) > INT_CONST NEW_LINE || abs ( state -> origin [ INT_CONST ] - ent -> current . origin [ INT_CONST ] ) > INT_CONST NEW_LINE || state -> event == EV_PLAYER_TELEPORT NEW_LINE || state -> event == EV_OTHER_TELEPORT NEW_LINE ) 
ent -> serverframe != cl . frame . serverframe - INT_CONST ) 
state -> event == EV_OTHER_TELEPORT ) 
! oldframe ) 
INT_CONST ) 
oldnum != INT_CONST ) 
cl_shownet -> value == INT_CONST ) 
oldframe ) 
flags & PS_M_TYPE ) 
flags & PS_M_VELOCITY ) 
flags & PS_M_TIME ) 
cl . attractloop ) 
flags & PS_VIEWOFFSET ) 
flags & PS_VIEWANGLES ) 
flags & PS_KICKANGLES ) 
flags & PS_WEAPONINDEX ) 
flags & PS_WEAPONFRAME ) 
flags & PS_BLEND ) 
flags & PS_FOV ) 
&v net_message ) 
FOR ( i = INT_CONST ; i < MAX_STATS ; i v++ ) 
FOR ( pnum = INT_CONST ; pnum < frame -> num_entities ; pnum v++ ) 
&v cl . frame , INT_CONST , SIZEOF ( cl . frame ) ) 
) 
&v net_message ) 
cls . serverProtocol != INT_CONST ) 
cl . frame . deltaframe <= INT_CONST ) 
cl . time > cl . frame . servertime ) 
&v net_message ) 
&v net_message ) 
&v net_message ) 
cmd == svc_packetentities2 ) 
cl . frame . valid ) 
cl . configstrings [ n ] [ INT_CONST ] ) 
! model [ INT_CONST ] ) 
cl . time / INT_CONST ) 
&v ent , INT_CONST , SIZEOF ( ent ) ) 
FOR ( pnum = INT_CONST ; pnum < frame -> num_entities ; pnum v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! ent . skin || ! ent . model ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v ent ) 
ent . origin , intensity , -v FLOAT_CONST , -v FLOAT_CONST , -v FLOAT_CONST ) 
! cl_gun -> value ) 
ps -> fov > INT_CONST ) 
gun_model ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
gun_frame ) 
gun . origin , gun . oldorigin ) 
&v gun ) 
cl . frame . serverframe - INT_CONST ) 
fabs ( ops -> pmove . origin [ INT_CONST ] - ps -> pmove . origin [ INT_CONST ] ) > INT_CONST * INT_CONST NEW_LINE || abs ( ops -> pmove . origin [ INT_CONST ] - ps -> pmove . origin [ INT_CONST ] ) > INT_CONST * INT_CONST NEW_LINE || abs ( ops -> pmove . origin [ INT_CONST ] - ps -> pmove . origin [ INT_CONST ] ) > INT_CONST * INT_CONST ) 
( cl_predict -> value ) && ! ( cl . frame . playerstate . pmove . pm_flags & PMF_NO_PREDICTION ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . frame . playerstate . pmove . pm_type < PM_DEAD ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ps -> fov - ops -> fov ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ps , ops ) 
&v cl . frame ) 
ent < INT_CONST || ent >= MAX_EDICTS ) 
__E__O__F__
ofs == lastofs ) 
FOR ( i = INT_CONST , ls = cl_lightstyle ; i < MAX_LIGHTSTYLES ; i v++ , ls v++ ) 
s ) 
FOR ( k = INT_CONST ; k < j ; k v++ ) 
FOR ( i = INT_CONST , ls = cl_lightstyle ; i < MAX_LIGHTSTYLES ; i v++ , ls v++ ) 
key ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
dl , INT_CONST , SIZEOF ( *v dl ) ) 
key ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
&v net_message ) 
i ) 
silenced ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
soundname , SIZEOF ( soundname ) , STRING , ( rand ( ) % INT_CONST ) + INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
NULL , i , CHAN_WEAPON , S_RegisterSound ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
&v net_message ) 
cl_entities [ ent ] . current . angles , forward , right , NULL ) 
ent ) 
flash_number ) 
origin , vec3_origin , INT_CONST , INT_CONST ) 
origin , vec3_origin , INT_CONST , INT_CONST ) 
origin , vec3_origin , INT_CONST , INT_CONST ) 
origin , vec3_origin , INT_CONST , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
origin ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
origin , vec3_origin , INT_CONST , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
origin , vec3_origin , INT_CONST , INT_CONST ) 
origin , vec3_origin , INT_CONST , INT_CONST ) 
origin , vec3_origin , INT_CONST , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
rand ( ) & INT_CONST ) 
vidref_val == VIDREF_GL ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
FOR ( i = INT_CONST ; i < cl_numparticles ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , INT_CONST , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , INT_CONST , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , INT_CONST , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , dec , vec ) 
old -> trailcount > INT_CONST ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
right , forward ) 
start , end , old , EF_ROCKET ) 
start , move ) 
vec , dec , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , right , up ) 
FOR ( i = INT_CONST ; i < len ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
vec , dec , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , INT_CONST , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , dec , vec ) 
FOR ( i = INT_CONST ; i < len ; i += dec ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
count > NUMVERTEXNORMALS ) 
FOR ( i = INT_CONST ; i < NUMVERTEXNORMALS * INT_CONST ; i v++ ) 
FLOAT ) 
FOR ( i = INT_CONST ; i < count ; i += INT_CONST ) 
ent -> fly_stoptime < cl . time ) 
n < INT_CONST ) 
origin , count ) 
FOR ( i = INT_CONST ; i < NUMVERTEXNORMALS * INT_CONST ; i v++ ) 
FLOAT ) 
FOR ( i = INT_CONST ; i < NUMVERTEXNORMALS ; i v++ ) 
ent -> origin , start ) 
start , move ) 
vec , INT_CONST , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
ent -> origin , org ) 
FOR ( i = -v INT_CONST ; i <= INT_CONST ; i += INT_CONST ) 
FOR ( j = -v INT_CONST ; j <= INT_CONST ; j += INT_CONST ) 
FOR ( k = -v INT_CONST ; k <= INT_CONST ; k += INT_CONST ) 
rand ( ) & INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = -v INT_CONST ; i <= INT_CONST ; i += INT_CONST ) 
FOR ( j = -v INT_CONST ; j <= INT_CONST ; j += INT_CONST ) 
FOR ( k = -v INT_CONST ; k <= INT_CONST ; k += INT_CONST ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
FOR ( p = active_particles ; p ; p = next ) 
p -> alphavel == INSTANT_PARTICLE ) 
NULL , ent -> number , CHAN_WEAPON , S_RegisterSound ( STRING ) , INT_CONST , ATTN_IDLE , INT_CONST ) 
cl_footsteps -> value ) 
NULL , ent -> number , CHAN_AUTO , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent -> number , CHAN_AUTO , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
NULL , ent -> number , CHAN_AUTO , S_RegisterSound ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
__E__O__F__
INT_CONST ) 
INT_CONST ) 
b -> down [ INT_CONST ] == k ) 
INT_CONST ) 
key -> state ) 
msec ) 
cmd , INT_CONST , SIZEOF ( *v cmd ) ) 
&v in_moveright ) 
&v in_up ) 
! ( in_klook . state & INT_CONST ) ) 
( in_speed . state & INT_CONST ) ^ ( INT ) ( cl_run -> value ) ) 
cl . frame . playerstate . pmove . delta_angles [ PITCH ] ) 
in_attack . state & INT_CONST ) 
anykeydown && cls . key_dest == key_game ) 
ms > INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
byte ) 
frame_msec < INT_CONST ) 
&v cmd ) 
&v cmd ) 
STRING , IN_UpDown ) 
STRING , STRING , INT_CONST ) 
CMD_BACKUP - INT_CONST ) 
) 
cls . state == ca_disconnected || cls . state == ca_connecting ) 
userinfo_modified ) 
&v buf , data , SIZEOF ( data ) ) 
cmd -> buttons && cl . cinematictime > INT_CONST && ! cl . attractloop NEW_LINE && cls . realtime - cl . cinematictime > INT_CONST ) 
) 
&v buf , clc_move ) 
&v buf , INT_CONST ) 
cl_nodelta -> value || ! cl . frame . valid || cls . demowaiting ) 
cls . netchan . outgoing_sequence - INT_CONST ) 
cls . netchan . outgoing_sequence - INT_CONST ) 
cls . netchan . outgoing_sequence ) 
NEW_LINE buf . data + checksumIndex + INT_CONST , buf . cursize - checksumIndex - INT_CONST , NEW_LINE cls . netchan . outgoing_sequence ) 
&v cls . netchan , buf . cursize , buf . data ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAX_ITEMS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_ITEMS ; i v++ ) 
num - top < DISPLAY_ITEMS ) 
) 
x , y + INT_CONST , STRING ) 
x , y , STRING ) 
FOR ( i = top ; i < num && i < top + DISPLAY_ITEMS ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
__E__O__F__
len ) 
! cls . demorecording ) 
&v len , INT_CONST , INT_CONST , cls . demofile ) 
Cmd_Argc ( ) != INT_CONST ) 
cls . demorecording ) 
cls . state != ca_active ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , Cmd_Argv ( INT_CONST ) ) 
STRING , name ) 
&v buf , buf_data , SIZEOF ( buf_data ) ) 
&v buf , svc_serverdata ) 
&v buf , cl . gamedir ) 
&v buf , cl . configstrings [ CS_NAME ] ) 
FOR ( i = INT_CONST ; i < MAX_CONFIGSTRINGS ; i v++ ) 
&v nullstate , INT_CONST , SIZEOF ( nullstate ) ) 
FOR ( i = INT_CONST ; i < MAX_EDICTS ; i v++ ) 
&v buf , svc_stufftext ) 
buf . cursize ) 
INT_CONST ) 
&v cls . netchan . message , clc_stringcmd ) 
argc > INT_CONST ) 
buffer , Cmd_Argv ( INT_CONST ) ) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
Cvar_VariableValue ( STRING ) > INT_CONST || ! Com_ServerState ( ) ) 
STRING , ! cl_paused -> value ) 
cls . disable_servercount != -v INT_CONST ) 
! NET_StringToAdr ( cls . servername , &v adr ) ) 
NS_CLIENT , adr , STRING , NEW_LINE PROTOCOL_VERSION , port , cls . challenge , Cvar_Userinfo ( ) ) 
cls . state == ca_disconnected && Com_ServerState ( ) ) 
cls . state != ca_connecting ) 
STRING , cls . servername ) 
NS_CLIENT , adr , STRING ) 
Cmd_Argc ( ) != INT_CONST ) 
Com_ServerState ( ) ) 
va ( STRING , msg ) , false ) 
INT_CONST ) 
true ) 
) 
cls . servername , server , SIZEOF ( cls . servername ) - INT_CONST ) 
! rcon_client_password -> string ) 
CHAR ) 
true ) 
message , STRING ) 
message , rcon_client_password -> string ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
cls . state >= ca_connected ) 
STRING ) 
&v cl , INT_CONST , SIZEOF ( cl ) ) 
&v cls . netchan . message ) 
cls . state == ca_disconnected ) 
cl . refdef . blend ) 
) 
) 
cls . demorecording ) 
( CHAR *p ) final + INT_CONST , STRING ) 
) 
cls . download ) 
Cmd_Argc ( ) != INT_CONST ) 
true ) 
! NET_StringToAdr ( Cmd_Argv ( INT_CONST ) , &v adr ) ) 
in ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
NS_CLIENT , out - send , send , adr ) 
cls . download ) 
STRING ) 
cls . download ) 
*v cls . servername ) 
STRING ) 
&v net_message ) 
STRING , s ) 
true ) 
STRING ) 
STRING , STRING , CVAR_NOSET ) 
STRING , STRING , CVAR_NOSET ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
&v net_message ) 
s , false ) 
INT_CONST ) 
STRING , NET_AdrToString ( net_from ) , c ) 
! strcmp ( c , STRING ) ) 
! strcmp ( c , STRING ) ) 
! strcmp ( c , STRING ) ) 
! strcmp ( c , STRING ) ) 
! strcmp ( c , STRING ) ) 
! strcmp ( c , STRING ) ) 
! strcmp ( c , STRING ) ) 
STRING ) 
cls . state >= ca_connected NEW_LINE && cls . realtime - cls . netchan . last_received > cl_timeout -> value * INT_CONST ) 
VOID ) 
gender_auto -> value ) 
gender -> modified ) 
cls . state != ca_connected ) 
allow_download_maps -> value ) 
precache_check >= CS_PLAYERSKINS && precache_check < CS_PLAYERSKINS + MAX_CLIENTS * PLAYER_MULT ) 
precache_check == ENV_CNT ) 
precache_check > ENV_CNT && precache_check < TEXTURE_CNT ) 
precache_check == TEXTURE_CNT ) 
precache_check == TEXTURE_CNT + INT_CONST ) 
fn , STRING , map_surfaces [ precache_tex v++ ] . rname ) 
) 
&v cls . netchan . message , clc_stringcmd ) 
Cmd_Argc ( ) < INT_CONST ) 
Cmd_Argv ( INT_CONST ) ) 
) 
) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_USERINFO ) 
STRING , STRING , CVAR_USERINFO | CVAR_ARCHIVE ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , CL_ForwardToServer_f ) 
STRING , CL_Userinfo_f ) 
STRING , CL_Changing_f ) 
STRING , CL_Quit_f ) 
STRING , CL_Connect_f ) 
STRING , CL_Rcon_f ) 
STRING , CL_Setenv_f ) 
STRING , CL_Precache_f ) 
STRING , CL_Download_f ) 
STRING , NULL ) 
cls . state == ca_uninitialized ) 
f , STRING ) 
path ) 
! strcmp ( cl . configstrings [ CS_MAXCLIENTS ] , STRING ) NEW_LINE || ! cl . configstrings [ CS_MAXCLIENTS ] [ INT_CONST ] ) 
! numcheatvars ) 
FOR ( i = INT_CONST , var = cheatvars ; i < numcheatvars ; i v++ , var v++ ) 
) 
) 
) 
) 
) 
) 
dedicated -> value ) 
! cl_timedemo -> value ) 
) 
cls . frametime > ( FLOAT_CONST / cl_minfps -> value ) ) 
msec > INT_CONST ) 
) 
) 
) 
) 
host_speeds -> value ) 
cl . refdef . vieworg , cl . v_forward , cl . v_right , cl . v_up ) 
) 
log_stats -> value ) 
) 
) 
) 
) 
) 
) 
) 
__E__O__F__
value1 [ INT_CONST ] ) 
ent ) 
( vidref_val == VIDREF_SOFT ) && ( ( r < INT_CONST ) || ( g < INT_CONST ) || ( b < INT_CONST ) ) ) 
ent ) 
vec , right , up ) 
vec , dec , vec ) 
len > INT_CONST ) 
start , move ) 
vec , spacing , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , INT_CONST , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
) 
FOR ( n = INT_CONST ; n < count ; n v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
) 
FOR ( n = INT_CONST ; n < count ; n v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , dec , vec ) 
FOR ( i = INT_CONST ; i < len ; i += dec ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
cl . v_right , right ) 
vec , step , vec ) 
FOR ( i = INT_CONST ; i < len ; i += step ) 
FOR ( k = -v INT_CONST ; k < INT_CONST ; k += INT_CONST ) 
i < INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , INT_CONST , forward , end ) 
start , move ) 
cl . v_right , right ) 
move , -v FLOAT_CONST , right , move ) 
FLOAT ) 
vec , step , vec ) 
FOR ( i = start_pt ; i < len ; i += step ) 
FOR ( rot = INT_CONST ; rot < M_PI * INT_CONST ; rot += rstep ) 
rand ( ) & INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
cl . v_forward , forward ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
dir , r , u ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
self -> dir , dir ) 
FOR ( i = INT_CONST ; i < self -> count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , forward ) 
vec , INT_CONST , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( ( FLOAT ) self -> endtime - ( FLOAT ) cl . time ) / FLOAT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( ( FLOAT ) self -> endtime - ( FLOAT ) cl . time ) / FLOAT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vec3_t start , vec3_t end , FLOAT color ) 
start , move ) 
vec , INT_CONST , vec ) 
len >= INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
dir , r , u ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
start , move ) 
vec , INT_CONST , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
__E__O__F__
strstr ( filename , STRING ) ) 
FS_LoadFile ( filename , NULL ) != -v INT_CONST ) 
cls . downloadname , filename ) 
cls . downloadname , cls . downloadtempname ) 
name , SIZEOF ( name ) , cls . downloadtempname ) 
name , STRING ) 
fp , INT_CONST , SEEK_END ) 
Cmd_Argc ( ) != INT_CONST ) 
filename , SIZEOF ( filename ) , STRING , Cmd_Argv ( INT_CONST ) ) 
strstr ( filename , STRING ) ) 
FS_LoadFile ( filename , NULL ) != -v INT_CONST ) 
STRING ) 
cls . downloadname , filename ) 
cls . downloadname , cls . downloadtempname ) 
&v cls . netchan . message , clc_stringcmd ) 
) 
FOR ( i = INT_CONST ; i < MAX_SOUNDS ; i v++ ) 
&v net_message ) 
! cls . download ) 
net_message . data + net_message . readcount , INT_CONST , size , cls . download ) 
percent != INT_CONST ) 
STRING ) 
&v net_message ) 
Com_ServerState ( ) && PROTOCOL_VERSION == INT_CONST ) 
&v net_message ) 
( *v str && ( ! fs_gamedirvar -> string || ! *v fs_gamedirvar -> string || strcmp ( fs_gamedirvar -> string , str ) ) ) || ( ! *v str && ( fs_gamedirvar -> string || *v fs_gamedirvar -> string ) ) ) 
&v net_message ) 
&v net_message ) 
cl . playernum == -v INT_CONST ) 
str ) 
&v nullstate , INT_CONST , SIZEOF ( nullstate ) ) 
&v bits ) 
ci -> cinfo , s , SIZEOF ( ci -> cinfo ) ) 
ci -> name , s , SIZEOF ( ci -> name ) ) 
cl_noskins -> value || *v s == INT_CONST ) 
FOR ( i = INT_CONST ; i < num_cl_weaponmodels ; i v++ ) 
! ci -> skin || ! ci -> icon || ! ci -> model || ! ci -> weaponmodel [ INT_CONST ] ) 
ci , s ) 
&v net_message ) 
i >= CS_LIGHTS && i < CS_LIGHTS + MAX_LIGHTSTYLES ) 
&v net_message ) 
flags & SND_VOLUME ) 
&v net_message ) 
flags & SND_POS ) 
&v net_message , pos_v ) 
! cl . sound_precache [ sound_num ] ) 
cl_shownet -> value == INT_CONST ) 
) 
cls . demorecording && ! cls . demowaiting ) 
__E__O__F__
! cl_predict -> value || ( cl . frame . playerstate . pmove . pm_flags & PMF_NO_PREDICTION ) ) 
CMD_BACKUP - INT_CONST ) 
cl . frame . playerstate . pmove . origin , cl . predicted_origins [ frame ] , delta ) 
delta [ INT_CONST ] ) 
cl . prediction_error ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < cl . frame . num_entities ; i v++ ) 
start , end , mins , maxs , INT_CONST , MASK_PLAYERSOLID ) 
start , mins , maxs , end , &v t ) 
point , INT_CONST ) 
FOR ( i = INT_CONST ; i < cl . frame . num_entities ; i v++ ) 
cls . state != ca_active ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
current - ack >= CMD_BACKUP ) 
&v pm , INT_CONST , SIZEOF ( pm ) ) 
cl . configstrings [ CS_AIRACCEL ] ) 
++v ack < current ) 
ack - INT_CONST ) 
pm . viewangles , cl . predicted_angles ) 
__E__O__F__
scr_debuggraph -> value || scr_timegraph -> value ) 
FOR ( i = INT_CONST ; i < cls . netchan . dropped ; i v++ ) 
FOR ( i = INT_CONST ; i < cl . surpressCount ; i v++ ) 
CMD_BACKUP - INT_CONST ) 
x , y - scr_graphheight -> value , NEW_LINE w , scr_graphheight -> value , INT_CONST ) 
FOR ( a = INT_CONST ; a < w ; a v++ ) 
scr_centerstring , str , SIZEOF ( scr_centerstring ) - INT_CONST ) 
*v s ) 
STRING ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( i = INT_CONST ; i < ( INT_CONST - l ) / INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ ) 
scr_center_lines <= INT_CONST ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
scr_viewsize -> value < INT_CONST ) 
viddef . width - scr_vrect . width ) 
Cmd_Argc ( ) < INT_CONST ) 
Cmd_Argv ( INT_CONST ) , rotate , axis ) 
STRING , SCR_TimeRefresh_f ) 
! scr_showpause -> value ) 
! cl_paused -> value ) 
FLOAT_CONST ) 
cls . state != ca_active || ! cl . refresh_prepped ) 
FLOAT_CONST ) 
scr_con_current ) 
) 
cls . state != ca_active ) 
Cmd_Argc ( ) == INT_CONST ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
scr_drawall -> value ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
top >= clear . y1 ) 
clear . y1 < top ) 
clear . x1 , clear . y1 , NEW_LINE clear . x2 - clear . x1 + INT_CONST , i - clear . y1 + INT_CONST , STRING ) 
clear . x1 , i , NEW_LINE clear . x2 - clear . x1 + INT_CONST , clear . y2 - i + INT_CONST , STRING ) 
clear . x1 , clear . y1 , NEW_LINE i - clear . x1 + INT_CONST , clear . y2 - clear . y1 + INT_CONST , STRING ) 
i , clear . y1 , NEW_LINE clear . x2 - i + INT_CONST , clear . y2 - clear . y1 + INT_CONST , STRING ) 
*v string ) 
*v string ) 
FOR ( i = INT_CONST ; i < width ; i v++ ) 
width < INT_CONST ) 
width > INT_CONST ) 
num , SIZEOF ( num ) , STRING , value ) 
*v ptr && l ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
cls . state != ca_active || ! cl . refresh_prepped ) 
s ) 
cls . disable_screen ) 
! scr_initialized || ! con . initialized ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
) 
__E__O__F__
STRING ) 
STRING ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
name , STRING , ROGUE_VERSION_ID ) 
STRING ) 
cl_playerbeams , INT_CONST , SIZEOF ( cl_playerbeams ) ) 
FOR ( i = INT_CONST ; i < MAX_EXPLOSIONS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_EXPLOSIONS ; i v++ ) 
) 
) 
&v net_message , pos ) 
&v net_message ) 
&v net_message ) 
pos , dir , color , count ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
model == cl_mod_heatbeam ) 
FOR ( i = INT_CONST , b = cl_playerbeams ; i < MAX_BEAMS ; i v++ , b v++ ) 
FOR ( i = INT_CONST , b = cl_playerbeams ; i < MAX_BEAMS ; i v++ , b v++ ) 
&v net_message , start ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
&v net_message , start ) 
FOR ( i = INT_CONST , l = cl_lasers ; i < MAX_LASERS ; i v++ , l v++ ) 
&v net_message ) 
id != -v INT_CONST ) 
FOR ( i = INT_CONST , s = cl_sustains ; i < MAX_SUSTAINS ; i v++ , s v++ ) 
&v net_message ) 
FOR ( i = INT_CONST , s = cl_sustains ; i < MAX_SUSTAINS ; i v++ , s v++ ) 
FOR ( i = INT_CONST , s = cl_sustains ; i < MAX_SUSTAINS ; i v++ , s v++ ) 
&v net_message ) 
type ) 
&v net_message , pos ) 
&v net_message , pos ) 
pos , INT_CONST , INT_CONST , cl_sfx_ric1 , INT_CONST , ATTN_NORM , INT_CONST ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message ) 
pos , dir , color , cnt ) 
&v net_message ) 
&v net_message , pos ) 
&v net_message , pos ) 
dir [ INT_CONST ] ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
INT_CONST ) 
&v net_message , pos ) 
cl_mod_parasite_segment ) 
&v net_message , pos ) 
cl_mod_grapple_cable ) 
&v net_message ) 
&v net_message , pos ) 
&v net_message ) 
&v net_message , pos ) 
dir [ INT_CONST ] ) 
type == TE_BLASTER2 ) 
type == TE_BLASTER2 ) 
cl_mod_lightning ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
cl_mod_heatbeam ) 
cl_mod_monster_heatbeam ) 
&v net_message , pos ) 
pos , dir , color , cnt , magnitude ) 
&v net_message , pos ) 
) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
&v net_message , pos ) 
) 
) 
&v net_message , pos ) 
ERR_DROP , STRING ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
b -> end , org , dist ) 
dist [ INT_CONST ] ) 
dist ) 
) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
hand ) 
FOR ( i = INT_CONST , b = cl_playerbeams ; i < MAX_BEAMS ; i v++ , b v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
b -> end , org , dist ) 
dist [ INT_CONST ] ) 
dist ) 
) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
&v ent , INT_CONST , SIZEOF ( ent ) ) 
FOR ( i = INT_CONST , ex = cl_explosions ; i < MAX_EXPLOSIONS ; i v++ , ex v++ ) 
FOR ( i = INT_CONST , l = cl_lasers ; i < MAX_LASERS ; i v++ , l v++ ) 
FOR ( i = INT_CONST , s = cl_sustains ; i < MAX_SUSTAINS ; i v++ , s v++ ) 
) 
) 
__E__O__F__
r_numparticles >= MAX_PARTICLES ) 
r_numdlights >= MAX_DLIGHTS ) 
style < INT_CONST || style > MAX_LIGHTSTYLES ) 
FOR ( i = INT_CONST ; i < r_numparticles ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
r_entities , INT_CONST , SIZEOF ( r_entities ) ) 
FOR ( i = INT_CONST ; i < r_numentities ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
r_dlights , INT_CONST , SIZEOF ( r_dlights ) ) 
FOR ( i = INT_CONST ; i < r_numdlights ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! cl . configstrings [ CS_MODELS + INT_CONST ] [ INT_CONST ] ) 
mapname , cl . configstrings [ CS_MODELS + INT_CONST ] + INT_CONST ) 
mapname ) 
STRING , mapname ) 
STRING ) 
) 
cl_weaponmodels [ INT_CONST ] , STRING ) 
FOR ( i = INT_CONST ; i < MAX_MODELS && cl . configstrings [ CS_MODELS + i ] [ INT_CONST ] ; i v++ ) 
STRING , i ) 
FOR ( i = INT_CONST ; i < MAX_IMAGES && cl . configstrings [ CS_IMAGES + i ] [ INT_CONST ] ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
&v cl . baseclientinfo , STRING ) 
STRING , i ) 
) 
) 
) 
atoi ( cl . configstrings [ CS_CDTRACK ] ) , true ) 
fov_x < INT_CONST || fov_x > INT_CONST ) 
height / x ) 
Cmd_Argc ( ) != INT_CONST ) 
! crosshair_pic [ INT_CONST ] ) 
cls . state != ca_active ) 
cl . frame . valid && ( cl . force_refdef || ! cl_paused -> value ) ) 
&v cl . refdef ) 
STRING , V_Viewpos_f ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
__E__O__F__
cl . attractloop ) 
cls . state == ca_disconnected ) 
STRING ) 
) 
cls . key_dest == key_console ) 
cls . key_dest == key_console ) 
Cmd_Argc ( ) != INT_CONST ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , Cmd_Argv ( INT_CONST ) ) 
STRING , name ) 
FOR ( l = con . current - con . totallines + INT_CONST ; l <= con . current ; l v++ ) 
FOR ( x = INT_CONST ; x < con . linewidth ; x v++ ) 
FOR ( ; l <= con . current ; l v++ ) 
FOR ( x = con . linewidth - INT_CONST ; x >= INT_CONST ; x v-- ) 
FOR ( x = INT_CONST ; buffer [ x ] ; x v++ ) 
f ) 
FOR ( i = INT_CONST ; i < NUM_CON_TIMES ; i v++ ) 
viddef . width >> INT_CONST ) 
width == con . linewidth ) 
FOR ( i = INT_CONST ; i < numlines ; i v++ ) 
FOR ( j = INT_CONST ; j < numchars ; j v++ ) 
) 
STRING , Con_ToggleConsole_f ) 
! con . initialized ) 
FOR ( l = INT_CONST ; l < con . linewidth ; l v++ ) 
l != con . linewidth && ( con . x + l > con . linewidth ) ) 
cr ) 
text ) 
buffer , CHAR_CONST , l ) 
cls . key_dest == key_menu ) 
( INT ) ( cls . realtime >> INT_CONST ) & INT_CONST ) 
FOR ( i = key_linepos + INT_CONST ; i < con . linewidth ; i v++ ) 
FOR ( i = INT_CONST ; i < con . linewidth ; i v++ ) 
FOR ( i = con . current - NUM_CON_TIMES + INT_CONST ; i <= con . current ; i v++ ) 
FOR ( x = INT_CONST ; x < con . linewidth ; x v++ ) 
cls . key_dest == key_message ) 
s [ x ] ) 
lines <= INT_CONST ) 
version , SIZEOF ( version ) , STRING , VERSION ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
lines - INT_CONST ) 
con . display != con . current ) 
FOR ( x = INT_CONST ; x < con . linewidth ; x += INT_CONST ) 
FOR ( i = INT_CONST ; i < rows ; i v++ , y -= INT_CONST , row v-- ) 
FOR ( x = INT_CONST ; x < con . linewidth ; x v++ ) 
cls . download ) 
dlbar , STRING ) 
dlbar , text ) 
FOR ( j = INT_CONST ; j < y ; j v++ ) 
dlbar + strlen ( dlbar ) , STRING , cls . downloadpercent ) 
FOR ( i = INT_CONST ; i < strlen ( dlbar ) ; i v++ ) 
__E__O__F__
*v s == CHAR_CONST || *v s == CHAR_CONST ) 
( toupper ( key ) == CHAR_CONST && keydown [ K_CTRL ] ) || NEW_LINE ( ( ( key == K_INS ) || ( key == K_KP_INS ) ) && keydown [ K_SHIFT ] ) ) 
key == CHAR_CONST ) 
key == K_ENTER || key == K_KP_ENTER ) 
key_lines [ edit_line ] [ INT_CONST ] == CHAR_CONST || key_lines [ edit_line ] [ INT_CONST ] == CHAR_CONST ) 
key == K_TAB ) 
) 
( key == K_UPARROW ) || ( key == K_KP_UPARROW ) || NEW_LINE ( ( key == CHAR_CONST ) && keydown [ K_CTRL ] ) ) 
( key == K_DOWNARROW ) || ( key == K_KP_DOWNARROW ) || NEW_LINE ( ( key == CHAR_CONST ) && keydown [ K_CTRL ] ) ) 
key == K_PGUP || key == K_KP_PGUP ) 
key == K_PGDN || key == K_KP_PGDN ) 
key == K_HOME || key == K_KP_HOME ) 
key == K_END || key == K_KP_END ) 
key == K_ESCAPE ) 
key < INT_CONST || key > INT_CONST ) 
chat_bufferlen == SIZEOF ( chat_buffer ) - INT_CONST ) 
FOR ( kn = keynames ; kn -> name ; kn v++ ) 
keynum == -v INT_CONST ) 
FOR ( kn = keynames ; kn -> name ; kn v++ ) 
Cmd_Argc ( ) != INT_CONST ) 
b , STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
c == INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
b , cmd ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = CHAR_CONST ; i <= CHAR_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
key_waiting == -v INT_CONST ) 
down ) 
key == K_SHIFT ) 
key == CHAR_CONST || key == CHAR_CONST ) 
cl . attractloop && cls . key_dest != key_menu ) 
key == K_ESCAPE ) 
down ) 
! down ) 
( cls . key_dest == key_menu && menubound [ key ] ) NEW_LINE || ( cls . key_dest == key_console && ! consolekeys [ key ] ) NEW_LINE || ( cls . key_dest == key_game && ( cls . state == ca_active || ! consolekeys [ key ] ) ) ) 
! down ) 
key ) 
key ) 
ERR_FATAL , STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
key_waiting == -v INT_CONST ) 
__E__O__F__
VOID ) 
*v m_drawfunc ) 
&v w , &v h , name ) 
Cvar_VariableValue ( STRING ) == INT_CONST NEW_LINE && Com_ServerState ( ) ) 
FOR ( i = INT_CONST ; i < m_menudepth ; i v++ ) 
! m_menudepth ) 
m ) 
key ) 
m ) 
m ) 
m ) 
m ) 
m ) 
! cached ) 
FOR ( i = INT_CONST ; i < NUM_CURSOR_FRAMES ; i v++ ) 
cursorname , SIZEOF ( cursorname ) , STRING , f ) 
cx , cy , INT_CONST ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
width > INT_CONST ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
cx , cy , INT_CONST ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
FOR ( i = INT_CONST ; names [ i ] != INT_CONST ; i v++ ) 
viddef . height / INT_CONST - INT_CONST ) 
FOR ( i = INT_CONST ; names [ i ] != INT_CONST ; i v++ ) 
xoffset - INT_CONST , ystart + m_main_cursor * INT_CONST + INT_CONST , ( INT ) ( cls . realtime / INT_CONST ) % NUM_CURSOR_FRAMES ) 
&v w , &v h , STRING ) 
xoffset - INT_CONST - w , ystart + h + INT_CONST , STRING ) 
key ) 
++v m_main_cursor >= MAIN_ITEMS ) 
&v s_multiplayer_menu , INT_CONST ) 
&v s_multiplayer_menu , ( VOID *p ) & s_join_network_server_action ) 
&v s_multiplayer_menu , NULL ) 
&v s_multiplayer_menu ) 
command ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
command ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
bindnames [ a -> generic . localdata [ INT_CONST ] ] [ INT_CONST ] , keys ) 
keys [ INT_CONST ] ) 
bindnames [ a -> generic . localdata [ INT_CONST ] ] [ INT_CONST ] , keys ) 
keys [ INT_CONST ] != -v INT_CONST ) 
&v s_keys_menu , STRING ) 
&v s_keys_menu , ( VOID *p ) & s_keys_attack_action ) 
&v s_keys_menu , ( VOID *p ) & s_keys_inventory_action ) 
&v s_keys_menu , ( VOID *p ) & s_keys_help_computer_action ) 
bind_grab ) 
key ) 
bindnames [ item -> generic . localdata [ INT_CONST ] ] [ INT_CONST ] ) 
STRING , ClampCvar ( INT_CONST , INT_CONST , cl_run -> value ) ) 
STRING , ClampCvar ( INT_CONST , INT_CONST , lookspring -> value ) ) 
STRING , ClampCvar ( INT_CONST , INT_CONST , lookstrafe -> value ) ) 
STRING , ClampCvar ( INT_CONST , INT_CONST , freelook -> value ) ) 
STRING , ClampCvar ( INT_CONST , INT_CONST , crosshair -> value ) ) 
STRING , ClampCvar ( INT_CONST , INT_CONST , in_joystick -> value ) ) 
) 
cl . attractloop ) 
) 
) 
) 
) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
) 
&v s_options_menu , ( VOID *p ) & s_options_sfxvolume_slider ) 
FOR ( i = INT_CONST , y = viddef . height - ( ( cls . realtime - credits_start_time ) / FLOAT_CONST ) ; credits [ i ] && y < viddef . height ; y += INT_CONST , i v++ ) 
FOR ( j = INT_CONST ; credits [ i ] [ j + stringoffset ] ; j v++ ) 
y < INT_CONST ) 
STRING , &v creditsBuffer ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
M_Credits_MenuDraw , M_Credits_Key ) 
) 
STRING , INT_CONST ) 
STRING ) 
&v s_game_menu , ( VOID *p ) & s_easy_game_action ) 
&v s_game_menu ) 
FOR ( i = INT_CONST ; i < MAX_SAVEGAMES ; i v++ ) 
m_savevalid [ a -> generic . localdata [ INT_CONST ] ] ) 
) 
FOR ( i = INT_CONST ; i < MAX_SAVEGAMES ; i v++ ) 
va ( STRING , a -> generic . localdata [ INT_CONST ] ) ) 
) 
FOR ( i = INT_CONST ; i < MAX_SAVEGAMES - INT_CONST ; i v++ ) 
m_num_servers == MAX_LOCAL_SERVERS ) 
FOR ( i = INT_CONST ; i < m_num_servers ; i v++ ) 
menuaction_s * ) 
Q_stricmp ( local_server_names [ index ] , NO_SERVER_STRING ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < MAX_LOCAL_SERVERS ; i v++ ) 
) 
) 
FOR ( i = INT_CONST ; i < MAX_LOCAL_SERVERS ; i v++ ) 
&v s_joinserver_menu , &v s_joinserver_address_book_action ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
s_rules_box . curvalue == INT_CONST ) 
Developer_searchpath ( INT_CONST ) == INT_CONST ) 
startmap , strchr ( mapnames [ s_startmap_list . curvalue ] , CHAR_CONST ) + INT_CONST ) 
s_maxclients_field . buffer ) 
STRING , ClampCvar ( INT_CONST , maxclients , maxclients ) ) 
spot ) 
) 
mapsname , SIZEOF ( mapsname ) , STRING , FS_Gamedir ( ) ) 
i < length ) 
nummaps == INT_CONST ) 
FOR ( i = INT_CONST ; i < nummaps ; i v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ ) 
fp != INT_CONST ) 
Developer_searchpath ( INT_CONST ) == INT_CONST ) 
s_timelimit_field . buffer , Cvar_VariableString ( STRING ) ) 
s_fraglimit_field . buffer , Cvar_VariableString ( STRING ) ) 
Cvar_VariableValue ( STRING ) == INT_CONST ) 
&v s_startserver_menu , &v s_startmap_list ) 
&v s_startserver_menu ) 
NULL ) 
FOR ( i = INT_CONST ; i < nummaps ; i v++ ) 
mapnames ) 
&v s_startserver_menu , key ) 
STRING ) 
f == &v s_friendlyfire_box ) 
Developer_searchpath ( INT_CONST ) == INT_CONST ) 
STRING , flags ) 
dmoptions_statusbar , SIZEOF ( dmoptions_statusbar ) , STRING , flags ) 
dmflags & DF_NO_FALLING ) 
dmflags & DF_WEAPONS_STAY ) 
dmflags & DF_INSTANT_ITEMS ) 
dmflags & DF_NO_ITEMS ) 
dmflags & DF_NO_HEALTH ) 
dmflags & DF_NO_ARMOR ) 
dmflags & DF_SPAWN_FARTHEST ) 
dmflags & DF_SAME_LEVEL ) 
dmflags & DF_FORCE_RESPAWN ) 
dmflags & DF_ALLOW_EXIT ) 
dmflags & DF_INFINITE_AMMO ) 
dmflags & DF_FIXED_FOV ) 
dmflags & DF_QUAD_DROP ) 
dmflags & DF_NO_FRIENDLY_FIRE ) 
Developer_searchpath ( INT_CONST ) == INT_CONST ) 
Developer_searchpath ( INT_CONST ) == INT_CONST ) 
INT_CONST ) 
f == &v s_allow_download_box ) 
f == &v s_allow_download_maps_box ) 
f == &v s_allow_download_models_box ) 
f == &v s_allow_download_players_box ) 
f == &v s_allow_download_sounds_box ) 
Cvar_VariableValue ( STRING ) != INT_CONST ) 
Cvar_VariableValue ( STRING ) != INT_CONST ) 
Cvar_VariableValue ( STRING ) != INT_CONST ) 
Cvar_VariableValue ( STRING ) != INT_CONST ) 
Cvar_VariableValue ( STRING ) != INT_CONST ) 
&v s_downloadoptions_menu , &v s_download_title ) 
&v s_downloadoptions_menu ) 
s_downloadoptions_menu . cursor == INT_CONST ) 
FOR ( i = INT_CONST ; i < NUM_ADDRESSBOOK_ENTRIES ; i v++ ) 
FOR ( index = INT_CONST ; index < NUM_ADDRESSBOOK_ENTRIES ; index v++ ) 
VOID *p self ) 
FOR ( i = INT_CONST ; i < n ; i v++ ) 
scratch , skin ) 
FOR ( i = INT_CONST ; i < npcxfiles ; i v++ ) 
CHAR *p , INT *p , UNSIGNED , UNSIGNED ) 
! dirnames ) 
FOR ( i = INT_CONST ; i < npms ; i v++ ) 
FOR ( k = INT_CONST ; k < npcxfiles - INT_CONST ; k v++ ) 
FOR ( s = INT_CONST , k = INT_CONST ; k < npcxfiles - INT_CONST ; k v++ ) 
strcmp ( a -> directory , STRING ) == INT_CONST ) 
STRING , STRING , CVAR_USERINFO | CVAR_ARCHIVE ) 
) 
s_numplayermodels == INT_CONST ) 
strchr ( currentdirectory , CHAR_CONST ) ) 
s_pmi , s_numplayermodels , SIZEOF ( s_pmi [ INT_CONST ] ) , pmicmpfnc ) 
s_pmnames , INT_CONST , SIZEOF ( s_pmnames ) ) 
FOR ( i = INT_CONST ; i < s_numplayermodels ; i v++ ) 
FOR ( j = INT_CONST ; j < s_pmi [ i ] . nskins ; j v++ ) 
s_player_name_field . buffer , name -> string ) 
STRING ) 
FOR ( i = INT_CONST ; i < SIZEOF ( rate_tbl ) / SIZEOF ( *v rate_tbl ) - INT_CONST ; i v++ ) 
&v s_player_config_menu , &v s_player_name_field ) 
&v refdef , INT_CONST , SIZEOF ( refdef ) ) 
refdef . fov_x , refdef . width , refdef . height ) 
s_pmi [ s_player_model_box . curvalue ] . skindisplaynames ) 
key == K_ESCAPE ) 
FOR ( i = INT_CONST ; i < s_numplayermodels ; i v++ ) 
FOR ( j = INT_CONST ; j < s_pmi [ i ] . nskins ; j v++ ) 
Gallery_MenuDraw , Gallery_MenuKey ) 
) 
&v w , &v h , STRING ) 
) 
cl . cinematictime > INT_CONST ) 
m_entersound ) 
m_keyfunc ) 
__E__O__F__
f -> generic . name ) 
f -> generic . x + f -> generic . parent -> x + INT_CONST , f -> generic . y + f -> generic . parent -> y - INT_CONST , INT_CONST ) 
f -> generic . x + f -> generic . parent -> x + INT_CONST + f -> visible_length * INT_CONST , f -> generic . y + f -> generic . parent -> y - INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST ; i < f -> visible_length ; i v++ ) 
f -> generic . x + f -> generic . parent -> x + INT_CONST , f -> generic . y + f -> generic . parent -> y , tempbuffer ) 
Menu_ItemAtCursor ( f -> generic . parent ) == f ) 
key ) 
key > INT_CONST ) 
( toupper ( key ) == CHAR_CONST && keydown [ K_CTRL ] ) || NEW_LINE ( ( ( key == K_INS ) || ( key == K_KP_INS ) ) && keydown [ K_SHIFT ] ) ) 
key ) 
&v f -> buffer [ f -> cursor ] , &v f -> buffer [ f -> cursor + INT_CONST ] , strlen ( &v f -> buffer [ f -> cursor + INT_CONST ] ) + INT_CONST ) 
! isdigit ( key ) && ( f -> generic . flags & QMF_NUMBERSONLY ) ) 
f -> cursor < f -> length ) 
menu ) 
m -> cursor >= INT_CONST && m -> cursor < m -> nitems ) 
dir == INT_CONST ) 
( menucommon_s * ) menu -> items [ menu -> nitems - INT_CONST ] ) 
VID_HEIGHT - height ) 
FOR ( i = INT_CONST ; i < menu -> nitems ; i v++ ) 
menu ) 
item && item -> cursordraw ) 
item ) 
FOR ( i = INT_CONST ; i < strlen ( string ) ; i v++ ) 
FOR ( i = INT_CONST ; i < strlen ( string ) ; i v++ ) 
FOR ( i = INT_CONST ; i < strlen ( string ) ; i v++ ) 
FOR ( i = INT_CONST ; i < strlen ( string ) ; i v++ ) 
item ) 
item ) 
FOR ( i = INT_CONST ; i < menu -> nitems ; i v++ ) 
l -> generic . callback ) 
l -> generic . x + l -> generic . parent -> x + LCOLUMN_OFFSET , l -> generic . y + l -> generic . parent -> y , l -> generic . name ) 
l -> generic . x - INT_CONST + l -> generic . parent -> x , l -> generic . parent -> y + l -> generic . y + l -> curvalue * INT_CONST + INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
s -> curvalue > s -> maxvalue ) 
s -> generic . x + s -> generic . parent -> x + LCOLUMN_OFFSET , NEW_LINE s -> generic . y + s -> generic . parent -> y , NEW_LINE s -> generic . name ) 
s -> range < INT_CONST ) 
FOR ( i = INT_CONST ; i < SLIDER_RANGE ; i v++ ) 
s -> curvalue < INT_CONST ) 
s -> generic . name ) 
__E__O__F__
STRING ) 
STRING , STRING , INT_CONST ) 
STRING ) 
! sound_started ) 
STRING ) 
FOR ( i = INT_CONST , sfx = known_sfx ; i < num_sfx ; i v++ , sfx v++ ) 
! name ) 
FOR ( i = INT_CONST ; i < num_sfx ; i v++ ) 
FOR ( i = INT_CONST ; i < num_sfx ; i v++ ) 
MAX_QPATH ) 
FOR ( i = INT_CONST ; i < num_sfx ; i v++ ) 
! sound_started ) 
! s_registering ) 
FOR ( i = INT_CONST , sfx = known_sfx ; i < num_sfx ; i v++ , sfx v++ ) 
FOR ( i = INT_CONST , sfx = known_sfx ; i < num_sfx ; i v++ , sfx v++ ) 
entchannel < INT_CONST ) 
FOR ( ch_idx = INT_CONST ; ch_idx < MAX_CHANNELS ; ch_idx v++ ) 
origin , listener_origin , source_vec ) 
source_vec ) 
listener_right , source_vec ) 
FLOAT_CONST - dist ) 
ch -> entnum == cl . playernum + INT_CONST ) 
ch -> fixed_origin ) 
ps == &v s_freeplays ) 
s_show -> value ) 
ps -> entnum , ps -> entchannel ) 
ps -> attenuation == ATTN_STATIC ) 
ch ) 
ch -> sfx ) 
ps ) 
cl . configstrings [ n ] [ INT_CONST ] ) 
! model [ INT_CONST ] ) 
sexedFilename , SIZEOF ( sexedFilename ) , STRING , model , base + INT_CONST ) 
! sfx ) 
! sound_started ) 
sfx ) 
) 
start < paintedtime ) 
! timeofs ) 
FOR ( sort = s_pendingplays . next ; NEW_LINE sort != &v s_pendingplays && sort -> begin < ps -> begin ; NEW_LINE sort = sort -> next ) 
! sound_started ) 
dma . samplebits == INT_CONST ) 
! sound_started ) 
s_playsounds , INT_CONST , SIZEOF ( s_playsounds ) ) 
FOR ( i = INT_CONST ; i < MAX_PLAYSOUNDS ; i v++ ) 
channels , INT_CONST , SIZEOF ( channels ) ) 
) 
cl_paused -> value ) 
FOR ( i = INT_CONST ; i < cl . frame . num_entities ; i v++ ) 
FOR ( i = INT_CONST ; i < cl . frame . num_entities ; i v++ ) 
FOR ( j = i + INT_CONST ; j < cl . frame . num_entities ; j v++ ) 
! sound_started ) 
channels == INT_CONST && width == INT_CONST ) 
FOR ( i = INT_CONST ; i < samples ; i v++ ) 
FOR ( i = INT_CONST ; ; i v++ ) 
FOR ( i = INT_CONST ; ; i v++ ) 
FOR ( i = INT_CONST ; ; i v++ ) 
FOR ( i = INT_CONST ; ; i v++ ) 
! sound_started ) 
cls . disable_screen ) 
s_volume -> modified ) 
FOR ( i = INT_CONST ; i < MAX_CHANNELS ; i v++ , ch v++ ) 
) 
s_show -> value ) 
FOR ( i = INT_CONST ; i < MAX_CHANNELS ; i v++ , ch v++ ) 
) 
samplepos < oldsamplepos ) 
! sound_started ) 
! dma . buffer ) 
paintedtime < soundtime ) 
endtime + dma . submission_chunk - INT_CONST ) 
) 
FOR ( sfx = known_sfx , i = INT_CONST ; i < num_sfx ; i v++ , sfx v++ ) 
__E__O__F__
sc -> loopstart != -v INT_CONST ) 
stepscale == INT_CONST && inwidth == INT_CONST && sc -> width == INT_CONST ) 
FOR ( i = INT_CONST ; i < outcount ; i v++ ) 
FOR ( i = INT_CONST ; i < outcount ; i v++ ) 
s -> name [ INT_CONST ] == CHAR_CONST ) 
! data ) 
s -> name , data , size ) 
FLOAT ) 
len + SIZEOF ( sfxcache_t ) ) 
s , sc -> speed , sc -> width , data + info . dataofs ) 
data ) 
&v info , INT_CONST , SIZEOF ( info ) ) 
! wav ) 
STRING ) 
STRING ) 
) 
STRING ) 
STRING ) 
) 
info . samples ) 
__E__O__F__
FOR ( i = INT_CONST ; i < snd_linear_count ; i += INT_CONST ) 
lpaintedtime < endtime ) 
( dma . samples >> INT_CONST ) - INT_CONST ) 
) 
UNSIGNED LONG *p ) 
s_testsound -> value ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
dma . samplebits == INT_CONST && dma . channels == INT_CONST ) 
pbuf , endtime ) 
INT *p ) 
paintedtime < endtime ) 
endtime - paintedtime > PAINTBUFFER_SIZE ) 
s_rawend < paintedtime ) 
FOR ( i = paintedtime ; i < stop ; i v++ ) 
FOR ( ; i < end ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_CHANNELS ; i v++ , ch v++ ) 
ch -> end - ltime < count ) 
end ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
ch -> leftvol > INT_CONST ) 
FOR ( i = INT_CONST ; i < count ; i v++ , samp v++ ) 
SIGNED SHORT *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , samp v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
range * SIZEOF ( UNSIGNED LONG ) ) 
__E__O__F__
level . sight_client == NULL ) 
dist ) 
FindTarget ( self ) ) 
! ( self -> spawnflags & INT_CONST ) && ( self -> monsterinfo . idle ) && ( level . time > self -> monsterinfo . idle_time ) ) 
FindTarget ( self ) ) 
self -> enemy -> s . origin , self -> s . origin , v ) 
dist ) 
self -> s . origin , other -> s . origin , v ) 
self -> s . origin , spot1 ) 
self -> monsterinfo . aiflags & AI_STAND_GROUND ) 
! ( self -> monsterinfo . aiflags & AI_STAND_GROUND ) ) 
self -> enemy -> client ) 
self -> enemy -> s . origin , self -> monsterinfo . last_sighting ) 
! self -> combattarget ) 
self -> combattarget ) 
self ) 
self -> monsterinfo . aiflags & AI_GOOD_GUY ) 
self -> monsterinfo . aiflags & AI_COMBAT_POINT ) 
! client -> inuse ) 
client -> enemy -> flags & FL_NOTARGET ) 
client -> light_level <= INT_CONST ) 
! visible ( self , client ) ) 
self ) 
! ( self -> monsterinfo . aiflags & AI_SOUND_TARGET ) && ( self -> monsterinfo . sight ) ) 
self -> s . angles [ YAW ] - self -> ideal_yaw ) 
self -> enemy -> health > INT_CONST ) 
self -> s . origin , spot1 ) 
self -> monsterinfo . melee ) 
! self -> monsterinfo . attack ) 
skill -> value == INT_CONST ) 
self -> flags & FL_FLY ) 
FacingIdeal ( self ) ) 
FacingIdeal ( self ) ) 
self -> monsterinfo . lefty ) 
self -> goalentity ) 
self -> monsterinfo . aiflags & AI_SOUND_TARGET ) 
( ! self -> enemy ) || ( ! self -> enemy -> inuse ) ) 
hesDeadJim ) 
self -> oldenemy && self -> oldenemy -> health > INT_CONST ) 
self , self -> enemy ) 
self , self -> enemy ) 
self -> monsterinfo . attack_state == AS_MISSILE ) 
! enemy_vis ) 
self -> monsterinfo . aiflags & AI_COMBAT_POINT ) 
self -> monsterinfo . aiflags & AI_SOUND_TARGET ) 
ai_checkattack ( self , dist ) ) 
enemy_vis ) 
coop -> value ) 
FindTarget ( self ) ) 
( self -> monsterinfo . search_time ) && ( level . time > ( self -> monsterinfo . search_time + INT_CONST ) ) ) 
) 
! ( self -> monsterinfo . aiflags & AI_LOST_SIGHT ) ) 
self -> monsterinfo . aiflags & AI_PURSUE_NEXT ) 
self -> s . origin , self -> monsterinfo . last_sighting , v ) 
self -> monsterinfo . last_sighting , self -> goalentity -> s . origin ) 
new ) 
self , dist ) 
tempgoal ) 
self ) 
__E__O__F__
! ent -> client -> chase_target -> inuse ) 
targ -> s . origin , ownerv ) 
targ -> client -> v_angle , angles ) 
o [ INT_CONST ] < targ -> s . origin [ INT_CONST ] + INT_CONST ) 
! targ -> groundentity ) 
trace . endpos , goal ) 
goal , INT_CONST , forward , goal ) 
goal , o ) 
goal , o ) 
goal , ent -> s . origin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent ) 
( ! ent -> client -> showscores && ! ent -> client -> menu && NEW_LINE ! ent -> client -> showinventory && ! ent -> client -> showhelp && NEW_LINE ! ( level . framenum & INT_CONST ) ) || ent -> client -> update_chase ) 
! ent -> client -> chase_target ) 
! ent -> client -> chase_target ) 
__E__O__F__
! ent -> client ) 
! ( ( INT ) ( dmflags -> value ) & ( DF_MODELTEAMS | DF_SKINTEAMS ) ) ) 
strcmp ( ent1Team , ent2Team ) == INT_CONST ) 
cl -> menu ) 
FOR ( i = INT_CONST ; i <= MAX_ITEMS ; i v++ ) 
cl -> menu ) 
FOR ( i = INT_CONST ; i <= MAX_ITEMS ; i v++ ) 
cl -> pers . inventory [ cl -> pers . selected_item ] ) 
deathmatch -> value && ! sv_cheats -> value ) 
) 
Q_stricmp ( name , STRING ) == INT_CONST ) 
give_all || Q_stricmp ( name , STRING ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ ) 
give_all || Q_stricmp ( name , STRING ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ ) 
give_all || Q_stricmp ( name , STRING ) == INT_CONST ) 
give_all || Q_stricmp ( name , STRING ) == INT_CONST ) 
give_all ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ ) 
name ) 
! it -> pickup ) 
it ) 
it -> flags & IT_AMMO ) 
deathmatch -> value && ! sv_cheats -> value ) 
! ( ent -> flags & FL_GODMODE ) ) 
deathmatch -> value && ! sv_cheats -> value ) 
! ( ent -> flags & FL_NOTARGET ) ) 
deathmatch -> value && ! sv_cheats -> value ) 
ent -> movetype == MOVETYPE_NOCLIP ) 
ent , PRINT_HIGH , msg ) 
) 
ent , it ) 
Q_stricmp ( gi . args ( ) , STRING ) == INT_CONST && ( it = CTFWhat_Tech ( ent ) ) != NULL ) 
ent , it ) 
ent -> client -> menu ) 
ctf -> value && cl -> resp . ctf_team == CTF_NOTEAM ) 
svc_inventory ) 
FOR ( i = INT_CONST ; i < MAX_ITEMS ; i v++ ) 
ent -> client -> menu ) 
ent -> client -> pers . selected_item == -v INT_CONST ) 
! it -> use ) 
! cl -> pers . weapon || ! cl -> pers . lastweapon ) 
! cl -> pers . weapon ) 
FOR ( i = INT_CONST ; i <= MAX_ITEMS ; i v++ ) 
! cl -> pers . weapon ) 
FOR ( i = INT_CONST ; i <= MAX_ITEMS ; i v++ ) 
! cl -> pers . weapon || ! cl -> pers . lastweapon ) 
ent ) 
ent -> client -> pers . selected_item == -v INT_CONST ) 
! it -> drop ) 
INT *p ) 
anum < bnum ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
index , count , SIZEOF ( index [ INT_CONST ] ) , PlayerSort ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
ent , PRINT_HIGH , STRING , large , count ) 
gi . argv ( INT_CONST ) ) 
ent -> client -> ps . pmove . pm_flags & PMF_DUCKED ) 
i ) 
ent , PRINT_HIGH , STRING ) 
ent , PRINT_HIGH , STRING ) 
ent , PRINT_HIGH , STRING ) 
ent , PRINT_HIGH , STRING ) 
flood_msgs -> value ) 
gi . argc ( ) < INT_CONST && ! arg0 ) 
strlen ( text ) > INT_CONST ) 
CheckFlood ( ent ) ) 
FOR ( j = INT_CONST ; j <= game . maxclients ; j v++ ) 
! ent -> client ) 
Q_stricmp ( cmd , STRING ) == INT_CONST ) 
level . intermissiontime ) 
ent , false , true ) 
__E__O__F__
targ -> movetype == MOVETYPE_PUSH ) 
( targ -> svflags & SVF_MONSTER ) && ( targ -> deadflag != DEAD_DEAD ) ) 
targ -> movetype == MOVETYPE_PUSH || targ -> movetype == MOVETYPE_STOP || targ -> movetype == MOVETYPE_NONE ) 
targ , inflictor , attacker , damage , point ) 
( targ -> svflags & SVF_MONSTER ) && ( targ -> deadflag != DEAD_DEAD ) ) 
targ , inflictor , attacker , damage , point ) 
! damage ) 
dflags & DAMAGE_NO_ARMOR ) 
! save ) 
client ) 
! damage ) 
! client ) 
dflags & DAMAGE_ENERGY ) 
targ -> monsterinfo . aiflags & AI_GOOD_GUY ) 
attacker -> client ) 
( ( targ -> flags & ( FL_FLY | FL_SWIM ) ) == ( attacker -> flags & ( FL_FLY | FL_SWIM ) ) ) && NEW_LINE ( strcmp ( targ -> classname , attacker -> classname ) != INT_CONST ) && NEW_LINE ( strcmp ( attacker -> classname , STRING ) != INT_CONST ) && NEW_LINE ( strcmp ( attacker -> classname , STRING ) != INT_CONST ) && NEW_LINE ( strcmp ( attacker -> classname , STRING ) != INT_CONST ) && NEW_LINE ( strcmp ( attacker -> classname , STRING ) != INT_CONST ) ) 
! targ -> takedamage ) 
( targ != attacker ) && ( ( deathmatch -> value && ( ( INT ) ( dmflags -> value ) & ( DF_MODELTEAMS | DF_SKINTEAMS ) ) ) || coop -> value ) ) 
skill -> value == INT_CONST && deathmatch -> value == INT_CONST && targ -> client ) 
dflags & DAMAGE_BULLET ) 
! ( dflags & DAMAGE_RADIUS ) && ( targ -> svflags & SVF_MONSTER ) && ( attacker -> client ) && ( ! targ -> enemy ) && ( targ -> health > INT_CONST ) ) 
( targ -> flags & FL_GODMODE ) && ! ( dflags & DAMAGE_NO_PROTECTION ) ) 
( client && client -> invincible_framenum > level . framenum ) && ! ( dflags & DAMAGE_NO_PROTECTION ) ) 
ctf -> value && targ -> client && attacker -> client && NEW_LINE targ -> client -> resp . ctf_team == attacker -> client -> resp . ctf_team && NEW_LINE targ != attacker && ( ( INT ) dmflags -> value & DF_ARMOR_PROTECT ) ) 
targ , take ) 
! ( dflags & DAMAGE_NO_PROTECTION ) && CheckTeamDamage ( targ , attacker ) ) 
targ -> svflags & SVF_MONSTER ) 
client ) 
( ent = findradius ( ent , inflictor -> s . origin , radius ) ) != NULL ) 
__E__O__F__
INT_CONST ) 
! from ) 
FOR ( ; from < &v g_edicts [ globals . num_edicts ] ; from v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
targ -> movetype == MOVETYPE_PUSH ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
competition -> value > INT_CONST ) 
t , SIZEOF ( t ) , STRING , s ) 
( p = strrchr ( t , CHAR_CONST ) ) != NULL ) 
CS_PLAYERSKINS + playernum , NEW_LINE va ( STRING , ent -> client -> pers . netname , t , CTF_TEAM2_SKIN ) ) 
CS_PLAYERSKINS + playernum , NEW_LINE va ( STRING , ent -> client -> pers . netname , s ) ) 
! ( ( INT ) dmflags -> value & DF_CTF_FORCEJOIN ) ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
ent -> client -> resp . ctf_state ) 
ent -> client -> resp . ctf_team ) 
) 
( spot = G_Find ( spot , FOFS ( classname ) , cname ) ) != NULL ) 
! count ) 
targ -> client && attacker -> client ) 
! targ -> client || ! attacker -> client || targ == attacker ) 
targ -> client -> resp . ctf_team == CTF_TEAM1 ) 
targ -> client -> pers . inventory [ ITEM_INDEX ( enemy_flag_item ) ] ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
targ -> client -> resp . ctf_lasthurtcarrier && NEW_LINE level . time - targ -> client -> resp . ctf_lasthurtcarrier < CTF_CARRIER_DANGER_PROTECT_TIMEOUT && NEW_LINE ! attacker -> client -> pers . inventory [ ITEM_INDEX ( flag_item ) ] ) 
attacker -> client -> resp . ctf_team ) 
( flag = G_Find ( flag , FOFS ( classname ) , c ) ) != NULL ) 
! flag ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
targ -> s . origin , flag -> s . origin , v1 ) 
( VectorLength ( v1 ) < CTF_TARGET_PROTECT_RADIUS || NEW_LINE VectorLength ( v2 ) < CTF_TARGET_PROTECT_RADIUS || NEW_LINE loc_CanSee ( flag , targ ) || loc_CanSee ( flag , attacker ) ) && NEW_LINE attacker -> client -> resp . ctf_team != targ -> client -> resp . ctf_team ) 
carrier && carrier != attacker ) 
! targ -> client || ! attacker -> client ) 
ctf_team ) 
( ent = G_Find ( ent , FOFS ( classname ) , c ) ) != NULL ) 
ent ) 
strcmp ( ent -> classname , STRING ) == INT_CONST ) 
ctf_team == CTF_TEAM1 ) 
ctf_team == other -> client -> resp . ctf_team ) 
! ( ent -> spawnflags & DROPPED_ITEM ) ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
PRINT_HIGH , STRING , NEW_LINE other -> client -> pers . netname , CTFTeamName ( ctf_team ) ) 
flag_item ) 
! ( ent -> spawnflags & DROPPED_ITEM ) ) 
other == ent -> owner && NEW_LINE ent -> nextthink - level . time > CTF_AUTO_FLAG_RETURN_TIMEOUT - INT_CONST ) 
strcmp ( ent -> classname , STRING ) == INT_CONST ) 
self -> client -> pers . inventory [ ITEM_INDEX ( flag1_item ) ] ) 
dropped ) 
-v INT_CONST , -v INT_CONST , -v INT_CONST ) 
ent -> model ) 
ent -> s . origin , ent -> mins , ent -> maxs , dest , ent , MASK_SOLID ) 
tr . endpos , ent -> s . origin ) 
ent ) 
player -> client -> pers . inventory [ ITEM_INDEX ( flag1_item ) ] ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
ent -> client -> v_angle , forward , NULL , NULL ) 
ent -> client -> v_angle , forward , NULL , NULL ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
ctfgame . match > MATCH_NONE ) 
ent -> client -> resp . ghost ) 
STRING ) 
level . intermissiontime && ( level . framenum & INT_CONST ) ) 
ctfgame . team1 > ctfgame . team2 ) 
tnames [ i ] ) 
STRING ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
ctfgame . last_flag_capture && level . time - ctfgame . last_flag_capture < INT_CONST ) 
ent -> client -> resp . ctf_team == CTF_TEAM1 && NEW_LINE ent -> client -> pers . inventory [ ITEM_INDEX ( flag2_item ) ] && NEW_LINE ( level . framenum & INT_CONST ) ) 
self -> owner , CHAN_RELIABLE + CHAN_WEAPON , gi . soundindex ( STRING ) , volume , ATTN_NORM , INT_CONST ) 
other == self -> owner ) 
vec3_origin , self -> velocity ) 
self -> owner , self -> s . origin , PNOISE_IMPACT ) 
other -> takedamage ) 
self -> owner -> client -> silencer_shots ) 
svc_temp_entity ) 
self -> owner -> client -> v_angle , f , r , NULL ) 
start , self -> owner -> s . origin , offset ) 
start , self -> s . origin , dir ) 
distance < INT_CONST ) 
dir , angles ) 
start , NULL , NULL , self -> s . origin , self , MASK_SHOT ) 
self -> s . origin , end ) 
svc_temp_entity ) 
strcmp ( self -> owner -> client -> pers . weapon -> classname , STRING ) == INT_CONST && NEW_LINE ! self -> owner -> client -> newweapon && NEW_LINE self -> owner -> client -> weaponstate != WEAPON_FIRING && NEW_LINE self -> owner -> client -> weaponstate != WEAPON_ACTIVATING ) 
self -> enemy ) 
self -> enemy -> velocity , self -> velocity ) 
self ) 
self -> owner -> client -> ctf_grapplestate > CTF_GRAPPLE_STATE_FLY ) 
dir ) 
) 
grapple ) 
self -> s . origin , NULL , NULL , grapple -> s . origin , grapple , MASK_SHOT ) 
ent -> client -> ctf_grapplestate > CTF_GRAPPLE_STATE_FLY ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
ent -> client -> silencer_shots ) 
svc_muzzleflash ) 
ent , vec3_origin , damage , INT_CONST ) 
( ent -> client -> buttons & BUTTON_ATTACK ) && NEW_LINE ent -> client -> weaponstate == WEAPON_FIRING && NEW_LINE ent -> client -> ctf_grapple ) 
ent -> client -> newweapon && NEW_LINE ent -> client -> ctf_grapplestate > CTF_GRAPPLE_STATE_FLY && NEW_LINE ent -> client -> weaponstate == WEAPON_FIRING ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , NEW_LINE CTFWeapon_Grapple_Fire ) 
prevstate == WEAPON_ACTIVATING && NEW_LINE ent -> client -> weaponstate == WEAPON_READY && NEW_LINE ent -> client -> ctf_grapplestate > CTF_GRAPPLE_STATE_FLY ) 
) 
ctfgame . match > MATCH_SETUP ) 
Q_stricmp ( t , STRING ) == INT_CONST ) 
ent -> client -> resp . ctf_team == desired_team ) 
ent -> client -> pers . userinfo , STRING ) 
ent -> solid == SOLID_NOT ) 
ent ) 
ent , ent , ent , INT_CONST , vec3_origin ) 
ent ) 
PRINT_HIGH , STRING , NEW_LINE ent -> client -> pers . netname , CTFTeamName ( desired_team ) ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
FOR ( j = INT_CONST ; j < total [ team ] ; j v++ ) 
FOR ( k = total [ team ] ; k > j ; k v-- ) 
string , STRING NEW_LINE STRING NEW_LINE STRING NEW_LINE STRING NEW_LINE STRING NEW_LINE STRING , NEW_LINE totalscore [ INT_CONST ] , total [ INT_CONST ] , NEW_LINE totalscore [ INT_CONST ] , total [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
last [ INT_CONST ] > last [ INT_CONST ] ) 
maxsize - len > INT_CONST ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
total [ INT_CONST ] - last [ INT_CONST ] > INT_CONST ) 
string + strlen ( string ) , STRING , NEW_LINE INT_CONST + ( last [ INT_CONST ] + INT_CONST ) * INT_CONST , total [ INT_CONST ] - last [ INT_CONST ] - INT_CONST ) 
string + strlen ( string ) , STRING , NEW_LINE INT_CONST + ( last [ INT_CONST ] + INT_CONST ) * INT_CONST , total [ INT_CONST ] - last [ INT_CONST ] - INT_CONST ) 
tnames [ i ] ) 
tnames [ i ] ) 
i v-- ) 
( spot = FindTechSpawn ( ) ) != NULL ) 
ent , item ) 
tnames [ i ] ) 
) 
ent -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
) 
angles , forward , right , NULL ) 
ent ) 
tnames [ i ] ) 
( spot = FindTechSpawn ( ) ) != NULL ) 
( ( INT ) dmflags -> value & DF_CTF_NO_TECH ) ) 
FOR ( ent = g_edicts + INT_CONST , i = INT_CONST ; i < globals . num_edicts ; i v++ , ent v++ ) 
ent -> client && ent -> client -> silencer_shots ) 
! tech ) 
ent -> client && ent -> client -> silencer_shots ) 
! tech ) 
ent -> client && ent -> client -> silencer_shots ) 
! client ) 
! tech ) 
( what = loc_findradius ( what , who -> s . origin , INT_CONST ) ) != NULL ) 
FOR ( i = INT_CONST ; loc_names [ i ] . classname ; i v++ ) 
hot , who ) 
! hot ) 
( what = G_Find ( what , FOFS ( classname ) , hot -> classname ) ) != NULL ) 
( item = FindItemByClassname ( hot -> classname ) ) == NULL ) 
who -> waterlevel ) 
who -> s . origin , hot -> s . origin , v ) 
who ) 
who ) 
buf + strlen ( buf ) , STRING , NEW_LINE who -> client -> pers . inventory [ index ] , item -> pickup_name ) 
! *v buf ) 
tnames [ i ] ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
! loc_CanSee ( targ , who ) ) 
CheckFlood ( who ) ) 
*v msg == CHAR_CONST ) 
FOR ( p = outmsg ; *v msg && ( p - outmsg ) < SIZEOF ( outmsg ) - INT_CONST ; msg v++ ) 
p , buf ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
) 
) 
g_edicts [ INT_CONST ] . message ) 
electpercentage -> value == INT_CONST ) 
ctfgame . election != ELECT_NONE ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
count < INT_CONST ) 
count * electpercentage -> value ) 
ctfgame . emsg , msg , SIZEOF ( ctfgame . emsg ) - INT_CONST ) 
PRINT_CHAT , STRING , ctfgame . emsg ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
) 
FOR ( ent = g_edicts + INT_CONST , i = INT_CONST ; i < globals . num_edicts ; i v++ , ent v++ ) 
FOR ( ghost = INT_CONST ; ghost < MAX_CLIENTS ; ghost v++ ) 
FOR ( ; ; ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
ctfgame . ghosts , INT_CONST , SIZEOF ( ctfgame . ghosts ) ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
) 
PRINT_HIGH , STRING , NEW_LINE ctfgame . team1 , ctfgame . total1 ) 
PRINT_CHAT , STRING , NEW_LINE ctfgame . total1 - ctfgame . total2 ) 
PRINT_HIGH , STRING , ctfgame . etarget -> client -> pers . netname ) 
PRINT_HIGH , STRING , NEW_LINE ctfgame . etarget -> client -> pers . netname , ctfgame . elevel ) 
ctfgame . evotes == ctfgame . needvotes ) 
PRINT_HIGH , STRING , ctfgame . emsg ) 
ent -> client -> resp . ctf_team == CTF_NOTEAM ) 
ctfgame . match != MATCH_SETUP ) 
ent -> client -> resp . ready ) 
PRINT_HIGH , STRING , ent -> client -> pers . netname ) 
FOR ( j = INT_CONST , i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
ctfgame . match != MATCH_SETUP && ctfgame . match != MATCH_PREGAME ) 
! ent -> client -> resp . ready ) 
PRINT_HIGH , STRING , ent -> client -> pers . netname ) 
ctfgame . match == MATCH_PREGAME ) 
gi . argc ( ) < INT_CONST ) 
ent -> client -> resp . ctf_team != CTF_NOTEAM ) 
gi . argv ( INT_CONST ) ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
ent ) 
ent -> client -> pers . userinfo , STRING ) 
ctfgame . match == MATCH_GAME ) 
ent ) 
PRINT_HIGH , STRING , NEW_LINE ent -> client -> pers . netname , CTFTeamName ( desired_team ) ) 
ent -> client -> chase_target ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
nochasemenu + jmenu_level ) 
ent ) 
ent ) 
text , STRING , NEW_LINE ent -> client -> pers . netname ) 
ent ) 
ctfgame . match >= MATCH_PREGAME && matchlock -> value ) 
ctf_forcejoin -> string && *v ctf_forcejoin -> string ) 
ent -> client -> chase_target ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
team1players , STRING , num1 ) 
ctfgame . match ) 
joinmenu [ jmenu_red ] . text ) 
ent ) 
ent -> movetype == MOVETYPE_NOCLIP ) 
ent ) 
ent ) 
ctfgame . election != ELECT_NONE && ctfgame . electtime <= level . time ) 
ctfgame . match != MATCH_NONE ) 
STRING , STRING ) 
ctfgame . match ) 
FOR ( j = INT_CONST , i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
capturelimit -> value && NEW_LINE ( ctfgame . team1 >= capturelimit -> value || NEW_LINE ctfgame . team2 >= capturelimit -> value ) ) 
! other -> client ) 
other ) 
other ) 
dest -> s . origin , other -> s . origin ) 
other -> velocity ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
other -> client -> v_angle , forward , NULL , NULL ) 
! KillBox ( other ) ) 
other ) 
! ent -> target ) 
ent , ent -> model ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
edict_t * ent ) 
settings -> matchlen != matchtime -> value ) 
settings -> matchsetuplen != matchsetuptime -> value ) 
settings -> matchstartlen != matchstarttime -> value ) 
settings -> weaponsstay != ! ! ( ( INT ) dmflags -> value & DF_WEAPONS_STAY ) ) 
settings -> instantitems != ! ! ( ( INT ) dmflags -> value & DF_INSTANT_ITEMS ) ) 
settings -> quaddrop != ! ! ( ( INT ) dmflags -> value & DF_QUAD_DROP ) ) 
settings -> instantweap != ! ! ( ( INT ) instantweap -> value ) ) 
settings -> matchlock != ! ! ( ( INT ) matchlock -> value ) ) 
ent ) 
ent ) 
settings -> matchlen % INT_CONST ) 
settings -> matchsetuplen % INT_CONST ) 
settings -> matchstartlen % INT_CONST ) 
ent , p ) 
ent , p ) 
ent , p ) 
ent , p ) 
ent , p ) 
text , STRING , settings -> matchlen ) 
text , STRING , settings -> matchsetuplen ) 
text , STRING , settings -> matchstartlen ) 
text , STRING , settings -> weaponsstay ? STRING ?: STRING ) 
text , STRING , settings -> instantitems ? STRING ?: STRING ) 
text , STRING , settings -> quaddrop ? STRING ?: STRING ) 
text , STRING , settings -> instantweap ? STRING ?: STRING ) 
text , STRING , settings -> matchlock ? STRING ?: STRING ) 
ent ) 
ent ) 
SIZEOF ( *v settings ) ) 
( INT ) dmflags -> value & DF_WEAPONS_STAY ) 
ent , def_setmenu , -v INT_CONST , SIZEOF ( def_setmenu ) / SIZEOF ( pmenu_t ) , settings ) 
ctfgame . match == MATCH_SETUP ) 
ctfgame . match != MATCH_SETUP ) 
ent , adminmenu , -v INT_CONST , SIZEOF ( adminmenu ) / SIZEOF ( pmenu_t ) , NULL ) 
gi . argc ( ) > INT_CONST && admin_password -> string && *v admin_password -> string && NEW_LINE ! ent -> client -> resp . admin && strcmp ( admin_password -> string , gi . argv ( INT_CONST ) ) == INT_CONST ) 
! ent -> client -> resp . admin ) 
ent -> client -> menu ) 
ctfgame . match == MATCH_SETUP ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
FOR ( i = INT_CONST , g = ctfgame . ghosts ; i < MAX_CLIENTS ; i v++ , g v++ ) 
text , STRING ) 
FOR ( i = INT_CONST , g = ctfgame . ghosts ; i < MAX_CLIENTS ; i v++ , g v++ ) 
ctfgame . match == MATCH_SETUP ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
FOR ( i = INT_CONST , e2 = g_edicts + INT_CONST ; i < maxclients -> value ; i v++ , e2 v++ ) 
gi . argc ( ) < INT_CONST ) 
warp_list -> string ) 
mlist , seps ) 
token == NULL ) 
mlist ) 
ent -> client -> resp . admin ) 
text , STRING , NEW_LINE ent -> client -> pers . netname , gi . argv ( INT_CONST ) ) 
! ent -> client -> resp . admin ) 
gi . argc ( ) < INT_CONST ) 
*v gi . argv ( INT_CONST ) < CHAR_CONST && *v gi . argv ( INT_CONST ) > CHAR_CONST ) 
gi . argv ( INT_CONST ) ) 
! targ -> inuse ) 
text , STRING , i - INT_CONST ) 
__E__O__F__
ent -> moveinfo . dir , ent -> moveinfo . remaining_distance / FRAMETIME , ent -> velocity ) 
( ent -> moveinfo . speed * FRAMETIME ) >= ent -> moveinfo . remaining_distance ) 
ent -> moveinfo . speed == ent -> moveinfo . accel && ent -> moveinfo . speed == ent -> moveinfo . decel ) 
ent -> moveinfo . state == STATE_UP ) 
move , FLOAT_CONST / FRAMETIME , ent -> avelocity ) 
ent -> moveinfo . state == STATE_UP ) 
traveltime < FRAMETIME ) 
traveltime / FRAMETIME ) 
destdelta , FLOAT_CONST / traveltime , ent -> avelocity ) 
moveinfo -> remaining_distance < moveinfo -> accel ) 
moveinfo -> speed , moveinfo -> accel ) 
( moveinfo -> remaining_distance - accel_dist - decel_dist ) < INT_CONST ) 
moveinfo -> remaining_distance <= moveinfo -> decel_distance ) 
moveinfo -> current_speed == moveinfo -> move_speed ) 
moveinfo -> current_speed < moveinfo -> speed ) 
ent -> moveinfo . current_speed == INT_CONST ) 
&v ent -> moveinfo ) 
ent -> moveinfo . remaining_distance <= ent -> moveinfo . current_speed ) 
ent -> moveinfo . dir , ent -> moveinfo . current_speed * INT_CONST , ent -> velocity ) 
other , self , self , vec3_origin , other -> s . origin , vec3_origin , self -> dmg , INT_CONST , INT_CONST , MOD_CRUSH ) 
self -> moveinfo . state == STATE_UP ) 
ent -> moveinfo . state == STATE_BOTTOM ) 
) 
ent -> pos1 [ INT_CONST ] - ent -> pos2 [ INT_CONST ] + st . lip ) 
ent -> spawnflags & PLAT_LOW_TRIGGER ) 
trigger ) 
ent , ent -> model ) 
! ent -> speed ) 
ent -> s . origin , ent -> pos1 ) 
ent ) 
ent -> targetname ) 
ent -> pos1 , ent -> moveinfo . start_origin ) 
STRING ) 
ent -> movedir ) 
ent -> spawnflags & INT_CONST ) 
self , self -> moveinfo . start_origin , button_done ) 
self -> health ) 
self , self -> activator ) 
ent -> s . angles , ent -> movedir ) 
ent -> sounds != INT_CONST ) 
ent -> health ) 
ent -> pos1 , ent -> moveinfo . start_origin ) 
ent ) 
! self -> target ) 
self -> moveinfo . wait >= INT_CONST ) 
self -> flags & FL_TEAMSLAVE ) 
FOR ( ent = self ; ent ; ent = ent -> teamchain ) 
ent ) 
FOR ( ent = self ; ent ; ent = ent -> teamchain ) 
self -> owner , other , other ) 
self -> flags & FL_TEAMSLAVE ) 
self -> moveinfo . distance ) 
FOR ( ent = self -> teamchain ; ent ; ent = ent -> teamchain ) 
FOR ( ent = self ; ent ; ent = ent -> teamchain ) 
ent -> flags & FL_TEAMSLAVE ) 
FOR ( other = ent -> teamchain ; other ; other = other -> teamchain ) 
) 
ent -> spawnflags & DOOR_START_OPEN ) 
! ( other -> svflags & SVF_MONSTER ) && ( ! other -> client ) ) 
other , self , self , vec3_origin , other -> s . origin , vec3_origin , self -> dmg , INT_CONST , INT_CONST , MOD_CRUSH ) 
self -> spawnflags & DOOR_CRUSHER ) 
FOR ( ent = self -> teammaster ; ent ; ent = ent -> teamchain ) 
FOR ( ent = self -> teammaster ; ent ; ent = ent -> teamchain ) 
FOR ( ent = self -> teammaster ; ent ; ent = ent -> teamchain ) 
other , STRING , self -> message ) 
ent -> sounds != INT_CONST ) 
ent -> s . angles , ent -> movedir ) 
! ent -> speed ) 
ent -> s . origin , ent -> pos1 ) 
ent -> spawnflags & DOOR_START_OPEN ) 
ent -> health ) 
ent -> spawnflags & INT_CONST ) 
! ent -> team ) 
ent -> health || ent -> targetname ) 
ent -> movedir ) 
ent -> spawnflags & DOOR_REVERSE ) 
ent -> s . angles , ent -> pos1 ) 
ent , ent -> model ) 
! ent -> speed ) 
ent -> spawnflags & DOOR_START_OPEN ) 
ent -> health ) 
ent -> s . origin , ent -> moveinfo . start_origin ) 
ent -> spawnflags & INT_CONST ) 
! ent -> team ) 
ent -> health || ent -> targetname ) 
self -> s . angles , self -> movedir ) 
self -> sounds ) 
self -> s . origin , self -> pos1 ) 
self -> spawnflags & DOOR_START_OPEN ) 
self -> pos1 , self -> moveinfo . start_origin ) 
! self -> speed ) 
! self -> wait ) 
self -> wait == -v INT_CONST ) 
self ) 
level . time < self -> touch_debounce_time ) 
self -> moveinfo . wait ) 
edict_t * self ) 
! self -> target ) 
self -> target ) 
ent -> spawnflags & INT_CONST ) 
! ( self -> flags & FL_TEAMSLAVE ) ) 
ent -> s . origin , self -> mins , dest ) 
ent -> s . origin , self -> mins , dest ) 
! self -> target ) 
ent -> s . origin , self -> mins , self -> s . origin ) 
! self -> targetname ) 
self -> spawnflags & TRAIN_START_ON ) 
self -> s . angles ) 
st . noise ) 
self ) 
self -> target ) 
self -> movetarget -> nextthink ) 
! other -> pathtarget ) 
other -> pathtarget ) 
self -> movetarget ) 
self -> nextthink ) 
self -> delay ) 
self -> random >= self -> wait ) 
self -> spawnflags & INT_CONST ) 
! ( self -> spawnflags & INT_CONST ) ) 
self , self -> model ) 
! VectorCompare ( self -> s . origin , vec3_origin ) ) 
level . time < self -> touch_debounce_time ) 
other , self , self , vec3_origin , other -> s . origin , vec3_origin , self -> dmg , INT_CONST , INT_CONST , MOD_CRUSH ) 
STRING ) 
ent , ent -> model ) 
! ( ent -> targetname ) || ( ent -> spawnflags & SECRET_ALWAYS_SHOOT ) ) 
! ent -> dmg ) 
ent -> s . angles , forward , right , up ) 
ent -> health ) 
__E__O__F__
FOR ( i = INT_CONST ; i < game . num_items ; i v++ , it v++ ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ , it v++ ) 
FOR ( count = INT_CONST , ent = master ; ent ; ent = ent -> chain , count v++ ) 
FOR ( count = INT_CONST , ent = master ; count < choice ; ent = ent -> chain , count v++ ) 
ent ) 
ent -> item ) 
deathmatch -> value ) 
! ( ent -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
other -> client -> pers . max_bullets < INT_CONST ) 
STRING ) 
! ( ent -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
other -> client -> pers . max_bullets < INT_CONST ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
! ( ent -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
item ) 
quad_drop_timeout_hack ) 
ent -> client -> quad_framenum > level . framenum ) 
ent -> client -> breather_framenum > level . framenum ) 
ent -> client -> enviro_framenum > level . framenum ) 
ent -> client -> invincible_framenum > level . framenum ) 
! ent -> client ) 
ent -> client -> pers . inventory [ index ] == max ) 
ent -> client -> pers . inventory [ index ] > max ) 
ent -> item -> flags & IT_WEAPON ) 
! Add_Ammo ( other , ent -> item , count ) ) 
! ( ent -> spawnflags & ( DROPPED_ITEM | DROPPED_PLAYER_ITEM ) ) && ( deathmatch -> value ) ) 
item ) 
! ( self -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
other -> health >= INT_CONST && ent -> count > INT_CONST ) 
other -> health > INT_CONST && ent -> count > INT_CONST ) 
( ent -> style & HEALTH_TIMED ) NEW_LINE && ! CTFHasRegeneration ( other ) NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE ) 
gitem_armor_t * ) 
other ) 
ent -> item -> tag == ARMOR_SHARD ) 
! old_armor_index ) 
! ( ent -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
ent -> flags & FL_POWER_ARMOR ) 
ent -> item ) 
ent -> item ) 
deathmatch -> value ) 
! other -> client ) 
taken ) 
! ( ent -> spawnflags & ITEM_TARGETS_USED ) ) 
! taken ) 
) 
dropped -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
ent -> client ) 
forward , INT_CONST , dropped -> velocity ) 
dropped ) 
ent -> spawnflags & ITEM_NO_TOUCH ) 
ent ) 
-v INT_CONST , -v INT_CONST , -v INT_CONST ) 
ent -> model ) 
ent -> s . origin , ent -> mins , ent -> maxs , dest , ent , MASK_SOLID ) 
tr . endpos , ent -> s . origin ) 
ent -> team ) 
ent -> spawnflags & ITEM_NO_TOUCH ) 
ent -> spawnflags & ITEM_TRIGGER_SPAWN ) 
ent ) 
! it ) 
it -> ammo && it -> ammo [ INT_CONST ] ) 
! s || ! s [ INT_CONST ] ) 
ent -> spawnflags ) 
deathmatch -> value ) 
coop -> value && ( strcmp ( ent -> classname , STRING ) == INT_CONST ) ) 
( coop -> value ) && ( item -> flags & IT_STAY_COOP ) ) 
! ctf -> value && NEW_LINE ( strcmp ( ent -> classname , STRING ) == INT_CONST || NEW_LINE strcmp ( ent -> classname , STRING ) == INT_CONST ) ) 
ent -> model ) 
self , FindItem ( STRING ) ) 
self , FindItem ( STRING ) ) 
self , FindItem ( STRING ) ) 
self , FindItem ( STRING ) ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ ) 
FindItem ( STRING ) ) 
__E__O__F__
TAG_LEVEL ) 
edict_t ) 
argptr , error ) 
ERR_FATAL , STRING , text ) 
argptr , msg ) 
STRING , text ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
) 
( INT ) dmflags -> value & DF_SAME_LEVEL ) 
*v level . forcemap ) 
*v sv_maplist -> string ) 
level . nextmap [ INT_CONST ] ) 
CreateTargetChangeLevel ( level . nextmap ) ) 
NULL , FOFS ( classname ) , STRING ) 
level . intermissiontime ) 
fraglimit -> value ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
CTFNextMap ( ) ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
) 
level . exitintermission ) 
FOR ( i = INT_CONST ; i < globals . num_edicts ; i v++ , ent v++ ) 
) 
) 
__E__O__F__
ent -> style , ent -> count ) 
damage < INT_CONST ) 
self -> s . frame == INT_CONST ) 
! self -> groundentity ) 
plane ) 
) 
self -> size , FLOAT_CONST , size ) 
gib , gibname ) 
type == GIB_ORGANIC ) 
damage , vd ) 
) 
gib ) 
self -> mins ) 
self , gibname ) 
type == GIB_ORGANIC ) 
damage , vd ) 
) 
) 
self ) 
rand ( ) & INT_CONST ) 
self , gibname ) 
damage , vd ) 
self -> client ) 
self ) 
) 
strcmp ( self -> classname , STRING ) == INT_CONST ) 
self -> item && ( self -> item -> flags & IT_TECH ) ) 
self ) 
self ) 
other -> movetarget != self ) 
self -> target ) 
self -> wait ) 
! other -> movetarget ) 
self -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
other -> movetarget != self ) 
other -> movetarget == self ) 
self -> pathtarget ) 
ent -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
! self -> targetname || deathmatch -> value ) 
self -> style >= INT_CONST ) 
! ( self -> spawnflags & INT_CONST ) ) 
self -> spawnflags & INT_CONST ) 
( self -> spawnflags & INT_CONST ) == INT_CONST ) 
! ( self -> spawnflags & INT_CONST ) ) 
self -> spawnflags & INT_CONST ) 
self -> spawnflags & INT_CONST ) 
! plane ) 
! self -> dmg ) 
self -> spawnflags & INT_CONST ) 
self ) 
self -> size , FLOAT_CONST , size ) 
self -> dmg ) 
size , FLOAT_CONST , size ) 
! mass ) 
mass >= INT_CONST ) 
count > INT_CONST ) 
self , attacker ) 
self -> dmg ) 
self ) 
STRING ) 
self , self -> model ) 
self -> spawnflags & INT_CONST ) 
self -> spawnflags & INT_CONST ) 
self ) 
( ! other -> groundentity ) || ( other -> groundentity == self ) ) 
self , self -> activator , self -> dmg , NULL , self -> dmg + INT_CONST , MOD_BARREL ) 
self -> s . origin , save ) 
FLOAT ) 
FLOAT ) 
) 
save , self -> s . origin ) 
self ) 
STRING ) 
self -> model ) 
! self -> mass ) 
self ) 
STRING ) 
self -> health > -v INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
ent ) 
STRING ) 
ent -> spawnflags & INT_CONST ) 
ent ) 
! ent -> speed ) 
ent ) 
self , self , self -> dmg , NULL , self -> dmg + INT_CONST , MOD_BOMB ) 
diff < -v FLOAT_CONST ) 
v , self -> s . angles ) 
NULL , FOFS ( classname ) , STRING ) 
viper -> moveinfo . dir , self -> moveinfo . dir ) 
STRING ) 
! self -> dmg ) 
self ) 
! ent -> speed ) 
ent ) 
self -> message ) 
FOR ( e = self -> teammaster ; e ; e = e -> teamchain ) 
self -> style == INT_CONST ) 
self -> style == INT_CONST ) 
self -> spawnflags & INT_CONST ) 
self -> enemy , self , self ) 
( ( self -> spawnflags & INT_CONST ) && ( self -> health > self -> wait ) ) || NEW_LINE ( ( self -> spawnflags & INT_CONST ) && ( self -> health < self -> wait ) ) ) 
( self -> spawnflags & INT_CONST ) && ( ! self -> count ) ) 
( self -> spawnflags & INT_CONST ) && ( ! self -> count ) ) 
CLOCK_MESSAGE_SIZE , TAG_LEVEL ) 
self -> spawnflags & INT_CONST ) 
! other -> client ) 
other ) 
other ) 
dest -> s . origin , other -> s . origin ) 
other -> velocity ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
other ) 
other ) 
! ent -> target ) 
ent , STRING ) 
ent -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
) 
edict_t * ent ) 
__E__O__F__
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
ent -> flags & ( FL_SWIM | FL_FLY ) ) 
ent -> s . origin , ent -> mins , ent -> maxs , point , ent , MASK_MONSTERSOLID ) 
trace . plane . normal [ INT_CONST ] < FLOAT_CONST && ! trace . startsolid ) 
! trace . startsolid && ! trace . allsolid ) 
point ) 
point ) 
ent -> health > INT_CONST ) 
( ent -> watertype & CONTENTS_LAVA ) && ! ( ent -> flags & FL_IMMUNE_LAVA ) ) 
ent , CHAN_BODY , gi . soundindex ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
ent -> s . origin , end ) 
ent ) 
ent -> monsterinfo . aiflags & AI_RESURRECTING ) 
ent -> health <= INT_CONST ) 
( self -> monsterinfo . nextframe ) && ( self -> monsterinfo . nextframe >= move -> firstframe ) && ( self -> monsterinfo . nextframe <= move -> lastframe ) ) 
move -> frame [ index ] . aifunc ) 
self ) 
self ) 
self ) 
self -> enemy && ! ( self -> spawnflags & INT_CONST ) && ! ( self -> enemy -> flags & FL_NOTARGET ) ) 
activator -> client ) 
self -> item ) 
self -> deathtarget ) 
( self -> spawnflags & INT_CONST ) && ! ( self -> monsterinfo . aiflags & AI_GOOD_GUY ) ) 
! ( self -> monsterinfo . aiflags & AI_GOOD_GUY ) ) 
! self -> monsterinfo . checkattack ) 
st . item ) 
self -> monsterinfo . currentmove ) 
self -> health <= INT_CONST ) 
self -> target ) 
self -> combattarget ) 
self -> target ) 
self ) 
self -> spawnflags & INT_CONST ) 
self ) 
self -> spawnflags & INT_CONST ) 
self ) 
self -> spawnflags & INT_CONST ) 
__E__O__F__
ent -> clipmask ) 
trace . startsolid ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
thinktime <= INT_CONST ) 
e1 -> touch && e1 -> solid != SOLID_NOT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( bumpcount = INT_CONST ; bumpcount < numbumps ; bumpcount v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numplanes ; i v++ ) 
FOR ( j = INT_CONST ; j < numplanes ; j v++ ) 
ent -> s . origin , start ) 
ent -> clipmask ) 
trace . fraction != FLOAT_CONST ) 
ent -> inuse ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vec3_origin , amove , org ) 
pusher -> s . origin , pushed_p -> origin ) 
pusher -> s . origin , move , pusher -> s . origin ) 
FOR ( e = INT_CONST ; e < globals . num_edicts ; e v++ , check v++ ) 
check -> groundentity != pusher ) 
FOR ( p = pushed_p - INT_CONST ; p >= pushed ; p v-- ) 
FOR ( p = pushed_p - INT_CONST ; p >= pushed ; p v-- ) 
ent -> flags & FL_TEAMSLAVE ) 
FOR ( part = ent ; part ; part = part -> teamchain ) 
FOR ( mv = ent ; mv ; mv = mv -> teamchain ) 
FOR ( part = ent ; part ; part = part -> teamchain ) 
ent ) 
ent ) 
ent -> flags & FL_TEAMSLAVE ) 
ent ) 
ent -> movetype != MOVETYPE_FLY NEW_LINE && ent -> movetype != MOVETYPE_FLYMISSILE ) 
ent -> velocity , FRAMETIME , move ) 
trace . plane . normal [ INT_CONST ] > FLOAT_CONST ) 
ent -> watertype & MASK_WATER ) 
isinwater ) 
FOR ( slave = ent -> teamchain ; slave ; slave = slave -> teamchain ) 
ent -> s . angles , FRAMETIME , ent -> avelocity , ent -> s . angles ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
! ent -> groundentity ) 
ent ) 
groundentity ) 
! wasonground ) 
( ent -> flags & FL_FLY ) && ( ent -> velocity [ INT_CONST ] != INT_CONST ) ) 
( ent -> flags & FL_SWIM ) && ( ent -> velocity [ INT_CONST ] != INT_CONST ) ) 
ent -> velocity [ INT_CONST ] || ent -> velocity [ INT_CONST ] || ent -> velocity [ INT_CONST ] ) 
vel [ INT_CONST ] * vel [ INT_CONST ] + vel [ INT_CONST ] * vel [ INT_CONST ] ) 
ent ) 
ent ) 
ent ) 
ent ) 
ent ) 
STRING , ( INT ) ent -> movetype ) 
__E__O__F__
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_NOSET ) 
STRING , STRING , CVAR_SERVERINFO | CVAR_LATCH ) 
STRING , STRING , CVAR_SERVERINFO | CVAR_LATCH ) 
! deathmatch -> value ) 
coop -> value ) 
STRING , STRING , CVAR_SERVERINFO ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
) 
game . helpmessage1 , SIZEOF ( game . helpmessage1 ) , STRING ) 
game . helpmessage2 , SIZEOF ( game . helpmessage2 ) , STRING ) 
game . maxentities * SIZEOF ( g_edicts [ INT_CONST ] ) , TAG_GAME ) 
game . maxclients * SIZEOF ( game . clients [ INT_CONST ] ) , TAG_GAME ) 
) 
VOID *p ) 
*v ( CHAR *p *p ) p ) 
*v ( edict_t * *v ) p == NULL ) 
*v ( gclient_t * *v ) p == NULL ) 
*v ( edict_t * *v ) p == NULL ) 
STRING ) 
VOID *p ) 
VOID *p ) 
INT *p ) 
INT *p ) 
INT *p ) 
INT *p ) 
INT *p ) 
STRING ) 
FOR ( field = clientfields ; field -> name ; field v++ ) 
&v temp , SIZEOF ( temp ) , INT_CONST , f ) 
FOR ( field = clientfields ; field -> name ; field v++ ) 
client , SIZEOF ( *v client ) , INT_CONST , f ) 
FOR ( field = clientfields ; field -> name ; field v++ ) 
! autosave ) 
&v game , SIZEOF ( game ) , INT_CONST , f ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
TAG_GAME ) 
filename , STRING ) 
game . maxentities * SIZEOF ( g_edicts [ INT_CONST ] ) , TAG_GAME ) 
&v game , SIZEOF ( game ) , INT_CONST , f ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
FOR ( field = savefields ; field -> name ; field v++ ) 
&v temp , SIZEOF ( temp ) , INT_CONST , f ) 
FOR ( field = savefields ; field -> name ; field v++ ) 
FOR ( field = levelfields ; field -> name ; field v++ ) 
&v temp , SIZEOF ( temp ) , INT_CONST , f ) 
FOR ( field = levelfields ; field -> name ; field v++ ) 
ent , SIZEOF ( *v ent ) , INT_CONST , f ) 
FOR ( field = savefields ; field -> name ; field v++ ) 
&v level , SIZEOF ( level ) , INT_CONST , f ) 
FOR ( field = levelfields ; field -> name ; field v++ ) 
filename , STRING ) 
edict_t ) 
VOID *p ) 
f ) 
FOR ( i = INT_CONST ; i < globals . num_edicts ; i v++ ) 
f ) 
filename , STRING ) 
TAG_LEVEL ) 
g_edicts , INT_CONST , game . maxentities * SIZEOF ( g_edicts [ INT_CONST ] ) ) 
&v i , SIZEOF ( i ) , INT_CONST , f ) 
&v base , SIZEOF ( base ) , INT_CONST , f ) 
f ) 
INT_CONST ) 
f ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
FOR ( i = INT_CONST ; i < globals . num_edicts ; i v++ ) 
__E__O__F__
! ent -> classname ) 
FOR ( i = INT_CONST , item = itemlist ; i < game . num_items ; i v++ , item v++ ) 
FOR ( s = spawns ; s -> name ; s v++ ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
FOR ( f = fields ; f -> name ; f v++ ) 
FLOAT *p ) 
&v st , INT_CONST , SIZEOF ( st ) ) 
INT_CONST ) 
&v data ) 
keyname [ INT_CONST ] == CHAR_CONST ) 
! init ) 
FOR ( i = INT_CONST , e = g_edicts + i ; i < globals . num_edicts ; i v++ , e v++ ) 
FOR ( j = i + INT_CONST , e2 = e + INT_CONST ; j < globals . num_edicts ; j v++ , e2 v++ ) 
STRING , c , c2 ) 
skill -> value ) 
TAG_LEVEL ) 
&v level , INT_CONST , SIZEOF ( level ) ) 
level . mapname , mapname , SIZEOF ( level . mapname ) - INT_CONST ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
INT_CONST ) 
STRING , inhibit ) 
) 
) 
edict_t * ent ) 
) 
) 
st . nextmap ) 
ent -> message && ent -> message [ INT_CONST ] ) 
CS_SKYAXIS , va ( STRING , NEW_LINE st . skyaxis [ INT_CONST ] , st . skyaxis [ INT_CONST ] , st . skyaxis [ INT_CONST ] ) ) 
CS_MAXCLIENTS , va ( STRING , ( INT ) ( maxclients -> value ) ) ) 
deathmatch -> value ) 
CS_STATUSBAR , dm_statusbar ) 
STRING ) 
! st . gravity ) 
FindItem ( STRING ) ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
CS_LIGHTS + INT_CONST , STRING ) 
CS_LIGHTS + INT_CONST , STRING ) 
CS_LIGHTS + INT_CONST , STRING ) 
__E__O__F__
INT_CONST ) 
__E__O__F__
ent -> spawnflags & INT_CONST ) 
ent -> s . sound ) 
ent -> spawnflags & INT_CONST ) 
! st . noise ) 
! ent -> volume ) 
ent -> spawnflags & INT_CONST ) 
ent ) 
ent ) 
! ent -> message ) 
ent , activator ) 
ent ) 
! st . noise ) 
! stricmp ( level . mapname , STRING ) && ent -> s . origin [ INT_CONST ] == INT_CONST && ent -> s . origin [ INT_CONST ] == -v INT_CONST && ent -> s . origin [ INT_CONST ] == -v INT_CONST ) 
level . found_goals == level . total_goals ) 
ent ) 
! st . noise ) 
svc_temp_entity ) 
self , self -> activator , self -> dmg , NULL , self -> dmg + INT_CONST , MOD_EXPLOSIVE ) 
self , self -> activator ) 
! self -> delay ) 
deathmatch -> value && ! ( ( INT ) dmflags -> value & DF_ALLOW_EXIT ) && other != world ) 
deathmatch -> value ) 
strstr ( self -> map , STRING ) ) 
( stricmp ( level . mapname , STRING ) == INT_CONST ) && ( stricmp ( ent -> map , STRING ) == INT_CONST ) ) 
self -> dmg ) 
! self -> count ) 
) 
self -> spawnflags & INT_CONST ) 
! self -> dmg ) 
self -> spawnflags & INT_CONST ) 
self -> s . origin , start ) 
tr . endpos , self -> s . old_origin ) 
self -> spawnflags & INT_CONST ) 
self -> spawnflags & INT_CONST ) 
! self -> dmg ) 
self -> spawnflags & INT_CONST ) 
level . time - self -> timestamp ) 
( level . time - self -> timestamp ) < self -> speed ) 
self ) 
deathmatch -> value ) 
! self -> target ) 
self -> movedir [ INT_CONST ] - self -> movedir [ INT_CONST ] ) 
self -> last_move_time < level . time ) 
FOR ( i = INT_CONST , e = g_edicts + i ; i < globals . num_edicts ; i v++ , e v++ ) 
level . time < self -> timestamp ) 
STRING ) 
__E__O__F__
ent -> wait > INT_CONST ) 
self ) 
ent -> spawnflags & INT_CONST ) 
! VectorCompare ( ent -> s . angles , vec3_origin ) ) 
ent -> spawnflags & INT_CONST ) 
ent ) 
! self -> item ) 
activator , CHAN_AUTO , gi . soundindex ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
FOR ( cube = INT_CONST ; cube < INT_CONST ; cube v++ ) 
FOR ( player = INT_CONST ; player <= game . maxclients ; player v++ ) 
FOR ( player = INT_CONST ; player <= game . maxclients ; player v++ ) 
self , activator ) 
! self -> item ) 
! self -> target ) 
STRING ) 
ent -> delay < FLOAT_CONST ) 
! ( self -> spawnflags & INT_CONST ) ) 
! other -> takedamage ) 
self -> spawnflags & INT_CONST ) 
STRING ) 
! self -> dmg ) 
self ) 
__E__O__F__
! from ) 
FOR ( ; from < &v g_edicts [ globals . num_edicts ] ; from v++ ) 
! from ) 
FOR ( ; from < &v g_edicts [ globals . num_edicts ] ; from v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! targetname ) 
INT_CONST ) 
! num_choices ) 
) 
ent -> delay ) 
) 
ent -> killtarget ) 
ent -> target ) 
index + INT_CONST ) 
index + INT_CONST ) 
s , INT_CONST , STRING , ( INT ) v [ INT_CONST ] , ( INT ) v [ INT_CONST ] , ( INT ) v [ INT_CONST ] ) 
angles ) 
INT ) 
FOR ( i = maxclients -> value + INT_CONST ; i < globals . num_edicts ; i v++ , e v++ ) 
( ed - g_edicts ) <= ( maxclients -> value + BODY_QUEUE_SIZE ) ) 
ed , INT_CONST , SIZEOF ( *v ed ) ) 
( ent -> client || ( ent -> svflags & SVF_MONSTER ) ) && ( ent -> health <= INT_CONST ) ) 
FOR ( i = INT_CONST ; i < num ; i v++ ) 
ent -> absmin , ent -> absmax , touch NEW_LINE , MAX_EDICTS , AREA_SOLID ) 
FOR ( i = INT_CONST ; i < num ; i v++ ) 
INT_CONST ) 
__E__O__F__
skill -> value == INT_CONST ) 
self -> enemy -> s . origin , self -> s . origin , dir ) 
self -> s . origin , range , dir , point ) 
self -> s . origin , NULL , NULL , point , self , MASK_SHOT ) 
( tr . ent -> svflags & SVF_MONSTER ) || ( tr . ent -> client ) ) 
self -> s . angles , forward , right , up ) 
tr . ent , self , self , dir , point , vec3_origin , damage , kick / INT_CONST , DAMAGE_NO_KNOCKBACK , MOD_HIT ) 
! ( tr . ent -> svflags & SVF_MONSTER ) && ( ! tr . ent -> client ) ) 
self -> enemy -> absmin , FLOAT_CONST , self -> enemy -> size , v ) 
self -> s . origin , NULL , NULL , start , self , MASK_SHOT ) 
start , water_start ) 
tr . endpos , water_start ) 
! ( ( tr . surface ) && ( tr . surface -> flags & SURF_SKY ) ) ) 
water ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
other == self -> owner ) 
self -> owner -> client ) 
self ) 
dir ) 
) 
start , bolt -> s . origin ) 
self -> client ) 
ent -> owner -> client ) 
ent -> enemy ) 
ent -> spawnflags & INT_CONST ) 
ent -> s . origin , -v FLOAT_CONST , ent -> velocity , origin ) 
ent ) 
! other -> takedamage ) 
ent ) 
aimdir , dir ) 
) 
grenade ) 
aimdir , dir ) 
) 
timer <= FLOAT_CONST ) 
other == ent -> owner ) 
ent -> owner -> client ) 
ent -> s . origin , -v FLOAT_CONST , ent -> velocity , origin ) 
other -> takedamage ) 
ent , ent -> owner , ent -> radius_dmg , other , ent -> dmg_radius , MOD_R_SPLASH ) 
svc_temp_entity ) 
ent ) 
) 
self -> client ) 
start , INT_CONST , aimdir , end ) 
svc_temp_entity ) 
self -> client ) 
self -> s . frame == INT_CONST ) 
self -> s . frame == INT_CONST ) 
self -> owner -> client ) 
other -> takedamage ) 
self , CHAN_VOICE , gi . soundindex ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
svc_temp_entity ) 
deathmatch -> value ) 
) 
self -> client ) 
__E__O__F__
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
mins [ INT_CONST ] + maxs [ INT_CONST ] ) 
trace . fraction == FLOAT_CONST ) 
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
ent -> s . origin , oldorg ) 
ent -> flags & ( FL_SWIM | FL_FLY ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! ( ent -> monsterinfo . aiflags & AI_NOSTEP ) ) 
neworg , ent -> mins , ent -> maxs , end , ent , MASK_MONSTERSOLID ) 
trace . allsolid ) 
ent -> waterlevel == INT_CONST ) 
trace . fraction == INT_CONST ) 
ent -> flags & FL_PARTIALGROUND ) 
ent ) 
trace . endpos , ent -> s . origin ) 
ent ) 
ent -> flags & FL_PARTIALGROUND ) 
relink ) 
current == ideal ) 
ent -> s . origin , oldorigin ) 
! enemy ) 
deltax > INT_CONST ) 
( ( rand ( ) & INT_CONST ) & INT_CONST ) || abs ( deltay ) > abs ( deltax ) ) 
d [ INT_CONST ] != DI_NODIR && d [ INT_CONST ] != turnaround NEW_LINE && SV_StepDirection ( actor , d [ INT_CONST ] , dist ) ) 
FOR ( tdir = INT_CONST ; tdir <= INT_CONST ; tdir += INT_CONST ) 
FOR ( tdir = INT_CONST ; tdir >= INT_CONST ; tdir -= INT_CONST ) 
turnaround != DI_NODIR && SV_StepDirection ( actor , turnaround , dist ) ) 
! M_CheckBottom ( actor ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
goal -> absmax [ i ] < ent -> absmin [ i ] - dist ) 
ent , move , true ) 
__E__O__F__
INT_CONST ) 
stricmp ( level . mapname , STRING ) == INT_CONST ) 
( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( stricmp ( level . mapname , STRING ) == INT_CONST ) ) 
! ent -> client ) 
coop -> value && attacker -> client ) 
PRINT_MEDIUM , STRING , self -> client -> pers . netname ) 
! deathmatch -> value ) 
quad ) 
attacker && attacker != world && attacker != self ) 
dir [ INT_CONST ] ) 
self -> avelocity ) 
! self -> deadflag ) 
self -> client -> pers . inventory , INT_CONST , SIZEOF ( self -> client -> pers . inventory ) ) 
self -> health < -v INT_CONST ) 
self , CHAN_BODY , gi . soundindex ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
! self -> deadflag ) 
i + INT_CONST ) 
self ) 
&v client -> pers , INT_CONST , SIZEOF ( client -> pers ) ) 
STRING ) 
STRING ) 
ctf -> value && client -> resp . ctf_team < CTF_TEAM1 ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
FOR ( n = INT_CONST ; n <= maxclients -> value ; n v++ ) 
( spot = G_Find ( spot , FOFS ( classname ) , STRING ) ) != NULL ) 
! count ) 
( spot = G_Find ( spot , FOFS ( classname ) , STRING ) ) != NULL ) 
bestspot ) 
NULL , FOFS ( classname ) , STRING ) 
! index ) 
INT_CONST ) 
deathmatch -> value ) 
! spot ) 
spot -> s . origin , origin ) 
FOR ( i = INT_CONST ; i < BODY_QUEUE_SIZE ; i v++ ) 
self -> health < -v INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
INT ) 
ent ) 
body ) 
ent -> mins , body -> mins ) 
body ) 
STRING ) 
ent , spawn_origin , spawn_angles ) 
deathmatch -> value ) 
FOR ( n = INT_CONST ; n < MAX_ITEMS ; n v++ ) 
client , INT_CONST , SIZEOF ( *v client ) ) 
ent ) 
mins , ent -> mins ) 
&v ent -> client -> ps , INT_CONST , SIZEOF ( client -> ps ) ) 
deathmatch -> value && ( ( INT ) dmflags -> value & DF_FIXED_FOV ) ) 
client -> pers . weapon -> view_model ) 
spawn_origin , ent -> s . origin ) 
ent -> s . origin , ent -> s . old_origin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
CTFStartClient ( ent ) ) 
ent ) 
ent ) 
ent -> client ) 
ent ) 
svc_muzzleflash ) 
PRINT_HIGH , STRING , ent -> client -> pers . netname ) 
ent ) 
ent - g_edicts - INT_CONST ) 
deathmatch -> value ) 
ent -> inuse == true ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
level . intermissiontime ) 
ent ) 
! Info_Validate ( userinfo ) ) 
userinfo , STRING ) 
userinfo , STRING ) 
ctf -> value ) 
deathmatch -> value && ( ( INT ) dmflags -> value & DF_FIXED_FOV ) ) 
userinfo , STRING ) 
ent -> client -> pers . userinfo , userinfo , SIZEOF ( ent -> client -> pers . userinfo ) - INT_CONST ) 
userinfo , STRING ) 
userinfo , STRING ) 
ent - g_edicts - INT_CONST ) 
ent -> inuse == false ) 
ent , userinfo ) 
game . maxclients > INT_CONST ) 
! ent -> client ) 
ent ) 
svc_muzzleflash ) 
ent ) 
CS_PLAYERSKINS + playernum , STRING ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
&v pm -> s , SIZEOF ( pm -> s ) ) 
level . intermissiontime ) 
ent -> client -> chase_target ) 
&v pm , INT_CONST , SIZEOF ( pm ) ) 
ent -> movetype == MOVETYPE_NOCLIP ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
memcmp ( &v client -> old_pmove , &v pm . s , SIZEOF ( pm . s ) ) ) 
&v pm ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pm . mins , ent -> mins ) 
ucmd -> angles [ INT_CONST ] ) 
ent -> groundentity && ! pm . groundentity && ( pm . cmd . upmove >= INT_CONST ) && ( pm . waterlevel == INT_CONST ) ) 
pm . groundentity ) 
client -> ctf_grapple ) 
ent -> movetype != MOVETYPE_NOCLIP ) 
FOR ( i = INT_CONST ; i < pm . numtouch ; i v++ ) 
FOR ( j = INT_CONST ; j < i ; j v++ ) 
client -> latched_buttons & BUTTON_ATTACK NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE && ent -> movetype != MOVETYPE_NOCLIP NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE ) 
ent ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
client -> menudirty && client -> menutime <= level . time ) 
level . intermissiontime ) 
! client -> weapon_thunk NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE && ent -> movetype != MOVETYPE_NOCLIP NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE ) 
! deathmatch -> value ) 
__E__O__F__
deathmatch -> value || coop -> value ) 
level . intermissiontime ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
strstr ( level . changemap , STRING ) ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
FOR ( n = INT_CONST ; n < MAX_ITEMS ; n v++ ) 
NULL , FOFS ( classname ) , STRING ) 
NULL , FOFS ( classname ) , STRING ) 
) 
ent -> s . origin , level . intermission_origin ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
ctf -> value ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
FOR ( j = INT_CONST ; j < total ; j v++ ) 
FOR ( k = total ; k > j ; k v-- ) 
string ) 
total > INT_CONST ) 
FOR ( i = INT_CONST ; i < total ; i v++ ) 
cl_ent == killer ) 
tag ) 
svc_layout ) 
ent ) 
skill -> value == INT_CONST ) 
string , SIZEOF ( string ) , NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING NEW_LINE STRING , NEW_LINE sk , NEW_LINE level . level_name , NEW_LINE game . helpmessage1 , NEW_LINE game . helpmessage2 , NEW_LINE level . killed_monsters , level . total_monsters , NEW_LINE level . found_goals , level . total_goals , NEW_LINE level . found_secrets , level . total_secrets ) 
deathmatch -> value ) 
ent -> client -> showhelp && ( ent -> client -> resp . game_helpchanged == game . helpchanged ) ) 
ent ) 
! ent -> client -> ammo_index COMMENT ) 
ent ) 
ent ) 
STRING ) 
level . time > ent -> client -> pickup_msg_time ) 
ent -> client -> quad_framenum > level . framenum ) 
ent -> client -> pers . selected_item == -v INT_CONST ) 
deathmatch -> value ) 
ent -> client -> resp . helpchanged && ( level . framenum & INT_CONST ) ) 
__E__O__F__
! ent -> client ) 
SIZEOF ( *v hnd ) ) 
SIZEOF ( pmenu_t ) * num ) 
FOR ( i = INT_CONST ; i < num ; i v++ ) 
cur < INT_CONST || ! entries [ cur ] . SelectFunc ) 
FOR ( i = INT_CONST , p = entries ; i < num ; i v++ , p v++ ) 
ent ) 
! ent -> client -> menu ) 
FOR ( i = INT_CONST ; i < hnd -> num ; i v++ ) 
! ent -> client -> menu ) 
string , STRING ) 
FOR ( i = INT_CONST , p = hnd -> entries ; i < hnd -> num ; i v++ , p v++ ) 
svc_layout ) 
level . time - ent -> client -> menutime >= FLOAT_CONST ) 
! ent -> client -> menu ) 
hnd -> cur < INT_CONST ) 
ent ) 
! ent -> client -> menu ) 
hnd -> cur < INT_CONST ) 
p -> SelectFunc ) 
ent ) 
! ent -> client -> menu ) 
hnd -> cur < INT_CONST ) 
p -> SelectFunc ) 
__E__O__F__
deathmatch -> value COMMENT ) 
FOR ( n = INT_CONST ; n < TRAIL_LENGTH ; n v++ ) 
! trail_active ) 
spot , trail [ PREV ( trail_head ) ] -> s . origin , temp ) 
trail_head ) 
! trail_active ) 
FOR ( marker = trail_head , n = TRAIL_LENGTH ; n ; n v-- ) 
visible ( self , trail [ marker ] ) ) 
visible ( self , trail [ PREV ( marker ) ] ) ) 
! trail_active ) 
FOR ( marker = trail_head , n = TRAIL_LENGTH ; n ; n v-- ) 
__E__O__F__
edict_t * player ) 
client -> damage_blood ) 
client -> damage_blood + client -> damage_armor + client -> damage_parmor ) 
client -> anim_priority < ANIM_PAIN && player -> s . modelindex == INT_CONST ) 
count < INT_CONST ) 
( level . time > player -> pain_debounce_time ) && ! ( player -> flags & FL_GODMODE ) && ( client -> invincible_framenum <= level . framenum ) ) 
client -> damage_alpha < INT_CONST ) 
v ) 
client -> damage_knockback ) 
ent -> deadflag ) 
v ) 
ent -> client -> fall_time - level . time ) 
bob > INT_CONST ) 
v , ent -> client -> kick_origin , v ) 
v [ INT_CONST ] < -v INT_CONST ) 
bobcycle & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
delta < -v INT_CONST ) 
delta > INT_CONST ) 
ent -> client -> ps . gunoffset ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
a <= INT_CONST ) 
INT_CONST - a3 ) 
ent -> s . origin , ent -> client -> ps . viewoffset , vieworg ) 
ent -> client -> quad_framenum > level . framenum ) 
ent -> client -> damage_alpha > INT_CONST ) 
ent -> client -> damage_alpha < INT_CONST ) 
ent -> client -> bonus_alpha < INT_CONST ) 
ent -> s . modelindex != INT_CONST ) 
level . time - ent -> client -> ctf_grapplereleasetime <= FRAMETIME * INT_CONST || NEW_LINE ( ent -> client -> ctf_grapple && NEW_LINE ent -> client -> ctf_grapplestate > CTF_GRAPPLE_STATE_FLY ) ) 
ent -> waterlevel == INT_CONST ) 
ent -> client -> fall_value > INT_CONST ) 
delta > INT_CONST ) 
current_player -> movetype == MOVETYPE_NOCLIP ) 
! old_waterlevel && waterlevel ) 
old_waterlevel && ! waterlevel ) 
old_waterlevel != INT_CONST && waterlevel == INT_CONST ) 
old_waterlevel == INT_CONST && waterlevel != INT_CONST ) 
waterlevel == INT_CONST ) 
waterlevel && ( current_player -> watertype & ( CONTENTS_LAVA | CONTENTS_SLIME ) ) ) 
ent -> health <= INT_CONST || level . intermissiontime ) 
ent ) 
ent -> client -> invincible_framenum > level . framenum NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE && ( level . framenum & INT_CONST ) NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE ) 
ent -> flags & FL_GODMODE ) 
ent -> client -> resp . game_helpchanged != game . helpchanged ) 
ent -> client -> resp . helpchanged && ent -> client -> resp . helpchanged <= INT_CONST && ! ( level . framenum & INT_CONST ) ) 
ent -> client -> pers . weapon ) 
ent -> s . modelindex != INT_CONST ) 
client -> ps . pmove . pm_flags & PMF_DUCKED ) 
duck != client -> anim_duck && client -> anim_priority < ANIM_DEATH ) 
client -> anim_priority == ANIM_DEATH ) 
! ent -> groundentity ) 
duck ) 
duck ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
level . intermissiontime ) 
ent -> client -> v_angle , forward , right , up ) 
) 
ent -> client -> v_angle [ PITCH ] > INT_CONST ) 
ent -> velocity [ INT_CONST ] * ent -> velocity [ INT_CONST ] + ent -> velocity [ INT_CONST ] * ent -> velocity [ INT_CONST ] ) 
xyspeed < INT_CONST ) 
xyspeed > INT_CONST ) 
ent ) 
ent ) 
ent ) 
ent ) 
ent ) 
! ent -> client -> chase_target ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
ent ) 
ent ) 
ent ) 
ent -> velocity , ent -> client -> oldvelocity ) 
ent -> client -> kick_origin ) 
ent -> client -> showscores && ! ( level . framenum & INT_CONST ) ) 
ent , ent -> enemy ) 
__E__O__F__
distance , _distance ) 
type == PNOISE_WEAPON ) 
deathmatch -> value ) 
type == PNOISE_SELF || type == PNOISE_WEAPON ) 
where , noise -> s . origin ) 
ent -> item ) 
( ( ( INT ) ( dmflags -> value ) & DF_WEAPONS_STAY ) || coop -> value ) NEW_LINE && other -> client -> pers . inventory [ index ] ) 
! ( ent -> spawnflags & DROPPED_ITEM ) ) 
other -> client -> pers . weapon != ent -> item && NEW_LINE ( other -> client -> pers . inventory [ index ] == INT_CONST ) && NEW_LINE ( ! deathmatch -> value || other -> client -> pers . weapon == FindItem ( STRING ) ) ) 
ent -> client -> grenade_time ) 
ent -> s . modelindex == INT_CONST ) 
ent -> client -> pers . weapon && ent -> client -> pers . weapon -> ammo ) 
ent -> client -> pers . weapon -> view_model ) 
ent -> client -> ps . pmove . pm_flags & PMF_DUCKED ) 
ent -> health < INT_CONST ) 
ent -> client -> pers . weapon && ent -> client -> pers . weapon -> weaponthink ) 
item == ent -> client -> pers . weapon ) 
( INT ) ( dmflags -> value ) & DF_WEAPONS_STAY ) 
( ( item == ent -> client -> pers . weapon ) || ( item == ent -> client -> newweapon ) ) && ( ent -> client -> pers . inventory [ index ] == INT_CONST ) ) 
ent , item ) 
ent -> deadflag || ent -> s . modelindex != INT_CONST ) 
ent -> client -> weaponstate == WEAPON_DROPPING ) 
ent -> client -> weaponstate == WEAPON_ACTIVATING ) 
( ent -> client -> newweapon ) && ( ent -> client -> weaponstate != WEAPON_FIRING ) ) 
( FRAME_DEACTIVATE_LAST - FRAME_DEACTIVATE_FIRST ) < INT_CONST ) 
ent -> client -> weaponstate == WEAPON_READY ) 
FOR ( n = INT_CONST ; pause_frames [ n ] ; n v++ ) 
ent -> client -> weaponstate == WEAPON_FIRING ) 
FOR ( n = INT_CONST ; fire_frames [ n ] ; n v++ ) 
ent , FRAME_ACTIVATE_LAST , FRAME_FIRE_LAST , NEW_LINE FRAME_IDLE_LAST , FRAME_DEACTIVATE_LAST , pause_frames , NEW_LINE fire_frames , fire ) 
stricmp ( ent -> client -> pers . weapon -> pickup_name , STRING ) == INT_CONST && NEW_LINE ent -> client -> weaponstate == WEAPON_FIRING ) 
is_quad ) 
GRENADE_TIMER - timer ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent -> deadflag || ent -> s . modelindex != INT_CONST ) 
ent -> client -> ps . pmove . pm_flags & PMF_DUCKED ) 
ent -> client -> weaponstate == WEAPON_ACTIVATING ) 
ent -> client -> weaponstate == WEAPON_READY ) 
ent -> client -> weaponstate == WEAPON_FIRING ) 
is_quad ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
ent , start , forward , damage , INT_CONST , FLOAT_CONST , radius ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_grenadelauncher_fire ) 
INT ) 
ent -> client -> v_angle , forward , right , NULL ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Weapon_RocketLauncher_Fire ) 
is_quad ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
ent , start , forward , damage , INT_CONST , effect , hyper ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
deathmatch -> value ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Weapon_Blaster_Fire ) 
STRING ) 
! ( ent -> client -> buttons & BUTTON_ATTACK ) ) 
ent -> client -> ps . gunframe == INT_CONST ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Weapon_HyperBlaster_Fire ) 
! ( ent -> client -> buttons & BUTTON_ATTACK ) ) 
ent -> client -> ps . gunframe == INT_CONST ) 
is_quad ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! deathmatch -> value ) 
ent -> client -> v_angle , ent -> client -> kick_angles , angles ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Machinegun_Fire ) 
deathmatch -> value ) 
ent -> client -> ps . gunframe == INT_CONST ) 
ent -> client -> ps . pmove . pm_flags & PMF_DUCKED ) 
ent -> client -> ps . gunframe <= INT_CONST ) 
is_quad ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < shots ; i v++ ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Chaingun_Fire ) 
ent -> client -> ps . gunframe == INT_CONST ) 
ent -> client -> v_angle , forward , right , NULL ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
is_quad ) 
deathmatch -> value ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_shotgun_fire ) 
ent -> client -> v_angle , forward , right , NULL ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
is_quad ) 
v , forward , NULL , NULL ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_supershotgun_fire ) 
deathmatch -> value ) 
is_quad ) 
ent -> client -> v_angle , forward , right , NULL ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_railgun_fire ) 
deathmatch -> value ) 
ent -> client -> pers . inventory [ ent -> client -> ammo_index ] < INT_CONST ) 
is_quad ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_bfg_fire ) 
__E__O__F__
vr , dir ) 
im , m , SIZEOF ( im ) ) 
zrot , INT_CONST , SIZEOF ( zrot ) ) 
DEG2RAD ( degrees ) ) 
m , zrot , tmpmat ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
M_PI * INT_CONST / INT_CONST ) 
forward ) 
normal , normal ) 
normal , p ) 
FOR ( pos = INT_CONST , i = INT_CONST ; i < INT_CONST ; i v++ ) 
dst , tempvec , src ) 
dst ) 
vec3_t emins , vec3_t emaxs , STRUCT cplane_s * p ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
p -> type < INT_CONST ) 
p -> signbits ) 
INT_CONST ) 
dist1 >= p -> dist ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
length ) 
length ) 
length ) 
length ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
*v in && *v in != CHAR_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST && *v in ; i v++ , in v++ ) 
FOR ( s2 = s ; s2 != in && *v s2 != CHAR_CONST ; s2 v-- ) 
*v src != CHAR_CONST && src != path ) 
path , extension ) 
l >> INT_CONST ) 
b1 << INT_CONST ) 
l >> INT_CONST ) 
( INT ) b1 << INT_CONST ) 
*v ( SHORT *p ) swaptest == INT_CONST ) 
! data ) 
c == CHAR_CONST && data [ INT_CONST ] == CHAR_CONST ) 
c == CHAR_CONST ) 
len == MAX_TOKEN_CHARS ) 
FOR ( i = size - INT_CONST ; i > INT_CONST ; i -= INT_CONST ) 
argptr , fmt ) 
*v s == CHAR_CONST ) 
strstr ( key , STRING ) ) 
INT_CONST ) 
strstr ( key , STRING ) || strstr ( value , STRING ) ) 
strstr ( key , STRING ) ) 
strstr ( key , STRING ) || strstr ( value , STRING ) ) 
strlen ( key ) > MAX_INFO_KEY - INT_CONST || strlen ( value ) > MAX_INFO_KEY - INT_CONST ) 
strlen ( newi ) + strlen ( s ) > maxsize ) 
s ) 
__E__O__F__
level . sight_client == NULL ) 
dist ) 
FindTarget ( self ) ) 
! ( self -> spawnflags & INT_CONST ) && ( self -> monsterinfo . idle ) && ( level . time > self -> monsterinfo . idle_time ) ) 
FindTarget ( self ) ) 
self -> enemy -> s . origin , self -> s . origin , v ) 
dist ) 
self -> s . origin , other -> s . origin , v ) 
self -> s . origin , spot1 ) 
self -> monsterinfo . aiflags & AI_STAND_GROUND ) 
! ( self -> monsterinfo . aiflags & AI_STAND_GROUND ) ) 
self -> enemy -> client ) 
self -> enemy -> s . origin , self -> monsterinfo . last_sighting ) 
! self -> combattarget ) 
self -> combattarget ) 
self ) 
self -> monsterinfo . aiflags & AI_GOOD_GUY ) 
self -> monsterinfo . aiflags & AI_COMBAT_POINT ) 
! client -> inuse ) 
client -> enemy -> flags & FL_NOTARGET ) 
client -> light_level <= INT_CONST ) 
! visible ( self , client ) ) 
self ) 
! ( self -> monsterinfo . aiflags & AI_SOUND_TARGET ) && ( self -> monsterinfo . sight ) ) 
self -> s . angles [ YAW ] - self -> ideal_yaw ) 
self -> enemy -> health > INT_CONST ) 
self -> s . origin , spot1 ) 
self -> monsterinfo . melee ) 
! self -> monsterinfo . attack ) 
skill -> value == INT_CONST ) 
self -> flags & FL_FLY ) 
FacingIdeal ( self ) ) 
FacingIdeal ( self ) ) 
self -> monsterinfo . lefty ) 
self -> goalentity ) 
self -> monsterinfo . aiflags & AI_SOUND_TARGET ) 
( ! self -> enemy ) || ( ! self -> enemy -> inuse ) ) 
hesDeadJim ) 
self -> oldenemy && self -> oldenemy -> health > INT_CONST ) 
self , self -> enemy ) 
self , self -> enemy ) 
self -> monsterinfo . attack_state == AS_MISSILE ) 
! enemy_vis ) 
self -> monsterinfo . aiflags & AI_COMBAT_POINT ) 
self -> monsterinfo . aiflags & AI_SOUND_TARGET ) 
ai_checkattack ( self , dist ) ) 
enemy_vis ) 
coop -> value ) 
FindTarget ( self ) ) 
( self -> monsterinfo . search_time ) && ( level . time > ( self -> monsterinfo . search_time + INT_CONST ) ) ) 
) 
! ( self -> monsterinfo . aiflags & AI_LOST_SIGHT ) ) 
self -> monsterinfo . aiflags & AI_PURSUE_NEXT ) 
self -> s . origin , self -> monsterinfo . last_sighting , v ) 
self -> monsterinfo . last_sighting , self -> goalentity -> s . origin ) 
new ) 
self , dist ) 
tempgoal ) 
self ) 
__E__O__F__
! ent -> client -> chase_target -> inuse NEW_LINE || ent -> client -> chase_target -> client -> resp . spectator ) 
targ -> s . origin , ownerv ) 
targ -> client -> v_angle , angles ) 
o [ INT_CONST ] < targ -> s . origin [ INT_CONST ] + INT_CONST ) 
! targ -> groundentity ) 
trace . endpos , goal ) 
goal , INT_CONST , forward , goal ) 
goal , o ) 
goal , o ) 
targ -> deadflag ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent ) 
! ent -> client -> chase_target ) 
! ent -> client -> chase_target ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
__E__O__F__
! ent -> client ) 
! ( ( INT ) ( dmflags -> value ) & ( DF_MODELTEAMS | DF_SKINTEAMS ) ) ) 
strcmp ( ent1Team , ent2Team ) == INT_CONST ) 
cl -> chase_target ) 
FOR ( i = INT_CONST ; i <= MAX_ITEMS ; i v++ ) 
cl -> chase_target ) 
FOR ( i = INT_CONST ; i <= MAX_ITEMS ; i v++ ) 
cl -> pers . inventory [ cl -> pers . selected_item ] ) 
deathmatch -> value && ! sv_cheats -> value ) 
) 
Q_stricmp ( name , STRING ) == INT_CONST ) 
give_all || Q_stricmp ( name , STRING ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ ) 
give_all || Q_stricmp ( name , STRING ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ ) 
give_all || Q_stricmp ( name , STRING ) == INT_CONST ) 
give_all || Q_stricmp ( name , STRING ) == INT_CONST ) 
give_all ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ ) 
name ) 
! it -> pickup ) 
it ) 
it -> flags & IT_AMMO ) 
deathmatch -> value && ! sv_cheats -> value ) 
! ( ent -> flags & FL_GODMODE ) ) 
deathmatch -> value && ! sv_cheats -> value ) 
! ( ent -> flags & FL_NOTARGET ) ) 
deathmatch -> value && ! sv_cheats -> value ) 
ent -> movetype == MOVETYPE_NOCLIP ) 
ent , PRINT_HIGH , msg ) 
) 
ent , it ) 
) 
ent , it ) 
cl -> showinventory ) 
svc_inventory ) 
FOR ( i = INT_CONST ; i < MAX_ITEMS ; i v++ ) 
ent ) 
ent -> client -> pers . selected_item == -v INT_CONST ) 
! it -> use ) 
! cl -> pers . weapon ) 
FOR ( i = INT_CONST ; i <= MAX_ITEMS ; i v++ ) 
! cl -> pers . weapon ) 
FOR ( i = INT_CONST ; i <= MAX_ITEMS ; i v++ ) 
! cl -> pers . weapon || ! cl -> pers . lastweapon ) 
ent ) 
ent -> client -> pers . selected_item == -v INT_CONST ) 
! it -> drop ) 
INT *p ) 
anum < bnum ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
index , count , SIZEOF ( index [ INT_CONST ] ) , PlayerSort ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
ent , PRINT_HIGH , STRING , large , count ) 
gi . argv ( INT_CONST ) ) 
ent -> client -> ps . pmove . pm_flags & PMF_DUCKED ) 
i ) 
ent , PRINT_HIGH , STRING ) 
ent , PRINT_HIGH , STRING ) 
ent , PRINT_HIGH , STRING ) 
ent , PRINT_HIGH , STRING ) 
gi . argc ( ) < INT_CONST && ! arg0 ) 
strlen ( text ) > INT_CONST ) 
flood_msgs -> value ) 
dedicated -> value ) 
FOR ( j = INT_CONST ; j <= game . maxclients ; j v++ ) 
FOR ( i = INT_CONST , e2 = g_edicts + INT_CONST ; i < maxclients -> value ; i v++ , e2 v++ ) 
! ent -> client ) 
Q_stricmp ( cmd , STRING ) == INT_CONST ) 
level . intermissiontime ) 
ent , false , true ) 
__E__O__F__
targ -> movetype == MOVETYPE_PUSH ) 
( targ -> svflags & SVF_MONSTER ) && ( targ -> deadflag != DEAD_DEAD ) ) 
targ -> movetype == MOVETYPE_PUSH || targ -> movetype == MOVETYPE_STOP || targ -> movetype == MOVETYPE_NONE ) 
targ , inflictor , attacker , damage , point ) 
( targ -> svflags & SVF_MONSTER ) && ( targ -> deadflag != DEAD_DEAD ) ) 
targ , inflictor , attacker , damage , point ) 
! damage ) 
dflags & DAMAGE_NO_ARMOR ) 
! save ) 
client ) 
! damage ) 
! client ) 
dflags & DAMAGE_ENERGY ) 
targ -> monsterinfo . aiflags & AI_GOOD_GUY ) 
attacker -> client ) 
( ( targ -> flags & ( FL_FLY | FL_SWIM ) ) == ( attacker -> flags & ( FL_FLY | FL_SWIM ) ) ) && NEW_LINE ( strcmp ( targ -> classname , attacker -> classname ) != INT_CONST ) && NEW_LINE ( strcmp ( attacker -> classname , STRING ) != INT_CONST ) && NEW_LINE ( strcmp ( attacker -> classname , STRING ) != INT_CONST ) && NEW_LINE ( strcmp ( attacker -> classname , STRING ) != INT_CONST ) && NEW_LINE ( strcmp ( attacker -> classname , STRING ) != INT_CONST ) ) 
attacker -> enemy == targ ) 
attacker -> enemy && attacker -> enemy != targ ) 
! targ -> takedamage ) 
( targ != attacker ) && ( ( deathmatch -> value && ( ( INT ) ( dmflags -> value ) & ( DF_MODELTEAMS | DF_SKINTEAMS ) ) ) || coop -> value ) ) 
skill -> value == INT_CONST && deathmatch -> value == INT_CONST && targ -> client ) 
dflags & DAMAGE_BULLET ) 
! ( dflags & DAMAGE_RADIUS ) && ( targ -> svflags & SVF_MONSTER ) && ( attacker -> client ) && ( ! targ -> enemy ) && ( targ -> health > INT_CONST ) ) 
( targ -> flags & FL_GODMODE ) && ! ( dflags & DAMAGE_NO_PROTECTION ) ) 
( client && client -> invincible_framenum > level . framenum ) && ! ( dflags & DAMAGE_NO_PROTECTION ) ) 
targ , point , normal , take , dflags ) 
targ , point , normal , take , te_sparks , dflags ) 
! ( dflags & DAMAGE_NO_PROTECTION ) && CheckTeamDamage ( targ , attacker ) ) 
targ -> svflags & SVF_MONSTER ) 
client ) 
( ent = findradius ( ent , inflictor -> s . origin , radius ) ) != NULL ) 
__E__O__F__
ent -> moveinfo . dir , ent -> moveinfo . remaining_distance / FRAMETIME , ent -> velocity ) 
( ent -> moveinfo . speed * FRAMETIME ) >= ent -> moveinfo . remaining_distance ) 
ent -> moveinfo . speed == ent -> moveinfo . accel && ent -> moveinfo . speed == ent -> moveinfo . decel ) 
ent -> moveinfo . state == STATE_UP ) 
move , FLOAT_CONST / FRAMETIME , ent -> avelocity ) 
ent -> moveinfo . state == STATE_UP ) 
traveltime < FRAMETIME ) 
traveltime / FRAMETIME ) 
destdelta , FLOAT_CONST / traveltime , ent -> avelocity ) 
moveinfo -> remaining_distance < moveinfo -> accel ) 
moveinfo -> speed , moveinfo -> accel ) 
( moveinfo -> remaining_distance - accel_dist - decel_dist ) < INT_CONST ) 
moveinfo -> remaining_distance <= moveinfo -> decel_distance ) 
moveinfo -> current_speed == moveinfo -> move_speed ) 
moveinfo -> current_speed < moveinfo -> speed ) 
ent -> moveinfo . current_speed == INT_CONST ) 
&v ent -> moveinfo ) 
ent -> moveinfo . remaining_distance <= ent -> moveinfo . current_speed ) 
ent -> moveinfo . dir , ent -> moveinfo . current_speed * INT_CONST , ent -> velocity ) 
other , self , self , vec3_origin , other -> s . origin , vec3_origin , self -> dmg , INT_CONST , INT_CONST , MOD_CRUSH ) 
self -> moveinfo . state == STATE_UP ) 
ent -> moveinfo . state == STATE_BOTTOM ) 
) 
ent -> pos1 [ INT_CONST ] - ent -> pos2 [ INT_CONST ] + st . lip ) 
ent -> spawnflags & PLAT_LOW_TRIGGER ) 
trigger ) 
ent , ent -> model ) 
! ent -> speed ) 
ent -> s . origin , ent -> pos1 ) 
ent ) 
ent -> targetname ) 
ent -> pos1 , ent -> moveinfo . start_origin ) 
STRING ) 
ent -> movedir ) 
ent -> spawnflags & INT_CONST ) 
self , self -> moveinfo . start_origin , button_done ) 
self -> health ) 
self , self -> activator ) 
ent -> s . angles , ent -> movedir ) 
ent -> sounds != INT_CONST ) 
ent -> health ) 
ent -> pos1 , ent -> moveinfo . start_origin ) 
ent ) 
! self -> target ) 
self -> moveinfo . wait >= INT_CONST ) 
self -> flags & FL_TEAMSLAVE ) 
FOR ( ent = self ; ent ; ent = ent -> teamchain ) 
ent ) 
FOR ( ent = self ; ent ; ent = ent -> teamchain ) 
self -> owner , other , other ) 
self -> flags & FL_TEAMSLAVE ) 
self -> moveinfo . distance ) 
FOR ( ent = self -> teamchain ; ent ; ent = ent -> teamchain ) 
FOR ( ent = self ; ent ; ent = ent -> teamchain ) 
ent -> flags & FL_TEAMSLAVE ) 
FOR ( other = ent -> teamchain ; other ; other = other -> teamchain ) 
) 
ent -> spawnflags & DOOR_START_OPEN ) 
! ( other -> svflags & SVF_MONSTER ) && ( ! other -> client ) ) 
other , self , self , vec3_origin , other -> s . origin , vec3_origin , self -> dmg , INT_CONST , INT_CONST , MOD_CRUSH ) 
self -> spawnflags & DOOR_CRUSHER ) 
FOR ( ent = self -> teammaster ; ent ; ent = ent -> teamchain ) 
FOR ( ent = self -> teammaster ; ent ; ent = ent -> teamchain ) 
FOR ( ent = self -> teammaster ; ent ; ent = ent -> teamchain ) 
other , STRING , self -> message ) 
ent -> sounds != INT_CONST ) 
ent -> s . angles , ent -> movedir ) 
! ent -> speed ) 
ent -> s . origin , ent -> pos1 ) 
ent -> spawnflags & DOOR_START_OPEN ) 
ent -> health ) 
ent -> spawnflags & INT_CONST ) 
! ent -> team ) 
ent -> health || ent -> targetname ) 
ent -> movedir ) 
ent -> spawnflags & DOOR_REVERSE ) 
ent -> s . angles , ent -> pos1 ) 
ent , ent -> model ) 
! ent -> speed ) 
ent -> spawnflags & DOOR_START_OPEN ) 
ent -> health ) 
ent -> s . origin , ent -> moveinfo . start_origin ) 
ent -> spawnflags & INT_CONST ) 
! ent -> team ) 
ent -> health || ent -> targetname ) 
self -> s . angles , self -> movedir ) 
self -> sounds ) 
self -> s . origin , self -> pos1 ) 
self -> spawnflags & DOOR_START_OPEN ) 
self -> pos1 , self -> moveinfo . start_origin ) 
! self -> speed ) 
! self -> wait ) 
self -> wait == -v INT_CONST ) 
self ) 
level . time < self -> touch_debounce_time ) 
self -> moveinfo . wait ) 
edict_t * self ) 
! self -> target ) 
self -> target ) 
ent -> spawnflags & INT_CONST ) 
! ( self -> flags & FL_TEAMSLAVE ) ) 
ent -> s . origin , self -> mins , dest ) 
ent -> s . origin , self -> mins , dest ) 
! self -> target ) 
ent -> s . origin , self -> mins , self -> s . origin ) 
! self -> targetname ) 
self -> spawnflags & TRAIN_START_ON ) 
self -> s . angles ) 
st . noise ) 
self ) 
self -> target ) 
self -> movetarget -> nextthink ) 
! other -> pathtarget ) 
other -> pathtarget ) 
self -> movetarget ) 
self -> nextthink ) 
self -> delay ) 
self -> random >= self -> wait ) 
self -> spawnflags & INT_CONST ) 
! ( self -> spawnflags & INT_CONST ) ) 
self , self -> model ) 
! VectorCompare ( self -> s . origin , vec3_origin ) ) 
level . time < self -> touch_debounce_time ) 
other , self , self , vec3_origin , other -> s . origin , vec3_origin , self -> dmg , INT_CONST , INT_CONST , MOD_CRUSH ) 
STRING ) 
ent , ent -> model ) 
! ( ent -> targetname ) || ( ent -> spawnflags & SECRET_ALWAYS_SHOOT ) ) 
! ent -> dmg ) 
ent -> s . angles , forward , right , up ) 
ent -> health ) 
__E__O__F__
FOR ( i = INT_CONST ; i < game . num_items ; i v++ , it v++ ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ , it v++ ) 
FOR ( count = INT_CONST , ent = master ; ent ; ent = ent -> chain , count v++ ) 
FOR ( count = INT_CONST , ent = master ; count < choice ; ent = ent -> chain , count v++ ) 
ent ) 
ent -> item ) 
deathmatch -> value ) 
! ( ent -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
other -> client -> pers . max_bullets < INT_CONST ) 
STRING ) 
! ( ent -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
other -> client -> pers . max_bullets < INT_CONST ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
! ( ent -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
item ) 
quad_drop_timeout_hack ) 
ent -> client -> quad_framenum > level . framenum ) 
ent -> client -> breather_framenum > level . framenum ) 
ent -> client -> enviro_framenum > level . framenum ) 
ent -> client -> invincible_framenum > level . framenum ) 
! ent -> client ) 
ent -> client -> pers . inventory [ index ] == max ) 
ent -> client -> pers . inventory [ index ] > max ) 
ent -> item -> flags & IT_WEAPON ) 
! Add_Ammo ( other , ent -> item , count ) ) 
! ( ent -> spawnflags & ( DROPPED_ITEM | DROPPED_PLAYER_ITEM ) ) && ( deathmatch -> value ) ) 
item ) 
ent ) 
! ( self -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
! ( ent -> style & HEALTH_IGNORE_MAX ) ) 
ent -> style & HEALTH_TIMED ) 
gitem_armor_t * ) 
other ) 
ent -> item -> tag == ARMOR_SHARD ) 
! old_armor_index ) 
! ( ent -> spawnflags & DROPPED_ITEM ) && ( deathmatch -> value ) ) 
ent -> flags & FL_POWER_ARMOR ) 
ent -> item ) 
ent -> item ) 
deathmatch -> value ) 
! other -> client ) 
taken ) 
! ( ent -> spawnflags & ITEM_TARGETS_USED ) ) 
! taken ) 
) 
dropped -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
ent -> client ) 
forward , INT_CONST , dropped -> velocity ) 
dropped ) 
ent -> spawnflags & ITEM_NO_TOUCH ) 
ent ) 
-v INT_CONST , -v INT_CONST , -v INT_CONST ) 
ent -> model ) 
ent -> s . origin , ent -> mins , ent -> maxs , dest , ent , MASK_SOLID ) 
tr . endpos , ent -> s . origin ) 
ent -> team ) 
ent -> spawnflags & ITEM_NO_TOUCH ) 
ent -> spawnflags & ITEM_TRIGGER_SPAWN ) 
ent ) 
! it ) 
it -> ammo && it -> ammo [ INT_CONST ] ) 
! s || ! s [ INT_CONST ] ) 
ent -> spawnflags ) 
deathmatch -> value ) 
coop -> value && ( strcmp ( ent -> classname , STRING ) == INT_CONST ) ) 
( coop -> value ) && ( item -> flags & IT_STAY_COOP ) ) 
ent -> model ) 
self , FindItem ( STRING ) ) 
self , FindItem ( STRING ) ) 
self , FindItem ( STRING ) ) 
self , FindItem ( STRING ) ) 
FOR ( i = INT_CONST ; i < game . num_items ; i v++ ) 
FindItem ( STRING ) ) 
__E__O__F__
TAG_LEVEL ) 
edict_t ) 
argptr , error ) 
ERR_FATAL , STRING , text ) 
argptr , msg ) 
STRING , text ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
) 
( INT ) dmflags -> value & DF_SAME_LEVEL ) 
*v sv_maplist -> string ) 
level . nextmap [ INT_CONST ] ) 
CreateTargetChangeLevel ( level . nextmap ) ) 
NULL , FOFS ( classname ) , STRING ) 
level . intermissiontime ) 
fraglimit -> value ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
command , SIZEOF ( command ) , STRING , level . changemap ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
) 
level . exitintermission ) 
FOR ( i = INT_CONST ; i < globals . num_edicts ; i v++ , ent v++ ) 
) 
) 
__E__O__F__
ent -> style , ent -> count ) 
damage < INT_CONST ) 
self -> s . frame == INT_CONST ) 
! self -> groundentity ) 
plane ) 
) 
self -> size , FLOAT_CONST , size ) 
gib , gibname ) 
type == GIB_ORGANIC ) 
damage , vd ) 
) 
gib ) 
self -> mins ) 
self , gibname ) 
type == GIB_ORGANIC ) 
damage , vd ) 
) 
) 
self ) 
rand ( ) & INT_CONST ) 
self , gibname ) 
damage , vd ) 
self -> client ) 
self ) 
) 
self ) 
self ) 
other -> movetarget != self ) 
self -> target ) 
self -> wait ) 
! other -> movetarget ) 
self -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
other -> movetarget != self ) 
other -> movetarget == self ) 
self -> pathtarget ) 
ent -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
! self -> targetname || deathmatch -> value ) 
self -> style >= INT_CONST ) 
! ( self -> spawnflags & INT_CONST ) ) 
self -> spawnflags & INT_CONST ) 
( self -> spawnflags & INT_CONST ) == INT_CONST ) 
! ( self -> spawnflags & INT_CONST ) ) 
self -> spawnflags & INT_CONST ) 
self -> spawnflags & INT_CONST ) 
! plane ) 
! self -> dmg ) 
self -> spawnflags & INT_CONST ) 
self ) 
self -> size , FLOAT_CONST , size ) 
self -> dmg ) 
size , FLOAT_CONST , size ) 
! mass ) 
mass >= INT_CONST ) 
count > INT_CONST ) 
self , attacker ) 
self -> dmg ) 
self ) 
STRING ) 
self , self -> model ) 
self -> spawnflags & INT_CONST ) 
self -> spawnflags & INT_CONST ) 
self ) 
( ! other -> groundentity ) || ( other -> groundentity == self ) ) 
self , self -> activator , self -> dmg , NULL , self -> dmg + INT_CONST , MOD_BARREL ) 
self -> s . origin , save ) 
FLOAT ) 
FLOAT ) 
) 
save , self -> s . origin ) 
self ) 
STRING ) 
self -> model ) 
! self -> mass ) 
self ) 
STRING ) 
self -> health > -v INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
ent ) 
STRING ) 
ent -> spawnflags & INT_CONST ) 
ent ) 
! ent -> speed ) 
ent ) 
self , self , self -> dmg , NULL , self -> dmg + INT_CONST , MOD_BOMB ) 
diff < -v FLOAT_CONST ) 
v , self -> s . angles ) 
NULL , FOFS ( classname ) , STRING ) 
viper -> moveinfo . dir , self -> moveinfo . dir ) 
STRING ) 
! self -> dmg ) 
self ) 
! ent -> speed ) 
ent ) 
self -> message ) 
FOR ( e = self -> teammaster ; e ; e = e -> teamchain ) 
self -> style == INT_CONST ) 
self -> style == INT_CONST ) 
self -> spawnflags & INT_CONST ) 
self -> enemy , self , self ) 
( ( self -> spawnflags & INT_CONST ) && ( self -> health > self -> wait ) ) || NEW_LINE ( ( self -> spawnflags & INT_CONST ) && ( self -> health < self -> wait ) ) ) 
( self -> spawnflags & INT_CONST ) && ( ! self -> count ) ) 
( self -> spawnflags & INT_CONST ) && ( ! self -> count ) ) 
CLOCK_MESSAGE_SIZE , TAG_LEVEL ) 
self -> spawnflags & INT_CONST ) 
! other -> client ) 
other ) 
dest -> s . origin , other -> s . origin ) 
other -> velocity ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
other ) 
other ) 
! ent -> target ) 
ent , STRING ) 
ent -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
) 
edict_t * ent ) 
__E__O__F__
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
svc_muzzleflash2 ) 
ent -> flags & ( FL_SWIM | FL_FLY ) ) 
ent -> s . origin , ent -> mins , ent -> maxs , point , ent , MASK_MONSTERSOLID ) 
trace . plane . normal [ INT_CONST ] < FLOAT_CONST && ! trace . startsolid ) 
! trace . startsolid && ! trace . allsolid ) 
point ) 
point ) 
ent -> health > INT_CONST ) 
( ent -> watertype & CONTENTS_LAVA ) && ! ( ent -> flags & FL_IMMUNE_LAVA ) ) 
ent , CHAN_BODY , gi . soundindex ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
ent -> s . origin , end ) 
ent ) 
ent -> monsterinfo . aiflags & AI_RESURRECTING ) 
ent -> health <= INT_CONST ) 
( self -> monsterinfo . nextframe ) && ( self -> monsterinfo . nextframe >= move -> firstframe ) && ( self -> monsterinfo . nextframe <= move -> lastframe ) ) 
move -> frame [ index ] . aifunc ) 
self ) 
self ) 
self ) 
self -> enemy && ! ( self -> spawnflags & INT_CONST ) && ! ( self -> enemy -> flags & FL_NOTARGET ) ) 
activator -> client ) 
self -> item ) 
self -> deathtarget ) 
( self -> spawnflags & INT_CONST ) && ! ( self -> monsterinfo . aiflags & AI_GOOD_GUY ) ) 
! ( self -> monsterinfo . aiflags & AI_GOOD_GUY ) ) 
! self -> monsterinfo . checkattack ) 
st . item ) 
self -> monsterinfo . currentmove ) 
self -> health <= INT_CONST ) 
self -> target ) 
self -> combattarget ) 
self -> target ) 
self ) 
self -> spawnflags & INT_CONST ) 
self ) 
self -> spawnflags & INT_CONST ) 
self ) 
self -> spawnflags & INT_CONST ) 
__E__O__F__
ent -> clipmask ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
thinktime <= INT_CONST ) 
e1 -> touch && e1 -> solid != SOLID_NOT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( bumpcount = INT_CONST ; bumpcount < numbumps ; bumpcount v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numplanes ; i v++ ) 
FOR ( j = INT_CONST ; j < numplanes ; j v++ ) 
ent -> s . origin , start ) 
ent -> clipmask ) 
trace . fraction != FLOAT_CONST ) 
ent -> inuse ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vec3_origin , amove , org ) 
pusher -> s . origin , pushed_p -> origin ) 
pusher -> s . origin , move , pusher -> s . origin ) 
FOR ( e = INT_CONST ; e < globals . num_edicts ; e v++ , check v++ ) 
check -> groundentity != pusher ) 
FOR ( p = pushed_p - INT_CONST ; p >= pushed ; p v-- ) 
FOR ( p = pushed_p - INT_CONST ; p >= pushed ; p v-- ) 
ent -> flags & FL_TEAMSLAVE ) 
FOR ( part = ent ; part ; part = part -> teamchain ) 
FOR ( mv = ent ; mv ; mv = mv -> teamchain ) 
FOR ( part = ent ; part ; part = part -> teamchain ) 
ent ) 
ent ) 
ent -> flags & FL_TEAMSLAVE ) 
ent ) 
ent -> movetype != MOVETYPE_FLY NEW_LINE && ent -> movetype != MOVETYPE_FLYMISSILE ) 
ent -> velocity , FRAMETIME , move ) 
trace . plane . normal [ INT_CONST ] > FLOAT_CONST ) 
ent -> watertype & MASK_WATER ) 
isinwater ) 
FOR ( slave = ent -> teamchain ; slave ; slave = slave -> teamchain ) 
ent -> s . angles , FRAMETIME , ent -> avelocity , ent -> s . angles ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
! ent -> groundentity ) 
ent ) 
groundentity ) 
! wasonground ) 
( ent -> flags & FL_FLY ) && ( ent -> velocity [ INT_CONST ] != INT_CONST ) ) 
( ent -> flags & FL_SWIM ) && ( ent -> velocity [ INT_CONST ] != INT_CONST ) ) 
ent -> velocity [ INT_CONST ] || ent -> velocity [ INT_CONST ] || ent -> velocity [ INT_CONST ] ) 
vel [ INT_CONST ] * vel [ INT_CONST ] + vel [ INT_CONST ] * vel [ INT_CONST ] ) 
ent ) 
ent ) 
ent ) 
ent ) 
ent ) 
STRING , ( INT ) ent -> movetype ) 
__E__O__F__
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_NOSET ) 
STRING , STRING , CVAR_SERVERINFO | CVAR_LATCH ) 
STRING , STRING , CVAR_SERVERINFO | CVAR_LATCH ) 
STRING , STRING , CVAR_SERVERINFO ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
) 
game . helpmessage1 , SIZEOF ( game . helpmessage1 ) , STRING ) 
game . helpmessage2 , SIZEOF ( game . helpmessage2 ) , STRING ) 
game . maxentities * SIZEOF ( g_edicts [ INT_CONST ] ) , TAG_GAME ) 
game . maxclients * SIZEOF ( game . clients [ INT_CONST ] ) , TAG_GAME ) 
field -> flags & FFL_SPAWNTEMP ) 
*v ( CHAR *p *p ) p ) 
*v ( edict_t * *v ) p == NULL ) 
*v ( gclient_t * *v ) p == NULL ) 
*v ( edict_t * *v ) p == NULL ) 
*v ( byte * *v ) p == NULL ) 
*v ( byte * *v ) p == NULL ) 
STRING ) 
field -> flags & FFL_SPAWNTEMP ) 
field -> flags & FFL_SPAWNTEMP ) 
INT *p ) 
INT *p ) 
INT *p ) 
INT *p ) 
INT *p ) 
INT *p ) 
STRING ) 
FOR ( field = clientfields ; field -> name ; field v++ ) 
&v temp , SIZEOF ( temp ) , INT_CONST , f ) 
FOR ( field = clientfields ; field -> name ; field v++ ) 
client , SIZEOF ( *v client ) , INT_CONST , f ) 
FOR ( field = clientfields ; field -> name ; field v++ ) 
! autosave ) 
&v game , SIZEOF ( game ) , INT_CONST , f ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
TAG_GAME ) 
filename , STRING ) 
game . maxentities * SIZEOF ( g_edicts [ INT_CONST ] ) , TAG_GAME ) 
&v game , SIZEOF ( game ) , INT_CONST , f ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
FOR ( field = fields ; field -> name ; field v++ ) 
&v temp , SIZEOF ( temp ) , INT_CONST , f ) 
FOR ( field = fields ; field -> name ; field v++ ) 
FOR ( field = levelfields ; field -> name ; field v++ ) 
&v temp , SIZEOF ( temp ) , INT_CONST , f ) 
FOR ( field = levelfields ; field -> name ; field v++ ) 
ent , SIZEOF ( *v ent ) , INT_CONST , f ) 
FOR ( field = fields ; field -> name ; field v++ ) 
&v level , SIZEOF ( level ) , INT_CONST , f ) 
FOR ( field = levelfields ; field -> name ; field v++ ) 
filename , STRING ) 
edict_t ) 
VOID *p ) 
f ) 
FOR ( i = INT_CONST ; i < globals . num_edicts ; i v++ ) 
f ) 
filename , STRING ) 
TAG_LEVEL ) 
g_edicts , INT_CONST , game . maxentities * SIZEOF ( g_edicts [ INT_CONST ] ) ) 
&v i , SIZEOF ( i ) , INT_CONST , f ) 
&v base , SIZEOF ( base ) , INT_CONST , f ) 
f ) 
INT_CONST ) 
f ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
FOR ( i = INT_CONST ; i < globals . num_edicts ; i v++ ) 
__E__O__F__
! ent -> classname ) 
FOR ( i = INT_CONST , item = itemlist ; i < game . num_items ; i v++ , item v++ ) 
FOR ( s = spawns ; s -> name ; s v++ ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
FOR ( f = fields ; f -> name ; f v++ ) 
FLOAT *p ) 
&v st , INT_CONST , SIZEOF ( st ) ) 
INT_CONST ) 
&v data ) 
keyname [ INT_CONST ] == CHAR_CONST ) 
! init ) 
FOR ( i = INT_CONST , e = g_edicts + i ; i < globals . num_edicts ; i v++ , e v++ ) 
FOR ( j = i + INT_CONST , e2 = e + INT_CONST ; j < globals . num_edicts ; j v++ , e2 v++ ) 
STRING , c , c2 ) 
skill -> value ) 
TAG_LEVEL ) 
&v level , INT_CONST , SIZEOF ( level ) ) 
level . mapname , mapname , SIZEOF ( level . mapname ) - INT_CONST ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
INT_CONST ) 
STRING , inhibit ) 
) 
edict_t * ent ) 
) 
) 
st . nextmap ) 
ent -> message && ent -> message [ INT_CONST ] ) 
CS_SKYAXIS , va ( STRING , NEW_LINE st . skyaxis [ INT_CONST ] , st . skyaxis [ INT_CONST ] , st . skyaxis [ INT_CONST ] ) ) 
CS_MAXCLIENTS , va ( STRING , ( INT ) ( maxclients -> value ) ) ) 
deathmatch -> value ) 
STRING ) 
! st . gravity ) 
FindItem ( STRING ) ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
CS_LIGHTS + INT_CONST , STRING ) 
CS_LIGHTS + INT_CONST , STRING ) 
CS_LIGHTS + INT_CONST , STRING ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
*v p && i < INT_CONST ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
gi . argc ( ) < INT_CONST ) 
! StringToFilter ( gi . argv ( INT_CONST ) , &v f ) ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
FOR ( j = i + INT_CONST ; j < numipfilters ; j v++ ) 
NULL , PRINT_HIGH , STRING ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
STRING , STRING , INT_CONST ) 
! *v game -> string ) 
name , STRING ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
INT_CONST ) 
__E__O__F__
ent -> spawnflags & INT_CONST ) 
ent -> s . sound ) 
ent -> spawnflags & INT_CONST ) 
! st . noise ) 
! ent -> volume ) 
ent -> spawnflags & INT_CONST ) 
ent ) 
ent ) 
! ent -> message ) 
ent , activator ) 
ent ) 
! st . noise ) 
! Q_stricmp ( level . mapname , STRING ) && ent -> s . origin [ INT_CONST ] == INT_CONST && ent -> s . origin [ INT_CONST ] == -v INT_CONST && ent -> s . origin [ INT_CONST ] == -v INT_CONST ) 
level . found_goals == level . total_goals ) 
ent ) 
! st . noise ) 
svc_temp_entity ) 
self , self -> activator , self -> dmg , NULL , self -> dmg + INT_CONST , MOD_EXPLOSIVE ) 
self , self -> activator ) 
! self -> delay ) 
deathmatch -> value && ! ( ( INT ) dmflags -> value & DF_ALLOW_EXIT ) && other != world ) 
deathmatch -> value ) 
strstr ( self -> map , STRING ) ) 
( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) && ( Q_stricmp ( ent -> map , STRING ) == INT_CONST ) ) 
self -> dmg ) 
! self -> count ) 
) 
self -> spawnflags & INT_CONST ) 
! self -> dmg ) 
self -> spawnflags & INT_CONST ) 
self -> s . origin , start ) 
tr . endpos , self -> s . old_origin ) 
self -> spawnflags & INT_CONST ) 
self -> spawnflags & INT_CONST ) 
! self -> dmg ) 
self -> spawnflags & INT_CONST ) 
level . time - self -> timestamp ) 
( level . time - self -> timestamp ) < self -> speed ) 
self ) 
deathmatch -> value ) 
! self -> target ) 
self -> movedir [ INT_CONST ] - self -> movedir [ INT_CONST ] ) 
self -> last_move_time < level . time ) 
FOR ( i = INT_CONST , e = g_edicts + i ; i < globals . num_edicts ; i v++ , e v++ ) 
level . time < self -> timestamp ) 
STRING ) 
__E__O__F__
ent -> wait > INT_CONST ) 
self ) 
ent -> spawnflags & INT_CONST ) 
! VectorCompare ( ent -> s . angles , vec3_origin ) ) 
ent -> spawnflags & INT_CONST ) 
ent ) 
! self -> item ) 
activator , CHAN_AUTO , gi . soundindex ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
FOR ( cube = INT_CONST ; cube < INT_CONST ; cube v++ ) 
FOR ( player = INT_CONST ; player <= game . maxclients ; player v++ ) 
FOR ( player = INT_CONST ; player <= game . maxclients ; player v++ ) 
self , activator ) 
! self -> item ) 
! self -> target ) 
STRING ) 
ent -> delay < FLOAT_CONST ) 
! ( self -> spawnflags & INT_CONST ) ) 
! other -> takedamage ) 
self -> spawnflags & INT_CONST ) 
STRING ) 
! self -> dmg ) 
self ) 
__E__O__F__
other -> takedamage ) 
self -> s . angles , f , r , u ) 
) 
self -> s . angles , current_angles ) 
self -> move_angles ) 
self -> move_angles [ PITCH ] > self -> pos1 [ PITCH ] ) 
self -> move_angles , current_angles , delta ) 
delta [ INT_CONST ] > self -> speed * FRAMETIME ) 
FOR ( ent = self -> teammaster ; ent ; ent = ent -> teamchain ) 
self -> owner ) 
! self -> target ) 
self ) 
! self -> speed ) 
self ) 
FOR ( ent = self -> target_ent -> teammaster ; ent -> teamchain != self ; ent = ent -> teamchain ) 
self , inflictor , attacker , damage ) 
self -> enemy && ( ! self -> enemy -> inuse || self -> enemy -> health <= INT_CONST ) ) 
self -> enemy -> s . origin , target ) 
level . time < self -> monsterinfo . attack_finished ) 
self -> target ) 
vec ) 
self -> s . origin , self -> target_ent -> s . origin , vec ) 
FOR ( ent = self -> target_ent -> teammaster ; ent -> teamchain ; ent = ent -> teamchain ) 
STRING ) 
self -> s . origin , self -> s . old_origin ) 
st . item ) 
self ) 
__E__O__F__
! from ) 
FOR ( ; from < &v g_edicts [ globals . num_edicts ] ; from v++ ) 
! from ) 
FOR ( ; from < &v g_edicts [ globals . num_edicts ] ; from v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! targetname ) 
INT_CONST ) 
! num_choices ) 
) 
ent -> delay ) 
) 
ent -> killtarget ) 
ent -> target ) 
index + INT_CONST ) 
index + INT_CONST ) 
s , INT_CONST , STRING , ( INT ) v [ INT_CONST ] , ( INT ) v [ INT_CONST ] , ( INT ) v [ INT_CONST ] ) 
angles ) 
INT ) 
FOR ( i = maxclients -> value + INT_CONST ; i < globals . num_edicts ; i v++ , e v++ ) 
( ed - g_edicts ) <= ( maxclients -> value + BODY_QUEUE_SIZE ) ) 
ed , INT_CONST , SIZEOF ( *v ed ) ) 
( ent -> client || ( ent -> svflags & SVF_MONSTER ) ) && ( ent -> health <= INT_CONST ) ) 
FOR ( i = INT_CONST ; i < num ; i v++ ) 
ent -> absmin , ent -> absmax , touch NEW_LINE , MAX_EDICTS , AREA_SOLID ) 
FOR ( i = INT_CONST ; i < num ; i v++ ) 
INT_CONST ) 
__E__O__F__
skill -> value == INT_CONST ) 
self -> enemy -> s . origin , self -> s . origin , dir ) 
self -> s . origin , range , dir , point ) 
self -> s . origin , NULL , NULL , point , self , MASK_SHOT ) 
( tr . ent -> svflags & SVF_MONSTER ) || ( tr . ent -> client ) ) 
self -> s . angles , forward , right , up ) 
tr . ent , self , self , dir , point , vec3_origin , damage , kick / INT_CONST , DAMAGE_NO_KNOCKBACK , MOD_HIT ) 
! ( tr . ent -> svflags & SVF_MONSTER ) && ( ! tr . ent -> client ) ) 
self -> enemy -> absmin , FLOAT_CONST , self -> enemy -> size , v ) 
self -> s . origin , NULL , NULL , start , self , MASK_SHOT ) 
start , water_start ) 
tr . endpos , water_start ) 
! ( ( tr . surface ) && ( tr . surface -> flags & SURF_SKY ) ) ) 
water ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
other == self -> owner ) 
self -> owner -> client ) 
self ) 
dir ) 
) 
start , bolt -> s . origin ) 
self -> client ) 
ent -> owner -> client ) 
ent -> enemy ) 
ent -> spawnflags & INT_CONST ) 
ent -> s . origin , -v FLOAT_CONST , ent -> velocity , origin ) 
ent ) 
! other -> takedamage ) 
ent ) 
aimdir , dir ) 
) 
grenade ) 
aimdir , dir ) 
) 
timer <= FLOAT_CONST ) 
other == ent -> owner ) 
ent -> owner -> client ) 
ent -> s . origin , -v FLOAT_CONST , ent -> velocity , origin ) 
other -> takedamage ) 
ent , ent -> owner , ent -> radius_dmg , other , ent -> dmg_radius , MOD_R_SPLASH ) 
svc_temp_entity ) 
ent ) 
) 
self -> client ) 
start , INT_CONST , aimdir , end ) 
svc_temp_entity ) 
self -> client ) 
self -> s . frame == INT_CONST ) 
self -> s . frame == INT_CONST ) 
self -> owner -> client ) 
other -> takedamage ) 
self , CHAN_VOICE , gi . soundindex ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
svc_temp_entity ) 
deathmatch -> value ) 
) 
self -> client ) 
__E__O__F__
level . time < FLOAT_CONST ) 
self -> monsterinfo . aiflags & AI_STAND_GROUND ) 
self -> health < ( self -> max_health / INT_CONST ) ) 
) 
self -> s . angles , forward , right , NULL ) 
self -> health <= -v INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
) 
level . time >= self -> monsterinfo . pausetime ) 
rand ( ) & INT_CONST ) 
self -> target ) 
self -> goalentity -> s . origin , self -> s . origin , v ) 
! self -> targetname ) 
! self -> target ) 
STRING ) 
! self -> health ) 
self ) 
self ) 
other -> movetarget != self ) 
self -> message ) 
FOR ( n = INT_CONST ; n <= game . maxclients ; n v++ ) 
self -> spawnflags & INT_CONST ) 
self -> spawnflags & INT_CONST ) 
! ( self -> spawnflags & INT_CONST ) && ( self -> pathtarget ) ) 
self -> target ) 
! other -> goalentity ) 
self -> spawnflags & INT_CONST ) 
self ) 
__E__O__F__
aim , MELEE_DISTANCE , self -> mins [ INT_CONST ] , -v INT_CONST ) 
edict_t * self ) 
skill -> value == INT_CONST ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
damage >= INT_CONST ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
self -> s . angles , forward , right , NULL ) 
self -> s . origin , monster_flash_offset [ MZ2_BOSS2_ROCKET_1 ] , forward , right , start ) 
self -> s . origin , monster_flash_offset [ MZ2_BOSS2_ROCKET_2 ] , forward , right , start ) 
self -> s . origin , monster_flash_offset [ MZ2_BOSS2_ROCKET_3 ] , forward , right , start ) 
self -> s . origin , monster_flash_offset [ MZ2_BOSS2_ROCKET_4 ] , forward , right , start ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , -v FLOAT_CONST , self -> enemy -> velocity , target ) 
self , start , forward , INT_CONST , INT_CONST , DEFAULT_BULLET_HSPREAD , DEFAULT_BULLET_VSPREAD , MZ2_BOSS2_MACHINEGUN_R1 ) 
self -> enemy -> s . origin , -v FLOAT_CONST , self -> enemy -> velocity , target ) 
target , start , forward ) 
self , start , forward , INT_CONST , INT_CONST , DEFAULT_BULLET_HSPREAD , DEFAULT_BULLET_VSPREAD , MZ2_BOSS2_MACHINEGUN_L1 ) 
self -> enemy -> s . origin , self -> s . origin , vec ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
self -> enemy -> health > INT_CONST ) 
self -> s . origin , spot1 ) 
enemy_range == RANGE_MELEE ) 
! self -> monsterinfo . attack ) 
random ( ) < chance ) 
self -> flags & FL_FLY ) 
STRING ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
self -> model ) 
STRING ) 
self -> mins , -v INT_CONST , -v INT_CONST , INT_CONST ) 
self ) 
__E__O__F__
) 
r <= FLOAT_CONST ) 
damage <= INT_CONST ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , vec ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , -v FLOAT_CONST , self -> enemy -> velocity , target ) 
self , start , forward , INT_CONST , INT_CONST , DEFAULT_BULLET_HSPREAD , DEFAULT_BULLET_VSPREAD , MZ2_JORG_MACHINEGUN_R1 ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , -v FLOAT_CONST , self -> enemy -> velocity , target ) 
self , start , forward , INT_CONST , INT_CONST , DEFAULT_BULLET_HSPREAD , DEFAULT_BULLET_VSPREAD , MZ2_JORG_MACHINEGUN_L1 ) 
random ( ) <= FLOAT_CONST ) 
) 
self -> enemy -> health > INT_CONST ) 
self -> s . origin , spot1 ) 
enemy_range == RANGE_MELEE ) 
! self -> monsterinfo . attack ) 
random ( ) < chance ) 
self -> flags & FL_FLY ) 
STRING ) 
) 
STRING ) 
self ) 
self ) 
__E__O__F__
) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , vec ) 
self -> s . angles , forward , right , NULL ) 
self , start , dir , INT_CONST , INT_CONST , MZ2_MAKRON_RAILGUN_1 ) 
self -> s . frame - FRAME_attak405 ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy ) 
dir , forward , NULL , NULL ) 
self , start , forward , INT_CONST , INT_CONST , MZ2_MAKRON_BLASTER_1 , EF_BLASTER ) 
damage <= INT_CONST ) 
) 
self -> enemy -> s . origin , self -> s . origin , vec ) 
r <= FLOAT_CONST ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST COMMENT ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
) 
edict_t * self ) 
self -> enemy -> health > INT_CONST ) 
self -> s . origin , spot1 ) 
enemy_range == RANGE_MELEE ) 
! self -> monsterinfo . attack ) 
random ( ) < chance ) 
self -> flags & FL_FLY ) 
STRING ) 
) 
STRING ) 
self ) 
self ) 
self ) 
! player ) 
) 
__E__O__F__
aim , MELEE_DISTANCE , self -> maxs [ INT_CONST ] , INT_CONST ) 
aim , MELEE_DISTANCE , self -> mins [ INT_CONST ] , INT_CONST ) 
aim , MELEE_DISTANCE , INT_CONST , INT_CONST ) 
self -> health < ( self -> max_health / INT_CONST ) ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
self -> monsterinfo . currentmove == &v chick_move_walk || NEW_LINE self -> monsterinfo . currentmove == &v chick_move_start_run ) 
self -> health < ( self -> max_health / INT_CONST ) ) 
) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
) 
aim , MELEE_DISTANCE , self -> mins [ INT_CONST ] , INT_CONST ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , vec ) 
self , start , dir , INT_CONST , INT_CONST , MZ2_CHICK_ROCKET_1 ) 
STRING ) 
self ) 
self ) 
__E__O__F__
__E__O__F__
edict_t * self ) 
aim , MELEE_DISTANCE , INT_CONST , INT_CONST ) 
self -> health < ( self -> max_health / INT_CONST ) ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
( self -> s . frame == FRAME_attak104 ) || ( self -> s . frame == FRAME_attak107 ) ) 
self -> enemy -> s . origin , end ) 
self , start , dir , INT_CONST , INT_CONST , MZ2_FLOAT_BLASTER_1 , effect ) 
self -> enemy -> s . origin , self -> s . origin , dir ) 
self -> s . angles , forward , right , NULL ) 
offset , FLOAT_CONST , -v FLOAT_CONST , INT_CONST ) 
svc_temp_entity ) 
origin , MULTICAST_PVS ) 
self -> enemy , self , self , dir , self -> enemy -> s . origin , vec3_origin , INT_CONST + rand ( ) % INT_CONST , -v INT_CONST , DAMAGE_ENERGY , MOD_UNKNOWN ) 
self -> health < ( self -> max_health / INT_CONST ) ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
self ) 
random ( ) <= FLOAT_CONST ) 
__E__O__F__
( self -> s . frame == FRAME_attak204 ) || ( self -> s . frame == FRAME_attak207 ) || ( self -> s . frame == FRAME_attak210 ) ) 
self , start , dir , INT_CONST , INT_CONST , flash_number , effect ) 
aim , MELEE_DISTANCE , self -> mins [ INT_CONST ] , INT_CONST ) 
aim , MELEE_DISTANCE , self -> maxs [ INT_CONST ] , INT_CONST ) 
self -> health < ( self -> max_health / INT_CONST ) ) 
! Q_stricmp ( level . mapname , STRING ) && ( self -> s . origin [ INT_CONST ] == -v INT_CONST ) ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
aim , MELEE_DISTANCE , self -> mins [ INT_CONST ] , -v INT_CONST ) 
self -> s . angles , forward , right , NULL ) 
self -> pos1 , start , dir ) 
self , start , dir , INT_CONST , INT_CONST , MZ2_GLADIATOR_RAILGUN_1 ) 
self -> s . origin , self -> enemy -> s . origin , v ) 
self , CHAN_WEAPON , sound_gun , INT_CONST , ATTN_NORM , INT_CONST ) 
random ( ) < FLOAT_CONST ) 
edict_t * self ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
rand ( ) & INT_CONST ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
self ) 
self -> s . frame - FRAME_attak216 ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , target ) 
target , start , aim ) 
self -> s . frame == FRAME_attak105 ) 
self -> s . angles , forward , right , NULL ) 
forward , aim ) 
self , start , aim , INT_CONST , INT_CONST , flash_number ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
self -> s . frame == FRAME_attak104 ) 
self -> enemy -> s . origin , end ) 
self , start , dir , INT_CONST , INT_CONST , MZ2_HOVER_BLASTER_1 , effect ) 
skill -> value == INT_CONST ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
STRING ) 
self ) 
self ) 
__E__O__F__
self -> health < ( self -> max_health / INT_CONST ) ) 
self -> s . frame == FRAME_attak111 ) 
self , start , forward , INT_CONST , INT_CONST , DEFAULT_BULLET_HSPREAD , DEFAULT_BULLET_VSPREAD , flash_number ) 
self ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
) 
self , CHAN_WEAPON , sound_weapon_cock , INT_CONST , ATTN_NORM , INT_CONST ) 
level . time >= self -> monsterinfo . pausetime ) 
aim , MELEE_DISTANCE , INT_CONST , INT_CONST ) 
STRING ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
self -> s . frame == FRAME_cr_pain10 ) 
self -> s . frame == FRAME_cr_pain10 ) 
random ( ) <= FLOAT_CONST ) 
level . time < self -> pain_debounce_time ) 
rand ( ) & INT_CONST ) 
skill -> value == INT_CONST ) 
self -> spawnflags & INT_CONST ) 
random ( ) < FLOAT_CONST ) 
( self -> spawnflags & INT_CONST ) && ( self -> spawnflags & INT_CONST ) ) 
( self -> spawnflags & INT_CONST ) && ( self -> spawnflags & INT_CONST ) ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
self -> spawnflags & INT_CONST ) 
STRING ) 
STRING ) 
self -> mins , -v INT_CONST , -v INT_CONST , -v INT_CONST ) 
self ) 
self -> spawnflags & INT_CONST ) 
self -> spawnflags & INT_CONST ) 
__E__O__F__
( ent = findradius ( ent , self -> s . origin , INT_CONST ) ) != NULL ) 
self , CHAN_VOICE , sound_idle1 , INT_CONST , ATTN_IDLE , INT_CONST ) 
self ) 
self , CHAN_VOICE , sound_search , INT_CONST , ATTN_IDLE , INT_CONST ) 
! self -> oldenemy ) 
self -> monsterinfo . aiflags & AI_STAND_GROUND ) 
skill -> value == INT_CONST ) 
( self -> s . frame == FRAME_attack9 ) || ( self -> s . frame == FRAME_attack12 ) ) 
self -> enemy -> s . origin , end ) 
self , start , dir , INT_CONST , INT_CONST , MZ2_MEDIC_BLASTER_1 , effect ) 
( self -> enemy ) && ( self -> enemy -> owner == self ) ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
! self -> enemy -> inuse ) 
start , self -> enemy -> s . origin , dir ) 
dir , angles ) 
start , INT_CONST , f , start ) 
self -> enemy -> s . origin , end ) 
svc_temp_entity ) 
self ) 
STRING ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
mins [ INT_CONST ] + maxs [ INT_CONST ] ) 
trace . fraction == FLOAT_CONST ) 
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
ent -> s . origin , oldorg ) 
ent -> flags & ( FL_SWIM | FL_FLY ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! ( ent -> monsterinfo . aiflags & AI_NOSTEP ) ) 
neworg , ent -> mins , ent -> maxs , end , ent , MASK_MONSTERSOLID ) 
trace . allsolid ) 
ent -> waterlevel == INT_CONST ) 
trace . fraction == INT_CONST ) 
ent -> flags & FL_PARTIALGROUND ) 
ent ) 
trace . endpos , ent -> s . origin ) 
ent ) 
ent -> flags & FL_PARTIALGROUND ) 
relink ) 
current == ideal ) 
ent -> s . origin , oldorigin ) 
! enemy ) 
deltax > INT_CONST ) 
( ( rand ( ) & INT_CONST ) & INT_CONST ) || abs ( deltay ) > abs ( deltax ) ) 
d [ INT_CONST ] != DI_NODIR && d [ INT_CONST ] != turnaround NEW_LINE && SV_StepDirection ( actor , d [ INT_CONST ] , dist ) ) 
FOR ( tdir = INT_CONST ; tdir <= INT_CONST ; tdir += INT_CONST ) 
FOR ( tdir = INT_CONST ; tdir >= INT_CONST ; tdir -= INT_CONST ) 
turnaround != DI_NODIR && SV_StepDirection ( actor , turnaround , dist ) ) 
! M_CheckBottom ( actor ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
goal -> absmax [ i ] < ent -> absmin [ i ] - dist ) 
ent , move , true ) 
__E__O__F__
aim , MELEE_DISTANCE , self -> mins [ INT_CONST ] , INT_CONST ) 
aim , MELEE_DISTANCE , self -> maxs [ INT_CONST ] , INT_CONST ) 
other -> takedamage ) 
self -> velocity , normal ) 
! M_CheckBottom ( self ) ) 
self , CHAN_VOICE , sound_sight , INT_CONST , ATTN_NORM , INT_CONST ) 
level . time > self -> monsterinfo . attack_finished ) 
self -> absmin [ INT_CONST ] > ( self -> enemy -> absmin [ INT_CONST ] + FLOAT_CONST * self -> enemy -> size [ INT_CONST ] ) ) 
distance < INT_CONST ) 
mutant_check_jump ( self ) ) 
self -> health < ( self -> max_health / INT_CONST ) ) 
skill -> value == INT_CONST ) 
self ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
random ( ) < FLOAT_CONST ) 
STRING ) 
self ) 
__E__O__F__
skill -> value == INT_CONST ) 
start , end , dir ) 
dir , angles ) 
self -> s . angles , f , r , NULL ) 
self -> enemy -> s . origin , end ) 
start , NULL , NULL , end , self , MASK_SHOT ) 
svc_temp_entity ) 
start , end , dir ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
self -> monsterinfo . currentmove == &v soldier_move_walk1 || NEW_LINE self -> monsterinfo . currentmove == &v soldier_move_walk2 || NEW_LINE self -> monsterinfo . currentmove == &v soldier_move_start_run ) 
self -> health < ( self -> max_health / INT_CONST ) ) 
n == INT_CONST ) 
skill -> value == INT_CONST ) 
r < FLOAT_CONST ) 
self -> s . skinnum < INT_CONST ) 
flash_number == INT_CONST || flash_number == INT_CONST ) 
self -> s . skinnum <= INT_CONST ) 
) 
) 
skill -> value == INT_CONST ) 
skill -> value >= INT_CONST ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
self -> s . skinnum == INT_CONST ) 
self , CHAN_VOICE , sound_death_ss , INT_CONST , ATTN_NORM , INT_CONST ) 
) 
STRING ) 
self ) 
self ) 
self ) 
self ) 
STRING ) 
self ) 
STRING ) 
self ) 
STRING ) 
__E__O__F__
damage <= INT_CONST ) 
skill -> value >= INT_CONST ) 
skill -> value == INT_CONST ) 
self -> s . frame == FRAME_attak2_8 ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , vec ) 
self , start , dir , INT_CONST , INT_CONST , flash_number ) 
self -> s . frame - FRAME_attak1_1 ) 
dir , forward , right , NULL ) 
self -> enemy ) 
self -> enemy -> s . origin , self -> s . origin , vec ) 
range <= INT_CONST ) 
random ( ) < FLOAT_CONST ) 
self -> s . origin , org ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
svc_temp_entity ) 
STRING ) 
STRING ) 
STRING ) 
self ) 
self ) 
__E__O__F__
self -> monsterinfo . currentmove == &v tank_move_walk || NEW_LINE self -> monsterinfo . currentmove == &v tank_move_start_run ) 
self , CHAN_VOICE , sound_pain , INT_CONST , ATTN_NORM , INT_CONST ) 
skill -> value == INT_CONST ) 
self -> s . frame == FRAME_attak110 ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , end ) 
self , start , dir , INT_CONST , INT_CONST , flash_number , EF_BLASTER ) 
self -> s . frame == FRAME_attak324 ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy -> s . origin , vec ) 
self , start , dir , INT_CONST , INT_CONST , flash_number ) 
self -> s . frame - FRAME_attak406 ) 
self -> s . angles , forward , right , NULL ) 
self -> enemy ) 
dir , forward , NULL , NULL ) 
self , start , forward , INT_CONST , INT_CONST , DEFAULT_BULLET_HSPREAD , DEFAULT_BULLET_VSPREAD , flash_number ) 
skill -> value >= INT_CONST ) 
self -> enemy -> health < INT_CONST ) 
self -> enemy -> s . origin , self -> s . origin , vec ) 
) 
range <= INT_CONST ) 
self -> health <= self -> gib_health ) 
FOR ( n = INT_CONST ; n < INT_CONST COMMENT ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
self -> deadflag == DEAD_DEAD ) 
edict_t * self ) 
STRING ) 
STRING ) 
STRING ) 
strcmp ( self -> classname , STRING ) == INT_CONST ) 
self ) 
self ) 
strcmp ( self -> classname , STRING ) == INT_CONST ) 
__E__O__F__
INT_CONST ) 
Q_stricmp ( level . mapname , STRING ) == INT_CONST ) 
( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) || NEW_LINE ( Q_stricmp ( level . mapname , STRING ) == INT_CONST ) ) 
! ent -> client ) 
! ent -> client ) 
coop -> value && attacker -> client ) 
IsFemale ( self ) ) 
IsFemale ( self ) ) 
IsFemale ( self ) ) 
PRINT_MEDIUM , STRING , self -> client -> pers . netname ) 
! deathmatch -> value ) 
quad ) 
attacker && attacker != world && attacker != self ) 
dir [ INT_CONST ] ) 
edict_t * self , edict_t * inflictor , edict_t * attacker , INT damage , vec3_t point ) 
self -> avelocity ) 
! self -> deadflag ) 
FOR ( n = INT_CONST ; n < game . num_items ; n v++ ) 
self -> health < -v INT_CONST ) 
self , CHAN_BODY , gi . soundindex ( STRING ) , INT_CONST , ATTN_NORM , INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
! self -> deadflag ) 
i + INT_CONST ) 
self ) 
&v client -> pers , INT_CONST , SIZEOF ( client -> pers ) ) 
STRING ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
FOR ( n = INT_CONST ; n <= maxclients -> value ; n v++ ) 
( spot = G_Find ( spot , FOFS ( classname ) , STRING ) ) != NULL ) 
! count ) 
( spot = G_Find ( spot , FOFS ( classname ) , STRING ) ) != NULL ) 
bestspot ) 
NULL , FOFS ( classname ) , STRING ) 
! index ) 
INT_CONST ) 
deathmatch -> value ) 
! spot ) 
spot -> s . origin , origin ) 
FOR ( i = INT_CONST ; i < BODY_QUEUE_SIZE ; i v++ ) 
self -> health < -v INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
INT ) 
ent ) 
body ) 
ent -> mins , body -> mins ) 
body ) 
STRING ) 
ent -> client -> pers . spectator ) 
FOR ( i = INT_CONST , numspec = INT_CONST ; i <= maxclients -> value ; i v++ ) 
ent ) 
! ent -> client -> pers . spectator ) 
ent -> client -> pers . spectator ) 
ent , spawn_origin , spawn_angles ) 
deathmatch -> value ) 
client , INT_CONST , SIZEOF ( *v client ) ) 
ent ) 
mins , ent -> mins ) 
&v ent -> client -> ps , INT_CONST , SIZEOF ( client -> ps ) ) 
deathmatch -> value && ( ( INT ) dmflags -> value & DF_FIXED_FOV ) ) 
client -> pers . weapon -> view_model ) 
spawn_origin , ent -> s . origin ) 
ent -> s . origin , ent -> s . old_origin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
client -> pers . spectator ) 
ent ) 
ent ) 
ent -> client ) 
ent ) 
svc_muzzleflash ) 
PRINT_HIGH , STRING , ent -> client -> pers . netname ) 
ent ) 
ent - g_edicts - INT_CONST ) 
deathmatch -> value ) 
ent -> inuse == true ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
level . intermissiontime ) 
ent ) 
! Info_Validate ( userinfo ) ) 
userinfo , STRING ) 
userinfo , STRING ) 
deathmatch -> value && *v s && strcmp ( s , STRING ) ) 
userinfo , STRING ) 
CS_PLAYERSKINS + playernum , va ( STRING , ent -> client -> pers . netname , s ) ) 
deathmatch -> value && ( ( INT ) dmflags -> value & DF_FIXED_FOV ) ) 
userinfo , STRING ) 
ent -> client -> pers . userinfo , userinfo , SIZEOF ( ent -> client -> pers . userinfo ) - INT_CONST ) 
userinfo , STRING ) 
userinfo , STRING ) 
FOR ( i = numspec = INT_CONST ; i < maxclients -> value ; i v++ ) 
ent - g_edicts - INT_CONST ) 
ent -> inuse == false ) 
ent , userinfo ) 
game . maxclients > INT_CONST ) 
! ent -> client ) 
svc_muzzleflash ) 
ent ) 
CS_PLAYERSKINS + playernum , STRING ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
&v pm -> s , SIZEOF ( pm -> s ) ) 
level . intermissiontime ) 
ent -> client -> chase_target ) 
ucmd -> angles [ INT_CONST ] ) 
&v pm , INT_CONST , SIZEOF ( pm ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < pm . numtouch ; i v++ ) 
FOR ( j = INT_CONST ; j < i ; j v++ ) 
client -> latched_buttons & BUTTON_ATTACK ) 
client -> resp . spectator ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
level . intermissiontime ) 
deathmatch -> value && NEW_LINE client -> pers . spectator != client -> resp . spectator && NEW_LINE ( level . time - client -> respawn_time ) >= INT_CONST ) 
! client -> weapon_thunk && ! client -> resp . spectator ) 
! deathmatch -> value ) 
__E__O__F__
deathmatch -> value || coop -> value ) 
level . intermissiontime ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
strstr ( level . changemap , STRING ) ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
FOR ( n = INT_CONST ; n < MAX_ITEMS ; n v++ ) 
NULL , FOFS ( classname ) , STRING ) 
NULL , FOFS ( classname ) , STRING ) 
) 
ent -> s . origin , level . intermission_origin ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
FOR ( i = INT_CONST ; i < game . maxclients ; i v++ ) 
FOR ( j = INT_CONST ; j < total ; j v++ ) 
FOR ( k = total ; k > j ; k v-- ) 
string ) 
total > INT_CONST ) 
FOR ( i = INT_CONST ; i < total ; i v++ ) 
cl_ent == killer ) 
tag ) 
svc_layout ) 
! deathmatch -> value && ! coop -> value ) 
ent ) 
skill -> value == INT_CONST ) 
string , SIZEOF ( string ) , NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING COMMENT_NL CPP_COMMENT NEW_LINE STRING NEW_LINE STRING , NEW_LINE sk , NEW_LINE level . level_name , NEW_LINE game . helpmessage1 , NEW_LINE game . helpmessage2 , NEW_LINE level . killed_monsters , level . total_monsters , NEW_LINE level . found_goals , level . total_goals , NEW_LINE level . found_secrets , level . total_secrets ) 
deathmatch -> value ) 
ent -> client -> showhelp && ( ent -> client -> pers . game_helpchanged == game . helpchanged ) ) 
ent ) 
! ent -> client -> ammo_index COMMENT ) 
ent ) 
ent ) 
STRING ) 
level . time > ent -> client -> pickup_msg_time ) 
ent -> client -> quad_framenum > level . framenum ) 
ent -> client -> pers . selected_item == -v INT_CONST ) 
deathmatch -> value ) 
ent -> client -> pers . helpchanged && ( level . framenum & INT_CONST ) ) 
FOR ( i = INT_CONST ; i <= maxclients -> value ; i v++ ) 
! cl -> chase_target ) 
cl -> pers . health <= INT_CONST || level . intermissiontime || cl -> showscores ) 
__E__O__F__
deathmatch -> value COMMENT ) 
FOR ( n = INT_CONST ; n < TRAIL_LENGTH ; n v++ ) 
! trail_active ) 
spot , trail [ PREV ( trail_head ) ] -> s . origin , temp ) 
trail_head ) 
! trail_active ) 
FOR ( marker = trail_head , n = TRAIL_LENGTH ; n ; n v-- ) 
visible ( self , trail [ marker ] ) ) 
visible ( self , trail [ PREV ( marker ) ] ) ) 
! trail_active ) 
FOR ( marker = trail_head , n = TRAIL_LENGTH ; n ; n v-- ) 
__E__O__F__
edict_t * player ) 
client -> damage_blood ) 
client -> damage_blood + client -> damage_armor + client -> damage_parmor ) 
client -> anim_priority < ANIM_PAIN && player -> s . modelindex == INT_CONST ) 
count < INT_CONST ) 
( level . time > player -> pain_debounce_time ) && ! ( player -> flags & FL_GODMODE ) && ( client -> invincible_framenum <= level . framenum ) ) 
client -> damage_alpha < INT_CONST ) 
v ) 
client -> damage_knockback ) 
ent -> deadflag ) 
v ) 
ent -> client -> fall_time - level . time ) 
bob > INT_CONST ) 
v , ent -> client -> kick_origin , v ) 
v [ INT_CONST ] < -v INT_CONST ) 
bobcycle & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
delta < -v INT_CONST ) 
delta > INT_CONST ) 
ent -> client -> ps . gunoffset ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
a <= INT_CONST ) 
INT_CONST - a3 ) 
ent -> s . origin , ent -> client -> ps . viewoffset , vieworg ) 
ent -> client -> quad_framenum > level . framenum ) 
ent -> client -> damage_alpha > INT_CONST ) 
ent -> client -> damage_alpha < INT_CONST ) 
ent -> client -> bonus_alpha < INT_CONST ) 
ent -> s . modelindex != INT_CONST ) 
ent -> waterlevel == INT_CONST ) 
ent -> client -> fall_value > INT_CONST ) 
delta > INT_CONST ) 
current_player -> movetype == MOVETYPE_NOCLIP ) 
! old_waterlevel && waterlevel ) 
old_waterlevel && ! waterlevel ) 
old_waterlevel != INT_CONST && waterlevel == INT_CONST ) 
old_waterlevel == INT_CONST && waterlevel != INT_CONST ) 
waterlevel == INT_CONST ) 
waterlevel && ( current_player -> watertype & ( CONTENTS_LAVA | CONTENTS_SLIME ) ) ) 
ent -> health <= INT_CONST || level . intermissiontime ) 
ent -> client -> quad_framenum > level . framenum ) 
ent -> client -> invincible_framenum > level . framenum ) 
ent -> flags & FL_GODMODE ) 
ent -> client -> pers . game_helpchanged != game . helpchanged ) 
ent -> client -> pers . helpchanged && ent -> client -> pers . helpchanged <= INT_CONST && ! ( level . framenum & INT_CONST ) ) 
ent -> client -> pers . weapon ) 
ent -> s . modelindex != INT_CONST ) 
client -> ps . pmove . pm_flags & PMF_DUCKED ) 
duck != client -> anim_duck && client -> anim_priority < ANIM_DEATH ) 
client -> anim_priority == ANIM_DEATH ) 
! ent -> groundentity ) 
duck ) 
duck ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
level . intermissiontime ) 
ent -> client -> v_angle , forward , right , up ) 
) 
ent -> client -> v_angle [ PITCH ] > INT_CONST ) 
ent -> velocity [ INT_CONST ] * ent -> velocity [ INT_CONST ] + ent -> velocity [ INT_CONST ] * ent -> velocity [ INT_CONST ] ) 
xyspeed < INT_CONST ) 
xyspeed > INT_CONST ) 
ent ) 
ent ) 
ent ) 
ent ) 
ent ) 
ent -> client -> resp . spectator ) 
ent ) 
ent ) 
ent ) 
ent ) 
ent -> velocity , ent -> client -> oldvelocity ) 
ent -> client -> kick_origin ) 
ent -> client -> showscores && ! ( level . framenum & INT_CONST ) ) 
__E__O__F__
distance , _distance ) 
type == PNOISE_WEAPON ) 
deathmatch -> value ) 
type == PNOISE_SELF || type == PNOISE_WEAPON ) 
where , noise -> s . origin ) 
ent -> item ) 
( ( ( INT ) ( dmflags -> value ) & DF_WEAPONS_STAY ) || coop -> value ) NEW_LINE && other -> client -> pers . inventory [ index ] ) 
! ( ent -> spawnflags & DROPPED_ITEM ) ) 
other -> client -> pers . weapon != ent -> item && NEW_LINE ( other -> client -> pers . inventory [ index ] == INT_CONST ) && NEW_LINE ( ! deathmatch -> value || other -> client -> pers . weapon == FindItem ( STRING ) ) ) 
ent -> client -> grenade_time ) 
ent -> s . modelindex == INT_CONST ) 
ent -> client -> pers . weapon && ent -> client -> pers . weapon -> ammo ) 
ent -> client -> pers . weapon -> view_model ) 
ent -> client -> ps . pmove . pm_flags & PMF_DUCKED ) 
ent -> health < INT_CONST ) 
ent -> client -> pers . weapon && ent -> client -> pers . weapon -> weaponthink ) 
item == ent -> client -> pers . weapon ) 
( INT ) ( dmflags -> value ) & DF_WEAPONS_STAY ) 
( ( item == ent -> client -> pers . weapon ) || ( item == ent -> client -> newweapon ) ) && ( ent -> client -> pers . inventory [ index ] == INT_CONST ) ) 
ent , item ) 
ent -> deadflag || ent -> s . modelindex != INT_CONST ) 
ent -> client -> weaponstate == WEAPON_DROPPING ) 
ent -> client -> weaponstate == WEAPON_ACTIVATING ) 
( ent -> client -> newweapon ) && ( ent -> client -> weaponstate != WEAPON_FIRING ) ) 
ent -> client -> weaponstate == WEAPON_READY ) 
FOR ( n = INT_CONST ; pause_frames [ n ] ; n v++ ) 
ent -> client -> weaponstate == WEAPON_FIRING ) 
FOR ( n = INT_CONST ; fire_frames [ n ] ; n v++ ) 
is_quad ) 
GRENADE_TIMER - timer ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent -> deadflag || ent -> s . modelindex != INT_CONST ) 
ent -> health <= INT_CONST ) 
ent -> client -> weaponstate == WEAPON_ACTIVATING ) 
ent -> client -> weaponstate == WEAPON_READY ) 
ent -> client -> weaponstate == WEAPON_FIRING ) 
is_quad ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
ent , start , forward , damage , INT_CONST , FLOAT_CONST , radius ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_grenadelauncher_fire ) 
INT ) 
ent -> client -> v_angle , forward , right , NULL ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Weapon_RocketLauncher_Fire ) 
is_quad ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
ent , start , forward , damage , INT_CONST , effect , hyper ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
deathmatch -> value ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Weapon_Blaster_Fire ) 
STRING ) 
! ( ent -> client -> buttons & BUTTON_ATTACK ) ) 
ent -> client -> ps . gunframe == INT_CONST ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Weapon_HyperBlaster_Fire ) 
! ( ent -> client -> buttons & BUTTON_ATTACK ) ) 
ent -> client -> ps . gunframe == INT_CONST ) 
is_quad ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! deathmatch -> value ) 
ent -> client -> v_angle , ent -> client -> kick_angles , angles ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Machinegun_Fire ) 
deathmatch -> value ) 
ent -> client -> ps . gunframe == INT_CONST ) 
ent -> client -> ps . pmove . pm_flags & PMF_DUCKED ) 
ent -> client -> ps . gunframe <= INT_CONST ) 
is_quad ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < shots ; i v++ ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , Chaingun_Fire ) 
ent -> client -> ps . gunframe == INT_CONST ) 
ent -> client -> v_angle , forward , right , NULL ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
is_quad ) 
deathmatch -> value ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_shotgun_fire ) 
ent -> client -> v_angle , forward , right , NULL ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
is_quad ) 
v , forward , NULL , NULL ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_supershotgun_fire ) 
deathmatch -> value ) 
is_quad ) 
ent -> client -> v_angle , forward , right , NULL ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
svc_muzzleflash ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_railgun_fire ) 
deathmatch -> value ) 
ent -> client -> pers . inventory [ ent -> client -> ammo_index ] < INT_CONST ) 
is_quad ) 
forward , -v INT_CONST , ent -> client -> kick_origin ) 
) 
offset , INT_CONST , INT_CONST , ent -> viewheight - INT_CONST ) 
ent , start , PNOISE_WEAPON ) 
! ( ( INT ) dmflags -> value & DF_INFINITE_AMMO ) ) 
ent , INT_CONST , INT_CONST , INT_CONST , INT_CONST , pause_frames , fire_frames , weapon_bfg_fire ) 
__E__O__F__
vr , dir ) 
im , m , SIZEOF ( im ) ) 
zrot , INT_CONST , SIZEOF ( zrot ) ) 
DEG2RAD ( degrees ) ) 
m , zrot , tmpmat ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
M_PI * INT_CONST / INT_CONST ) 
forward ) 
normal , normal ) 
normal , p ) 
FOR ( pos = INT_CONST , i = INT_CONST ; i < INT_CONST ; i v++ ) 
dst , tempvec , src ) 
dst ) 
vec3_t emins , vec3_t emaxs , STRUCT cplane_s * p ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
p -> type < INT_CONST ) 
p -> signbits ) 
INT_CONST ) 
dist1 >= p -> dist ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
length ) 
length ) 
length ) 
length ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
*v in && *v in != CHAR_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST && *v in ; i v++ , in v++ ) 
FOR ( s2 = s ; s2 != in && *v s2 != CHAR_CONST ; s2 v-- ) 
*v src != CHAR_CONST && src != path ) 
path , extension ) 
l >> INT_CONST ) 
b1 << INT_CONST ) 
l >> INT_CONST ) 
( INT ) b1 << INT_CONST ) 
*v ( SHORT *p ) swaptest == INT_CONST ) 
! data ) 
c == CHAR_CONST && data [ INT_CONST ] == CHAR_CONST ) 
c == CHAR_CONST ) 
len == MAX_TOKEN_CHARS ) 
FOR ( i = size - INT_CONST ; i > INT_CONST ; i -= INT_CONST ) 
argptr , fmt ) 
*v s == CHAR_CONST ) 
strstr ( key , STRING ) ) 
INT_CONST ) 
strstr ( key , STRING ) || strstr ( value , STRING ) ) 
strstr ( key , STRING ) ) 
strstr ( key , STRING ) || strstr ( value , STRING ) ) 
strlen ( key ) > MAX_INFO_KEY - INT_CONST || strlen ( value ) > MAX_INFO_KEY - INT_CONST ) 
strlen ( newi ) + strlen ( s ) > maxsize ) 
s ) 
__E__O__F__
__E__O__F__
stderr , STRING ) 
PRINT_ALL , STRING ) 
PRINT_ALL , STRING , mode ) 
! ri . Vid_GetModeInfo ( &v width , &v height , mode ) ) 
PRINT_ALL , STRING , width , height ) 
) 
! GLimp_InitGraphics ( fullscreen ) ) 
width , height ) 
! x_disp ) 
stderr , STRING ) 
getpid ( ) ) 
vid . width , vid . height ) 
NULL ) 
x_disp , True ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
x_disp , DefaultScreen ( x_disp ) , NEW_LINE StudlyRGBattributes ) 
PRINT_ALL , STRING , NEW_LINE ( INT ) ( x_visinfo -> visualid ) ) 
x_visinfo -> depth == INT_CONST ) 
x_visinfo -> class == PseudoColor ) 
x_disp , x_win , CreateNullCursor ( x_disp , x_win ) ) 
fullscreen ) 
x_disp , x_win ) 
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
&v x_event . xkey ) 
_windowed_mouse -> value ) 
x_event . xbutton . button == INT_CONST ) 
x_event . xbutton . button == INT_CONST ) 
doShm && x_event . type == x_shmeventtype ) 
stderr , STRING ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , RW_IN_MLookDown ) 
STRING , Force_CenterView_f ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! mouse_x && ! mouse_y ) 
( *v in_state -> in_strafe_state & INT_CONST ) || NEW_LINE ( lookstrafe -> value && mlooking ) ) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
__E__O__F__
__E__O__F__
INT ) 
size + INT_CONST ) 
base ) 
&v tp , &v tzp ) 
tp . tv_sec - secbase ) 
strcmp ( name , STRING ) == INT_CONST || strcmp ( name , STRING ) == INT_CONST ) 
fdir ) 
( p = strrchr ( findbase , CHAR_CONST ) ) != NULL ) 
fdir == NULL ) 
__E__O__F__
dma . samplebits != INT_CONST ) 
STRING , STRING , ac ) 
dma_buffer ) 
nFrames <= QSND_SKID ) 
sgisnd_aport , QSND_BUFFER_FRAMES ) 
__E__O__F__
argptr , fmt ) 
strlen ( text ) > SIZEOF ( text ) ) 
FOR ( p = ( UNSIGNED CHAR *p ) text ; *v p ; p v++ ) 
) 
select ( INT_CONST , &v fdset , NULL , NULL , &v timeout ) == -v INT_CONST || ! FD_ISSET ( INT_CONST , &v fdset ) ) 
len < INT_CONST ) 
getuid ( ) , getuid ( ) ) 
game_library ) 
STRING , gamename ) 
INT_CONST ) 
VOID *p ) 
parms ) 
) 
) 
argc , argv ) 
STRING , STRING , INT_CONST ) 
) 
checked ) 
( mnt = setmntent ( STRING , STRING ) ) == NULL ) 
found_cd ) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
__E__O__F__
s_ref_list [ s_current_menu_index ] . curvalue < INT_CONST ) 
STRING , slider -> curvalue * INT_CONST ) 
s_current_menu_index == INT_CONST ) 
FLOAT_CONST - ( s_brightness_slider [ s_current_menu_index ] . curvalue / FLOAT_CONST - FLOAT_CONST ) ) 
STRING , gamma ) 
s_ref_list [ s_current_menu_index ] . curvalue ) 
STRING , STRING ) 
Q_stricmp ( vid_ref -> string , STRING ) == INT_CONST ) 
! gl_driver ) 
! scr_viewsize ) 
strcmp ( vid_ref -> string , STRING ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v s_software_menu , ( VOID *p ) & s_ref_list [ SOFTWARE_MENU ] ) 
&v s_opengl_menu , ( VOID *p ) & s_ref_list [ OPENGL_MENU ] ) 
&v s_software_menu , ( VOID *p ) & s_defaults_action [ SOFTWARE_MENU ] ) 
&v s_software_menu ) 
s_current_menu_index == INT_CONST ) 
s_current_menu , INT_CONST ) 
s_current_menu ) 
key ) 
m , INT_CONST ) 
m , -v INT_CONST ) 
m , INT_CONST ) 
m ) 
__E__O__F__
print_level == PRINT_ALL ) 
err_level , STRING , msg ) 
&v re , INT_CONST , SIZEOF ( re ) ) 
reflib_active ) 
curpath , SIZEOF ( curpath ) ) 
INT_CONST ) 
( GetRefAPI = ( VOID *p ) dlsym ( reflib_library , STRING ) ) == INT_CONST ) 
re . api_version != API_VERSION ) 
( RW_IN_Init_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Shutdown_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Activate_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Commands_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Move_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Frame_fp = dlsym ( reflib_library , STRING ) ) == NULL ) 
getuid ( ) , getuid ( ) ) 
( KBD_Init_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( KBD_Update_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( KBD_Close_fp = dlsym ( reflib_library , STRING ) ) == NULL ) 
STRING ) 
vid_ref -> modified ) 
vid_ref -> modified ) 
STRING , VID_Restart_f ) 
STRING ) 
__E__O__F__
ioctl ( cdfile , CDROMREADTOCHDR , &v tochdr ) == -v INT_CONST ) 
cdfile == -v INT_CONST || ! enabled ) 
track < INT_CONST || track > maxTrack ) 
ioctl ( cdfile , CDROMREADTOCENTRY , &v entry ) == -v INT_CONST ) 
playing ) 
ioctl ( cdfile , CDROMPLAYTRKIND , &v ti ) == -v INT_CONST ) 
cd_volume -> value == FLOAT_CONST ) 
Cmd_Argc ( ) < INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n <= ret ; n v++ ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
! cdValid ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
cdfile == -v INT_CONST || ! enabled ) 
playing && lastchk < time ( NULL ) ) 
STRING , STRING , CVAR_NOSET ) 
STRING , STRING , CVAR_ARCHIVE ) 
saved_euid ) 
cd_dev -> string , O_RDONLY ) 
getuid ( ) ) 
cdfile == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
CDAudio_GetAudioDiskInfo ( ) ) 
STRING , CD_f ) 
STRING ) 
__E__O__F__
( c = *v p v++ ) == CHAR_CONST || c == CHAR_CONST ) 
( c = *v p v++ ) != CHAR_CONST ) 
( c = *v p v++ ) != CHAR_CONST ) 
__E__O__F__
FOR ( i = INT_CONST ; i < NUM_RESOLUTIONS ; i v++ ) 
PRINT_ALL , STRING ) 
PRINT_ALL , STRING , mode ) 
! ri . Vid_GetModeInfo ( &v width , &v height , mode ) ) 
PRINT_ALL , STRING , width , height ) 
) 
INT_CONST , findres ( &v width , &v height ) , GR_REFRESH_75Hz , NEW_LINE attribs ) 
width , height ) 
fc ) 
FOR ( intbl = ( byte * ) table , i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
__E__O__F__
a -> type == NA_BROADCAST ) 
a . type == NA_IPX ) 
FOR ( colon = copy ; *v colon ; colon v++ ) 
! NET_StringToSockaddr ( s , ( STRUCT sockaddr * ) & sadr ) ) 
loop -> send - loop -> get > MAX_LOOPBACK ) 
net_message -> data , loop -> msgs [ i ] . data , loop -> msgs [ i ] . datalen ) 
MAX_LOOPBACK - INT_CONST ) 
loop -> msgs [ i ] . data , data , length ) 
NET_GetLoopPacket ( sock , net_from , net_message ) ) 
FOR ( protocol = INT_CONST ; protocol < INT_CONST ; protocol v++ ) 
to . type == NA_LOOPBACK ) 
to . type == NA_BROADCAST ) 
net_socket , data , length , INT_CONST , ( STRUCT sockaddr * ) & addr , SIZEOF ( addr ) ) 
STRING , va ( STRING , PORT_SERVER ) , CVAR_NOSET ) 
! ip_sockets [ NS_SERVER ] ) 
! multiplayer ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
ioctl ( newsocket , FIONBIO , &v _true ) == -v INT_CONST ) 
setsockopt ( newsocket , SOL_SOCKET , SO_BROADCAST , ( CHAR *p ) & i , SIZEOF ( i ) ) == -v INT_CONST ) 
! net_interface || ! net_interface [ INT_CONST ] || ! stricmp ( net_interface , STRING ) ) 
bind ( newsocket , ( VOID *p ) & address , SIZEOF ( address ) ) == -v INT_CONST ) 
code ) 
! ip_sockets [ NS_SERVER ] || ( dedicated && ! dedicated -> value ) ) 
msec % INT_CONST ) 
__E__O__F__
__E__O__F__
INT ) 
INT ) 
size + INT_CONST ) 
membase , maxhunksize , curhunksize + SIZEOF ( INT ) , INT_CONST ) 
base ) 
&v tp , &v tzp ) 
tp . tv_sec - secbase ) 
strcmp ( name , STRING ) == INT_CONST || strcmp ( name , STRING ) == INT_CONST ) 
fdir ) 
( p = strrchr ( findbase , CHAR_CONST ) ) != NULL ) 
fdir == NULL ) 
__E__O__F__
scantokey [ sc ] , state == KEY_EVENTPRESS ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
keyboard_init ( ) ) 
STRING , STRING , INT_CONST ) 
STRING , RW_IN_MLookDown ) 
STRING , Force_CenterView_f ) 
) 
STRING , STRING , INT_CONST ) 
mouse_init ( mdev -> string , mtype , ( INT ) mrate -> value ) ) 
) 
( mouse_buttonstate & MOUSE_LEFTBUTTON ) && NEW_LINE ! ( mouse_oldbuttonstate & MOUSE_LEFTBUTTON ) ) 
) 
m_filter -> value ) 
! mx && ! my ) 
( *v in_state -> in_strafe_state & INT_CONST ) || NEW_LINE ( lookstrafe -> value && mlooking ) ) 
__E__O__F__
) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
) 
vid . width , vid . height ) 
current_mode < INT_CONST ) 
vid . width , vid . height ) 
PRINT_ALL , STRING , current_mode ) 
VGA_planar ) 
current_mode ) 
CHAR *p ) 
vid . rowbytes * vid . height ) 
FOR ( offset = INT_CONST ; offset < total ; offset += INT_CONST ) 
PRINT_ALL , STRING , mode ) 
! ri . Vid_GetModeInfo ( pwidth , pheight , mode ) ) 
PRINT_ALL , STRING , *v pwidth , *v pheight ) 
! SWimp_InitGraphics ( false ) ) 
( CONST UNSIGNED CHAR *p ) d_8to24table ) 
! palette ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , pal += INT_CONST , tp += INT_CONST ) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
__E__O__F__
STRING , STRING , CVAR_ARCHIVE ) 
STRING , RW_IN_MLookDown ) 
STRING , Force_CenterView_f ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! mouse_x && ! mouse_y ) 
( *v in_state -> in_strafe_state & INT_CONST ) || NEW_LINE ( lookstrafe -> value && mlooking ) ) 
FOR ( r_shift = -v INT_CONST , x = INT_CONST ; x < r_mask ; x = x << INT_CONST ) 
FOR ( g_shift = -v INT_CONST , x = INT_CONST ; x < g_mask ; x = x << INT_CONST ) 
FOR ( b_shift = -v INT_CONST , x = INT_CONST ; x < b_mask ; x = x << INT_CONST ) 
( x < INT_CONST ) || ( y < INT_CONST ) ) 
FOR ( yi = y ; yi < ( y + height ) ; yi v++ ) 
FOR ( xi = ( x + width - INT_CONST ) ; xi >= x ; xi -= INT_CONST ) 
x_framebuffer [ INT_CONST ] ) 
pwidth == INT_CONST ) 
x_disp , NEW_LINE x_vis , NEW_LINE x_visinfo -> depth , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE malloc ( mem ) , NEW_LINE vid . width , vid . height , NEW_LINE INT_CONST , NEW_LINE INT_CONST ) 
FOR ( frm = INT_CONST ; frm < INT_CONST ; frm v++ ) 
x_framebuffer [ frm ] ) 
x_disp , NEW_LINE x_vis , NEW_LINE x_visinfo -> depth , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE &v x_shminfo [ frm ] , NEW_LINE vid . width , NEW_LINE vid . height ) 
size < minsize ) 
! XShmAttach ( x_disp , &v x_shminfo [ frm ] ) ) 
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
&v x_event . xkey ) 
_windowed_mouse -> value ) 
x_event . xbutton . button == INT_CONST ) 
x_event . xbutton . button == INT_CONST ) 
doShm && x_event . type == x_shmeventtype ) 
getpid ( ) ) 
) 
vid . width , vid . height ) 
x_disp ) 
x_disp , True ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
x_disp , template_mask , &v template , &v num_visuals ) 
FOR ( i = INT_CONST ; i < num_visuals ; i v++ ) 
verbose ) 
CPP_COMMENT NEW_LINE vid . width , vid . height , NEW_LINE INT_CONST , COMMENT_NL CPP_COMMENT NEW_LINE x_visinfo -> depth , NEW_LINE InputOutput , NEW_LINE x_vis , NEW_LINE attribmask , NEW_LINE &v attribs ) 
x_visinfo -> depth == INT_CONST ) 
x_visinfo -> class == PseudoColor ) 
x_disp , x_win , CreateNullCursor ( x_disp , x_win ) ) 
x_disp , x_win ) 
doShm ) 
x_visinfo -> depth != INT_CONST ) 
PRINT_ALL , STRING , mode ) 
! ri . Vid_GetModeInfo ( pwidth , pheight , mode ) ) 
PRINT_ALL , STRING , *v pwidth , *v pheight ) 
! SWimp_InitGraphics ( false ) ) 
( CONST UNSIGNED CHAR *p ) d_8to24table ) 
! X11_active ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! X11_active ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
x_disp , x_win ) 
x_disp ) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
__E__O__F__
snd_inited ) 
! audio_fd ) 
audio_fd , SNDCTL_DSP_RESET , INT_CONST ) 
ioctl ( audio_fd , SNDCTL_DSP_GETCAPS , &v caps ) == -v INT_CONST ) 
! ( caps & DSP_CAP_TRIGGER ) || ! ( caps & DSP_CAP_MMAP ) ) 
ioctl ( audio_fd , SNDCTL_DSP_GETOSPACE , &v info ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < SIZEOF ( tryrates ) / INT_CONST ; i v++ ) 
! dma . buffer ) 
dma . channels == INT_CONST ) 
audio_fd , SNDCTL_DSP_SETTRIGGER , &v tmp ) 
! snd_inited ) 
ioctl ( audio_fd , SNDCTL_DSP_GETOPTR , &v count ) == -v INT_CONST ) 
__E__O__F__
argptr , fmt ) 
strlen ( text ) > SIZEOF ( text ) ) 
FOR ( p = ( UNSIGNED CHAR *p ) text ; *v p ; p v++ ) 
INT_CONST ) 
select ( INT_CONST , &v fdset , NULL , NULL , &v timeout ) == -v INT_CONST || ! FD_ISSET ( INT_CONST , &v fdset ) ) 
len < INT_CONST ) 
getuid ( ) , getuid ( ) ) 
game_library ) 
STRING , gamename ) 
INT_CONST ) 
VOID *p ) 
parms ) 
) 
) 
argc , argv ) 
INT_CONST , F_SETFL , fcntl ( INT_CONST , F_GETFL , INT_CONST ) | FNDELAY ) 
STRING , STRING , INT_CONST ) 
) 
checked ) 
found_cd ) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
__E__O__F__
s_ref_list [ s_current_menu_index ] . curvalue < INT_CONST ) 
STRING , slider -> curvalue * INT_CONST ) 
s_current_menu_index == INT_CONST ) 
FLOAT_CONST - ( s_brightness_slider [ s_current_menu_index ] . curvalue / FLOAT_CONST - FLOAT_CONST ) ) 
STRING , gamma ) 
s_ref_list [ s_current_menu_index ] . curvalue ) 
STRING , STRING ) 
STRING , STRING ) 
stricmp ( vid_ref -> string , STRING ) == INT_CONST ) 
! gl_driver ) 
! scr_viewsize ) 
strcmp ( vid_ref -> string , STRING ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v s_software_menu , ( VOID *p ) & s_ref_list [ SOFTWARE_MENU ] ) 
&v s_opengl_menu , ( VOID *p ) & s_ref_list [ OPENGL_MENU ] ) 
&v s_software_menu , ( VOID *p ) & s_defaults_action [ SOFTWARE_MENU ] ) 
&v s_software_menu ) 
s_current_menu_index == INT_CONST ) 
s_current_menu , INT_CONST ) 
s_current_menu ) 
key ) 
m , INT_CONST ) 
m , -v INT_CONST ) 
m , INT_CONST ) 
m ) 
__E__O__F__
print_level == PRINT_ALL ) 
err_level , STRING , msg ) 
&v re , INT_CONST , SIZEOF ( re ) ) 
STRING , name ) 
saved_euid ) 
( fp = fopen ( SO_FILE , STRING ) ) == NULL ) 
strstr ( fn , STRING ) == NULL ) 
stat ( fn , &v st ) == -v INT_CONST ) 
( reflib_library = dlopen ( fn , RTLD_NOW ) ) == INT_CONST ) 
( GetRefAPI = ( VOID *p ) dlsym ( reflib_library , STRING ) ) == INT_CONST ) 
re . api_version != API_VERSION ) 
( RW_IN_Init_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Shutdown_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Activate_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Commands_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Move_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( RW_IN_Frame_fp = dlsym ( reflib_library , STRING ) ) == NULL ) 
re . Init ( INT_CONST , INT_CONST ) == -v INT_CONST ) 
( KBD_Init_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( KBD_Update_fp = dlsym ( reflib_library , STRING ) ) == NULL || NEW_LINE ( KBD_Close_fp = dlsym ( reflib_library , STRING ) ) == NULL ) 
getuid ( ) , getuid ( ) ) 
STRING ) 
vid_ref -> modified ) 
vid_ref -> modified ) 
getenv ( STRING ) ) 
STRING , VID_Restart_f ) 
STRING ) 
__E__O__F__
__E__O__F__
INT_CONST ) 
__E__O__F__
__E__O__F__
__E__O__F__
__E__O__F__
__E__O__F__
STRING ) 
INT_CONST ) 
INT_CONST ) 
__E__O__F__
argptr , fmt ) 
print_level == PRINT_ALL ) 
argptr , fmt ) 
err_level , STRING , msg ) 
__E__O__F__
templen ) 
templen ) 
text ) 
text ) 
ERR_FATAL , STRING ) 
cmd_text . cursize ) 
FOR ( i = INT_CONST ; i < cmd_text . cursize ; i v++ ) 
FOR ( i = INT_CONST ; i < COM_Argc ( ) ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
s + INT_CONST ) 
FOR ( i = INT_CONST ; i < s - INT_CONST ; i v++ ) 
FOR ( j = i ; ( text [ j ] != CHAR_CONST ) && ( text [ j ] != CHAR_CONST ) && ( text [ j ] != INT_CONST ) ; j v++ ) 
build [ INT_CONST ] != INT_CONST ) 
Cmd_Argc ( ) != INT_CONST ) 
Cmd_Argv ( INT_CONST ) , ( VOID *p *p ) & f ) 
f2 ) 
f2 ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
INT_CONST ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
! a ) 
) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
scan ) 
FOR ( i = INT_CONST ; i < len ; i v++ ) 
inquote ) 
inquote ) 
FOR ( i = INT_CONST ; i < cmd_argc ; i v++ ) 
FOR ( ; l >= INT_CONST ; l v-- ) 
! text ) 
CHAR *p cmd_name , xcommand_t function ) 
Cvar_VariableString ( cmd_name ) [ INT_CONST ] ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
SIZEOF ( cmd_function_t ) ) 
INT_CONST ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
text , true ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next , i v++ ) 
__E__O__F__
VOID *p ) 
count < INT_CONST ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
count < INT_CONST ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
count > MAX_MAP_BRUSHES ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
count < INT_CONST ) 
count > MAX_MAP_PLANES ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
map_leafs [ INT_CONST ] . contents != CONTENTS_SOLID ) 
FOR ( i = INT_CONST ; i < numleafs ; i v++ ) 
count < INT_CONST ) 
count > MAX_MAP_PLANES ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
count < INT_CONST ) 
count > MAX_MAP_LEAFBRUSHES ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
count > MAX_MAP_BRUSHSIDES ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
count > MAX_MAP_AREAS ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
count > MAX_MAP_AREAS ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
l -> filelen > MAX_MAP_VISIBILITY ) 
map_vis -> numclusters ) 
FOR ( i = INT_CONST ; i < map_vis -> numclusters ; i v++ ) 
STRING , STRING , INT_CONST ) 
! strcmp ( map_name , name ) && ( clientload || ! Cvar_VariableValue ( STRING ) ) ) 
! name || ! name [ INT_CONST ] ) 
name , ( VOID *p *p ) & buf ) 
dheader_t * ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
&v header . lumps [ LUMP_TEXINFO ] ) 
buf ) 
) 
portalopen , INT_CONST , SIZEOF ( portalopen ) ) 
map_name , name ) 
! name || name [ INT_CONST ] != CHAR_CONST ) 
numnodes + INT_CONST > MAX_MAP_NODES NEW_LINE || numbrushes + INT_CONST > MAX_MAP_BRUSHES NEW_LINE || numleafbrushes + INT_CONST > MAX_MAP_LEAFBRUSHES NEW_LINE || numbrushsides + INT_CONST > MAX_MAP_BRUSHSIDES NEW_LINE || numplanes + INT_CONST > MAX_MAP_PLANES ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
num >= INT_CONST ) 
INT_CONST ) 
headnode ) 
topnode ) 
! numnodes ) 
p , headnode ) 
p , origin , p_l ) 
headnode != box_headnode && NEW_LINE ( angles [ INT_CONST ] || angles [ INT_CONST ] || angles [ INT_CONST ] ) ) 
p_l , headnode ) 
! brush -> numsides ) 
FOR ( i = INT_CONST ; i < brush -> numsides ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! startout ) 
! getout ) 
! brush -> numsides ) 
FOR ( i = INT_CONST ; i < brush -> numsides ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! ( leaf -> contents & trace_contents ) ) 
FOR ( k = INT_CONST ; k < leaf -> numleafbrushes ; k v++ ) 
! ( leaf -> contents & trace_contents ) ) 
FOR ( k = INT_CONST ; k < leaf -> numleafbrushes ; k v++ ) 
trace_trace . fraction <= p1f ) 
num < INT_CONST ) 
plane -> type < INT_CONST ) 
node -> children [ INT_CONST ] , p1f , p2f , p1 , p2 ) 
t1 >= offset && t2 >= offset ) 
t1 < t2 ) 
frac < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
frac2 < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v trace_trace , INT_CONST , SIZEOF ( trace_trace ) ) 
! numnodes ) 
start , trace_start ) 
start [ INT_CONST ] == end [ INT_CONST ] && start [ INT_CONST ] == end [ INT_CONST ] && start [ INT_CONST ] == end [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numleafs ; i v++ ) 
mins [ INT_CONST ] == INT_CONST && mins [ INT_CONST ] == INT_CONST && mins [ INT_CONST ] == INT_CONST NEW_LINE && maxs [ INT_CONST ] == INT_CONST && maxs [ INT_CONST ] == INT_CONST && maxs [ INT_CONST ] == INT_CONST ) 
headnode , INT_CONST , INT_CONST , start , end ) 
trace_trace . fraction == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
start , origin , start_l ) 
headnode != box_headnode && NEW_LINE ( angles [ INT_CONST ] || angles [ INT_CONST ] || angles [ INT_CONST ] ) ) 
start_l , end_l , mins , maxs , headnode , brushmask ) 
rotated && trace . fraction != FLOAT_CONST ) 
end [ INT_CONST ] - start [ INT_CONST ] ) 
numclusters + INT_CONST ) 
row ) 
area -> floodvalid == floodvalid ) 
FOR ( i = INT_CONST ; i < area -> numareaportals ; i v++ , p v++ ) 
FOR ( i = INT_CONST ; i < numareas ; i v++ ) 
numareas + INT_CONST ) 
map_noareas -> value ) 
buffer , INT_CONST , bytes ) 
FOR ( i = INT_CONST ; i < numareas ; i v++ ) 
nodenum < INT_CONST ) 
visbits [ cluster >> INT_CONST ] & ( INT_CONST << ( cluster & INT_CONST ) ) ) 
CM_HeadnodeVisible ( node -> children [ INT_CONST ] , visbits ) ) 
__E__O__F__
argptr , fmt ) 
rd_target ) 
msg ) 
logfile_active && logfile_active -> value ) 
recursive ) 
argptr , fmt ) 
logfile ) 
STRING , msg ) 
logfile ) 
) 
cmd -> angles [ INT_CONST ] != from -> angles [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < NUMVERTEXNORMALS ; i v++ ) 
sb ) 
! to -> number ) 
to -> number >= INT_CONST ) 
to -> effects != from -> effects ) 
to -> event ) 
! bits && ! force ) 
bits & INT_CONST ) 
bits & INT_CONST ) 
bits & U_NUMBER16 ) 
msg , to -> skinnum ) 
bits & U_SOUND ) 
move , from , SIZEOF ( *v move ) ) 
msg_read ) 
bits & CM_BUTTONS ) 
msg_read ) 
FOR ( i = INT_CONST ; i < len ; i v++ ) 
sizebuf_t * buf , CHAR *p data ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
argc > MAX_NUM_ARGVS ) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
*v s == CHAR_CONST ) 
( zhead_t * ) ptr ) 
z -> magic != Z_MAGIC ) 
z ) 
FOR ( z = z_chain . next ; z != &v z_chain ; z = next ) 
VOID *p ) 
sequence / INT_CONST ) 
length > INT_CONST ) 
sequence & INT_CONST ) 
( sequence + challenge ) / INT_CONST ) 
sequence & INT_CONST ) 
Com_BlockChecksum ( buf , length ) ) 
sequence < INT_CONST ) 
length > INT_CONST ) 
chkb , length ) 
FOR ( x = INT_CONST , n = INT_CONST ; n < length ; n v++ ) 
setjmp ( abortframe ) ) 
argc , argv ) 
) 
) 
) 
false ) 
) 
STRING ) 
true ) 
STRING , Z_Stats_f ) 
dedicated -> value ) 
) 
) 
! Cbuf_AddLateCommands ( ) ) 
! dedicated -> value ) 
) 
STRING ) 
setjmp ( abortframe ) ) 
fixedtime -> value ) 
showtrace -> value ) 
va ( STRING , s ) ) 
host_speeds -> value ) 
host_speeds -> value ) 
__E__O__F__
&v crc ) 
__E__O__F__
FOR ( var = cvar_vars ; var ; var = var -> next ) 
FOR ( cvar = cvar_vars ; cvar ; cvar = cvar -> next ) 
FOR ( cvar = cvar_vars ; cvar ; cvar = cvar -> next ) 
var_name ) 
! var_value ) 
SIZEOF ( *v var ) ) 
var_name ) 
var_name , value , INT_CONST ) 
var -> flags & ( CVAR_USERINFO | CVAR_SERVERINFO ) ) 
! force ) 
! strcmp ( value , var -> string ) ) 
var -> flags & CVAR_USERINFO ) 
var_name , value , flags ) 
var -> flags & CVAR_USERINFO ) 
value == ( INT ) value ) 
FOR ( var = cvar_vars ; var ; var = var -> next ) 
Cmd_Argv ( INT_CONST ) ) 
v -> name , Cmd_Argv ( INT_CONST ) ) 
) 
c == INT_CONST ) 
path , STRING ) 
FOR ( var = cvar_vars ; var ; var = var -> next ) 
FOR ( var = cvar_vars ; var ; var = var -> next , i v++ ) 
FOR ( var = cvar_vars ; var ; var = var -> next ) 
__E__O__F__
f ) 
FOR ( ofs = path + INT_CONST ; *v ofs ; ofs v++ ) 
who == INT_CONST ) 
FOR ( search = fs_searchpaths ; search ; search = search -> next ) 
FOR ( link = fs_links ; link ; link = link -> next ) 
FOR ( search = fs_searchpaths ; search ; search = search -> next ) 
search -> pack ) 
FOR ( i = INT_CONST ; i < pak -> numfiles ; i v++ ) 
! strcmp ( filename , STRING ) || ! strncmp ( filename , STRING , INT_CONST ) ) 
FOR ( search = fs_searchpaths ; search ; search = search -> next ) 
FOR ( i = INT_CONST ; i < pak -> numfiles ; i v++ ) 
byte * ) 
remaining ) 
path , &v h ) 
len ) 
buf , len , h ) 
h ) 
packfile , STRING ) 
dpackfile_t ) 
numpackfiles > MAX_FILES_IN_PACK ) 
packhandle , header . dirofs , SEEK_SET ) 
( VOID *p ) info , header . dirlen ) 
checksum != PAK0_CHECKSUM ) 
FOR ( i = INT_CONST ; i < numpackfiles ; i v++ ) 
SIZEOF ( pack_t ) ) 
fs_gamedir , dir ) 
SIZEOF ( searchpath_t ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
strstr ( dir , STRING ) || strstr ( dir , STRING ) NEW_LINE || strstr ( dir , STRING ) || strstr ( dir , STRING ) ) 
fs_searchpaths != fs_base_searchpaths ) 
dedicated && ! dedicated -> value ) 
! strcmp ( dir , BASEDIRNAME ) || ( *v dir == INT_CONST ) ) 
Cmd_Argc ( ) != INT_CONST ) 
FOR ( l = fs_links ; l ; l = l -> next ) 
SIZEOF ( *v l ) ) 
findname , musthave , canthave ) 
! nfiles ) 
SIZEOF ( CHAR *p ) * nfiles ) 
findname , musthave , canthave ) 
Cmd_Argc ( ) != INT_CONST ) 
( path = FS_NextPath ( path ) ) != NULL ) 
FOR ( i = INT_CONST ; i < ndirs - INT_CONST ; i v++ ) 
STRING ) 
FOR ( s = fs_searchpaths ; s ; s = s -> next ) 
STRING ) 
FOR ( l = fs_links ; l ; l = l -> next ) 
! prevpath ) 
FOR ( s = fs_searchpaths ; s ; s = s -> next ) 
STRING , STRING , CVAR_NOSET ) 
STRING , STRING , CVAR_NOSET ) 
va ( STRING BASEDIRNAME , fs_basedir -> string ) ) 
STRING , STRING , CVAR_LATCH | CVAR_SERVERINFO ) 
__E__O__F__
UNSIGNED INT ) 
( context -> count [ INT_CONST ] += ( ( UINT4 ) inputLen << INT_CONST ) ) < ( ( UINT4 ) inputLen << INT_CONST ) ) 
inputLen >= partLen ) 
FOR ( i = partLen ; i + INT_CONST < inputLen ; i += INT_CONST ) 
( POINTER ) & context -> buffer [ index ] , ( POINTER ) & input [ i ] , inputLen - i ) 
bits , context -> count , INT_CONST ) 
UNSIGNED INT ) 
context , bits , INT_CONST ) 
( POINTER ) context , INT_CONST , SIZEOF ( *v context ) ) 
x , block , INT_CONST ) 
a , b , c , d , x [ INT_CONST ] , S11 ) 
FOR ( i = INT_CONST , j = INT_CONST ; j < len ; i v++ , j += INT_CONST ) 
FOR ( i = INT_CONST , j = INT_CONST ; j < len ; i v++ , j += INT_CONST ) 
&v ctx ) 
__E__O__F__
) 
STRING , STRING , INT_CONST ) 
&v send , send_buf , SIZEOF ( send_buf ) ) 
net_socket , send . cursize , send . data , adr ) 
net_socket , adr , strlen ( string ) , ( byte * ) string ) 
&v chan -> message , chan -> message_buf , SIZEOF ( chan -> message_buf ) ) 
chan -> incoming_acknowledged > chan -> last_reliable_sequence NEW_LINE && chan -> incoming_reliable_acknowledged != chan -> reliable_sequence ) 
chan -> message . overflowed ) 
chan ) 
! chan -> reliable_length && chan -> message . cursize ) 
&v send , send_buf , SIZEOF ( send_buf ) ) 
chan -> outgoing_sequence & ~ ( INT_CONST << INT_CONST ) ) 
&v send , w1 ) 
chan -> sock == NS_CLIENT ) 
send . maxsize - send . cursize >= length ) 
showpackets -> value ) 
msg ) 
chan -> sock == NS_SERVER ) 
INT_CONST << INT_CONST ) 
showpackets -> value ) 
sequence <= chan -> incoming_sequence ) 
chan -> incoming_sequence + INT_CONST ) 
reliable_ack == chan -> reliable_sequence ) 
reliable_message ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( bumpcount = INT_CONST ; bumpcount < numbumps ; bumpcount v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
numplanes == INT_CONST ) 
FOR ( i = INT_CONST ; i < numplanes ; i v++ ) 
FOR ( j = INT_CONST ; j < numplanes ; j v++ ) 
pm -> s . pm_time ) 
pml . origin , start_o ) 
) 
pml . origin , down_o ) 
start_o , up ) 
up , pm -> mins , pm -> maxs , up ) 
up , pml . origin ) 
) 
pml . origin , down ) 
pml . origin , up , delta ) 
down_o , start_o , delta ) 
down_o [ INT_CONST ] - start_o [ INT_CONST ] ) 
( pm -> groundentity && pml . groundsurface && ! ( pml . groundsurface -> flags & SURF_SLICK ) ) || ( pml . ladder ) ) 
pm -> waterlevel && ! pml . ladder ) 
pml . velocity , wishdir ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pml . ladder && fabs ( pml . velocity [ INT_CONST ] ) <= INT_CONST ) 
pm -> watertype & MASK_CURRENT ) 
pm -> groundentity ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
wishvel , wishdir ) 
wishspeed > pm_maxspeed ) 
wishdir , wishspeed , pm_wateraccelerate ) 
) 
pml . forward ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
wishvel ) 
wishvel , wishdir ) 
pm -> s . pm_flags & PMF_DUCKED ) 
wishspeed > maxspeed ) 
wishdir , wishspeed , pm_accelerate ) 
pm_airaccelerate ) 
pml . velocity [ INT_CONST ] > INT_CONST ) 
point ) 
pm -> cmd . upmove < INT_CONST ) 
pm -> s . pm_flags & PMF_JUMP_HELD ) 
pml . velocity [ INT_CONST ] <= -v INT_CONST ) 
pm -> groundentity == NULL ) 
pml . velocity [ INT_CONST ] < INT_CONST ) 
pm -> s . pm_time ) 
flatforward ) 
pml . origin , INT_CONST , flatforward , spot ) 
pm -> waterlevel != INT_CONST ) 
flatforward , INT_CONST , pml . velocity ) 
pml . velocity ) 
pml . velocity , newspeed , pml . velocity ) 
pml . forward ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
wishvel , wishdir ) 
wishspeed > pm_maxspeed ) 
pml . velocity , wishdir ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pm -> s . pm_type == PM_GIB ) 
pm -> s . pm_type == PM_DEAD ) 
pm -> s . pm_flags & PMF_DUCKED ) 
pm -> s . pm_flags & PMF_DUCKED ) 
! pm -> groundentity ) 
pml . velocity ) 
pm -> s . pm_type == PM_SPECTATOR ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pml . previous_origin , pm -> s . origin ) 
pm -> s . origin , base ) 
FOR ( z = INT_CONST ; z >= -v INT_CONST ; z v-- ) 
FOR ( y = INT_CONST ; y >= -v INT_CONST ; y v-- ) 
FOR ( x = INT_CONST ; x >= -v INT_CONST ; x v-- ) 
STRING ) 
pm -> s . origin , base ) 
FOR ( z = INT_CONST ; z < INT_CONST ; z v++ ) 
FOR ( y = INT_CONST ; y < INT_CONST ; y v++ ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
STRING ) 
pm -> s . pm_flags & PMF_TIME_TELEPORT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pm -> viewangles ) 
&v pml , INT_CONST , SIZEOF ( pml ) ) 
pm -> s . origin , pml . previous_origin ) 
) 
pm -> s . pm_type == PM_SPECTATOR ) 
pm -> s . pm_type >= PM_DEAD ) 
pm -> s . pm_type == PM_FREEZE ) 
) 
pm -> snapinitial ) 
) 
pm -> s . pm_type == PM_DEAD ) 
pm -> s . pm_time ) 
pm -> s . pm_flags & PMF_TIME_TELEPORT ) 
pml . velocity [ INT_CONST ] < INT_CONST ) 
pm -> viewangles , angles ) 
) 
) 
__E__O__F__
STRING , it_pic ) 
( num & INT_CONST ) == INT_CONST ) 
draw_chars -> texnum ) 
GL_QUADS ) 
name [ INT_CONST ] != CHAR_CONST && name [ INT_CONST ] != CHAR_CONST ) 
pic ) 
pic ) 
scrap_dirty ) 
( ( gl_config . renderer == GL_RENDERER_MCD ) || ( gl_config . renderer & GL_RENDERER_RENDITION ) ) && ! gl -> has_alpha ) 
pic ) 
( ( gl_config . renderer == GL_RENDERER_MCD ) || ( gl_config . renderer & GL_RENDERER_RENDITION ) ) && ! gl -> has_alpha ) 
pic ) 
( ( gl_config . renderer == GL_RENDERER_MCD ) || ( gl_config . renderer & GL_RENDERER_RENDITION ) ) && ! image -> has_alpha ) 
( ( gl_config . renderer == GL_RENDERER_MCD ) || ( gl_config . renderer & GL_RENDERER_RENDITION ) ) && ! image -> has_alpha ) 
( UNSIGNED ) c > INT_CONST ) 
color . v [ INT_CONST ] / FLOAT_CONST , NEW_LINE color . v [ INT_CONST ] / FLOAT_CONST , NEW_LINE color . v [ INT_CONST ] / FLOAT_CONST ) 
x , y ) 
) 
INT_CONST , INT_CONST ) 
) 
INT_CONST ) 
rows <= INT_CONST ) 
! qglColorTableEXT ) 
FOR ( i = INT_CONST ; i < trows ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < trows ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
( gl_config . renderer == GL_RENDERER_MCD ) || ( gl_config . renderer & GL_RENDERER_RENDITION ) ) 
( gl_config . renderer == GL_RENDERER_MCD ) || ( gl_config . renderer & GL_RENDERER_RENDITION ) ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
qglColorTableEXT && gl_ext_palettedtexture -> value ) 
! qglSelectTextureSGIS ) 
tmu == INT_CONST ) 
mode != lastmodes [ gl_state . currenttmu ] ) 
gl_nobind -> value && draw_chars ) 
gl_state . currenttextures [ gl_state . currenttmu ] == texnum ) 
FOR ( i = INT_CONST ; i < NUM_GL_MODES ; i v++ ) 
i == NUM_GL_MODES ) 
FOR ( i = INT_CONST , glt = gltextures ; i < numgltextures ; i v++ , glt v++ ) 
FOR ( i = INT_CONST ; i < NUM_GL_ALPHA_MODES ; i v++ ) 
i == NUM_GL_ALPHA_MODES ) 
FOR ( i = INT_CONST ; i < NUM_GL_SOLID_MODES ; i v++ ) 
i == NUM_GL_SOLID_MODES ) 
PRINT_ALL , STRING ) 
FOR ( i = INT_CONST , image = gltextures ; i < numgltextures ; i v++ , image v++ ) 
FOR ( texnum = INT_CONST ; texnum < MAX_SCRAPS ; texnum v++ ) 
FOR ( i = INT_CONST ; i < BLOCK_WIDTH - w ; i v++ ) 
FOR ( j = INT_CONST ; j < w ; j v++ ) 
FOR ( i = INT_CONST ; i < w ; i v++ ) 
filename , ( VOID *p *p ) & raw ) 
pcx_t * ) 
pcx -> xmin ) 
pcx -> manufacturer != INT_CONST NEW_LINE || pcx -> version != INT_CONST NEW_LINE || pcx -> encoding != INT_CONST NEW_LINE || pcx -> bits_per_pixel != INT_CONST NEW_LINE || pcx -> xmax >= INT_CONST NEW_LINE || pcx -> ymax >= INT_CONST ) 
( pcx -> ymax + INT_CONST ) * ( pcx -> xmax + INT_CONST ) ) 
palette ) 
width ) 
FOR ( y = INT_CONST ; y <= pcx -> ymax ; y v++ , pix += pcx -> xmax + INT_CONST ) 
FOR ( x = INT_CONST ; x <= pcx -> xmax ; ) 
raw - ( byte * ) pcx > len ) 
pcx ) 
name , ( VOID *p *p ) & buffer ) 
*v ( ( SHORT *p ) tmp ) ) 
targa_header . image_type != INT_CONST NEW_LINE && targa_header . image_type != INT_CONST ) 
width ) 
targa_header . id_length != INT_CONST ) 
FOR ( row = rows - INT_CONST ; row >= INT_CONST ; row v-- ) 
FOR ( column = INT_CONST ; column < columns ; column v++ ) 
FOR ( row = rows - INT_CONST ; row >= INT_CONST ; row v-- ) 
FOR ( column = INT_CONST ; column < columns ; ) 
FOR ( j = INT_CONST ; j < packetSize ; j v++ ) 
FOR ( j = INT_CONST ; j < packetSize ; j v++ ) 
targa_header . pixel_size ) 
buffer ) 
filledcolor == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; ++v i ) 
( fillcolor == filledcolor ) || ( fillcolor == INT_CONST ) ) 
inpt + INT_CONST ) 
outpt != inpt ) 
FOR ( i = INT_CONST ; i < outwidth ; i v++ ) 
FOR ( i = INT_CONST ; i < outwidth ; i v++ ) 
FOR ( i = INT_CONST ; i < outheight ; i v++ , out += outwidth ) 
FOR ( j = INT_CONST ; j < outwidth ; j v++ ) 
FOR ( i = INT_CONST ; i < c ; i v++ , p += INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i v++ , p += INT_CONST ) 
FOR ( i = INT_CONST ; i < height ; i v++ , in += width ) 
FOR ( j = INT_CONST ; j < width ; j += INT_CONST , out += INT_CONST , in += INT_CONST ) 
FOR ( i = INT_CONST ; i < scaled_width * scaled_height ; i v++ ) 
FOR ( scaled_width = INT_CONST ; scaled_width < width ; scaled_width <<= INT_CONST ) 
FOR ( scaled_height = INT_CONST ; scaled_height < height ; scaled_height <<= INT_CONST ) 
mipmap ) 
scaled_width > INT_CONST ) 
scaled_width * scaled_height > SIZEOF ( scaled ) / INT_CONST ) 
( byte * ) data ) 
FOR ( i = INT_CONST ; i < c ; i v++ , scan += INT_CONST ) 
samples == gl_solid_format ) 
mipmap ) 
qglColorTableEXT && gl_ext_palettedtexture -> value && ( samples == gl_solid_format ) ) 
mipmap ) 
samples == gl_alpha_format ) 
s > SIZEOF ( trans ) / INT_CONST ) 
FOR ( i = INT_CONST ; i < s ; i v++ ) 
FOR ( i = INT_CONST , image = gltextures ; i < numgltextures ; i v++ , image v++ ) 
strlen ( name ) >= SIZEOF ( image -> name ) ) 
type == it_skin && bits == INT_CONST ) 
image -> type == it_pic && bits == INT_CONST NEW_LINE && image -> width < INT_CONST && image -> height < INT_CONST ) 
FOR ( i = INT_CONST ; i < image -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < image -> width ; j v++ , k v++ ) 
name , ( VOID *p *p ) & mt ) 
mt -> width ) 
name , ( byte * ) mt + ofs , width , height , it_wall , INT_CONST ) 
( VOID *p ) mt ) 
! name ) 
FOR ( i = INT_CONST , image = gltextures ; i < numgltextures ; i v++ , image v++ ) 
! strcmp ( name + len - INT_CONST , STRING ) ) 
FOR ( i = INT_CONST , image = gltextures ; i < numgltextures ; i v++ , image v++ ) 
STRING , &v pic , &v pal , &v width , &v height ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST ) 
pic ) 
STRING , STRING , INT_CONST ) 
intensity -> value <= INT_CONST ) 
) 
qglColorTableEXT ) 
gl_config . renderer & ( GL_RENDERER_VOODOO | GL_RENDERER_VOODOO2 ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST , image = gltextures ; i < numgltextures ; i v++ , image v++ ) 
__E__O__F__
light -> origin , r_origin , v ) 
VectorLength ( v ) < rad ) 
light -> color [ INT_CONST ] , light -> color [ INT_CONST ] , light -> color [ INT_CONST ] , light -> intensity * FLOAT_CONST , v_blend ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i >= INT_CONST ; i v-- ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
v ) 
! gl_flashblend -> value ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < r_newrefdef . num_dlights ; i v++ , l v++ ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
light , bit , node -> children [ INT_CONST ] ) 
gl_flashblend -> value ) 
FOR ( i = INT_CONST ; i < r_newrefdef . num_dlights ; i v++ , l v++ ) 
node -> contents != -v INT_CONST ) 
start , plane -> normal ) 
node -> children [ side ] , start , mid ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
dt * ( ( surf -> extents [ INT_CONST ] >> INT_CONST ) + INT_CONST ) + ds ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
node -> children [ ! side ] , mid , end ) 
FOR ( lnum = INT_CONST ; lnum < r_newrefdef . num_dlights ; lnum v++ , dl v++ ) 
color , gl_modulate -> value , color ) 
surf -> extents [ INT_CONST ] >> INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < r_newrefdef . num_dlights ; lnum v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( t = INT_CONST , ftacc = INT_CONST ; t < tmax ; t v++ , ftacc += INT_CONST ) 
FOR ( s = INT_CONST , fsacc = INT_CONST ; s < smax ; s v++ , fsacc += INT_CONST , pfBL += INT_CONST ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
surf -> texinfo -> flags & ( SURF_SKY | SURF_TRANS33 | SURF_TRANS66 | SURF_WARP ) ) 
FOR ( i = INT_CONST ; i < size * INT_CONST ; i v++ ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( nummaps = INT_CONST ; nummaps < MAXLIGHTMAPS && surf -> styles [ nummaps ] != INT_CONST ; NEW_LINE nummaps v++ ) 
nummaps == INT_CONST ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ , bl += INT_CONST ) 
FOR ( i = INT_CONST ; i < size ; i v++ , bl += INT_CONST ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ , bl += INT_CONST ) 
FOR ( i = INT_CONST ; i < size ; i v++ , bl += INT_CONST ) 
surf -> dlightframe == r_framecount ) 
monolightmap == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < tmax ; i v++ , dest += stride ) 
FOR ( j = INT_CONST ; j < smax ; j v++ ) 
bl [ INT_CONST ] ) 
r < INT_CONST ) 
FOR ( i = INT_CONST ; i < tmax ; i v++ , dest += stride ) 
FOR ( j = INT_CONST ; j < smax ; j v++ ) 
bl [ INT_CONST ] ) 
r < INT_CONST ) 
__E__O__F__
currententity -> flags & ( RF_SHELL_RED | RF_SHELL_GREEN | RF_SHELL_BLUE | RF_SHELL_DOUBLE | RF_SHELL_HALF_DAM ) ) 
FOR ( i = INT_CONST ; i < nverts ; i v++ , v v++ , ov v++ , lerp += INT_CONST ) 
FOR ( i = INT_CONST ; i < nverts ; i v++ , v v++ , ov v++ , lerp += INT_CONST ) 
daliasframe_t * ) 
daliasframe_t * ) 
INT *p ) 
currententity -> flags & RF_TRANSLUCENT ) 
currententity -> flags & ( RF_SHELL_RED | RF_SHELL_GREEN | RF_SHELL_BLUE | RF_SHELL_DOUBLE | RF_SHELL_HALF_DAM ) ) 
currententity -> oldorigin , currententity -> origin , delta ) 
delta , vectors [ INT_CONST ] ) 
delta , vectors [ INT_CONST ] ) 
delta , vectors [ INT_CONST ] ) 
move , oldframe -> translate , move ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
paliashdr -> num_xyz , v , ov , verts , lerp , move , frontv , backv ) 
gl_vertex_arrays -> value ) 
FOR ( i = INT_CONST ; i < paliashdr -> num_xyz ; i v++ ) 
currententity -> flags & ( RF_SHELL_RED | RF_SHELL_GREEN | RF_SHELL_BLUE | RF_SHELL_DOUBLE | RF_SHELL_HALF_DAM ) ) 
daliasframe_t * ) 
INT *p ) 
INT_CONST ) 
dmdl_t * ) 
( e -> frame >= paliashdr -> num_frames ) || ( e -> frame < INT_CONST ) ) 
daliasframe_t * ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
e -> angles , angles ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( p = INT_CONST ; p < INT_CONST ; p v++ ) 
FOR ( f = INT_CONST ; f < INT_CONST ; f v++ ) 
! ( e -> flags & RF_WEAPONMODEL ) ) 
e -> flags & RF_WEAPONMODEL ) 
dmdl_t * ) 
currententity -> flags & ( RF_SHELL_HALF_DAM | RF_SHELL_GREEN | RF_SHELL_RED | RF_SHELL_BLUE | RF_SHELL_DOUBLE ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
currententity -> flags & ( RF_SHELL_BLUE | RF_SHELL_DOUBLE ) ) 
currententity -> flags & RF_FULLBRIGHT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
currententity -> flags & RF_MINLIGHT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
currententity -> flags & RF_GLOW ) 
r_newrefdef . time * INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
r_newrefdef . rdflags & RDF_IRGOGGLES && currententity -> flags & RF_IR_VISIBLE ) 
currententity -> flags & RF_DEPTHHACK ) 
gldepthmin , gldepthmin + FLOAT_CONST * ( gldepthmax - gldepthmin ) ) 
) 
e ) 
currententity -> skin ) 
GL_SMOOTH ) 
GL_MODULATE ) 
( currententity -> frame >= paliashdr -> num_frames ) NEW_LINE || ( currententity -> frame < INT_CONST ) ) 
( currententity -> oldframe >= paliashdr -> num_frames ) NEW_LINE || ( currententity -> oldframe < INT_CONST ) ) 
! r_lerpmodels -> value ) 
GL_REPLACE ) 
) 
GL_CULL_FACE ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
currententity -> flags & RF_TRANSLUCENT ) 
currententity -> flags & RF_DEPTHHACK ) 
__E__O__F__
model -> vis -> numclusters + INT_CONST ) 
row ) 
PRINT_ALL , STRING ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
name [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
mod -> name , &v buf ) 
LittleLong ( *v ( UNSIGNED *p ) buf ) ) 
INT_CONST ) 
INT_CONST ) 
ERR_DROP , STRING , mod -> name ) 
) 
buf ) 
! l -> filelen ) 
FOR ( i = INT_CONST ; i < loadmodel -> vis -> numclusters ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
corner ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( step = out -> next ; step && step != out ; step = step -> next ) 
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
loadmodel ) 
FOR ( surfnum = INT_CONST ; surfnum < count ; surfnum v++ , in v++ , out v++ ) 
in -> planenum ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < out -> nummarksurfaces ; j v++ ) 
FOR ( poly = out -> firstmarksurface [ j ] -> polys ; poly ; poly = poly -> next ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
header -> version ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < mod -> numsubmodels ; i v++ ) 
dmdl_t * ) 
pinmodel -> version ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dmdl_t ) / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < pheader -> num_st ; i v++ ) 
dtriangle_t * ) 
FOR ( i = INT_CONST ; i < pheader -> num_tris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < pheader -> num_frames ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
INT *p ) 
FOR ( i = INT_CONST ; i < pheader -> num_glcmds ; i v++ ) 
( CHAR *p ) pheader + pheader -> ofs_skins , ( CHAR *p ) pinmodel + pheader -> ofs_skins , NEW_LINE pheader -> num_skins * MAX_SKINNAME ) 
FOR ( i = INT_CONST ; i < pheader -> num_skins ; i v++ ) 
dsprite_t * ) 
sprin -> ident ) 
sprout -> version != SPRITE_VERSION ) 
FOR ( i = INT_CONST ; i < sprout -> numframes ; i v++ ) 
fullname , SIZEOF ( fullname ) , STRING , model ) 
STRING , STRING , INT_CONST ) 
name , false ) 
FOR ( i = INT_CONST ; i < sprout -> numframes ; i v++ ) 
FOR ( i = INT_CONST ; i < pheader -> num_skins ; i v++ ) 
FOR ( i = INT_CONST ; i < mod -> numtexinfo ; i v++ ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
) 
FOR ( i = INT_CONST ; i < mod_numknown ; i v++ ) 
__E__O__F__
r_nocull -> value ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
dsprite_t * ) 
e -> frame < INT_CONST || e -> frame >= psprite -> numframes ) 
psprite -> type == SPR_ORIENTED ) 
currententity -> angles , v_forward , v_right , v_up ) 
e -> flags & RF_TRANSLUCENT ) 
currentmodel -> skins [ e -> frame ] -> texnum ) 
alpha == FLOAT_CONST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
alpha != FLOAT_CONST ) 
currententity -> flags & RF_FULLBRIGHT ) 
GL_TEXTURE_2D ) 
GL_TRIANGLE_FAN ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
GL_TRIANGLE_FAN ) 
FOR ( i = INT_CONST ; i >= INT_CONST ; i v-- ) 
INT_CONST , INT_CONST , INT_CONST ) 
! r_drawentities -> value ) 
FOR ( i = INT_CONST ; i < r_newrefdef . num_entities ; i v++ ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < r_newrefdef . num_entities ; i v++ ) 
r_particletexture -> texnum ) 
GL_BLEND ) 
vup , FLOAT_CONST , up ) 
FOR ( p = particles , i = INT_CONST ; i < num_particles ; i v++ , p v++ ) 
FLOAT_CONST , FLOAT_CONST ) 
) 
GL_REPLACE ) 
GL_FALSE ) 
FOR ( i = INT_CONST , p = r_newrefdef . particles ; i < r_newrefdef . num_particles ; i v++ , p v++ ) 
) 
-v INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_QUADS ) 
INT_CONST , INT_CONST , INT_CONST ) 
GL_BLEND ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
vpn , vright , frustum [ INT_CONST ] . normal ) 
frustum [ INT_CONST ] . normal ) 
frustum [ INT_CONST ] . normal , vup , vpn , -v ( INT_CONST - r_newrefdef . fov_x / INT_CONST ) ) 
frustum [ INT_CONST ] . normal , vup , vpn , INT_CONST - r_newrefdef . fov_x / INT_CONST ) 
frustum [ INT_CONST ] . normal , vright , vpn , INT_CONST - r_newrefdef . fov_y / INT_CONST ) 
frustum [ INT_CONST ] . normal , vright , vpn , -v ( INT_CONST - r_newrefdef . fov_y / INT_CONST ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
r_newrefdef . vieworg , r_origin ) 
r_newrefdef . viewangles , vpn , vright , vup ) 
! ( r_newrefdef . rdflags & RDF_NOWORLDMODEL ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
r_newrefdef . rdflags & RDF_NOWORLDMODEL ) 
r_newrefdef . x * vid . width / vid . width ) 
x , y2 , w , h ) 
FLOAT ) 
GL_MODELVIEW ) 
gl_cull -> value ) 
gldepthmin , gldepthmax ) 
! r_worldmodel && ! ( r_newrefdef . rdflags & RDF_NOWORLDMODEL ) ) 
) 
gl_finish -> value ) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
r_speeds -> value ) 
INT_CONST , INT_CONST , vid . width , vid . height ) 
! ( gl_config . renderer & GL_RENDERER_INTERGRAPH ) ) 
GL_BACK_LEFT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
r_newrefdef . rdflags & RDF_NOWORLDMODEL ) 
r_newrefdef . vieworg , shadelight ) 
shadelight [ INT_CONST ] > shadelight [ INT_CONST ] ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , GL_ImageList_f ) 
vid_fullscreen -> modified && ! gl_config . allow_cds ) 
( err = GLimp_SetMode ( &v vid . width , &v vid . height , gl_mode -> value , fullscreen ) ) == rserr_ok ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
PRINT_ALL , STRING REF_VERSION STRING ) 
) 
) 
! QGL_Init ( gl_driver -> string ) ) 
! GLimp_Init ( hinstance , hWnd ) ) 
! R_SetMode ( ) ) 
) 
GL_VENDOR ) 
renderer_buffer , gl_config . renderer_string ) 
vendor_buffer , gl_config . vendor_string ) 
strstr ( renderer_buffer , STRING ) ) 
gl_config . renderer & GL_RENDERER_POWERVR ) 
gl_config . renderer == GL_RENDERER_MCD ) 
gl_config . renderer & GL_RENDERER_3DLABS ) 
gl_config . allow_cds ) 
strstr ( gl_config . extensions_string , STRING ) ) 
strstr ( gl_config . extensions_string , STRING ) ) 
strstr ( gl_config . extensions_string , STRING ) && NEW_LINE strstr ( gl_config . extensions_string , STRING ) ) 
strstr ( gl_config . extensions_string , STRING ) ) 
) 
) 
) 
) 
) 
) 
gl_mode -> modified || vid_fullscreen -> modified ) 
STRING , STRING , INT_CONST ) 
gl_log -> modified ) 
gl_log -> value ) 
vid_gamma -> modified ) 
camera_separation ) 
INT_CONST , INT_CONST , vid . width , vid . height ) 
gl_drawbuffer -> modified ) 
gl_texturemode -> modified ) 
gl_texturealphamode -> modified ) 
gl_texturesolidmode -> modified ) 
) 
) 
byte * ) 
palette ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
VectorNormalize ( normalized_direction ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
GL_TEXTURE_2D ) 
d_8to24table [ e -> skinnum & INT_CONST ] ) 
r , g , b , e -> alpha ) 
GL_TRIANGLE_STRIP ) 
FOR ( i = INT_CONST ; i < NUM_BEAM_SEGS ; i v++ ) 
GL_TEXTURE_2D ) 
) 
argptr , error ) 
ERR_FATAL , STRING , text ) 
argptr , fmt ) 
PRINT_ALL , STRING , text ) 
__E__O__F__
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y < INT_CONST ; y v++ ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y < INT_CONST ; y v++ ) 
checkname , SIZEOF ( checkname ) , STRING , ri . FS_Gamedir ( ) ) 
picname , STRING ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
INT_CONST , INT_CONST , vid . width , vid . height , GL_RGB , GL_UNSIGNED_BYTE , buffer + INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i += INT_CONST ) 
checkname , STRING ) 
buffer ) 
GL_ALPHA_TEST ) 
GL_DEPTH_TEST ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
gl_texturemode -> string ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , gl_filter_min ) 
GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_REPEAT ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_REPLACE ) 
qglPointParameterfEXT ) 
qglColorTableEXT && gl_ext_palettedtexture -> value ) 
) 
__E__O__F__
! tex -> next ) 
glpoly_t * ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE , nv += VERTEXSIZE ) 
p ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
p ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
GL_POLYGON ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
( r_newrefdef . time / FLOAT_CONST ) - ( INT ) ( r_newrefdef . time / FLOAT_CONST ) ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
! gl_showtris -> value ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTMAPS ; i v++ ) 
FOR ( surf = gl_lms . lightmap_surfaces [ i ] ; surf != INT_CONST ; surf = surf -> lightmapchain ) 
FOR ( ; p ; p = p -> chain ) 
FOR ( j = INT_CONST ; j < p -> numverts ; j v++ ) 
p -> verts [ j - INT_CONST ] ) 
p -> verts [ INT_CONST ] ) 
) 
GL_DEPTH_TEST ) 
FOR ( ; p != INT_CONST ; p = p -> chain ) 
FOR ( j = INT_CONST ; j < p -> numverts ; j v++ , v += VERTEXSIZE ) 
FOR ( ; p != INT_CONST ; p = p -> chain ) 
FOR ( j = INT_CONST ; j < p -> numverts ; j v++ , v += VERTEXSIZE ) 
r_fullbright -> value ) 
INT_CONST ) 
! gl_lightmap -> value ) 
currentmodel == r_worldmodel ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTMAPS ; i v++ ) 
FOR ( surf = gl_lms . lightmap_surfaces [ i ] ; surf != INT_CONST ; surf = surf -> lightmapchain ) 
gl_dynamic -> value ) 
FOR ( surf = gl_lms . lightmap_surfaces [ INT_CONST ] ; surf != INT_CONST ; surf = surf -> lightmapchain ) 
FOR ( drawsurf = newdrawsurf ; drawsurf != surf ; drawsurf = drawsurf -> lightmapchain ) 
( drawsurf -> light_s - drawsurf -> dlight_s ) * ( FLOAT_CONST / FLOAT_CONST ) , NEW_LINE ( drawsurf -> light_t - drawsurf -> dlight_t ) * ( FLOAT_CONST / FLOAT_CONST ) ) 
FOR ( surf = newdrawsurf ; surf != INT_CONST ; surf = surf -> lightmapchain ) 
GL_BLEND ) 
fa -> texinfo ) 
fa -> flags & SURF_DRAWTURB ) 
FLOAT_CONST ) 
fa -> texinfo -> flags & SURF_FLOWING ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && fa -> styles [ maps ] != INT_CONST ; maps v++ ) 
( fa -> dlightframe == r_framecount ) ) 
is_dynamic ) 
r_world_matrix ) 
FOR ( s = r_alpha_surfaces ; s ; s = s -> texturechain ) 
GL_REPLACE ) 
! qglSelectTextureSGIS ) 
FOR ( i = INT_CONST , image = gltextures ; i < numgltextures ; i v++ , image v++ ) 
FOR ( ; s ; s = s -> texturechain ) 
FOR ( i = INT_CONST , image = gltextures ; i < numgltextures ; i v++ , image v++ ) 
FOR ( s = image -> texturechain ; s ; s = s -> texturechain ) 
FOR ( i = INT_CONST , image = gltextures ; i < numgltextures ; i v++ , image v++ ) 
FOR ( ; s ; s = s -> texturechain ) 
GL_REPLACE ) 
FOR ( map = INT_CONST ; map < MAXLIGHTMAPS && surf -> styles [ map ] != INT_CONST ; map v++ ) 
( surf -> dlightframe == r_framecount ) ) 
is_dynamic ) 
( r_newrefdef . time / FLOAT_CONST ) - ( INT ) ( r_newrefdef . time / FLOAT_CONST ) ) 
FOR ( p = surf -> polys ; p ; p = p -> chain ) 
FOR ( i = INT_CONST ; i < nv ; i v++ , v += VERTEXSIZE ) 
FOR ( p = surf -> polys ; p ; p = p -> chain ) 
FOR ( i = INT_CONST ; i < nv ; i v++ , v += VERTEXSIZE ) 
( r_newrefdef . time / FLOAT_CONST ) - ( INT ) ( r_newrefdef . time / FLOAT_CONST ) ) 
FOR ( p = surf -> polys ; p ; p = p -> chain ) 
FOR ( i = INT_CONST ; i < nv ; i v++ , v += VERTEXSIZE ) 
FOR ( p = surf -> polys ; p ; p = p -> chain ) 
FOR ( i = INT_CONST ; i < nv ; i v++ , v += VERTEXSIZE ) 
! gl_flashblend -> value ) 
FOR ( k = INT_CONST ; k < r_newrefdef . num_dlights ; k v++ , lt v++ ) 
currententity -> flags & RF_TRANSLUCENT ) 
FOR ( i = INT_CONST ; i < currentmodel -> nummodelsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
! ( currententity -> flags & RF_TRANSLUCENT ) ) 
currentmodel -> nummodelsurfaces == INT_CONST ) 
e -> angles [ INT_CONST ] || e -> angles [ INT_CONST ] || e -> angles [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
R_CullBox ( mins , maxs ) ) 
r_newrefdef . vieworg , e -> origin , modelorg ) 
) 
) 
) 
node -> contents == CONTENTS_SOLID ) 
node -> contents != -v INT_CONST ) 
plane -> type ) 
modelorg , plane -> normal ) 
dot >= INT_CONST ) 
node -> children [ side ] ) 
FOR ( c = node -> numsurfaces , surf = r_worldmodel -> surfaces + node -> firstsurface ; c ; c v-- , surf v++ ) 
node -> children [ ! side ] ) 
! r_drawworld -> value ) 
r_newrefdef . vieworg , modelorg ) 
&v ent , INT_CONST , SIZEOF ( ent ) ) 
INT_CONST , INT_CONST , INT_CONST ) 
qglMTexCoord2fSGIS ) 
) 
r_oldviewcluster == r_viewcluster && r_oldviewcluster2 == r_viewcluster2 && ! r_novis -> value && r_viewcluster != -v INT_CONST ) 
gl_lockpvs -> value ) 
r_novis -> value || r_viewcluster == -v INT_CONST || ! r_worldmodel -> vis ) 
FOR ( i = INT_CONST ; i < r_worldmodel -> numleafs ; i v++ ) 
FOR ( i = INT_CONST ; i < r_worldmodel -> numnodes ; i v++ ) 
r_viewcluster , r_worldmodel ) 
r_viewcluster2 != r_viewcluster ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( i = INT_CONST , leaf = r_worldmodel -> leafs ; i < r_worldmodel -> numleafs ; i v++ , leaf v++ ) 
FOR ( i = INT_CONST ; i < r_worldmodel -> vis -> numclusters ; i v++ ) 
dynamic ) 
gl_state . lightmap_textures + texture ) 
dynamic ) 
FOR ( i = INT_CONST ; i < BLOCK_WIDTH ; i v++ ) 
INT_CONST , NEW_LINE GL_LIGHTMAP_FORMAT , NEW_LINE GL_UNSIGNED_BYTE , NEW_LINE gl_lms . lightmap_buffer ) 
FOR ( i = INT_CONST ; i < BLOCK_WIDTH - w ; i v++ ) 
FOR ( j = INT_CONST ; j < w ; j v++ ) 
best + h > BLOCK_HEIGHT ) 
FOR ( i = INT_CONST ; i < w ; i v++ ) 
total ) 
SIZEOF ( glpoly_t ) + ( lnumverts - INT_CONST ) * VERTEXSIZE * SIZEOF ( FLOAT ) ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
surf -> flags & ( SURF_DRAWSKY | SURF_DRAWTURB ) ) 
! LM_AllocBlock ( smax , tmax , &v surf -> light_s , &v surf -> light_t ) ) 
surf -> light_t * BLOCK_WIDTH + surf -> light_s ) 
surf ) 
gl_lms . allocated , INT_CONST , SIZEOF ( gl_lms . allocated ) ) 
true ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTSTYLES ; i v++ ) 
! gl_state . lightmap_textures ) 
toupper ( gl_monolightmap -> string [ INT_CONST ] ) == CHAR_CONST ) 
gl_state . lightmap_textures + INT_CONST ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numverts ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ , v v++ ) 
numverts > INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < numverts ; j v++ , v += INT_CONST ) 
FOR ( j = INT_CONST ; j < numverts ; j v++ , v += INT_CONST ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
SIZEOF ( glpoly_t ) + ( ( numverts - INT_CONST ) + INT_CONST ) * VERTEXSIZE * SIZEOF ( FLOAT ) ) 
FOR ( i = INT_CONST ; i < numverts ; i v++ , verts += INT_CONST ) 
total , ( FLOAT_CONST / numverts ) , poly -> verts [ INT_CONST ] ) 
poly -> verts [ i + INT_CONST ] , poly -> verts [ INT_CONST ] , SIZEOF ( poly -> verts [ INT_CONST ] ) ) 
FOR ( i = INT_CONST ; i < fa -> numedges ; i v++ ) 
numverts , verts [ INT_CONST ] ) 
fa -> texinfo -> flags & SURF_FLOWING ) 
FOR ( bp = fa -> polys ; bp ; bp = bp -> next ) 
FOR ( i = INT_CONST , v = p -> verts [ INT_CONST ] ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
GL_POLYGON ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , vecs += INT_CONST ) 
vec3_origin , v ) 
FOR ( i = INT_CONST , vp = vecs ; i < nump ; i v++ , vp += INT_CONST ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , vecs += INT_CONST ) 
nump > MAX_CLIP_VERTS - INT_CONST ) 
nump , vecs ) 
FOR ( i = INT_CONST , v = vecs ; i < nump ; i v++ , v += INT_CONST ) 
! front || ! back ) 
nump , vecs , stage + INT_CONST ) 
vecs , ( vecs + ( i * INT_CONST ) ) ) 
FOR ( i = INT_CONST , v = vecs ; i < nump ; i v++ , v += INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
newc [ INT_CONST ] , newv [ INT_CONST ] [ INT_CONST ] , stage + INT_CONST ) 
FOR ( p = fa -> polys ; p ; p = p -> next ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
s + INT_CONST ) 
s < sky_min ) 
GL_BLEND ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
skyname , name , SIZEOF ( skyname ) - INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
finalvert_t * pfv0 , finalvert_t * pfv1 , finalvert_t * out ) 
ALIAS_Z_CLIP_PLANE - pfv0 -> xyz [ INT_CONST ] ) 
pfv1 -> s - pfv0 -> s ) 
out ) 
pfv0 -> v >= pfv1 -> v ) 
pfv1 -> u - pfv0 -> u ) 
pfv0 -> u - pfv1 -> u ) 
pfv0 -> v >= pfv1 -> v ) 
pfv0 -> v >= pfv1 -> v ) 
pfv1 -> u - pfv0 -> u ) 
pfv0 -> u - pfv1 -> u ) 
pfv0 -> v >= pfv1 -> v ) 
pfv1 -> u - pfv0 -> u ) 
pfv0 -> u - pfv1 -> u ) 
FOR ( i = INT_CONST ; i < count ; j = i , i v++ ) 
clipflags & ALIAS_Z_CLIP ) 
clipflags & ALIAS_LEFT_CLIP ) 
clipflags & ALIAS_RIGHT_CLIP ) 
k == INT_CONST ) 
clipflags & ALIAS_BOTTOM_CLIP ) 
clipflags & ALIAS_TOP_CLIP ) 
FOR ( i = INT_CONST ; i < k ; i v++ ) 
FOR ( i = INT_CONST ; i < k - INT_CONST ; i v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mins , transformed_min , aliastransform ) 
transformed_min [ INT_CONST ] >= ALIAS_Z_CLIP_PLANE ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
aggregate_and_clipcode ) 
r_thisframe , aliasworldtransform ) 
currententity -> backlerp == INT_CONST ) 
r_lastframe , aliasoldworldtransform ) 
( ccodes [ INT_CONST ] | ccodes [ INT_CONST ] ) == BBOX_TRIVIAL_ACCEPT ) 
r_newrefdef . rdflags & RDF_IRGOGGLES && currententity -> flags & RF_IR_VISIBLE ) 
finalvert_t * ) 
aliasbatchedtransformdata . num_points , NEW_LINE aliasbatchedtransformdata . dest_verts , NEW_LINE aliasbatchedtransformdata . last_verts , NEW_LINE aliasbatchedtransformdata . this_verts ) 
( currententity -> flags & RF_WEAPONMODEL ) && ( r_lefthand -> value == FLOAT_CONST ) ) 
FOR ( i = INT_CONST ; i < s_pmdl -> num_tris ; i v++ , ptri v++ ) 
FOR ( i = INT_CONST ; i < s_pmdl -> num_tris ; i v++ , ptri v++ ) 
pfv [ INT_CONST ] , pfv [ INT_CONST ] , pfv [ INT_CONST ] ) 
angles , s_alias_forward , s_alias_right , s_alias_up ) 
aliasworldtransform , INT_CONST , SIZEOF ( aliasworldtransform ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vright , viewmatrix [ INT_CONST ] ) 
viewmatrix , aliasworldtransform , aliastransform ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < numpoints ; i v++ , fv v++ , oldv v++ , newv v++ ) 
x * aliasxscale * zi ) 
fv -> u < r_refdef . aliasvrect . x ) 
currententity -> skin ) 
! pskindesc ) 
) 
currententity -> flags & RF_FULLBRIGHT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
currententity -> flags & RF_WEAPONMODEL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
currententity -> flags & RF_GLOW ) 
r_newrefdef . time * INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
light [ INT_CONST ] + light [ INT_CONST ] + light [ INT_CONST ] ) 
lighting . ambientlight > INT_CONST ) 
r_ambientlight < LIGHT_MIN ) 
r_ambientlight < LIGHT_MIN ) 
r_shadelight < INT_CONST ) 
lighting . plightvec , s_alias_forward ) 
( thisframe >= pmdl -> num_frames ) || ( thisframe < INT_CONST ) ) 
daliasframe_t * ) 
currententity -> angles , vectors [ INT_CONST ] , vectors [ INT_CONST ] , vectors [ INT_CONST ] ) 
currententity -> oldorigin , currententity -> origin , translation ) 
translation , vectors [ INT_CONST ] ) 
translation , vectors [ INT_CONST ] ) 
translation , vectors [ INT_CONST ] ) 
r_lerp_move , r_lastframe -> translate , r_lerp_move ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
dmdl_t * ) 
r_lerpmodels -> value == INT_CONST ) 
s_pmdl ) 
R_AliasCheckBBox ( ) == BBOX_TRIVIAL_REJECT ) 
! R_AliasSetupSkin ( ) ) 
) 
currententity -> flags & ( RF_SHELL_RED | RF_SHELL_GREEN | RF_SHELL_BLUE | RF_SHELL_DOUBLE | RF_SHELL_HALF_DAM ) ) 
s_pmdl , currententity -> backlerp ) 
currententity -> flags & RF_DEPTHHACK ) 
( currententity -> flags & RF_WEAPONMODEL ) && ( r_lefthand -> value == FLOAT_CONST ) ) 
__E__O__F__
vec , tvec ) 
angle ) 
angle ) 
temp2 , temp1 , temp3 ) 
angle ) 
temp1 , temp3 , entity_rotation ) 
modelorg ) 
) 
r_entorigin , splitplane -> normal ) 
FOR ( ; pedges ; pedges = pnextedge ) 
plastvert -> position , tplane . normal ) 
pvert -> position , tplane . normal ) 
makeclippededge ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
FOR ( j = INT_CONST ; j < psurf -> numedges ; j v++ ) 
FOR ( i = INT_CONST ; i < numsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
node -> contents == CONTENTS_SOLID ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
node -> contents != -v INT_CONST ) 
plane -> type ) 
node -> children [ side ] , clipflags ) 
c ) 
node -> children [ ! side ] , clipflags ) 
INT ) 
r_origin , modelorg ) 
currentmodel -> nodes , INT_CONST ) 
__E__O__F__
name [ INT_CONST ] != CHAR_CONST && name [ INT_CONST ] != CHAR_CONST ) 
num == INT_CONST || num == INT_CONST + INT_CONST ) 
y > vid . height - INT_CONST || x < INT_CONST || x > vid . width - INT_CONST ) 
y < INT_CONST ) 
drawline v-- ) 
pic ) 
( x < INT_CONST ) || NEW_LINE ( x + w > vid . width ) || NEW_LINE ( y + h > vid . height ) ) 
y < INT_CONST ) 
FOR ( v = INT_CONST ; v < height ; v v++ , dest += vid . rowbytes ) 
FOR ( u = INT_CONST ; u < w ; u += INT_CONST ) 
name ) 
x , y , w , h , &v pic ) 
name ) 
( x < INT_CONST ) || NEW_LINE ( x + pic -> width > vid . width ) || NEW_LINE ( y + pic -> height > vid . height ) ) 
! pic -> transparent ) 
FOR ( v = INT_CONST ; v < height ; v v++ ) 
FOR ( v = INT_CONST ; v < height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
FOR ( v = INT_CONST ; v < height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u += INT_CONST ) 
x < INT_CONST ) 
FOR ( i = INT_CONST ; i < h ; i v++ , pdest += vid . rowbytes ) 
FOR ( j = x ; j < x2 ; j v++ ) 
x + w > vid . width ) 
FOR ( v = INT_CONST ; v < h ; v v++ , dest += vid . rowbytes ) 
FOR ( u = INT_CONST ; u < w ; u v++ ) 
FOR ( y = INT_CONST ; y < vid . height ; y v++ ) 
FOR ( x = INT_CONST ; x < vid . width ; x v++ ) 
__E__O__F__
FOR ( *v pdrawfunc ) 
sw_draworder -> value ) 
FOR ( v = r_refdef . vrect . y ; v < r_refdef . vrectbottom ; v v++ ) 
edgelist -> u >= edgestoadd -> u ) 
edgelist -> u >= edgestoadd -> u ) 
edgelist -> u >= edgestoadd -> u ) 
edge_t * pedge ) 
INT_CONST ) 
pwedge -> u > pedge -> u ) 
pedge == &v edge_tail ) 
iu > surf -> last_u ) 
++v surf -> spanstate == INT_CONST ) 
surf -> insubmodel && ( surf -> key == surf2 -> key ) ) 
iu > surf2 -> last_u ) 
--v surf -> spanstate == INT_CONST ) 
edge -> surfs [ INT_CONST ] ) 
++v surf -> spanstate == INT_CONST ) 
FOR ( edge = edge_head . next ; edge != &v edge_tail ; edge = edge -> next ) 
) 
FOR ( edge = edge_head . next ; edge != &v edge_tail ; edge = edge -> next ) 
) 
espan_t * ) 
r_refdef . vrectright << INT_CONST ) 
FOR ( iv = r_refdef . vrect . y ; iv < bottom ; iv v++ ) 
newedges [ iv ] ) 
span_p > max_span_p ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
FLOAT ) 
newedges [ iv ] ) 
) 
scale >= d_scalemip [ INT_CONST ] ) 
FOR ( span = surf -> spans ; span ; span = span -> pnext ) 
FOR ( ; u <= u2 ; u v++ ) 
FLOAT ) 
pface -> texinfo -> vecs [ INT_CONST ] , p_saxis ) 
transformed_modelorg , mipscale , p_temp1 ) 
( fixed16_t ) ( DotProduct ( p_temp1 , p_saxis ) * INT_CONST + FLOAT_CONST ) ) 
pface -> texinfo -> flags & SURF_FLOWING ) 
( pface -> extents [ INT_CONST ] << INT_CONST ) >> miplevel ) 
s , ( INT ) sw_clearcolor -> value & INT_CONST ) 
s -> insubmodel ) 
r_origin , currententity -> origin , NEW_LINE local_modelorg ) 
pface ) 
! ( pface -> texinfo -> flags & SURF_WARP ) ) 
s -> insubmodel ) 
world_transformed_modelorg , NEW_LINE transformed_modelorg ) 
pface ) 
s -> spans ) 
s -> spans ) 
s -> insubmodel ) 
r_origin , currententity -> origin , local_modelorg ) 
pixel_t * ) 
pface ) 
s -> spans ) 
s -> spans ) 
s -> insubmodel ) 
world_transformed_modelorg , NEW_LINE transformed_modelorg ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
r_origin , vec3_origin , modelorg ) 
! sw_drawflat -> value ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
r_origin , vec3_origin , modelorg ) 
__E__O__F__
PRINT_ALL , STRING ) 
FOR ( i = INT_CONST , image = r_images ; i < numr_images ; i v++ , image v++ ) 
filename , ( VOID *p *p ) & raw ) 
pcx_t * ) 
pcx -> xmin ) 
pcx -> manufacturer != INT_CONST NEW_LINE || pcx -> version != INT_CONST NEW_LINE || pcx -> encoding != INT_CONST NEW_LINE || pcx -> bits_per_pixel != INT_CONST NEW_LINE || pcx -> xmax >= INT_CONST NEW_LINE || pcx -> ymax >= INT_CONST ) 
( pcx -> ymax + INT_CONST ) * ( pcx -> xmax + INT_CONST ) ) 
palette ) 
width ) 
FOR ( y = INT_CONST ; y <= pcx -> ymax ; y v++ , pix += pcx -> xmax + INT_CONST ) 
FOR ( x = INT_CONST ; x <= pcx -> xmax ; ) 
raw - ( byte * ) pcx > len ) 
pcx ) 
name , ( VOID *p *p ) & buffer ) 
*v ( ( SHORT *p ) buf_p ) ) 
targa_header . image_type != INT_CONST NEW_LINE && targa_header . image_type != INT_CONST ) 
width ) 
targa_header . id_length != INT_CONST ) 
FOR ( row = rows - INT_CONST ; row >= INT_CONST ; row v-- ) 
FOR ( column = INT_CONST ; column < columns ; column v++ ) 
FOR ( row = rows - INT_CONST ; row >= INT_CONST ; row v-- ) 
FOR ( column = INT_CONST ; column < columns ; ) 
FOR ( j = INT_CONST ; j < packetSize ; j v++ ) 
FOR ( j = INT_CONST ; j < packetSize ; j v++ ) 
targa_header . pixel_size ) 
buffer ) 
FOR ( i = INT_CONST , image = r_images ; i < numr_images ; i v++ , image v++ ) 
) 
c ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
name , ( VOID *p *p ) & mt ) 
) 
INT_CONST + INT_CONST + INT_CONST + INT_CONST ) 
mt -> offsets [ INT_CONST ] ) 
( VOID *p ) mt ) 
! name ) 
FOR ( i = INT_CONST , image = r_images ; i < numr_images ; i v++ , image v++ ) 
! strcmp ( name + len - INT_CONST , STRING ) ) 
FOR ( i = INT_CONST , image = r_images ; i < numr_images ; i v++ , image v++ ) 
FOR ( i = INT_CONST , image = r_images ; i < numr_images ; i v++ , image v++ ) 
__E__O__F__
i < INT_CONST ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
light , bit , node -> children [ INT_CONST ] ) 
FOR ( i = INT_CONST , l = r_newrefdef . dlights ; i < r_newrefdef . num_dlights ; i v++ , l v++ ) 
node -> contents != -v INT_CONST ) 
start , plane -> normal ) 
node -> children [ side ] , start , mid ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
node -> children [ ! side ] , mid , end ) 
FOR ( lnum = INT_CONST ; lnum < r_newrefdef . num_dlights ; lnum v++ ) 
surf -> extents [ INT_CONST ] >> INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < r_newrefdef . num_dlights ; lnum v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( t = INT_CONST ; t < tmax ; t v++ ) 
FOR ( s = INT_CONST ; s < smax ; s v++ ) 
surf -> extents [ INT_CONST ] >> INT_CONST ) 
r_fullbright -> value || ! r_worldmodel -> lightdata ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
__E__O__F__
image_t * ) 
FOR ( m = INT_CONST ; m < INT_CONST ; m v++ ) 
FOR ( y = INT_CONST ; y < ( INT_CONST >> m ) ; y v++ ) 
FOR ( x = INT_CONST ; x < ( INT_CONST >> m ) ; x v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING , STRING , CVAR_USERINFO | CVAR_ARCHIVE ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , Mod_Modellist_f ) 
STRING , STRING , INT_CONST ) 
) 
( LONG ) R_EdgeCodeStart , NEW_LINE ( LONG ) R_EdgeCodeEnd - ( LONG ) R_EdgeCodeStart ) 
) 
INT_CONST ) 
PRINT_ALL , STRING REF_VERSION STRING ) 
d_pzbuffer ) 
sc_base ) 
vid . colormap ) 
) 
r_cnumsurfs <= MINSURFACES ) 
) 
r_numallocatededges < MINEDGES ) 
r_oldviewcluster == r_viewcluster && ! r_novis -> value && r_viewcluster != -v INT_CONST ) 
sw_lockpvs -> value ) 
r_novis -> value || r_viewcluster == -v INT_CONST || ! r_worldmodel -> vis ) 
FOR ( i = INT_CONST ; i < r_worldmodel -> numleafs ; i v++ ) 
FOR ( i = INT_CONST ; i < r_worldmodel -> numnodes ; i v++ ) 
r_viewcluster , r_worldmodel ) 
FOR ( i = INT_CONST , leaf = r_worldmodel -> leafs ; i < r_worldmodel -> numleafs ; i v++ , leaf v++ ) 
FOR ( i = INT_CONST ; i < r_worldmodel -> vis -> numclusters ; i v++ ) 
! r_drawentities -> value ) 
FOR ( i = INT_CONST ; i < r_newrefdef . num_entities ; i v++ ) 
! translucent_entities ) 
FOR ( i = INT_CONST ; i < r_newrefdef . num_entities ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
rejectpt , view_clipplanes [ i ] . normal ) 
INT_CONST ) 
! angles [ INT_CONST ] && ! angles [ INT_CONST ] && ! angles [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
angles , forward , right , up ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! r_drawentities -> value ) 
FOR ( i = INT_CONST ; i < r_newrefdef . num_entities ; i v++ ) 
currentmodel -> mins , currentmodel -> maxs , NEW_LINE currententity -> angles , mins , maxs ) 
) 
currentmodel ) 
base_vpn , vpn ) 
r_surfsonstack ) 
) 
) 
r_dspeeds -> value ) 
) 
r_dspeeds -> value ) 
) 
r_dspeeds -> value ) 
) 
alpha <= INT_CONST ) 
alpha > INT_CONST ) 
FLOAT_CONST - alpha ) 
byte * ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , in += INT_CONST , out += INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
( CONST UNSIGNED CHAR *p ) palette [ INT_CONST ] ) 
( r_newrefdef . rdflags & RDF_NOWORLDMODEL ) || ( ! r_drawentities -> value ) || ( ! currententity ) ) 
r_newrefdef . vieworg , light ) 
! r_worldmodel && ! ( r_newrefdef . rdflags & RDF_NOWORLDMODEL ) ) 
r_speeds -> value || r_dspeeds -> value ) 
) 
r_worldmodel ) 
) 
r_dspeeds -> value ) 
) 
r_dspeeds -> value ) 
) 
r_dspeeds -> value ) 
) 
r_dowarp ) 
sw_aliasstats -> value ) 
d_pzbuffer ) 
sc_base ) 
vid . width * vid . height * INT_CONST ) 
) 
( CONST UNSIGNED CHAR *p ) d_8to24table ) 
vid_gamma -> modified ) 
sw_mode -> modified || vid_fullscreen -> modified ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
sw_state . currentpalette ) 
vid . rowbytes ) 
FOR ( i = INT_CONST ; i < vid . height ; i v++ , d += w ) 
FOR ( j = INT_CONST ; j < w ; j v++ ) 
) 
palette ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
g == FLOAT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VectorNormalize ( normalized_direction ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < NUM_BEAM_SEGS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_BEAM_SEGS ; i v++ ) 
skyname , name , SIZEOF ( skyname ) - INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING , &v vid . colormap , &v pal , NULL , NULL ) 
byte * ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , out += INT_CONST ) 
pal ) 
) 
argptr , error ) 
ERR_FATAL , STRING , text ) 
argptr , fmt ) 
PRINT_ALL , STRING , text ) 
__E__O__F__
! protectset8 ) 
) 
yscale > xscale ) 
d_pix_min < INT_CONST ) 
FOR ( i = INT_CONST ; i < vid . height ; i v++ ) 
r_newrefdef . rdflags & RDF_NOWORLDMODEL ) 
) 
) 
PRINT_ALL , STRING , NEW_LINE ms , c_faceclip , r_polycount , r_drawnpolycount , c_surf ) 
) 
da_time2 - da_time1 ) 
PRINT_ALL , STRING , NEW_LINE ms , dp_time , rw_time , db_time , se_time , de_time , da_time ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
naked ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
( FLOAT ) r_newrefdef . fov_x / INT_CONST * M_PI ) 
FLOAT ) 
INT ) 
( FLOAT ) r_refdef . vrect . width * XCENTERING ) 
r_refdef . vrect . width - INT_CONST ) 
xOrigin * r_refdef . horizontalFieldOfView ) 
( FLOAT_CONST - xOrigin ) * r_refdef . horizontalFieldOfView ) 
yOrigin * verticalFieldOfView ) 
( FLOAT_CONST - yOrigin ) * verticalFieldOfView ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
r_fullbright -> modified ) 
r_refdef . viewangles , vpn , vright , vup ) 
! ( r_newrefdef . rdflags & RDF_NOWORLDMODEL ) ) 
sw_waterwarp -> value && ( r_newrefdef . rdflags & RDF_UNDERWATER ) ) 
vpn , base_vpn ) 
d_minmip > INT_CONST ) 
FOR ( i = INT_CONST ; i < ( NUM_MIPS - INT_CONST ) ; i v++ ) 
pcx_t * ) 
( SHORT ) ( width - INT_CONST ) ) 
( SHORT ) width ) 
pcx -> filler , INT_CONST , SIZEOF ( pcx -> filler ) ) 
FOR ( i = INT_CONST ; i < height ; i v++ ) 
FOR ( j = INT_CONST ; j < width ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pcx ) 
checkname , SIZEOF ( checkname ) , STRING , ri . FS_Gamedir ( ) ) 
pcxname , STRING ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
checkname , vid . buffer , vid . width , vid . height , vid . rowbytes , NEW_LINE palette ) 
__E__O__F__
PRINT_ALL , STRING ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
name [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
mod -> name , ( VOID *p *p ) & buf ) 
LittleLong ( *v ( UNSIGNED *p ) buf ) ) 
INT_CONST ) 
INT_CONST ) 
ERR_DROP , STRING , mod -> name ) 
) 
buf ) 
model -> vis -> numclusters + INT_CONST ) 
row ) 
! l -> filelen ) 
FOR ( i = INT_CONST ; i < size ; i v++ , in += INT_CONST ) 
node -> contents != -v INT_CONST ) 
node -> children [ INT_CONST ] ) 
! l -> filelen ) 
FOR ( i = INT_CONST ; i < loadmodel -> vis -> numclusters ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( step = out -> next ; step && step != out ; step = step -> next ) 
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( surfnum = INT_CONST ; surfnum < count ; surfnum v++ , in v++ , out v++ ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < mod -> numsubmodels ; i v++ ) 
) 
dmdl_t * ) 
pinmodel -> version ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dmdl_t ) / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < pheader -> num_st ; i v++ ) 
dtriangle_t * ) 
FOR ( i = INT_CONST ; i < pheader -> num_tris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < pheader -> num_frames ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
INT *p ) 
FOR ( i = INT_CONST ; i < pheader -> num_glcmds ; i v++ ) 
( CHAR *p ) pheader + pheader -> ofs_skins , ( CHAR *p ) pinmodel + pheader -> ofs_skins , NEW_LINE pheader -> num_skins * MAX_SKINNAME ) 
FOR ( i = INT_CONST ; i < pheader -> num_skins ; i v++ ) 
dsprite_t * ) 
sprin -> ident ) 
sprout -> version != SPRITE_VERSION ) 
FOR ( i = INT_CONST ; i < sprout -> numframes ; i v++ ) 
fullname , SIZEOF ( fullname ) , STRING , model ) 
) 
STRING , STRING , INT_CONST ) 
name , false ) 
FOR ( i = INT_CONST ; i < sprout -> numframes ; i v++ ) 
FOR ( i = INT_CONST ; i < pheader -> num_skins ; i v++ ) 
FOR ( i = INT_CONST ; i < mod -> numtexinfo ; i v++ ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
) 
FOR ( i = INT_CONST ; i < mod_numknown ; i v++ ) 
__E__O__F__
*v blendfunc ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
d_zwidth * v + u ) 
pparticle -> origin , r_origin , local ) 
local , r_pright ) 
transformed [ INT_CONST ] < PARTICLE_Z_CLIP ) 
INT ) 
( v > d_vrectbottom_particle ) || NEW_LINE ( u > d_vrectright_particle ) || NEW_LINE ( v < d_vrecty ) || NEW_LINE ( u < d_vrectx ) ) 
d_zwidth * v ) 
pix < d_pix_min ) 
level ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += r_screenwidth ) 
FOR ( i = INT_CONST ; i < pix ; i v++ ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += r_screenwidth ) 
FOR ( i = INT_CONST ; i < pix ; i v++ ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += r_screenwidth ) 
FOR ( i = INT_CONST ; i < pix ; i v++ ) 
vright , xscaleshrink , r_pright ) 
FOR ( p = r_newrefdef . particles , i = INT_CONST ; i < r_newrefdef . num_particles ; i v++ , p v++ ) 
p -> alpha > FLOAT_CONST ) 
__E__O__F__
s_spanletvars . spancount == AFFINE_SPANLET_SIZE ) 
clip_current ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , instep += SIZEOF ( vec5_t ) / SIZEOF ( FLOAT ) ) 
instep , in , SIZEOF ( vec5_t ) ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , instep += SIZEOF ( vec5_t ) / SIZEOF ( FLOAT ) ) 
iswater ) 
INT ) 
FLOAT ) 
INT ) 
s_spanletvars . t > bbextentt ) 
i == INT_CONST ) 
FOR ( v = itop ; v < ibottom ; v v++ ) 
vvert < r_refdef . fvrecty_adj ) 
FOR ( v = itop ; v < ibottom ; v v++ ) 
! textured ) 
alpha == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < nump ; i v++ ) 
isturbulent ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
fa -> texinfo -> vecs [ INT_CONST ] , r_polydesc . vright ) 
fa -> flags & SURF_PLANEBACK ) 
fa -> texinfo -> flags & SURF_WARP ) 
r_polydesc . vpn , pverts [ INT_CONST ] ) 
fa -> texinfo -> flags & SURF_FLOWING ) 
r_polydesc . vpn , p_normal ) 
-v ( DotProduct ( r_polydesc . viewer_position , r_polydesc . vpn ) ) + r_polydesc . dist ) 
fixed16_t ) 
r_polydesc . pixel_width << INT_CONST ) 
FOR ( i = INT_CONST ; i < r_polydesc . nump ; i v++ ) 
ymin ) 
ymin >= ymax ) 
) 
s_polygon_spans , iswater ) 
s ) 
r_origin , r_polydesc . viewer_position ) 
a , r_clip_verts [ INT_CONST ] [ INT_CONST ] ) 
d , c , s0 ) 
r_polydesc . vpn , r_clip_verts [ INT_CONST ] [ INT_CONST ] ) 
alpha , false , false ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAX_LBM_HEIGHT ; i v++ , s += skinwidth ) 
! ( dv0_ab | dv1_ab ) ) 
! ( dv0_ac | dv1_ac ) ) 
d_xdenom < INT_CONST ) 
errorterm >= INT_CONST ) 
numer >= FLOAT_CONST ) 
numer / denom ) 
-v numer / denom ) 
( ( tm <= INT_CONST ) && ( tm >= -v INT_CONST ) ) && NEW_LINE ( ( tn <= INT_CONST ) && ( tn >= -v INT_CONST ) ) ) 
INT_CONST / d_xdenom ) 
empty ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
FLOAT ) 
INT ) 
INT_CONST ) 
r_affinetridesc . skinwidth ) 
byte * ) 
byte * ) 
initialleftheight == INT_CONST ) 
ubasestep < INT_CONST ) 
pedgetable -> numleftedges == INT_CONST ) 
prighttop [ INT_CONST ] , prighttop [ INT_CONST ] , NEW_LINE prightbottom [ INT_CONST ] , prightbottom [ INT_CONST ] ) 
*v d_pdrawspans ) 
pedgetable -> numrightedges == INT_CONST ) 
r_p0 [ INT_CONST ] >= r_p1 [ INT_CONST ] ) 
r_p0 [ INT_CONST ] == r_p2 [ INT_CONST ] ) 
r_p0 [ INT_CONST ] > r_p2 [ INT_CONST ] ) 
__E__O__F__
loadmodel -> numsurfaces > MAX_MAP_FACES NEW_LINE || loadmodel -> numvertexes > MAX_MAP_VERTS NEW_LINE || loadmodel -> numedges > MAX_MAP_EDGES ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
insubmodel ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
r_lastvertvalid ) 
world , modelorg , local ) 
transformed [ INT_CONST ] < NEAR_CLIP ) 
xcenter + scale * transformed [ INT_CONST ] ) 
r_nearzionly ) 
INT ) 
ceilv0 == r_ceilv1 ) 
cacheoffset != INT_CONST ) 
side == INT_CONST ) 
( r_u1 - u0 ) / ( r_v1 - v0 ) ) 
( u0 - r_u1 ) / ( v0 - r_v1 ) ) 
edge -> u < r_refdef . vrect_x_adj_shift20 ) 
clip ) 
pv0 , pv1 ) 
edge_t * ) 
! pedge_t -> surfs [ INT_CONST ] ) 
fa -> texinfo -> flags & ( SURF_TRANS33 | SURF_TRANS66 ) ) 
fa -> texinfo -> flags & SURF_SKY ) 
( surface_p ) >= surf_max ) 
( edge_p + fa -> numedges + INT_CONST ) >= edge_max ) 
FOR ( i = INT_CONST , mask = INT_CONST ; i >= INT_CONST ; i v-- , mask >>= INT_CONST ) 
FOR ( i = INT_CONST ; i < fa -> numedges ; i v++ ) 
r_rightclipped ) 
r_rightclipped ) 
makeleftedge ) 
makerightedge ) 
! r_emitted ) 
pplane -> normal , p_normal ) 
psurf -> texinfo -> flags & ( SURF_TRANS33 | SURF_TRANS66 ) ) 
surface_p >= surf_max ) 
( edge_p + psurf -> numedges + INT_CONST ) >= edge_max ) 
FOR ( i = INT_CONST , mask = INT_CONST ; i >= INT_CONST ; i v-- , mask >>= INT_CONST ) 
FOR ( ; pedges ; pedges = pedges -> pnext ) 
makeleftedge ) 
makerightedge ) 
! r_emitted ) 
pplane -> normal , p_normal ) 
__E__O__F__
w != cached_width || h != cached_height ) 
FOR ( v = INT_CONST ; v < h + AMP2 * INT_CONST ; v v++ ) 
FOR ( u = INT_CONST ; u < w + AMP2 * INT_CONST ; u v++ ) 
( INT ) ( r_newrefdef . time * SPEED ) & ( CYCLE - INT_CONST ) ) 
FOR ( v = INT_CONST ; v < h ; v v++ , dest += vid . rowbytes ) 
FOR ( u = INT_CONST ; u < w ; u += INT_CONST ) 
UNSIGNED CHAR *p ) 
FLOAT ) 
INT ) 
INT ) 
snext - r_turb_s ) 
INT ) 
r_turb_spancount > INT_CONST ) 
UNSIGNED CHAR *p ) 
FLOAT ) 
INT ) 
INT ) 
snext - r_turb_s ) 
INT ) 
r_turb_spancount > INT_CONST ) 
UNSIGNED CHAR *p ) 
FLOAT ) 
INT ) 
FLOAT ) 
INT ) 
__E__O__F__
dsprite_t * ) 
vup , r_polydesc . vup ) 
r_polydesc . vright , NEW_LINE s_psprframe -> width - s_psprframe -> origin_x , right ) 
r_polydesc . vup ) 
r_polydesc . pixel_width >> INT_CONST ) 
currententity -> flags & RF_TRANSLUCENT ) 
__E__O__F__
! tex -> next ) 
INT_CONST << blockdivshift ) 
tmax * smax ) 
( soffset >> r_drawsurf . surfmip ) + ( smax << INT_CONST ) ) 
FOR ( u = INT_CONST ; u < r_numhblocks ; u v++ ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
sw_surfcacheoverride -> value ) 
size + INT_CONST ) 
PRINT_ALL , STRING , size / INT_CONST ) 
surfcache_t * ) 
FOR ( c = sc_base ; c ; c = c -> next ) 
( width < INT_CONST ) || ( width > INT_CONST ) ) 
! sc_rover || ( byte * ) sc_rover - ( byte * ) sc_base > sc_size - size ) 
! sc_rover ) 
new -> size - size > INT_CONST ) 
d_roverwrapped ) 
FOR ( test = sc_base ; test ; test = test -> next ) 
surface -> texinfo ) 
cache && ! cache -> dlight && surface -> dlightframe != r_framecount NEW_LINE && cache -> image == r_drawsurf . image NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] ) 
! cache ) 
) 
__E__O__F__
! dedicated -> value ) 
STRING , STRING ) 
FOR ( i = INT_CONST ; i < MAX_MASTERS ; i v++ ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
Cmd_Argc ( ) < INT_CONST ) 
s [ INT_CONST ] >= CHAR_CONST && s [ INT_CONST ] <= CHAR_CONST ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
STRING , s ) 
STRING , savename ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , savename ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , savename ) 
STRING , src , dst ) 
src , STRING ) 
INT_CONST ) 
f1 ) 
STRING , src , dst ) 
dst ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , src ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , src ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , src ) 
STRING ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , sv . name ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , sv . name ) 
STRING ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , sv . name ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , sv . name ) 
STRING , autosave ? STRING ?: STRING ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) ) 
comment , INT_CONST , SIZEOF ( comment ) ) 
! autosave ) 
comment , SIZEOF ( comment ) , STRING , sv . configstrings [ CS_NAME ] ) 
comment , INT_CONST , SIZEOF ( comment ) , f ) 
svs . mapcmd , INT_CONST , SIZEOF ( svs . mapcmd ) , f ) 
FOR ( var = cvar_vars ; var ; var = var -> next ) 
f ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) ) 
STRING ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) ) 
comment , SIZEOF ( comment ) , f ) 
mapcmd , SIZEOF ( mapcmd ) , f ) 
INT_CONST ) 
f ) 
) 
svs . mapcmd , mapcmd ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) ) 
Cmd_Argc ( ) != INT_CONST ) 
STRING , Cmd_Argv ( INT_CONST ) ) 
va ( STRING , FS_Gamedir ( ) ) ) 
INT_CONST ) 
sv . state == ss_game ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
false , Cmd_Argv ( INT_CONST ) , false ) 
svs . mapcmd , Cmd_Argv ( INT_CONST ) , SIZEOF ( svs . mapcmd ) - INT_CONST ) 
! dedicated -> value ) 
INT_CONST ) 
STRING ) 
Cmd_Argc ( ) != INT_CONST ) 
STRING ) 
INT_CONST ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , Cmd_Argv ( INT_CONST ) ) 
Cmd_Argv ( INT_CONST ) , STRING ) 
) 
false , svs . mapcmd , true ) 
sv . state != ss_game ) 
Cmd_Argc ( ) != INT_CONST ) 
Cvar_VariableValue ( STRING ) ) 
! strcmp ( Cmd_Argv ( INT_CONST ) , STRING ) ) 
maxclients -> value == INT_CONST && svs . clients [ INT_CONST ] . edict -> client -> ps . stats [ STAT_HEALTH ] <= INT_CONST ) 
INT_CONST ) 
STRING ) 
) 
false ) 
STRING , dir ) 
STRING ) 
Cmd_Argc ( ) != INT_CONST ) 
! SV_SetPlayer ( ) ) 
sv_client , PRINT_HIGH , STRING ) 
STRING ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ ) 
Cmd_Argc ( ) < INT_CONST ) 
*v p == CHAR_CONST ) 
text , p ) 
FOR ( j = INT_CONST , client = svs . clients ; j < maxclients -> value ; j v++ , client v++ ) 
! SV_SetPlayer ( ) ) 
Cmd_Argc ( ) != INT_CONST ) 
svs . demofile ) 
sv . state != ss_game ) 
name , SIZEOF ( name ) , STRING , FS_Gamedir ( ) , Cmd_Argv ( INT_CONST ) ) 
STRING , name ) 
&v svs . demo_multicast , svs . demo_multicast_buf , SIZEOF ( svs . demo_multicast_buf ) ) 
&v buf , buf_data , SIZEOF ( buf_data ) ) 
&v buf , svc_serverdata ) 
&v buf , INT_CONST ) 
&v buf , Cvar_VariableString ( STRING ) ) 
&v buf , sv . configstrings [ CS_NAME ] ) 
FOR ( i = INT_CONST ; i < MAX_CONFIGSTRINGS ; i v++ ) 
STRING , buf . cursize ) 
) 
STRING , SV_Map_f ) 
dedicated -> value ) 
STRING , SV_Savegame_f ) 
STRING , SV_KillServer_f ) 
STRING , SV_ServerCommand_f ) 
__E__O__F__
! numprojs ) 
FOR ( n = INT_CONST ; n < numprojs ; n v++ ) 
FOR ( i = INT_CONST ; i < len ; i v++ ) 
numprojs ) 
msg , INT_CONST ) 
numprojs ) 
! from ) 
ps -> pmove . pm_type != ops -> pmove . pm_type ) 
msg , svc_playerinfo ) 
pflags & PS_M_TYPE ) 
pflags & PS_M_VELOCITY ) 
pflags & PS_M_TIME ) 
pflags & PS_VIEWOFFSET ) 
pflags & PS_VIEWANGLES ) 
pflags & PS_KICKANGLES ) 
pflags & PS_WEAPONINDEX ) 
pflags & PS_WEAPONFRAME ) 
pflags & PS_BLEND ) 
FOR ( i = INT_CONST ; i < MAX_STATS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_STATS ; i v++ ) 
client -> lastframe <= INT_CONST ) 
msg , svc_frame ) 
msg , client -> surpressCount ) 
msg , frame -> areabytes ) 
oldframe , frame , msg ) 
oldframe , frame , msg ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mins , maxs , leafs , INT_CONST , NULL ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < i ; j v++ ) 
FOR ( j = INT_CONST ; j < longs ; j v++ ) 
! clent -> client ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
frame -> areabits , clientarea ) 
org ) 
FOR ( e = INT_CONST ; e < ge -> num_edicts ; e v++ ) 
! CM_AreasConnected ( clientarea , ent -> areanum ) ) 
FOR ( i = INT_CONST ; i < ent -> num_clusters ; i v++ ) 
len > INT_CONST ) 
! svs . demofile ) 
&v buf , svc_frame ) 
&v buf , svc_packetentities ) 
e ) 
&v buf , INT_CONST ) 
&v buf , svs . demo_multicast . data , svs . demo_multicast . cursize ) 
buf . cursize ) 
__E__O__F__
! ent ) 
reliable ) 
STRING , msg ) 
ent ) 
argptr , fmt ) 
ent ) 
&v sv . multicast , svc_centerprint ) 
ERR_DROP , STRING , msg ) 
! name ) 
name [ INT_CONST ] == CHAR_CONST ) 
sv . configstrings [ index ] , val ) 
&v sv . multicast ) 
p1 ) 
p2 ) 
p1 ) 
p2 ) 
ge ) 
game_export_t * ) 
! ge ) 
__E__O__F__
FOR ( i = INT_CONST ; i < max && sv . configstrings [ start + i ] [ INT_CONST ] ; i v++ ) 
sv . state != ss_loading ) 
&v sv . multicast ) 
FOR ( entnum = INT_CONST ; entnum < ge -> num_edicts ; entnum v++ ) 
sv_noreload -> value ) 
) 
) 
! sv . loadgame ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
attractloop ) 
STRING , server ) 
sv . state ) 
&v sv , INT_CONST , SIZEOF ( sv ) ) 
sv . configstrings [ CS_NAME ] , server ) 
&v sv . multicast , sv . multicast_buf , SIZEOF ( sv . multicast_buf ) ) 
sv . name , server ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
sv . name , server ) 
serverstate != ss_game ) 
) 
FOR ( i = INT_CONST ; i < CM_NumInlineModels ( ) ; i v++ ) 
sv . state ) 
sv . name , CM_EntityString ( ) , spawnpoint ) 
) 
sv . state ) 
) 
STRING , sv . name , CVAR_SERVERINFO | CVAR_NOSET ) 
STRING ) 
svs . initialized ) 
) 
Cvar_VariableValue ( STRING ) && Cvar_VariableValue ( STRING ) ) 
dedicated -> value ) 
Cvar_VariableValue ( STRING ) ) 
) 
( maxclients -> value > INT_CONST ) ) 
idmaster , SIZEOF ( idmaster ) , STRING , PORT_MASTER ) 
) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
sv . state == ss_dead && ! sv . loadgame ) 
level , STRING ) 
Cvar_VariableValue ( STRING ) && ! Q_stricmp ( level , STRING ) ) 
level , STRING ) 
level [ INT_CONST ] == CHAR_CONST ) 
STRING ) 
__E__O__F__
&v drop -> netchan . message , svc_disconnect ) 
drop -> state == cs_spawned ) 
drop -> download ) 
status , Cvar_Serverinfo ( ) ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
maxclients -> value == INT_CONST ) 
version != PROTOCOL_VERSION ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
NS_SERVER , net_from , STRING , string ) 
FOR ( i = INT_CONST ; i < MAX_CHALLENGES ; i v++ ) 
i == MAX_CHALLENGES ) 
NS_SERVER , net_from , STRING , svs . challenges [ i ] . challenge ) 
STRING ) 
Cmd_Argv ( INT_CONST ) ) 
Cmd_Argv ( INT_CONST ) ) 
Cmd_Argv ( INT_CONST ) ) 
userinfo , Cmd_Argv ( INT_CONST ) , SIZEOF ( userinfo ) - INT_CONST ) 
userinfo , STRING , NET_AdrToString ( net_from ) ) 
sv . attractloop ) 
! NET_IsLocalAddress ( adr ) ) 
FOR ( i = INT_CONST ; i < MAX_CHALLENGES ; i v++ ) 
newcl , INT_CONST , SIZEOF ( client_t ) ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
newcl - svs . clients ) 
! ( ge -> ClientConnect ( ent , userinfo ) ) ) 
newcl -> userinfo , userinfo , SIZEOF ( newcl -> userinfo ) - INT_CONST ) 
NS_SERVER , adr , STRING ) 
NS_SERVER , &v newcl -> netchan , adr , qport ) 
&v newcl -> datagram , newcl -> datagram_buf , SIZEOF ( newcl -> datagram_buf ) ) 
) 
i == INT_CONST ) 
! Rcon_Validate ( ) ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
) 
&v net_message ) 
&v net_message ) 
s , false ) 
INT_CONST ) 
! strcmp ( c , STRING ) ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
FOR ( j = INT_CONST ; j < LATENCY_COUNTS ; j v++ ) 
sv . framenum & INT_CONST ) 
FOR ( i = INT_CONST ; i < maxclients -> value ; i v++ ) 
NET_GetPacket ( NS_SERVER , &v net_from , &v net_message ) ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
FOR ( i = INT_CONST ; i < ge -> num_edicts ; i v++ , ent v++ ) 
! sv_paused -> value || maxclients -> value > INT_CONST ) 
host_speeds -> value ) 
! svs . initialized ) 
) 
) 
) 
! sv_timedemo -> value && svs . realtime < sv . time ) 
) 
) 
) 
) 
) 
) 
) 
! dedicated -> value ) 
svs . last_heartbeat > svs . realtime ) 
) 
FOR ( i = INT_CONST ; i < MAX_MASTERS ; i v++ ) 
! dedicated -> value ) 
FOR ( i = INT_CONST ; i < MAX_MASTERS ; i v++ ) 
cl -> edict , cl -> userinfo ) 
FOR ( i = INT_CONST ; i < SIZEOF ( cl -> name ) ; i v++ ) 
cl -> userinfo , STRING ) 
cl -> userinfo , STRING ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_LATCH ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_ARCHIVE ) 
&v net_message , net_message_buffer , SIZEOF ( net_message_buffer ) ) 
reconnect ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
sv . demofile ) 
svs . clients ) 
__E__O__F__
__E__O__F__
argptr , fmt ) 
FOR ( i = INT_CONST ; i < INT_CONST && string [ i ] ; i v++ ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < maxclients -> value ; i v++ , cl v++ ) 
&v sv . multicast , svc_stufftext ) 
to != MULTICAST_ALL_R && to != MULTICAST_ALL ) 
svs . demofile ) 
origin ) 
origin ) 
ERR_FATAL , STRING , to ) 
FOR ( j = INT_CONST , client = svs . clients ; j < maxclients -> value ; j v++ , client v++ ) 
&v sv . multicast ) 
volume < INT_CONST || volume > FLOAT_CONST ) 
channel & INT_CONST ) 
volume != DEFAULT_SOUND_PACKET_VOLUME ) 
( entity -> svflags & SVF_NOCLIENT ) NEW_LINE || ( entity -> solid == SOLID_BSP ) NEW_LINE || origin ) 
timeofs ) 
! origin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v sv . multicast , svc_sound ) 
flags & SND_VOLUME ) 
attenuation == ATTN_NONE ) 
client ) 
&v msg , msg_buf , SIZEOF ( msg_buf ) ) 
client , &v msg ) 
client -> datagram . overflowed ) 
msg . overflowed ) 
STRING , client -> name ) 
&v client -> netchan , msg . cursize , msg . data ) 
c -> netchan . remote_address . type == NA_LOOPBACK ) 
FOR ( i = INT_CONST ; i < RATE_MESSAGES ; i v++ ) 
total > c -> rate ) 
sv . state == ss_demo && sv . demofile ) 
FOR ( i = INT_CONST , c = svs . clients ; i < maxclients -> value ; i v++ , c v++ ) 
c -> netchan . message . cursize || curtime - c -> netchan . last_sent > INT_CONST ) 
__E__O__F__
name , SIZEOF ( name ) , STRING , sv . name ) 
STRING , sv_client -> name ) 
sv_client -> state != cs_connected ) 
sv . state == ss_demo ) 
STRING ) 
&v sv_client -> netchan . message , svc_serverdata ) 
sv . state == ss_cinematic || sv . state == ss_pic ) 
&v sv_client -> netchan . message , sv . configstrings [ CS_NAME ] ) 
sv . state == ss_game ) 
STRING , sv_client -> name ) 
sv_client -> state != cs_connected ) 
atoi ( Cmd_Argv ( INT_CONST ) ) != svs . spawncount ) 
sv_client -> netchan . message . cursize < MAX_MSGLEN / INT_CONST NEW_LINE && start < MAX_CONFIGSTRINGS ) 
start == MAX_CONFIGSTRINGS ) 
STRING , sv_client -> name ) 
sv_client -> state != cs_connected ) 
sv_client -> netchan . message . cursize < MAX_MSGLEN / INT_CONST NEW_LINE && start < MAX_EDICTS ) 
start == MAX_EDICTS ) 
atoi ( Cmd_Argv ( INT_CONST ) ) != svs . spawncount ) 
sv_player ) 
) 
! sv_client -> download ) 
! size ) 
INT_CONST ) 
Cmd_Argc ( ) > INT_CONST ) 
strstr ( name , STRING ) || ! allow_download -> value NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE || *v name == CHAR_CONST NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE || *v name == CHAR_CONST NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE || ( strncmp ( name , STRING , INT_CONST ) == INT_CONST && ! allow_download_players -> value ) NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE || ( strncmp ( name , STRING , INT_CONST ) == INT_CONST && ! allow_download_models -> value ) NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE || ( strncmp ( name , STRING , INT_CONST ) == INT_CONST && ! allow_download_sounds -> value ) NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE || ( strncmp ( name , STRING , INT_CONST ) == INT_CONST && ! allow_download_maps -> value ) NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE || ! strstr ( name , STRING ) ) 
sv_client -> download ) 
offset > sv_client -> downloadsize ) 
) 
sv . state == ss_game || ( sv . state == ss_pic && ! Cvar_VariableValue ( STRING ) ) ) 
STRING ) 
STRING , sv_client -> name ) 
) 
FOR ( u = ucmds ; u -> name ; u v++ ) 
cl -> commandMsec < INT_CONST && sv_enforcetime -> value ) 
cl -> edict , cmd ) 
INT_CONST ) 
__E__O__F__
&v anode -> trigger_edicts ) 
depth + INT_CONST , mins2 , maxs2 ) 
ent -> area . prev ) 
ent -> maxs , ent -> mins , ent -> size ) 
i < INT_CONST ) 
ent -> solid == SOLID_BSP && NEW_LINE ( ent -> s . angles [ INT_CONST ] || ent -> s . angles [ INT_CONST ] || ent -> s . angles [ INT_CONST ] ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent -> s . origin , ent -> mins , ent -> absmin ) 
ent -> absmin , ent -> absmax , NEW_LINE leafs , MAX_TOTAL_ENT_LEAFS , &v topnode ) 
FOR ( i = INT_CONST ; i < num_leafs ; i v++ ) 
num_leafs >= MAX_TOTAL_ENT_LEAFS ) 
FOR ( i = INT_CONST ; i < num_leafs ; i v++ ) 
FOR ( j = INT_CONST ; j < i ; j v++ ) 
! ent -> linkcount ) 
ent -> solid == SOLID_NOT ) 
area_type == AREA_SOLID ) 
FOR ( l = start -> next ; l != start ; l = next ) 
area_maxs [ node -> axis ] > node -> dist ) 
sv_areanodes ) 
p , sv . models [ INT_CONST ] -> headnode ) 
p , p , touch , MAX_EDICTS , AREA_SOLID ) 
FOR ( i = INT_CONST ; i < num ; i v++ ) 
ent -> solid == SOLID_BSP ) 
! model ) 
ent -> mins , ent -> maxs ) 
clip -> boxmins , clip -> boxmaxs , touchlist NEW_LINE , MAX_EDICTS , AREA_SOLID ) 
FOR ( i = INT_CONST ; i < num ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! mins ) 
start , end , mins , maxs , INT_CONST , contentmask ) 
mins , clip . mins2 ) 
&v clip ) 
__E__O__F__
( c = *v p v++ ) == CHAR_CONST || c == CHAR_CONST ) 
( c = *v p v++ ) != CHAR_CONST ) 
( c = *v p v++ ) != CHAR_CONST ) 
__E__O__F__
__E__O__F__
a -> type == NA_BROADCAST ) 
a . type == NA_IPX ) 
FOR ( colon = copy ; *v colon ; colon v++ ) 
! NET_StringToSockaddr ( s , ( STRUCT sockaddr * ) & sadr ) ) 
loop -> send - loop -> get > MAX_LOOPBACK ) 
net_message -> data , loop -> msgs [ i ] . data , loop -> msgs [ i ] . datalen ) 
MAX_LOOPBACK - INT_CONST ) 
loop -> msgs [ i ] . data , data , length ) 
NET_GetLoopPacket ( sock , net_from , net_message ) ) 
FOR ( protocol = INT_CONST ; protocol < INT_CONST ; protocol v++ ) 
to . type == NA_LOOPBACK ) 
to . type == NA_BROADCAST ) 
net_socket , data , length , INT_CONST , ( STRUCT sockaddr * ) & addr , SIZEOF ( addr ) ) 
STRING , va ( STRING , PORT_SERVER ) , CVAR_NOSET ) 
! ip_sockets [ NS_SERVER ] ) 
! multiplayer ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
ioctl ( newsocket , FIONBIO , &v _true ) == -v INT_CONST ) 
setsockopt ( newsocket , SOL_SOCKET , SO_BROADCAST , ( CHAR *p ) & i , SIZEOF ( i ) ) == -v INT_CONST ) 
! net_interface || ! net_interface [ INT_CONST ] || ! stricmp ( net_interface , STRING ) ) 
bind ( newsocket , ( VOID *p ) & address , SIZEOF ( address ) ) == -v INT_CONST ) 
code ) 
! ip_sockets [ NS_SERVER ] || ( dedicated && ! dedicated -> value ) ) 
msec % INT_CONST ) 
__E__O__F__
maxhunksize ) 
size + INT_CONST ) 
membase , curhunksize ) 
&v tp , &v tzp ) 
tp . tv_sec - secbase ) 
strcmp ( name , STRING ) == INT_CONST || strcmp ( name , STRING ) == INT_CONST ) 
fdir ) 
fdir == NULL ) 
__E__O__F__
argptr , fmt ) 
strlen ( text ) > SIZEOF ( text ) ) 
FOR ( p = ( UNSIGNED CHAR *p ) text ; *v p ; p v++ ) 
) 
select ( INT_CONST , &v fdset , NULL , NULL , &v timeout ) == -v INT_CONST || ! FD_ISSET ( INT_CONST , &v fdset ) ) 
game_library ) 
STRING , gamename ) 
INT_CONST ) 
STRING , dlerror ( ) ) 
VOID *p ) 
parms ) 
) 
( argc + INT_CONST ) * SIZEOF ( CHAR *p ) ) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
newargc , newargv ) 
STRING , STRING , INT_CONST ) 
! nostdout -> value ) 
) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
__E__O__F__
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_DOOR_OPEN , ( DWORD ) NULL ) ) 
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_DOOR_CLOSED , ( DWORD ) NULL ) ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
! enabled ) 
track < INT_CONST || track > maxTrack ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
playing ) 
track , INT_CONST , INT_CONST , INT_CONST ) 
Cvar_VariableValue ( STRING ) ) 
track , looping ) 
! enabled ) 
! enabled ) 
Cmd_Argc ( ) < INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n <= ret ; n v++ ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
! cdValid ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
STRING , STRING , CVAR_ARCHIVE ) 
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_TIME_FORMAT , ( DWORD ) ( LPVOID ) & mciSetParms ) ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
CDAudio_GetAudioDiskInfo ( ) ) 
STRING , CD_f ) 
STRING ) 
__E__O__F__
FOR ( i = INT_CONST ; i < ccom_argc ; i v++ ) 
( t = CCheckParm ( STRING ) ) > INT_CONST ) 
! hFile || ! heventParent || ! heventChild ) 
STRING ) 
NULL , FALSE , FALSE , NULL ) 
! heventDone ) 
! _beginthreadex ( NULL , INT_CONST , RequestProc , NULL , INT_CONST , &v threadAddr ) ) 
STD_OUTPUT_HANDLE ) 
hStdout , INT_CONST , INT_CONST ) 
INT_CONST ) 
dwRet == WAIT_OBJECT_0 + INT_CONST ) 
INT_CONST ) 
hfileBuffer , NEW_LINE FILE_MAP_READ | FILE_MAP_WRITE , INT_CONST , INT_CONST , INT_CONST ) 
NEW_LINE hStdout , NEW_LINE pszText , NEW_LINE INT_CONST * ( iEndLine - iBeginLine + INT_CONST ) , NEW_LINE coord , NEW_LINE &v dwRead ) 
bRet ) 
LPTSTR ) 
*v sz ) 
*v sz == INT_CONST ) 
isalpha ( c ) ) 
! SetConsoleScreenBufferSize ( hStdout , info . dwSize ) ) 
! SetConsoleWindowInfo ( hStdout , TRUE , &v info . srWindow ) ) 
! SetConsoleScreenBufferSize ( hStdout , info . dwSize ) ) 
! SetConsoleWindowInfo ( hStdout , TRUE , &v info . srWindow ) ) 
__E__O__F__
buffer , qglGetString ( GL_RENDERER ) ) 
WNDPROC ) 
&v r , stylebits , FALSE ) 
fullscreen ) 
NEW_LINE exstyle , NEW_LINE WINDOW_CLASS_NAME , NEW_LINE STRING , NEW_LINE stylebits , NEW_LINE x , y , w , h , NEW_LINE NULL , NEW_LINE NULL , NEW_LINE glw_state . hInstance , NEW_LINE NULL ) 
! glw_state . hWnd ) 
! GLimp_InitGL ( ) ) 
glw_state . hWnd ) 
width , height ) 
PRINT_ALL , STRING ) 
PRINT_ALL , STRING , mode ) 
! ri . Vid_GetModeInfo ( &v width , &v height , mode ) ) 
PRINT_ALL , STRING , width , height , win_fs [ fullscreen ] ) 
glw_state . hWnd ) 
fullscreen ) 
glw_state . log_fp ) 
WINDOW_CLASS_NAME , glw_state . hInstance ) 
gl_state . fullscreen ) 
vinfo ) 
GetVersionEx ( &v vinfo ) ) 
HINSTANCE ) 
strstr ( gl_driver -> string , STRING ) != INT_CONST ) 
glw_state . minidriver ) 
! ( pfd . dwFlags & PFD_STEREO ) && ( stereo -> value != INT_CONST ) ) 
( glw_state . hGLRC = qwglCreateContext ( glw_state . hDC ) ) == INT_CONST ) 
! qwglMakeCurrent ( glw_state . hDC , glw_state . hGLRC ) ) 
! VerifyDriver ( ) ) 
PRINT_ALL , STRING , ( INT ) pfd . cColorBits , ( INT ) pfd . cDepthBits ) 
glw_state . hGLRC ) 
glw_state . hDC ) 
camera_separation < INT_CONST && gl_state . stereo_enabled ) 
) 
stricmp ( gl_drawbuffer -> string , STRING ) == INT_CONST ) 
__E__O__F__
! mouseinitialized ) 
mouseparmsvalid ) 
cl_hwnd , &v window_rect ) 
window_center_x , window_center_y ) 
cl_hwnd ) 
NULL ) 
STRING , STRING , CVAR_NOSET ) 
! mouseinitialized ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
! mouseactive ) 
! GetCursorPos ( &v current_pos ) ) 
! mx && ! my ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe -> value && mlooking ) ) 
mx || my ) 
STRING , STRING , INT_CONST ) 
STRING , STRING , CVAR_ARCHIVE ) 
STRING , STRING , INT_CONST ) 
STRING , IN_MLookDown ) 
STRING , Joy_AdvancedUpdate_f ) 
) 
! cl . refresh_prepped NEW_LINE || cls . key_dest == key_console NEW_LINE || cls . key_dest == key_menu ) 
) 
ActiveApp ) 
STRING , STRING , CVAR_NOSET ) 
FOR ( joy_id = INT_CONST ; joy_id < numdevs ; joy_id v++ ) 
mmr != JOYERR_NOERROR ) 
&v jc , INT_CONST , SIZEOF ( jc ) ) 
STRING ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
joy_advanced -> value == FLOAT_CONST ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
! joy_avail ) 
FOR ( i = INT_CONST ; i < joy_numbuttons ; i v++ ) 
joy_haspov ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
joyGetPosEx ( joy_id , &v ji ) == JOYERR_NOERROR ) 
joy_advancedinit != true ) 
! joy_avail || ! in_joystick -> value ) 
IN_ReadJoystick ( ) != true ) 
( in_speed . state & INT_CONST ) ^ ( INT ) cl_run -> value ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
__E__O__F__
a -> type == NA_BROADCAST ) 
a . type == NA_IPX ) 
a . type == NA_IPX ) 
a . type == NA_LOOPBACK ) 
CHAR *p s , STRUCT sockaddr * sadr ) 
FOR ( colon = copy ; *v colon ; colon v++ ) 
! NET_StringToSockaddr ( s , &v sadr ) ) 
loop -> send - loop -> get > MAX_LOOPBACK ) 
net_message -> data , loop -> msgs [ i ] . data , loop -> msgs [ i ] . datalen ) 
MAX_LOOPBACK - INT_CONST ) 
loop -> msgs [ i ] . data , data , length ) 
NET_GetLoopPacket ( sock , net_from , net_message ) ) 
FOR ( protocol = INT_CONST ; protocol < INT_CONST ; protocol v++ ) 
to . type == NA_LOOPBACK ) 
to . type == NA_BROADCAST ) 
net_socket , data , length , INT_CONST , &v addr , SIZEOF ( addr ) ) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
ioctlsocket ( newsocket , FIONBIO , &v _true ) == -v INT_CONST ) 
setsockopt ( newsocket , SOL_SOCKET , SO_BROADCAST , ( CHAR *p ) & i , SIZEOF ( i ) ) == -v INT_CONST ) 
! net_interface || ! net_interface [ INT_CONST ] || ! stricmp ( net_interface , STRING ) ) 
bind ( newsocket , ( VOID *p ) & address , SIZEOF ( address ) ) == -v INT_CONST ) 
STRING , STRING , CVAR_NOSET ) 
STRING ) 
! ip_sockets [ NS_SERVER ] ) 
dedicated ) 
( newsocket = socket ( PF_IPX , SOCK_DGRAM , NSPROTO_IPX ) ) == -v INT_CONST ) 
ioctlsocket ( newsocket , FIONBIO , &v _true ) == -v INT_CONST ) 
setsockopt ( newsocket , SOL_SOCKET , SO_BROADCAST , ( CHAR *p ) & _true , SIZEOF ( _true ) ) == -v INT_CONST ) 
address . sa_netnum , INT_CONST , INT_CONST ) 
STRING ) 
! ipx_sockets [ NS_SERVER ] ) 
dedicated ) 
old_config == multiplayer ) 
! multiplayer ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! noudp -> value ) 
! dedicated || ! dedicated -> value ) 
MAKEWORD ( INT_CONST , INT_CONST ) , &v winsockdata ) 
STRING , STRING , CVAR_NOSET ) 
STRING , STRING , INT_CONST ) 
) 
) 
__E__O__F__
( glw_state . hinstOpenGL = LoadLibrary ( dllname ) ) == INT_CONST ) 
STRING ) 
STRING ) 
STRING ) 
__E__O__F__
NULL , maxsize , MEM_RESERVE , PAGE_NOACCESS ) 
size + INT_CONST ) 
membase , cursize + size , MEM_COMMIT , PAGE_READWRITE ) 
membase , cursize , MEM_COMMIT , PAGE_READONLY ) 
! initialized ) 
) 
findhandle ) 
path , findbase ) 
findhandle == -v INT_CONST ) 
__E__O__F__
WINAPI * QDirectDrawCreate ) 
PRINT_ALL , STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! sww_state . hinstDDRAW ) 
( QDirectDrawCreate = ( HRESULT ( WINAPI * ) ( GUID FAR * , LPDIRECTDRAW FAR * , IUnknown FAR * ) ) GetProcAddress ( sww_state . hinstDDRAW , STRING ) ) == NULL ) 
PRINT_ALL , STRING ) 
PRINT_ALL , STRING ) 
PRINT_ALL , STRING ) 
&v ddsd , INT_CONST , SIZEOF ( ddsd ) ) 
PRINT_ALL , STRING ) 
sww_state . lpddsFrontBuffer , &v ddscaps ) 
PRINT_ALL , STRING ) 
&v ddsd , INT_CONST , SIZEOF ( ddsd ) ) 
PRINT_ALL , STRING ) 
PRINT_ALL , STRING ) 
PRINT_ALL , STRING ) 
( CONST UNSIGNED CHAR *p ) sw_state . currentpalette ) 
&v ddsd , INT_CONST , SIZEOF ( ddsd ) ) 
FOR ( i = INT_CONST ; i < vid . height ; i v++ ) 
PRINT_ALL , STRING ) 
) 
! sww_state . lpddpPalette ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , pal += INT_CONST ) 
sww_state . lpddpPalette -> lpVtbl -> SetEntries ( sww_state . lpddpPalette , NEW_LINE INT_CONST , NEW_LINE INT_CONST , NEW_LINE INT_CONST , NEW_LINE palentries ) != DD_OK ) 
sww_state . lpddsBackBuffer ) 
sww_state . lpddsFrontBuffer ) 
sww_state . lpddpPalette ) 
sww_state . lpDirectDraw ) 
sww_state . hinstDDRAW ) 
__E__O__F__
&v dibheader , INT_CONST , SIZEOF ( dibheader ) ) 
! sww_state . hDC ) 
GetDeviceCaps ( sww_state . hDC , RASTERCAPS ) & RC_PALETTE ) 
BITMAPINFOHEADER ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
sww_state . hDC , NEW_LINE pbmiDIB , NEW_LINE DIB_RGB_COLORS , NEW_LINE &v sww_state . pDIBBase , NEW_LINE NULL , NEW_LINE INT_CONST ) 
pbmiDIB -> bmiHeader . biHeight > INT_CONST ) 
( sww_state . hdcDIBSection = CreateCompatibleDC ( sww_state . hDC ) ) == NULL ) 
) 
CONST UNSIGNED CHAR *p _pal ) 
sww_state . hdcDIBSection ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , pal += INT_CONST ) 
sww_state . palettized ) 
SetSystemPaletteUse ( hDC , SYSPAL_NOSTATIC ) == SYSPAL_ERROR ) 
FOR ( i = INT_CONST , pal = _pal ; i < INT_CONST ; i v++ , pal += INT_CONST ) 
sww_state . hpalOld ) 
sww_state . hdcDIBSection ) 
sww_state . hDIBSection ) 
sww_state . hDC ) 
FOR ( i = INT_CONST ; i < NUM_SYS_COLORS ; i v++ ) 
__E__O__F__
STRING , STRING , INT_CONST ) 
vid_fullscreen -> value ) 
&v r , stylebits , FALSE ) 
NEW_LINE exstyle , NEW_LINE WINDOW_CLASS_NAME , NEW_LINE STRING , NEW_LINE stylebits , NEW_LINE x , y , w , h , NEW_LINE NULL , NEW_LINE NULL , NEW_LINE sww_state . hInstance , NEW_LINE NULL ) 
! sww_state . hWnd ) 
width , height ) 
) 
vid . width , vid . height , WINDOW_STYLE ) 
! fullscreen ) 
PRINT_ALL , STRING , mode ) 
! ri . Vid_GetModeInfo ( pwidth , pheight , mode ) ) 
PRINT_ALL , STRING , *v pwidth , *v pheight , win_fs [ fullscreen ] ) 
fullscreen ) 
retval != rserr_unknown ) 
! palette ) 
sww_state . hWnd ) 
! VirtualProtect ( ( LPVOID ) startaddr , length , PAGE_READWRITE , &v flOldProtect ) ) 
__E__O__F__
&v format , INT_CONST , SIZEOF ( format ) ) 
&v dsbuf , INT_CONST , SIZEOF ( dsbuf ) ) 
&v dsbcaps , INT_CONST , SIZEOF ( dsbcaps ) ) 
STRING ) 
&v dsbuf , INT_CONST , SIZEOF ( dsbuf ) ) 
pDSBuf , INT_CONST , INT_CONST , DSBPLAY_LOOPING ) 
snd_firsttime ) 
pDSBuf ) 
dma . samplebits / INT_CONST ) 
pDSBuf ) 
pDSPBuf && ( pDSBuf != pDSPBuf ) ) 
STRING ) 
pDS ) 
FOR ( i = INT_CONST ; i < WAV_BUFFERS ; i v++ ) 
pDS ) 
hInstDS ) 
s_khz -> value == INT_CONST ) 
! hInstDS ) 
STRING ) 
dscaps ) 
DS_OK != pDS -> lpVtbl -> GetCaps ( pDS , &v dscaps ) ) 
dscaps . dwFlags & DSCAPS_EMULDRIVER ) 
! DS_CreateBuffers ( ) ) 
STRING ) 
STRING ) 
s_khz -> value == INT_CONST ) 
STRING ) 
STRING ) 
STRING ) 
lpWaveHdr == NULL ) 
STRING ) 
FOR ( i = INT_CONST ; i < WAV_BUFFERS ; i v++ ) 
dma . samplebits / INT_CONST ) 
( VOID *p ) & dma , INT_CONST , SIZEOF ( dma ) ) 
STRING , STRING , INT_CONST ) 
! s_wavonly -> value ) 
snd_firsttime ) 
! dsound_init && ( stat != SIS_NOTAVAIL ) ) 
! dsound_init && ! wav_init ) 
dsound_init ) 
dma . samples - INT_CONST ) 
! pDSBuf ) 
pDSBuf -> lpVtbl -> GetStatus ( pDSBuf , &v dwStatus ) != DS_OK ) 
( hresult = pDSBuf -> lpVtbl -> Lock ( pDSBuf , INT_CONST , gSndBufSize , &v pbuf , &v locksize , NEW_LINE &v pbuf2 , &v dwSize2 , INT_CONST ) ) != DS_OK ) 
! dma . buffer ) 
pDSBuf ) 
INT_CONST ) 
( ( snd_sent - snd_completed ) >> sample16 ) < INT_CONST ) 
__E__O__F__
) 
argptr , error ) 
NULL , text , STRING , INT_CONST COMMENT ) 
qwclsemaphore ) 
INT_CONST ) 
) 
INT_CONST ) 
NEW_LINE FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM , NEW_LINE NULL , NEW_LINE GetLastError ( ) , NEW_LINE MAKELANGID ( LANG_NEUTRAL , SUBLANG_DEFAULT ) , COMMENT_NL CPP_COMMENT NEW_LINE ( LPTSTR ) & lpMsgBuf , NEW_LINE INT_CONST , NEW_LINE NULL NEW_LINE ) 
NULL , lpMsgBuf , STRING , MB_OK | MB_ICONINFORMATION ) 
lpMsgBuf ) 
done ) 
SEM_FAILCRITICALERRORS ) 
FOR ( drive [ INT_CONST ] = CHAR_CONST ; drive [ INT_CONST ] <= CHAR_CONST ; drive [ INT_CONST ] v++ ) 
) 
NEW_LINE NULL , COMMENT NEW_LINE INT_CONST , COMMENT NEW_LINE STRING ) 
NEW_LINE NULL , COMMENT NEW_LINE INT_CONST , COMMENT NEW_LINE INT_CONST , COMMENT NEW_LINE STRING ) 
vinfo ) 
! GetVersionEx ( &v vinfo ) ) 
! dedicated || ! dedicated -> value ) 
FOR ( ; ; ) 
! dedicated || ! dedicated -> value ) 
houtput , string , strlen ( string ) , &v dummy , NULL ) 
console_textlen ) 
) 
OpenClipboard ( NULL ) != INT_CONST ) 
game_library ) 
cwd , SIZEOF ( cwd ) ) 
VOID *p ) 
parms ) 
*v lpCmdLine && ( argc < MAX_NUM_ARGVS ) ) 
hPrevInstance ) 
lpCmdLine ) 
) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
argc , argv ) 
INT_CONST ) 
__E__O__F__
print_level == PRINT_ALL ) 
err_level , STRING , msg ) 
modified > INT_CONST ) 
! is_extended ) 
) 
fActive && ! Minimized ) 
! ActiveApp ) 
uMsg == MSH_MOUSEWHEEL ) 
uMsg ) 
STRING ) 
hWnd , uMsg , wParam , lParam ) 
wParam == SC_SCREENSAVE ) 
MapKey ( lParam ) , false , sys_msg_time ) 
hWnd , uMsg , wParam , lParam ) 
cl_hwnd , GWL_STYLE ) 
cl_hwnd , vid_xpos -> value , vid_ypos -> value , w , h , TRUE ) 
STRING , name ) 
( reflib_library = LoadLibrary ( name ) ) == INT_CONST ) 
( GetRefAPI = ( VOID *p ) GetProcAddress ( reflib_library , STRING ) ) == INT_CONST ) 
re . api_version != API_VERSION ) 
re . Init ( global_hInstance , MainWndProc ) == -v INT_CONST ) 
STRING ) 
vid_ref ) 
win_noalttab -> modified ) 
vid_ref -> modified ) 
vid_xpos -> modified || vid_ypos -> modified ) 
STRING , VID_Restart_f ) 
__E__O__F__
s_ref_list [ s_current_menu_index ] . curvalue == INT_CONST ) 
STRING , slider -> curvalue * INT_CONST ) 
s_current_menu_index == SOFTWARE_MENU ) 
FLOAT_CONST - ( s_brightness_slider [ s_current_menu_index ] . curvalue / FLOAT_CONST - FLOAT_CONST ) ) 
STRING , gamma ) 
s_ref_list [ s_current_menu_index ] . curvalue ) 
STRING , STRING ) 
STRING , STRING ) 
STRING , STRING ) 
STRING , STRING ) 
stricmp ( vid_ref -> string , STRING ) == INT_CONST ) 
envbuffer , SIZEOF ( envbuffer ) , STRING , g ) 
) 
) 
! gl_driver ) 
! scr_viewsize ) 
strcmp ( vid_ref -> string , STRING ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v s_software_menu , ( VOID *p ) & s_ref_list [ SOFTWARE_MENU ] ) 
&v s_opengl_menu , ( VOID *p ) & s_ref_list [ OPENGL_MENU ] ) 
&v s_software_menu , ( VOID *p ) & s_defaults_action [ SOFTWARE_MENU ] ) 
&v s_software_menu ) 
s_current_menu_index == INT_CONST ) 
s_current_menu , INT_CONST ) 
s_current_menu ) 
key ) 
m , INT_CONST ) 
m , -v INT_CONST ) 
m , INT_CONST ) 
! Menu_SelectItem ( m ) ) 
__E__O__F__
b != INT_CONST ) 
FOR ( m = INT_CONST ; m < INT_CONST ; m v++ ) 
&v date [ INT_CONST ] ) 
&v date [ INT_CONST ] ) 
INT ) 
( ( y % INT_CONST ) == INT_CONST ) && m > INT_CONST ) 
time [ INT_CONST ] - CHAR_CONST ) 
__E__O__F__
rb >> INT_CONST ) 
STRUCT reset_s ) 
INT_CONST ) 
STRUCT reset_s ) 
INT_CONST ) 
STRUCT audioTrackInfo_s ) 
INT_CONST ) 
cdRequest -> status & STATUS_ERROR_BIT ) 
control & AUDIO_CONTROL_DATA_TRACK ) 
STRUCT audioDiskInfo_s ) 
INT_CONST ) 
cdRequest -> status & STATUS_ERROR_BIT ) 
FOR ( n = cd . lowTrack ; n <= cd . highTrack ; n v++ ) 
STRUCT audioStatus_s ) 
INT_CONST ) 
cdRequest -> status & STATUS_ERROR_BIT ) 
STRUCT mediaChange_s ) 
INT_CONST ) 
STRUCT audioChannelInfo_s ) 
INT_CONST ) 
INT_CONST ) 
playing ) 
track < cd . lowTrack || track > cd . highTrack ) 
cd . track [ track ] . isData ) 
INT_CONST ) 
cdRequest -> status & STATUS_ERROR_BIT ) 
INT_CONST ) 
INT_CONST ) 
Cmd_Argc ( ) < INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n <= ret ; n v++ ) 
! cd . valid ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = cd . lowTrack ; n <= cd . highTrack ; n v++ ) 
! initialized || ! enabled ) 
mediaCheck ) 
INT ) 
cls . state == ca_dedicated ) 
INT_CONST ) 
) 
SIZEOF ( STRUCT cd_request NEW_LINE ) + SIZEOF ( UNION readInfo_u ) ) 
STRUCT cd_request * ) 
UNION readInfo_u * ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
INT_CONST ) 
STRING , CD_f ) 
STRING ) 
__E__O__F__
ioctl ( cdfile , CDROMREADTOCHDR , &v tochdr ) == -v INT_CONST ) 
cdfile == -v INT_CONST || ! enabled ) 
track < INT_CONST || track > maxTrack ) 
ioctl ( cdfile , CDROMREADTOCENTRY , &v entry ) == -v INT_CONST ) 
playing ) 
ioctl ( cdfile , CDROMPLAYTRKIND , &v ti ) == -v INT_CONST ) 
cdvolume == FLOAT_CONST ) 
Cmd_Argc ( ) < INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n <= ret ; n v++ ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
! cdValid ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
! enabled ) 
playing && lastchk < time ( NULL ) ) 
cls . state == ca_dedicated ) 
( cdfile = open ( cd_dev , O_RDONLY ) ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
CDAudio_GetAudioDiskInfo ( ) ) 
STRING , CD_f ) 
STRING ) 
__E__O__F__
__E__O__F__
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_DOOR_OPEN , ( DWORD ) NULL ) ) 
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_DOOR_CLOSED , ( DWORD ) NULL ) ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
! enabled ) 
track < INT_CONST || track > maxTrack ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
playing ) 
track , INT_CONST , INT_CONST , INT_CONST ) 
cdvolume == FLOAT_CONST ) 
! enabled ) 
! enabled ) 
Cmd_Argc ( ) < INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n <= ret ; n v++ ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
! cdValid ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
cls . state == ca_dedicated ) 
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_TIME_FORMAT , ( DWORD ) ( LPVOID ) & mciSetParms ) ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
CDAudio_GetAudioDiskInfo ( ) ) 
STRING , CD_f ) 
__E__O__F__
st , STRING , playernum ) 
vec3_origin , pmove . physents [ INT_CONST ] . origin ) 
player_state_t * self , player_state_t * player , vec3_t vec , qboolean checkvis ) 
vec , v ) 
player -> origin , v ) 
player -> origin , vec ) 
player -> origin , vec , v ) 
player -> viewangles , vec ) 
vec3_origin , forward , vec2 ) 
vec3_origin , right , vec2 ) 
max >= INT_CONST ) 
FOR ( i = INT_CONST , max = -v INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
usercmd_t * cmd ) 
! cl . spectator ) 
! locked || ! Cam_IsVisible ( player , desired_position ) ) 
current ) 
current == ideal ) 
current + move ) 
cls . state != ca_active || ! cl . spectator || NEW_LINE ! autocam || ! locked ) 
player -> origin , cl . simorg , vec ) 
cls . state != ca_active ) 
autocam && locked ) 
autocam && cl_hightrack . value ) 
locked ) 
locked && autocam ) 
s -> name [ INT_CONST ] && ! s -> spectator ) 
__E__O__F__
cls . timedemo ) 
( FLOAT ) realtime ) 
&v c , SIZEOF ( c ) , INT_CONST , cls . demofile ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v cmd , SIZEOF ( cmd ) , INT_CONST , cls . demofile ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cls . demofile ) 
! cls . demorecording ) 
&v c , SIZEOF ( c ) , INT_CONST , cls . demofile ) 
msg -> cursize ) 
cls . demofile ) 
&v demotime , SIZEOF ( demotime ) , INT_CONST , cls . demofile ) 
cls . timedemo ) 
realtime + FLOAT_CONST < demotime ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v net_message . cursize , INT_CONST , INT_CONST , cls . demofile ) 
net_message . cursize > MAX_MSGLEN ) 
&v i , INT_CONST , INT_CONST , cls . demofile ) 
STRING ) 
&v net_message ) 
&v net_message , svc_disconnect ) 
cls . demofile ) 
! cls . demorecording ) 
&v c , SIZEOF ( c ) , INT_CONST , cls . demofile ) 
msg -> cursize + INT_CONST ) 
seq ) 
msg -> data , msg -> cursize , INT_CONST , cls . demofile ) 
cls . demofile ) 
! cls . demorecording ) 
&v c , SIZEOF ( c ) , INT_CONST , cls . demofile ) 
cls . netchan . outgoing_sequence ) 
cls . demofile ) 
) 
cls . state != ca_active ) 
cls . demorecording ) 
name , STRING ) 
STRING , name ) 
&v buf , INT_CONST , SIZEOF ( buf ) ) 
&v buf , svc_serverdata ) 
cl . spectator ) 
&v buf , cl . levelname ) 
&v buf , movevars . gravity ) 
&v buf , svc_cdtrack ) 
&v buf , svc_stufftext ) 
&v buf , seq v++ ) 
&v buf , svc_soundlist ) 
*v s ) 
*v s ) 
FOR ( i = INT_CONST ; i < cl . num_statics ; i v++ ) 
FOR ( j = INT_CONST ; j < MAX_MODELS ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
&v blankes , INT_CONST , SIZEOF ( blankes ) ) 
FOR ( i = INT_CONST ; i < MAX_EDICTS ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
&v buf , svc_stufftext ) 
buf . cursize ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTSTYLES ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_CL_STATS ; i v++ ) 
&v buf , svc_updatestatlong ) 
&v buf , svc_updatestatlong ) 
&v buf , svc_updatestatlong ) 
&v buf , svc_stufftext ) 
&v buf , seq v++ ) 
) 
) 
! *v cls . servername ) 
cls . demorecording ) 
name , STRING ) 
STRING , name ) 
) 
Cmd_Argc ( ) != INT_CONST ) 
) 
name , Cmd_Argv ( INT_CONST ) ) 
STRING , name ) 
&v cls . netchan , net_from , INT_CONST ) 
host_framecount - cls . td_startframe ) 
) 
__E__O__F__
key ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
dl , INT_CONST , SIZEOF ( *v dl ) ) 
key ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
bits & U_MOREBITS ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
&v olde , INT_CONST , SIZEOF ( olde ) ) 
INT_CONST ) 
delta ) 
INT_CONST ) 
INT_CONST * cl . time ) 
FOR ( pnum = INT_CONST ; pnum < pack -> num_entities ; pnum v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < cl_oldnumvisedicts ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST , pr = cl_projectiles ; i < cl_num_projectiles ; i v++ , pr v++ ) 
) 
) 
) 
) 
flags & PF_MSEC ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl_flagindex == -v INT_CONST ) 
) 
ent -> angles , v_forward , v_right , v_up ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent -> angles , newent -> angles ) 
playertime > realtime ) 
FOR ( j = INT_CONST , info = cl . players , state = frame -> playerstate ; j < MAX_CLIENTS NEW_LINE ; j v++ , info v++ , state v++ ) 
vec3_origin , pmove . physents [ INT_CONST ] . origin ) 
FOR ( i = INT_CONST ; i < pak -> num_entities ; i v++ ) 
playertime > realtime ) 
FOR ( j = INT_CONST , pplayer = predicted_players , state = frame -> playerstate ; NEW_LINE j < MAX_CLIENTS ; NEW_LINE j v++ , pplayer v++ , state v++ ) 
state , &v exact , &v state -> command , false ) 
! cl_solid_players . value ) 
FOR ( j = INT_CONST , pplayer = predicted_players ; j < MAX_CLIENTS ; j v++ , pplayer v++ ) 
! pplayer -> active ) 
) 
__E__O__F__
b -> down [ INT_CONST ] == k ) 
up || down ) 
cmd , INT_CONST , SIZEOF ( *v cmd ) ) 
&v in_moveright ) 
&v in_up ) 
! ( in_klook . state & INT_CONST ) ) 
in_speed . state & INT_CONST ) 
++v cl . movemessages <= INT_CONST ) 
ms > INT_CONST ) 
cl . viewangles , cmd -> angles ) 
cmd -> forwardmove ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cls . demoplayback ) 
cmd ) 
cmd ) 
cl . spectator ) 
cmd ) 
&v buf , clc_move ) 
&v buf , INT_CONST ) 
) 
cls . netchan . outgoing_sequence - INT_CONST ) 
cls . netchan . outgoing_sequence - INT_CONST ) 
cls . netchan . outgoing_sequence ) 
NEW_LINE buf . data + checksumIndex + INT_CONST , buf . cursize - checksumIndex - INT_CONST , NEW_LINE seq_hash ) 
cls . netchan . outgoing_sequence - cl . validsequence >= UPDATE_BACKUP - INT_CONST ) 
&v cl_nodelta ) 
__E__O__F__
! NET_StringToAdr ( cls . servername , &v adr ) ) 
! NET_IsClientLegal ( &v adr ) ) 
adr . port == INT_CONST ) 
STRING ) 
cls . userinfo , STRING , NET_AdrToString ( adr ) , MAX_INFO_STRING ) 
data , STRING , NEW_LINE INT_CONST , INT_CONST , INT_CONST , INT_CONST , PROTOCOL_VERSION , cls . qport , cls . challenge , cls . userinfo ) 
connect_time == -v INT_CONST ) 
adr . port == INT_CONST ) 
STRING , cls . servername ) 
Cmd_Argc ( ) != INT_CONST ) 
INT_CONST ) 
cls . servername , server , SIZEOF ( cls . servername ) - INT_CONST ) 
! rcon_password . string ) 
message , STRING ) 
message , rcon_password . string ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
cls . state >= ca_connected ) 
STRING ) 
true ) 
STRING ) 
host_hunklevel ) 
&v cl , INT_CONST , SIZEOF ( cl ) ) 
&v cls . netchan . message ) 
cl_efrags , INT_CONST , SIZEOF ( cl_efrags ) ) 
FOR ( i = INT_CONST ; i < MAX_EFRAGS - INT_CONST ; i v++ ) 
mainwindow , STRING ) 
cls . demoplayback ) 
final + INT_CONST , STRING ) 
cls . download ) 
) 
Cmd_Argc ( ) != INT_CONST ) 
Cmd_Argv ( INT_CONST ) ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
STRING , c ) 
Cmd_Argc ( ) == INT_CONST ) 
Cmd_Argc ( ) == INT_CONST ) 
Cmd_Argc ( ) != INT_CONST ) 
cl . serverinfo , Cmd_Argv ( INT_CONST ) ) 
( p = Info_ValueForKey ( cl . serverinfo , STRING ) ) && *v p ) 
Cmd_Argc ( ) != INT_CONST ) 
INT_CONST ) 
Cmd_Argc ( ) != INT_CONST ) 
! NET_StringToAdr ( Cmd_Argv ( INT_CONST ) , &v adr ) ) 
INT_CONST ) 
in ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
out - send , send , adr ) 
cls . demonum == -v INT_CONST ) 
str , STRING , cls . demos [ cls . demonum ] ) 
true ) 
STRING ) 
true ) 
cls . state == ca_connected ) 
! *v cls . servername ) 
) 
) 
c == A2C_CLIENT_COMMAND ) 
c == A2C_PRINT ) 
c == A2A_PING ) 
c == S2C_CHALLENGE ) 
c == svc_disconnect ) 
cls . state >= ca_connected NEW_LINE && realtime - cls . netchan . last_received > cl_timeout . value ) 
VOID ) 
cls . state == ca_disconnected ) 
Cmd_Argc ( ) != INT_CONST ) 
cls . downloadname , STRING , com_gamedir , Cmd_Argv ( INT_CONST ) ) 
FOR ( ; ; ) 
cls . downloadtempname , cls . downloadname ) 
&v cls . netchan . message , clc_stringcmd ) 
cls . userinfo , STRING , STRING , MAX_INFO_STRING ) 
) 
&v show_fps ) 
&v cl_warncmd ) 
&v m_pitch ) 
&v rcon_password ) 
&v entlatency ) 
&v localid ) 
&v baseskin ) 
&v name ) 
STRING , CL_Version_f ) 
STRING , CL_Changing_f ) 
STRING , Skin_Skins_f ) 
STRING , CL_Quit_f ) 
STRING , CL_Connect_f ) 
STRING , CL_Rcon_f ) 
STRING , CL_SetInfo_f ) 
STRING , CL_Color_f ) 
STRING , CL_NextUpload ) 
STRING , NULL ) 
STRING , CL_Windows_f ) 
STRING , string ) 
host_initialized ) 
f ) 
oldrealtime > realtime ) 
oldrealtime > realtime ) 
) 
) 
) 
cls . state == ca_disconnected ) 
false ) 
) 
true ) 
) 
host_speeds . value ) 
host_speeds . value ) 
cls . state == ca_active ) 
STRING ) 
COM_CheckParm ( STRING ) ) 
parms -> memsize < MINIMUM_MEMORY ) 
) 
) 
STRING ) 
STRING , parms -> memsize / ( INT_CONST * FLOAT_CONST ) ) 
) 
INT_CONST , STRING ) 
STRING , VERSION , build_number ( ) ) 
STRING ) 
) 
__E__O__F__
FOR ( i = cls . netchan . outgoing_sequence - UPDATE_BACKUP + INT_CONST NEW_LINE ; i <= cls . netchan . outgoing_sequence NEW_LINE ; i v++ ) 
FOR ( a = INT_CONST ; a < NET_TIMINGS ; a v++ ) 
strstr ( filename , STRING ) ) 
filename , &v f ) 
f ) 
cls . demorecording ) 
cls . demoplayback ) 
cls . downloadname , cls . downloadtempname ) 
&v cls . netchan . message , clc_stringcmd ) 
cls . downloadnumber == INT_CONST ) 
FOR ( NEW_LINE ; cl . model_name [ cls . downloadnumber ] [ INT_CONST ] NEW_LINE ; cls . downloadnumber v++ ) 
FOR ( i = INT_CONST ; i < MAX_MODELS ; i v++ ) 
STRING NEW_LINE STRING , gamedirfile ) 
) 
&v cls . netchan . message , clc_stringcmd ) 
cls . downloadnumber == INT_CONST ) 
FOR ( NEW_LINE ; cl . sound_name [ cls . downloadnumber ] [ INT_CONST ] NEW_LINE ; cls . downloadnumber v++ ) 
FOR ( i = INT_CONST ; i < MAX_SOUNDS ; i v++ ) 
cl . model_precache , INT_CONST , SIZEOF ( cl . model_precache ) ) 
) 
) 
) 
STRING ) 
) 
cls . demoplayback ) 
size == -v INT_CONST ) 
! cls . download ) 
net_message . data + msg_readcount , INT_CONST , size , cls . download ) 
percent != INT_CONST ) 
! upload_data ) 
! size ) 
STRING , upload_pos - r , r ) 
upload_data ) 
upload_data ) 
) 
) 
) 
stricmp ( gamedirfile , str ) ) 
str ) 
cflag ) 
) 
) 
) 
STRING ) 
cl . sound_name , INT_CONST , SIZEOF ( cl . sound_name ) ) 
) 
FOR ( ; ; ) 
) 
n ) 
) 
) 
FOR ( ; ; ) 
) 
n ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v es ) 
es . origin , ent -> origin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent > MAX_EDICTS ) 
latency < INT_CONST || latency > FLOAT_CONST ) 
latency < cls . latency ) 
slot > MAX_CLIENTS ) 
s , Info_ValueForKey ( player -> userinfo , STRING ) ) 
FOR ( i = INT_CONST ; i < VID_GRADES ; i v++ , dest += INT_CONST , source += INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
) 
slot , player ) 
) 
key , MSG_ReadString ( ) , SIZEOF ( key ) - INT_CONST ) 
STRING , player -> name , key , value ) 
player -> userinfo , key , value , MAX_INFO_STRING ) 
slot , player ) 
key , MSG_ReadString ( ) , SIZEOF ( key ) - INT_CONST ) 
STRING , key , value ) 
cl . serverinfo , key , value , MAX_SERVERINFO_STRING ) 
) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
) 
( UNSIGNED ) ( i - INT_CONST ) >= MAX_CLIENTS ) 
i - INT_CONST == cl . playernum && gl_flashblend . value ) 
i ) 
) 
cl_shownet . value == INT_CONST ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < i ; j v++ ) 
) 
__E__O__F__
PM_HullPointContents ( &v cl . model_precache [ INT_CONST ] -> hulls [ INT_CONST ] , INT_CONST , pmove . origin ) == CONTENTS_EMPTY ) 
FOR ( x = -v INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = -v INT_CONST ; y <= INT_CONST ; y v++ ) 
u -> msec > INT_CONST ) 
from -> origin , pmove . origin ) 
) 
cl_pushlatency . value > INT_CONST ) 
cls . state == ca_onserver ) 
text , STRING , cls . servername ) 
cl_nopred . value ) 
cl . playernum ) 
FOR ( i = INT_CONST ; i < UPDATE_BACKUP - INT_CONST && cls . netchan . incoming_sequence + i < NEW_LINE cls . netchan . outgoing_sequence ; i v++ ) 
i == UPDATE_BACKUP - INT_CONST || ! to ) 
to -> senttime == from -> senttime ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAX_EXPLOSIONS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_EXPLOSIONS ; i v++ ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
start , b -> start ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
start , b -> start ) 
) 
) 
) 
) 
-v INT_CONST , INT_CONST , cl_sfx_ric1 , pos , INT_CONST , INT_CONST ) 
) 
-v INT_CONST , INT_CONST , cl_sfx_ric1 , pos , INT_CONST , INT_CONST ) 
) 
) 
Mod_ForName ( STRING , true ) ) 
Mod_ForName ( STRING , true ) ) 
Mod_ForName ( STRING , true ) ) 
) 
) 
) 
) 
) 
STRING ) 
cl_numvisedicts == MAX_VISEDICTS ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
b -> entity == cl . playernum + INT_CONST ) 
b -> end , b -> start , dist ) 
b -> start , org ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID ) 
FOR ( i = INT_CONST , ex = cl_explosions ; i < MAX_EXPLOSIONS ; i v++ , ex v++ ) 
__E__O__F__
templen ) 
FOR ( i = INT_CONST ; i < cmd_text . cursize ; i v++ ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
s + INT_CONST ) 
FOR ( i = INT_CONST ; i < s - INT_CONST ; i v++ ) 
FOR ( j = i ; ( text [ j ] != CHAR_CONST ) && ( text [ j ] != CHAR_CONST ) && ( text [ j ] != INT_CONST ) ; j v++ ) 
Cmd_Argc ( ) != INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
INT_CONST ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
! a ) 
) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( i = INT_CONST ; i < cmd_argc ; i v++ ) 
CHAR *p cmd_name , xcommand_t function ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
SIZEOF ( cmd_function_t ) ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
Q_strcasecmp ( Cmd_Argv ( INT_CONST ) , STRING ) == INT_CONST ) 
text ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
! Cvar_Command ( ) && ( cl_warncmd . value || developer . value ) ) 
CHAR *p parm ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
str [ INT_CONST ] == CHAR_CONST ) 
INT_CONST ) 
str [ INT_CONST ] == CHAR_CONST ) 
INT_CONST ) 
decimal == -v INT_CONST ) 
l >> INT_CONST ) 
b1 << INT_CONST ) 
l >> INT_CONST ) 
( INT ) b1 << INT_CONST ) 
cmd -> angles [ INT_CONST ] != from -> angles [ INT_CONST ] ) 
move , from , SIZEOF ( *v move ) ) 
) 
bits & CM_BUTTONS ) 
sizebuf_t * buf , CHAR *p data ) 
*v in && *v in != CHAR_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST && *v in ; i v++ , in v++ ) 
FOR ( s2 = s ; *v s2 && *v s2 != CHAR_CONST ; s2 v-- ) 
*v src != CHAR_CONST && src != path ) 
path , extension ) 
c == CHAR_CONST && data [ INT_CONST ] == CHAR_CONST ) 
c == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
STRING , &v h ) 
! h ) 
check , INT_CONST , SIZEOF ( check ) , h ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( com_argc = INT_CONST ; ( com_argc < MAX_NUM_ARGVS ) && ( com_argc < argc ) ; NEW_LINE com_argc v++ ) 
safe ) 
FOR ( i = INT_CONST ; i < NUM_SAFE_ARGVS ; i v++ ) 
*v ( SHORT *p ) swaptest == INT_CONST ) 
&v registered ) 
) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
f ) 
path , STRING ) 
FOR ( s = com_searchpaths ; s ; s = s -> next ) 
FOR ( ofs = path + INT_CONST ; *v ofs ; ofs v++ ) 
in ) 
FOR ( search = com_searchpaths ; search ; search = search -> next ) 
search -> pack ) 
FOR ( i = INT_CONST ; i < pak -> numfiles ; i v++ ) 
path , &v h ) 
path , base ) 
COM_FileOpenRead ( packfile , &v packhandle ) == -v INT_CONST ) 
dpackfile_t ) 
numpackfiles > MAX_FILES_IN_PACK ) 
packhandle , header . dirofs , SEEK_SET ) 
( byte * ) info , header . dirlen ) 
crc != PAK0_CRC ) 
FOR ( i = INT_CONST ; i < numpackfiles ; i v++ ) 
SIZEOF ( pack_t ) ) 
( p = strrchr ( dir , CHAR_CONST ) ) != NULL ) 
SIZEOF ( searchpath_t ) ) 
FOR ( i = INT_CONST ; ; i v++ ) 
strstr ( dir , STRING ) || strstr ( dir , STRING ) NEW_LINE || strstr ( dir , STRING ) || strstr ( dir , STRING ) ) 
! strcmp ( gamedirfile , dir ) ) 
com_searchpaths != com_base_searchpaths ) 
) 
! strcmp ( dir , STRING ) || ! strcmp ( dir , STRING ) ) 
SIZEOF ( searchpath_t ) ) 
FOR ( i = INT_CONST ; ; i v++ ) 
STRING ) 
valueindex + INT_CONST ) 
strstr ( key , STRING ) ) 
INT_CONST ) 
INT_CONST ) 
strstr ( key , STRING ) || strstr ( value , STRING ) ) 
strlen ( key ) > INT_CONST || strlen ( value ) > INT_CONST ) 
*v ( v = Info_ValueForKey ( s , key ) ) ) 
( INT ) ( strlen ( new ) + strlen ( s ) ) > maxsize ) 
s ) 
s , key , value , maxsize ) 
*v s == CHAR_CONST ) 
last_mapchecksum != mapchecksum ) 
sequence % ( SIZEOF ( chktbl ) - INT_CONST ) ) 
length > INT_CONST ) 
sequence & INT_CONST ) 
Com_BlockChecksum ( chkbuf , length ) ) 
sequence % ( SIZEOF ( chktbl ) - INT_CONST ) ) 
length > INT_CONST ) 
sequence & INT_CONST ) 
chkb , length ) 
b != INT_CONST ) 
FOR ( m = INT_CONST ; m < INT_CONST ; m v++ ) 
&v date [ INT_CONST ] ) 
&v date [ INT_CONST ] ) 
INT ) 
( ( y % INT_CONST ) == INT_CONST ) && m > INT_CONST ) 
__E__O__F__
key_dest == key_console ) 
key_dest == key_console ) 
FOR ( i = INT_CONST ; i < NUM_CON_TIMES ; i v++ ) 
vid . width >> INT_CONST ) 
width == con_linewidth ) 
FOR ( i = INT_CONST ; i < numlines ; i v++ ) 
FOR ( j = INT_CONST ; j < numchars ; j v++ ) 
) 
STRING , Con_ToggleConsole_f ) 
txt [ INT_CONST ] == INT_CONST || txt [ INT_CONST ] == INT_CONST ) 
FOR ( l = INT_CONST ; l < con_linewidth ; l v++ ) 
l != con_linewidth && ( con -> x + l > con_linewidth ) ) 
cr ) 
STRING , msg ) 
con_debuglog ) 
cls . state != ca_active ) 
! inupdate ) 
key_dest != key_console && cls . state == ca_active ) 
( INT ) ( realtime * con_cursorspeed ) & INT_CONST ) 
FOR ( i = key_linepos + INT_CONST ; i < con_linewidth ; i v++ ) 
FOR ( i = INT_CONST ; i < con_linewidth ; i v++ ) 
FOR ( i = con -> current - NUM_CON_TIMES + INT_CONST ; i <= con -> current ; i v++ ) 
FOR ( x = INT_CONST ; x < con_linewidth ; x v++ ) 
key_dest == key_message ) 
s [ x ] ) 
lines - INT_CONST ) 
con -> display != con -> current ) 
FOR ( x = INT_CONST ; x < con_linewidth ; x += INT_CONST ) 
FOR ( i = INT_CONST ; i < rows ; i v++ , y -= INT_CONST , row v-- ) 
FOR ( x = INT_CONST ; x < con_linewidth ; x v++ ) 
cls . download ) 
dlbar , STRING ) 
dlbar , text ) 
FOR ( j = INT_CONST ; j < y ; j v++ ) 
dlbar + strlen ( dlbar ) , STRING , cls . downloadpercent ) 
FOR ( i = INT_CONST ; i < strlen ( dlbar ) ; i v++ ) 
) 
STRING ) 
text ) 
STRING ) 
STRING ) 
__E__O__F__
&v crc ) 
__E__O__F__
FOR ( var = cvar_vars ; var ; var = var -> next ) 
FOR ( cvar = cvar_vars ; cvar ; cvar = cvar -> next ) 
FOR ( cvar = cvar_vars ; cvar ; cvar = cvar -> next ) 
STRING , var_name ) 
var -> info ) 
Cvar_FindVar ( variable -> name ) ) 
Cmd_Exists ( variable -> name ) ) 
value , variable -> string ) 
Cmd_Argv ( INT_CONST ) ) 
v -> name , Cmd_Argv ( INT_CONST ) ) 
FOR ( var = cvar_vars ; var ; var = var -> next ) 
__E__O__F__
FOR ( pic = menu_cachepics , i = INT_CONST ; i < menu_numcachepics ; pic v++ , i v++ ) 
&v pic -> cache ) 
dat ) 
dat ) 
y < INT_CONST ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
UNSIGNED SHORT *p ) 
r_pixbytes == INT_CONST ) 
UNSIGNED SHORT *p ) 
crosshair . value == INT_CONST ) 
! vid . direct ) 
row << INT_CONST ) 
drawline v-- ) 
( x < INT_CONST ) || NEW_LINE ( x + pic -> width > vid . width ) || NEW_LINE ( y < INT_CONST ) || NEW_LINE ( y + pic -> height > vid . height ) ) 
r_pixbytes == INT_CONST ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
UNSIGNED SHORT *p ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
( x < INT_CONST ) || NEW_LINE ( x + width > vid . width ) || NEW_LINE ( y < INT_CONST ) || NEW_LINE ( y + height > vid . height ) ) 
r_pixbytes == INT_CONST ) 
FOR ( v = INT_CONST ; v < height ; v v++ ) 
UNSIGNED SHORT *p ) 
FOR ( v = INT_CONST ; v < height ; v v++ ) 
FOR ( u = srcx ; u < ( srcx + width ) ; u v++ ) 
x < INT_CONST || ( UNSIGNED ) ( x + pic -> width ) > vid . width || y < INT_CONST || NEW_LINE ( UNSIGNED ) ( y + pic -> height ) > vid . height ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u += INT_CONST ) 
UNSIGNED SHORT *p ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
x < INT_CONST || ( UNSIGNED ) ( x + pic -> width ) > vid . width || y < INT_CONST || NEW_LINE ( UNSIGNED ) ( y + pic -> height ) > vid . height ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u += INT_CONST ) 
UNSIGNED SHORT *p ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
row << INT_CONST ) 
drawline v-- ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
STRING ) 
cls . download ) 
saveback , conback -> data + INT_CONST * INT_CONST , INT_CONST * INT_CONST ) 
FOR ( x = INT_CONST ; x < strlen ( ver ) ; x v++ ) 
r_pixbytes == INT_CONST ) 
FOR ( y = INT_CONST ; y < lines ; y v++ , dest += vid . conrowbytes ) 
FOR ( x = INT_CONST ; x < vid . conwidth ; x += INT_CONST ) 
FOR ( y = INT_CONST ; y < lines ; y v++ , pusdest += ( vid . conrowbytes >> INT_CONST ) ) 
FOR ( x = INT_CONST ; x < vid . conwidth ; x += INT_CONST ) 
conback -> data + INT_CONST * INT_CONST , saveback , INT_CONST * INT_CONST ) 
prect -> y * vid . rowbytes ) 
transparent ) 
FOR ( i = INT_CONST ; i < prect -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < prect -> width ; j v++ ) 
FOR ( i = INT_CONST ; i < prect -> height ; i v++ ) 
UNSIGNED SHORT *p ) 
transparent ) 
FOR ( i = INT_CONST ; i < prect -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < prect -> width ; j v++ ) 
FOR ( i = INT_CONST ; i < prect -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < prect -> width ; j v++ ) 
height > INT_CONST ) 
x < INT_CONST || x + w > vid . width || NEW_LINE y < INT_CONST || y + h > vid . height ) 
r_pixbytes == INT_CONST ) 
FOR ( v = INT_CONST ; v < h ; v v++ , dest += vid . rowbytes ) 
FOR ( u = INT_CONST ; u < w ; u v++ ) 
FOR ( v = INT_CONST ; v < h ; v v++ , pusdest += ( vid . rowbytes >> INT_CONST ) ) 
FOR ( u = INT_CONST ; u < w ; u v++ ) 
) 
FOR ( y = INT_CONST ; y < vid . height ; y v++ ) 
byte * ) 
FOR ( x = INT_CONST ; x < vid . width ; x v++ ) 
) 
__E__O__F__
scale >= d_scalemip [ INT_CONST ] ) 
FOR ( span = surf -> spans ; span ; span = span -> pnext ) 
FOR ( u v++ ; u <= u2 ; u v++ ) 
FOR ( u v++ ; u & INT_CONST ; u v++ ) 
FOR ( ; u <= u2 ; u += INT_CONST ) 
FOR ( ; u <= u2 ; u v++ ) 
FLOAT ) 
pface -> texinfo -> vecs [ INT_CONST ] , p_saxis ) 
transformed_modelorg , mipscale , p_temp1 ) 
( fixed16_t ) ( DotProduct ( p_temp1 , p_saxis ) * INT_CONST + FLOAT_CONST ) ) 
modelorg , transformed_modelorg ) 
r_drawflat . value ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
pface -> texinfo -> texture -> offsets [ INT_CONST ] ) 
base_vup , vup ) 
base_vright , vright ) 
base_vup , vup ) 
base_vright , vright ) 
__E__O__F__
rx < INT_CONST ) 
( ( rwidth & INT_CONST ) == INT_CONST ) && ( ( ( LONG ) dest & INT_CONST ) == INT_CONST ) ) 
UNSIGNED *p ) 
FOR ( ry = INT_CONST ; ry < rheight ; ry v++ ) 
FOR ( rx = INT_CONST ; rx < rwidth ; rx v++ ) 
FOR ( ry = INT_CONST ; ry < rheight ; ry v++ ) 
FOR ( rx = INT_CONST ; rx < rwidth ; rx v++ ) 
__E__O__F__
&v d_subdiv16 ) 
r_dowarp ) 
d_minmip > INT_CONST ) 
FOR ( i = INT_CONST ; i < ( NUM_MIPS - INT_CONST ) ; i v++ ) 
__E__O__F__
! protectset8 ) 
r_dowarp ) 
d_pix_min < INT_CONST ) 
FOR ( i = INT_CONST ; i < vid . height ; i v++ ) 
) 
__E__O__F__
pparticle -> org , r_origin , local ) 
local , r_pright ) 
transformed [ INT_CONST ] < PARTICLE_Z_CLIP ) 
( v > d_vrectbottom_particle ) || NEW_LINE ( u > d_vrectright_particle ) || NEW_LINE ( v < d_vrecty ) || NEW_LINE ( u < d_vrectx ) ) 
d_zwidth * v ) 
pix < d_pix_min ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( i = INT_CONST ; i < pix ; i v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numverts ; i v++ , fv v++ ) 
( fv -> v [ INT_CONST ] < r_refdef . vrectright ) && NEW_LINE ( fv -> v [ INT_CONST ] < r_refdef . vrectbottom ) ) 
FOR ( i = INT_CONST ; i < lnumtriangles ; i v++ ) 
FOR ( i = INT_CONST ; i < lnumtriangles ; i v++ , ptri v++ ) 
d < -v INT_CONST || d > INT_CONST ) 
lp1 [ INT_CONST ] + lp2 [ INT_CONST ] ) 
lp2 [ INT_CONST ] > lp1 [ INT_CONST ] ) 
lp3 , lp1 , new ) 
FOR ( i = INT_CONST ; i < MAX_LBM_HEIGHT ; i v++ , s += skinwidth ) 
errorterm >= INT_CONST ) 
( ( tm <= INT_CONST ) && ( tm >= -v INT_CONST ) ) && NEW_LINE ( ( tn <= INT_CONST ) && ( tn >= -v INT_CONST ) ) ) 
FLOAT ) 
INT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST ) 
r_affinetridesc . skinwidth ) 
plefttop [ INT_CONST ] , plefttop [ INT_CONST ] , NEW_LINE pleftbottom [ INT_CONST ] , pleftbottom [ INT_CONST ] ) 
byte * ) 
byte * ) 
ubasestep < INT_CONST ) 
( r_sstepy + r_sstepx * d_countextrastep ) >> INT_CONST ) 
initialleftheight ) 
pedgetable -> numleftedges == INT_CONST ) 
prighttop [ INT_CONST ] , prighttop [ INT_CONST ] , NEW_LINE prightbottom [ INT_CONST ] , prightbottom [ INT_CONST ] ) 
a_spans ) 
pedgetable -> numrightedges == INT_CONST ) 
r_p0 [ INT_CONST ] >= r_p1 [ INT_CONST ] ) 
r_p0 [ INT_CONST ] == r_p2 [ INT_CONST ] ) 
r_p0 [ INT_CONST ] > r_p2 [ INT_CONST ] ) 
lp1 [ INT_CONST ] + lp2 [ INT_CONST ] ) 
new [ INT_CONST ] > d_pzbuffer [ ofs ] ) 
lp1 , new ) 
lp1 [ INT_CONST ] + lp2 [ INT_CONST ] ) 
new , lp3 ) 
lp1 , new , lp3 ) 
__E__O__F__
FLOAT ) 
FOR ( v = INT_CONST ; v < scr_vrect . height + AMP2 * INT_CONST ; v v++ ) 
FOR ( u = INT_CONST ; u < scr_vrect . width + AMP2 * INT_CONST ; u v++ ) 
( INT ) ( cl . time * SPEED ) & ( CYCLE - INT_CONST ) ) 
FOR ( v = INT_CONST ; v < scr_vrect . height ; v v++ , dest += vid . rowbytes ) 
FOR ( u = INT_CONST ; u < scr_vrect . width ; u += INT_CONST ) 
UNSIGNED CHAR *p ) 
FLOAT ) 
INT ) 
INT ) 
snext - r_turb_s ) 
INT ) 
r_turb_spancount > INT_CONST ) 
UNSIGNED CHAR *p ) 
FLOAT ) 
INT ) 
FLOAT ) 
INT ) 
__E__O__F__
r_refdef . vrect . width >= r_refdef . vrect . height ) 
end ) 
INT ) 
u , v , &v s , &v t ) 
__E__O__F__
INT ) 
FLOAT ) 
INT ) 
i == INT_CONST ) 
FOR ( v = itop ; v < ibottom ; v v++ ) 
vvert < r_refdef . fvrecty_adj ) 
FOR ( v = itop ; v < ibottom ; v v++ ) 
r_spritedesc . vpn , p_normal ) 
-v DotProduct ( modelorg , r_spritedesc . vpn ) ) 
modelorg , p_temp1 ) 
( fixed16_t ) ( DotProduct ( p_temp1 , p_saxis ) * INT_CONST + FLOAT_CONST ) ) 
FOR ( i = INT_CONST ; i < r_spritedesc . nump ; i v++ ) 
ymin ) 
ymin >= ymax ) 
) 
__E__O__F__
COM_CheckParm ( STRING ) ) 
byte * ) 
FOR ( i = INT_CONST ; i < GUARDSIZE ; i v++ ) 
FOR ( i = INT_CONST ; i < GUARDSIZE ; i v++ ) 
FOR ( c = sc_base ; c ; c = c -> next ) 
( width < INT_CONST ) || ( width > INT_CONST ) ) 
! sc_rover || ( byte * ) sc_rover - ( byte * ) sc_base > sc_size - size ) 
! sc_rover ) 
new -> size - size > INT_CONST ) 
d_roverwrapped ) 
) 
FOR ( test = sc_base ; test ; test = test -> next ) 
surface -> texinfo -> texture ) 
cache && ! cache -> dlight && surface -> dlightframe != r_framecount NEW_LINE && cache -> texture == r_drawsurf . texture NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] ) 
! cache ) 
) 
__E__O__F__
__E__O__F__
*v pz <= izi ) 
__E__O__F__
FOR ( texnum = INT_CONST ; texnum < MAX_SCRAPS ; texnum v++ ) 
FOR ( i = INT_CONST ; i < BLOCK_WIDTH - w ; i v++ ) 
FOR ( j = INT_CONST ; j < w ; j v++ ) 
FOR ( i = INT_CONST ; i < w ; i v++ ) 
STRING ) 
name ) 
p -> width < INT_CONST && p -> height < INT_CONST ) 
FOR ( i = INT_CONST ; i < p -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < p -> width ; j v++ , k v++ ) 
FOR ( pic = menu_cachepics , i = INT_CONST ; i < menu_numcachepics ; pic v++ , i v++ ) 
qpic_t * ) 
! strcmp ( path , STRING ) ) 
glpic_t * ) 
row << INT_CONST ) 
drawline v-- ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST , glt = gltextures ; i < numgltextures ; i v++ , glt v++ ) 
&v gl_nobind ) 
! Q_strncasecmp ( ( CHAR *p ) gl_renderer , STRING , INT_CONST ) || NEW_LINE ! Q_strncasecmp ( ( CHAR *p ) gl_renderer , STRING , INT_CONST ) ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST * INT_CONST ; i v++ ) 
STRING , INT_CONST , INT_CONST , draw_chars , false , true ) 
) 
qpic_t * ) 
ver , STRING , VERSION ) 
FOR ( x = INT_CONST ; x < strlen ( ver ) ; x v++ ) 
vid . conwidth * vid . conheight , STRING ) 
FOR ( y = INT_CONST ; y < vid . conheight ; y v++ , dest += vid . conwidth ) 
FOR ( x = INT_CONST ; x < vid . conwidth ; x += INT_CONST ) 
glpic_t * ) 
start ) 
STRING ) 
num == INT_CONST ) 
char_texture ) 
GL_QUADS ) 
crosshair . value == INT_CONST ) 
scrap_dirty ) 
scrap_dirty ) 
scrap_dirty ) 
srcx * oldglwidth ) 
srcy * oldglheight ) 
translate_texture ) 
FOR ( v = INT_CONST ; v < INT_CONST ; v v++ , dest += INT_CONST ) 
FOR ( u = INT_CONST ; u < INT_CONST ; u v++ ) 
GL_TEXTURE_2D , INT_CONST , gl_alpha_format , INT_CONST , INT_CONST , INT_CONST , GL_RGBA , GL_UNSIGNED_BYTE , trans ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ) 
INT_CONST , INT_CONST , INT_CONST ) 
vid . height * INT_CONST ) 
! cls . download ) 
FOR ( i = INT_CONST ; i < strlen ( ver ) ; i v++ ) 
x , y ) 
) 
INT_CONST , INT_CONST ) 
) 
) 
GL_PROJECTION ) 
GL_MODELVIEW ) 
FOR ( i = INT_CONST , glt = gltextures ; i < numgltextures ; i v++ , glt v++ ) 
FOR ( i = INT_CONST ; i < outheight ; i v++ , out += outwidth ) 
FOR ( j = INT_CONST ; j < outwidth ; j += INT_CONST ) 
FOR ( i = INT_CONST ; i < outheight ; i v++ , out += outwidth ) 
FOR ( j = INT_CONST ; j < outwidth ; j += INT_CONST ) 
FOR ( i = INT_CONST ; i < height ; i v++ , in += width ) 
FOR ( j = INT_CONST ; j < width ; j += INT_CONST , out += INT_CONST , in += INT_CONST ) 
FOR ( i = INT_CONST ; i < height ; i v++ , in += width ) 
FOR ( j = INT_CONST ; j < width ; j += INT_CONST , out += INT_CONST , in += INT_CONST ) 
FOR ( scaled_width = INT_CONST ; scaled_width < width ; scaled_width <<= INT_CONST ) 
FOR ( scaled_height = INT_CONST ; scaled_height < height ; scaled_height <<= INT_CONST ) 
scaled_width > gl_max_size . value ) 
mipmap ) 
alpha ) 
FOR ( i = INT_CONST ; i < s ; i v++ ) 
FOR ( scaled_width = INT_CONST ; scaled_width < width ; scaled_width <<= INT_CONST ) 
FOR ( scaled_height = INT_CONST ; scaled_height < height ; scaled_height <<= INT_CONST ) 
scaled_width > gl_max_size . value ) 
scaled_width == width && scaled_height == height ) 
alpha ) 
FOR ( i = INT_CONST ; i < s ; i v++ ) 
FOR ( i = INT_CONST ; i < s ; i += INT_CONST ) 
VID_Is8bit ( ) && ! alpha && ( data != scrap_texels [ INT_CONST ] ) ) 
trans , width , height , mipmap , alpha ) 
identifier [ INT_CONST ] ) 
FOR ( i = INT_CONST , glt = gltextures ; i < numgltextures ; i v++ , glt v++ ) 
glt -> identifier , identifier ) 
texture_extension_number ) 
data , width , height , mipmap , alpha ) 
__E__O__F__
startv ) 
startv + INT_CONST ) 
FOR ( j = starttri + INT_CONST , check = &v triangles [ starttri + INT_CONST ] ; j < pheader -> numtris ; j v++ , check v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( j = starttri + INT_CONST ; j < pheader -> numtris ; j v++ ) 
startv ) 
startv + INT_CONST ) 
FOR ( j = starttri + INT_CONST , check = &v triangles [ starttri + INT_CONST ] ; j < pheader -> numtris ; j v++ , check v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( j = starttri + INT_CONST ; j < pheader -> numtris ; j v++ ) 
used , INT_CONST , SIZEOF ( used ) ) 
FOR ( i = INT_CONST ; i < pheader -> numtris ; i v++ ) 
FOR ( type = INT_CONST ; type < INT_CONST ; type v++ ) 
FOR ( startv = INT_CONST ; startv < INT_CONST ; startv v++ ) 
FOR ( j = INT_CONST ; j < bestlen + INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < bestlen ; j v++ ) 
FOR ( j = INT_CONST ; j < bestlen ; j v++ ) 
FOR ( j = INT_CONST ; j < bestlen + INT_CONST ; j v++ ) 
STRING , pheader -> numtris , numorder , numcommands ) 
cache , STRING ) 
cache , &v f ) 
numcommands * INT_CONST ) 
paliashdr -> numposes * paliashdr -> poseverts NEW_LINE * SIZEOF ( trivertx_t ) ) 
FOR ( i = INT_CONST ; i < paliashdr -> numposes ; i v++ ) 
FOR ( j = INT_CONST ; j < numorder ; j v++ ) 
__E__O__F__
model -> numleafs + INT_CONST ) 
row ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
! mod -> needload ) 
! crash ) 
UNSIGNED *p ) 
mod -> name , loadname ) 
mod , buf ) 
mod , buf ) 
! l -> filelen ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
anims , INT_CONST , SIZEOF ( anims ) ) 
FOR ( j = i + INT_CONST ; j < m -> nummiptex ; j v++ ) 
num + INT_CONST > altmax ) 
FOR ( j = INT_CONST ; j < max ; j v++ ) 
FOR ( j = INT_CONST ; j < altmax ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( surfnum = INT_CONST ; surfnum < count ; surfnum v++ , in v++ , out v++ ) 
in -> planenum ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
s , STRING , Info_ValueForKey ( cl . serverinfo , STRING ) ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < out -> nummarksurfaces ; j v++ ) 
FOR ( j = INT_CONST ; j < out -> nummarksurfaces ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
corner ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < HEADER_LUMPS ; i v++ ) 
&v header -> lumps [ LUMP_VERTEXES ] ) 
) 
FOR ( i = INT_CONST ; i < mod -> numsubmodels ; i v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
trivertx_t * ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
daliasinterval_t * ) 
pin_intervals -> interval ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
filledcolor == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; ++v i ) 
( fillcolor == filledcolor ) || ( fillcolor == INT_CONST ) ) 
inpt + INT_CONST ) 
outpt != inpt ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
FOR ( j = INT_CONST ; j < groupskins ; j v++ ) 
FOR ( COMMENT ; j < INT_CONST ; j v++ ) 
VOID *p ) 
! strcmp ( loadmodel -> name , STRING ) || NEW_LINE ! strcmp ( loadmodel -> name , STRING ) ) 
FOR ( len = com_filesize , p = buffer ; len ; len v-- , p v++ ) 
pinmodel -> version ) 
pheader -> skinheight > MAX_LBM_HEIGHT ) 
pheader -> numverts <= INT_CONST ) 
pheader -> numtris <= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
daliasskintype_t * ) 
stvert_t * ) 
FOR ( i = INT_CONST ; i < pheader -> numverts ; i v++ ) 
dtriangle_t * ) 
FOR ( i = INT_CONST ; i < pheader -> numtris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
daliasframetype_t * ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
mod , pheader ) 
) 
start ) 
dspriteframe_t * ) 
pinframe -> width ) 
SIZEOF ( mspriteframe_t ) , loadname ) 
pspriteframe , INT_CONST , SIZEOF ( mspriteframe_t ) ) 
pinframe -> origin [ INT_CONST ] ) 
name , STRING , loadmodel -> name , framenum ) 
VOID *p ) 
dspritegroup_t * ) 
pingroup -> numframes ) 
SIZEOF ( mspritegroup_t ) + NEW_LINE ( numframes - INT_CONST ) * SIZEOF ( pspritegroup -> frames [ INT_CONST ] ) , loadname ) 
mspriteframe_t * ) 
dspriteinterval_t * ) 
numframes * SIZEOF ( FLOAT ) , loadname ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
msprite_t ) 
size , loadname ) 
pin -> type ) 
numframes < INT_CONST ) 
dspriteframetype_t * ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
__E__O__F__
h == INT_CONST ) 
FOR ( i = INT_CONST ; i < h ; i v++ ) 
FOR ( ; i < s ; i v++ ) 
row << INT_CONST ) 
FOR ( drawline = INT_CONST ; drawline ; drawline v-- , y v++ ) 
FOR ( nx = INT_CONST ; nx < INT_CONST ; nx v++ ) 
) 
FOR ( a = INT_CONST ; a < NET_TIMINGS ; a v++ ) 
FOR ( y = INT_CONST ; y < NET_GRAPHHEIGHT ; y v++ ) 
FOR ( x = INT_CONST ; x < NET_TIMINGS ; x v++ ) 
x , y , NET_TIMINGS / INT_CONST , NET_GRAPHHEIGHT / INT_CONST + INT_CONST ) 
st , STRING , lost ) 
INT_CONST , INT_CONST , INT_CONST ) 
__E__O__F__
! walk ) 
node -> contents < INT_CONST ) 
r_emins , r_emaxs , splitplane ) 
! r_pefragtopnode ) 
sides & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . worldmodel -> nodes ) 
( pefrag = *v ppefrag ) != NULL ) 
__E__O__F__
INT ) 
FOR ( j = INT_CONST ; j < MAX_LIGHTSTYLES ; j v++ ) 
INT_CONST - v_blend [ INT_CONST ] ) 
INT_CONST - a2 ) 
FOR ( i = INT_CONST ; i >= INT_CONST ; i v-- ) 
light -> origin , r_origin , v ) 
INT_CONST , FLOAT_CONST , INT_CONST , light -> radius * FLOAT_CONST ) 
GL_TRIANGLE_FAN ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i >= INT_CONST ; i v-- ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! gl_flashblend . value ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , l v++ ) 
INT_CONST , INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
light , bit , node -> children [ INT_CONST ] ) 
gl_flashblend . value ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , l v++ ) 
node -> contents < INT_CONST ) 
start , plane -> normal ) 
node -> children [ side ] , start , mid ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
lightmap ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
node -> children [ ! side ] , mid , end ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
e -> angles [ INT_CONST ] , INT_CONST , INT_CONST , INT_CONST ) 
( frame >= psprite -> numframes ) || ( frame < INT_CONST ) ) 
psprite -> frames [ frame ] . type == SPR_SINGLE ) 
( INT ) ( time / fullinterval ) ) 
FOR ( i = INT_CONST ; i < ( numframes - INT_CONST ) ; i v++ ) 
e ) 
psprite -> type == SPR_ORIENTED ) 
currententity -> angles , v_forward , v_right , v_up ) 
INT_CONST , INT_CONST , INT_CONST ) 
) 
frame -> gl_texturenum ) 
GL_ALPHA_TEST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
trivertx_t * ) 
INT_CONST ) 
trivertx_t * ) 
INT_CONST ) 
( frame >= paliashdr -> numframes ) || ( frame < INT_CONST ) ) 
numposes > INT_CONST ) 
paliashdr , pose ) 
currententity -> origin , clmodel -> mins , mins ) 
R_CullBox ( mins , maxs ) ) 
currententity -> origin ) 
e == &v cl . viewent && ambientlight < INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
ambientlight > INT_CONST ) 
! strcmp ( clmodel -> name , STRING ) ) 
aliashdr_t * ) 
) 
) 
! strcmp ( clmodel -> name , STRING ) ) 
paliashdr -> scale [ INT_CONST ] * INT_CONST , paliashdr -> scale [ INT_CONST ] * INT_CONST , paliashdr -> scale [ INT_CONST ] * INT_CONST ) 
INT ) 
currententity -> scoreboard && ! gl_nocolors . value ) 
gl_smoothmodels . value ) 
gl_affinemodels . value ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
GL_FLAT ) 
r_shadows . value ) 
! r_drawentities . value ) 
FOR ( i = INT_CONST ; i < cl_numvisedicts ; i v++ ) 
FOR ( i = INT_CONST ; i < cl_numvisedicts ; i v++ ) 
! r_drawviewmodel . value || ! Cam_DrawViewModel ( ) ) 
j < INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
FLOAT ) 
gldepthmin , gldepthmin + FLOAT_CONST * ( gldepthmax - gldepthmin ) ) 
) 
GL_QUADS ) 
INT_CONST , INT_CONST , INT_CONST ) 
GL_BLEND ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
r_refdef . fov_x == INT_CONST ) 
frustum [ INT_CONST ] . normal , vup , vpn , -v ( INT_CONST - r_refdef . fov_x / INT_CONST ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
r_refdef . vieworg , r_origin ) 
r_refdef . viewangles , vpn , vright , vup ) 
r_origin , cl . worldmodel ) 
r_viewleaf -> contents ) 
GL_PROJECTION ) 
x > INT_CONST ) 
envmap ) 
glx + x , gly + y2 , w , h ) 
gl_cull . value ) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
gldepthmin , gldepthmax ) 
! mirror ) 
r_refdef . vieworg , mirror_plane -> normal ) 
vpn , mirror_plane -> normal ) 
vpn [ INT_CONST ] ) 
cl_numvisedicts < MAX_VISEDICTS ) 
gldepthmin , gldepthmax ) 
) 
gldepthmin , gldepthmax ) 
GL_BLEND ) 
r_base_world_matrix ) 
INT_CONST , INT_CONST , INT_CONST , r_mirroralpha . value ) 
FOR ( ; s ; s = s -> texturechain ) 
r_norefresh . value ) 
gl_finish . value ) 
) 
) 
r_speeds . value ) 
__E__O__F__
SIZEOF ( texture_t ) + INT_CONST * INT_CONST + INT_CONST * INT_CONST + INT_CONST * INT_CONST + INT_CONST * INT_CONST , STRING ) 
FOR ( m = INT_CONST ; m < INT_CONST ; m v++ ) 
FOR ( y = INT_CONST ; y < ( INT_CONST >> m ) ; y v++ ) 
FOR ( x = INT_CONST ; x < ( INT_CONST >> m ) ; x v++ ) 
particletexture ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y < INT_CONST ; y v++ ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_MODULATE ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ) 
GL_FRONT ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
GL_BACK ) 
&v gl_clear ) 
&v gl_keeptjunctions ) 
) 
) 
) 
! player -> name [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < s ; i += INT_CONST ) 
INT ) 
FOR ( i = INT_CONST ; i < scaled_height ; i v++ , out2 += scaled_width ) 
FOR ( j = INT_CONST ; j < scaled_width ; j += INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < scaled_height ; i v++ , out += scaled_width ) 
FOR ( j = INT_CONST ; j < scaled_width ; j += INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numleafs ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numtextures ; i v++ ) 
GL_FRONT ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
GL_BACK ) 
__E__O__F__
surf -> extents [ INT_CONST ] >> INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( t = INT_CONST ; t < tmax ; t v++ ) 
FOR ( s = INT_CONST ; s < smax ; s v++ ) 
rad - dist ) 
surf -> dlightframe == r_framecount ) 
surf -> extents [ INT_CONST ] >> INT_CONST ) 
COMMENT ! cl . worldmodel -> lightdata ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < tmax ; i v++ , dest += stride ) 
FOR ( j = INT_CONST ; j < smax ; j v++ ) 
FOR ( i = INT_CONST ; i < tmax ; i v++ , dest += stride ) 
FOR ( j = INT_CONST ; j < smax ; j v++ ) 
STRING ) 
currententity -> frame ) 
base -> anim_min > reletive || base -> anim_max <= reletive ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
s -> flags & SURF_DRAWTURB ) 
s -> flags & SURF_DRAWSKY ) 
s -> texinfo -> texture ) 
lightmap_textures + s -> lightmaptexturenum ) 
! ( s -> flags & ( SURF_DRAWSKY | SURF_DRAWTURB | SURF_UNDERWATER ) ) ) 
s -> texinfo -> texture ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
s -> texinfo -> texture ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
s -> flags & SURF_DRAWTURB ) 
s -> flags & SURF_DRAWSKY ) 
s ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
nv ) 
) 
GL_TRIANGLE_FAN ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
) 
GL_TRIANGLE_FAN ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
GL_POLYGON ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
r_fullbright . value ) 
gl_lightmap_format == GL_LUMINANCE ) 
! r_lightmap . value ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTMAPS ; i v++ ) 
FOR ( ; p ; p = p -> chain ) 
FOR ( j = INT_CONST ; j < p -> numverts ; j v++ , v += VERTEXSIZE ) 
GL_BLEND ) 
INT_CONST ) 
fa -> flags & SURF_DRAWSKY ) 
fa ) 
fa -> flags & SURF_DRAWTURB ) 
fa ) 
( ( r_viewleaf -> contents == CONTENTS_EMPTY && ( fa -> flags & SURF_UNDERWATER ) ) || NEW_LINE ( r_viewleaf -> contents != CONTENTS_EMPTY && ! ( fa -> flags & SURF_UNDERWATER ) ) ) NEW_LINE && ! ( fa -> flags & SURF_DONTWARP ) ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && fa -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
fa -> dlightframe == r_framecount COMMENT_NL CPP_COMMENT NEW_LINE || fa -> cached_dlight ) 
fa -> flags & ( SURF_DRAWSKY | SURF_DRAWTURB ) ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && fa -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
fa -> dlightframe == r_framecount COMMENT_NL CPP_COMMENT NEW_LINE || fa -> cached_dlight ) 
r_wateralpha . value == FLOAT_CONST ) 
r_world_matrix ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numtextures ; i v++ ) 
FOR ( ; s ; s = s -> texturechain ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
r_wateralpha . value == FLOAT_CONST && gl_texsort . value ) 
r_world_matrix ) 
! gl_texsort . value ) 
FOR ( s = waterchain ; s ; s = s -> texturechain ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numtextures ; i v++ ) 
FOR ( ; s ; s = s -> texturechain ) 
r_wateralpha . value < FLOAT_CONST ) 
! gl_texsort . value ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numtextures ; i v++ ) 
FOR ( ; s ; s = s -> texturechain ) 
e -> angles [ INT_CONST ] || e -> angles [ INT_CONST ] || e -> angles [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
R_CullBox ( mins , maxs ) ) 
r_refdef . vieworg , e -> origin , modelorg ) 
clmodel -> firstmodelsurface != INT_CONST && ! gl_flashblend . value ) 
FOR ( k = INT_CONST ; k < MAX_DLIGHTS ; k v++ ) 
) 
FOR ( i = INT_CONST ; i < clmodel -> nummodelsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
) 
) 
node -> contents == CONTENTS_SOLID ) 
node -> contents < INT_CONST ) 
pleaf -> efrags ) 
plane -> type ) 
modelorg , plane -> normal ) 
dot >= INT_CONST ) 
c ) 
FOR ( ; c ; c v-- , surf v++ ) 
node -> children [ ! side ] ) 
&v ent , INT_CONST , SIZEOF ( ent ) ) 
r_refdef . vieworg , modelorg ) 
INT_CONST , INT_CONST , INT_CONST ) 
) 
) 
r_oldviewleaf == r_viewleaf && ! r_novis . value ) 
r_novis . value ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numleafs ; i v++ ) 
FOR ( texnum = INT_CONST ; texnum < MAX_LIGHTMAPS ; texnum v++ ) 
FOR ( i = INT_CONST ; i < BLOCK_WIDTH - w ; i v++ ) 
FOR ( j = INT_CONST ; j < w ; j v++ ) 
FOR ( i = INT_CONST ; i < w ; i v++ ) 
STRING ) 
SIZEOF ( glpoly_t ) + ( lnumverts - INT_CONST ) * VERTEXSIZE * SIZEOF ( FLOAT ) ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
! gl_keeptjunctions . value && ! ( fa -> flags & SURF_UNDERWATER ) ) 
FOR ( i = INT_CONST ; i < lnumverts ; ++v i ) 
FOR ( j = i + INT_CONST ; j < lnumverts ; ++v j ) 
FOR ( k = INT_CONST ; k < VERTEXSIZE ; ++v k ) 
surf -> flags & ( SURF_DRAWSKY | SURF_DRAWTURB ) ) 
smax , tmax , &v surf -> light_s , &v surf -> light_t ) 
allocated , INT_CONST , SIZEOF ( allocated ) ) 
! lightmap_textures ) 
COM_CheckParm ( STRING ) ) 
FOR ( j = INT_CONST ; j < MAX_MODELS ; j v++ ) 
FOR ( i = INT_CONST ; i < m -> numsurfaces ; i v++ ) 
! gl_texsort . value ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTMAPS ; i v++ ) 
! gl_texsort . value ) 
__E__O__F__
*v str ) 
cl . intermission ) 
scr_center_lines <= INT_CONST ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
fov_x < INT_CONST || fov_x > INT_CONST ) 
height / x ) 
) 
scr_viewsize . value < INT_CONST ) 
! cl_sbar . value && full ) 
cl_sbar . value || ! full ) 
STRING , SCR_ScreenShot_f ) 
STRING ) 
count < INT_CONST ) 
! show_fps . value ) 
st , STRING , lastfps ) 
! scr_showpause . value ) 
! cl . paused ) 
! scr_drawloading ) 
clearconsole v++ < vid . numpages ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
glwidth * glheight * INT_CONST + INT_CONST ) 
glx , gly , glwidth , glheight , GL_RGB , GL_UNSIGNED_BYTE , buffer + INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i += INT_CONST ) 
buffer ) 
( SHORT ) ( width - INT_CONST ) ) 
( SHORT ) width ) 
pcx -> filler , INT_CONST , SIZEOF ( pcx -> filler ) ) 
height - INT_CONST ) 
FOR ( i = INT_CONST ; i < height ; i v++ ) 
FOR ( j = INT_CONST ; j < width ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
upload ) 
r == lr && g == lg && b == lb ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
row << INT_CONST ) 
drawline v-- ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
( y * width ) + x ) 
CONST UNSIGNED CHAR *p ) 
CL_IsUploading ( ) ) 
pcxname , STRING ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
glx , gly , glwidth , glheight , GL_RGB , GL_UNSIGNED_BYTE , newbuf ) 
vid . width < RSSHOT_WIDTH ) 
FLOAT ) 
FOR ( y = INT_CONST ; y < h ; y v++ ) 
FOR ( x = INT_CONST ; x < w ; x v++ ) 
FOR ( COMMENT ; dy < dey ; dy v++ ) 
FOR ( nx = dx ; nx < dex ; nx v++ ) 
FOR ( y = INT_CONST ; y < h ; y v++ ) 
FOR ( x = INT_CONST ; x < w ; x v++ ) 
&v now ) 
st , cls . servername , SIZEOF ( st ) ) 
st , name . string , SIZEOF ( st ) ) 
pcxname , newbuf , w , h , w , host_basepal , true ) 
newbuf ) 
STRING , pcxname ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST && scr_conlines != scr_con_current ; i v++ ) 
host_basepal ) 
r_refdef . vrect . x , INT_CONST , NEW_LINE r_refdef . vrect . x + r_refdef . vrect . width , NEW_LINE r_refdef . vrect . y ) 
scr_disabled_for_loading ) 
! scr_initialized || ! con_initialized ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
oldfov != scr_fov . value ) 
vid . recalc_refdef ) 
) 
r_netgraph . value ) 
) 
) 
__E__O__F__
&v trace , INT_CONST , SIZEOF ( trace_t ) ) 
cl . worldmodel -> hulls , INT_CONST , INT_CONST , INT_CONST , start , end , &v trace ) 
FOR ( i = INT_CONST , p = puffs ; i < MAX_PUFFS ; i v++ , p v++ ) 
incoming ) 
origin , p -> origin ) 
incoming , p -> normal , p -> up ) 
p -> up , p -> normal , p -> right ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
INT_CONST , INT_CONST , INT_CONST ) 
GL_LINES ) 
pts [ INT_CONST ] [ INT_CONST ] ) 
pts [ INT_CONST ] [ INT_CONST ] ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
GL_TRIANGLES ) 
FOR ( i = INT_CONST , p = puffs ; i < MAX_PUFFS ; i v++ , p v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < num_mice ; i v++ ) 
STRING , O_RDONLY ) 
scantokey [ sc ] , state == KEY_EVENTPRESS ) 
UseKeyboard ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
palflag ) 
STRING , &v f ) 
FOR ( i = INT_CONST ; i < ( INT_CONST << INT_CONST ) ; i v++ ) 
FOR ( v = INT_CONST , k = INT_CONST , bestdist = FLOAT_CONST ; v < INT_CONST ; v v++ , pal += INT_CONST ) 
GL_VERSION ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_ALPHA_TEST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
COM_CheckParm ( STRING ) ) 
UseKeyboard ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_RESOLUTIONS ; i v++ ) 
strstr ( gl_extensions , STRING ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
strstr ( gl_extensions , STRING ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
) 
&v vid_mode ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
vid . conwidth < INT_CONST ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
fc ) 
vid . conheight > height ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
) 
) 
gldir , STRING , com_gamedir ) 
palette ) 
) 
STRING , width , height ) 
UseMouse ) 
&v mouse_button_commands [ INT_CONST ] ) 
mouse_update ( ) ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
! dpy ) 
event . type ) 
dgamouse && _windowed_mouse . value ) 
event . xbutton . button == INT_CONST ) 
event . xbutton . button == INT_CONST ) 
old_windowed_mouse != _windowed_mouse . value ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
palflag ) 
STRING , &v f ) 
FOR ( i = INT_CONST ; i < ( INT_CONST << INT_CONST ) ; i v++ ) 
FOR ( v = INT_CONST , k = INT_CONST , bestdist = FLOAT_CONST ; v < INT_CONST ; v v++ , pal += INT_CONST ) 
GL_VERSION ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_ALPHA_TEST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
strstr ( gl_extensions , STRING ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
strstr ( gl_extensions , STRING ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
&v vid_mode ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
vid . conwidth < INT_CONST ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
dpy ) 
dpy , scrnum , attrib ) 
dpy , root , INT_CONST , INT_CONST , width , height , NEW_LINE INT_CONST , visinfo -> depth , InputOutput , NEW_LINE visinfo -> visual , mask , &v attr ) 
dpy , win , INT_CONST , INT_CONST ) 
dpy ) 
dpy , visinfo , NULL , True ) 
dpy , win , ctx ) 
vid . conheight > height ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
) 
) 
gldir , STRING , com_gamedir ) 
palette ) 
) 
STRING , width , height ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
Cmd_Argc ( ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < num_mice ; i v++ ) 
STRING , O_RDONLY ) 
scantokey [ sc ] , state == KEY_EVENTPRESS ) 
UseKeyboard ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
palflag ) 
STRING , &v f ) 
FOR ( i = INT_CONST ; i < ( INT_CONST << INT_CONST ) ; i v++ ) 
FOR ( v = INT_CONST , k = INT_CONST , bestdist = FLOAT_CONST ; v < INT_CONST ; v v++ , pal += INT_CONST ) 
GL_VERSION ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_ALPHA_TEST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
COM_CheckParm ( STRING ) ) 
UseKeyboard ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_RESOLUTIONS ; i v++ ) 
strstr ( gl_extensions , STRING ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
strstr ( gl_extensions , STRING ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
) 
&v vid_mode ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
vid . conwidth < INT_CONST ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
fc ) 
vid . conheight > height ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
) 
) 
gldir , STRING , com_gamedir ) 
palette ) 
) 
STRING , width , height ) 
UseMouse ) 
&v mouse_button_commands [ INT_CONST ] ) 
mouse_update ( ) ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
Cmd_Argc ( ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
dpy , ctx ) 
usedga ) 
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
&v x_event . xkey ) 
x_event . xbutton . button == INT_CONST ) 
x_event . xbutton . button == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
palflag ) 
STRING , &v f ) 
FOR ( i = INT_CONST ; i < ( INT_CONST << INT_CONST ) ; i v++ ) 
FOR ( v = INT_CONST , k = INT_CONST , bestdist = FLOAT_CONST ; v < INT_CONST ; v v++ , pal += INT_CONST ) 
GL_VERSION ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_ALPHA_TEST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
strstr ( gl_extensions , STRING ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
strstr ( gl_extensions , STRING ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
&v vid_mode ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
vid . conwidth < INT_CONST ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
dpy ) 
dpy , scrnum , attrib ) 
dpy , root , visinfo -> visual , AllocNone ) 
dpy , root , INT_CONST , INT_CONST , width , height , NEW_LINE INT_CONST , visinfo -> depth , InputOutput , NEW_LINE visinfo -> visual , mask , &v attr ) 
dpy , win , INT_CONST , INT_CONST ) 
dpy ) 
COM_CheckParm ( STRING ) ) 
! ctx ) 
dpy , win , ctx ) 
vid . conheight > height ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
) 
) 
gldir , STRING , com_gamedir ) 
palette ) 
) 
STRING , width , height ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
&v rect , WindowStyle , FALSE , INT_CONST ) 
NEW_LINE ExWindowStyle , NEW_LINE STRING , NEW_LINE STRING , NEW_LINE WindowStyle , NEW_LINE rect . left , rect . top , NEW_LINE width , NEW_LINE height , NEW_LINE NULL , NEW_LINE NULL , NEW_LINE global_hInstance , NEW_LINE NULL ) 
! dibwindow ) 
dibwindow , WindowRect . right - WindowRect . left , NEW_LINE WindowRect . bottom - WindowRect . top , false ) 
dibwindow ) 
vid . conheight > modelist [ modenum ] . height ) 
mainwindow , WM_SETICON , ( WPARAM ) TRUE , ( LPARAM ) hIcon ) 
! leavecurrentmode ) 
&v rect , WindowStyle , FALSE , INT_CONST ) 
NEW_LINE ExWindowStyle , NEW_LINE STRING , NEW_LINE STRING , NEW_LINE WindowStyle , NEW_LINE rect . left , rect . top , NEW_LINE width , NEW_LINE height , NEW_LINE NULL , NEW_LINE NULL , NEW_LINE global_hInstance , NEW_LINE NULL ) 
! dibwindow ) 
dibwindow ) 
vid . conheight > modelist [ modenum ] . height ) 
mainwindow , WM_SETICON , ( WPARAM ) TRUE , ( LPARAM ) hIcon ) 
( windowed && ( modenum != INT_CONST ) ) || NEW_LINE ( ! windowed && ( modenum < INT_CONST ) ) || NEW_LINE ( ! windowed && ( modenum >= nummodes ) ) ) 
) 
vid_modenum == NO_MODE ) 
modelist [ modenum ] . type == MS_WINDOWED ) 
) 
) 
! stat ) 
mainwindow ) 
PeekMessage ( &v msg , NULL , INT_CONST , INT_CONST , PM_REMOVE ) ) 
INT_CONST ) 
mainwindow , HWND_TOP , INT_CONST , INT_CONST , INT_CONST , INT_CONST , NEW_LINE SWP_DRAWFRAME | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | NEW_LINE SWP_NOCOPYBITS ) 
) 
! msg_suppress_1 ) 
) 
UNSIGNED CHAR *p ) 
! texture_ext || COM_CheckParm ( STRING ) ) 
( bindTexFunc = ( BINDTEXFUNCPTR ) NEW_LINE wglGetProcAddress ( ( LPCSTR ) STRING ) ) == NULL ) 
UNSIGNED CHAR *p ) 
STRING ) 
GL_VERSION ) 
strnicmp ( gl_renderer , STRING , INT_CONST ) == INT_CONST ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_ALPHA_TEST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
) 
GL_VERTEX_ARRAY_EXT ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < ( INT_CONST << INT_CONST ) ; i v++ ) 
FOR ( v = INT_CONST , k = INT_CONST , l = INT_CONST * INT_CONST ; v < INT_CONST ; v v++ , pal += INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
! ActiveApp && sound_active ) 
fActive ) 
! fActive ) 
uMsg == uiWheelMessage ) 
wParam & MK_LBUTTON ) 
hWnd , uMsg , wParam , lParam ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
STRING , VID_GetExtModeDescription ( modenum ) ) 
) 
FOR ( i = INT_CONST ; i < lnummodes ; i v++ ) 
WNDPROC ) 
COM_CheckParm ( STRING ) ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE modelist [ nummodes ] . width , NEW_LINE modelist [ nummodes ] . height , NEW_LINE modelist [ nummodes ] . bpp ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
lowresmodes ) 
FOR ( j = INT_CONST ; ( j < numlowresmodes ) && ( nummodes < MAX_MODE_LIST ) ; j v++ ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
nummodes == originalnummodes ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( i = COM_CheckParm ( STRING ) ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pal , palette , SIZEOF ( palette ) ) 
&v devmode , INT_CONST , SIZEOF ( devmode ) ) 
&v vid_mode ) 
STRING , VID_NumModes_f ) 
global_hInstance , MAKEINTRESOURCE ( IDI_ICON2 ) ) 
) 
global_hInstance ) 
global_hInstance ) 
COM_CheckParm ( STRING ) ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE devmode . dmPelsWidth , devmode . dmPelsHeight , NEW_LINE devmode . dmBitsPerPel ) 
FOR ( i = nummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
FOR ( i = INT_CONST , vid_default = INT_CONST ; i < nummodes ; i v++ ) 
FOR ( i = INT_CONST , vid_default = INT_CONST ; i < nummodes ; i v++ ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
vid . conwidth < INT_CONST ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
hwnd_dialog ) 
palette ) 
vid_default , palette ) 
mainwindow ) 
maindc ) 
gldir , STRING , com_gamedir ) 
) 
badmode . modedesc , STRING ) 
COM_CheckParm ( STRING ) ) 
STRING ) 
) 
FOR ( i = INT_CONST ; ( i < lnummodes ) && ( vid_wmodes < MAX_MODEDESCS ) ; i v++ ) 
vid_wmodes > INT_CONST ) 
FOR ( i = INT_CONST ; i < vid_wmodes ; i v++ ) 
INT_CONST * INT_CONST , INT_CONST + MODE_AREA_HEIGHT * INT_CONST + INT_CONST * INT_CONST , NEW_LINE STRING ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numverts ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ , v v++ ) 
numverts > INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < numverts ; j v++ , v += INT_CONST ) 
FOR ( j = INT_CONST ; j < numverts ; j v++ , v += INT_CONST ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
SIZEOF ( glpoly_t ) + ( numverts - INT_CONST ) * VERTEXSIZE * SIZEOF ( FLOAT ) ) 
FOR ( i = INT_CONST ; i < numverts ; i v++ , verts += INT_CONST ) 
FOR ( i = INT_CONST ; i < fa -> numedges ; i v++ ) 
numverts , verts [ INT_CONST ] ) 
FOR ( p = fa -> polys ; p ; p = p -> next ) 
FOR ( i = INT_CONST , v = p -> verts [ INT_CONST ] ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
FOR ( p = fa -> polys ; p ; p = p -> next ) 
FOR ( i = INT_CONST , v = p -> verts [ INT_CONST ] ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
solidskytexture ) 
fa ) 
GL_BLEND ) 
fa ) 
GL_BLEND ) 
) 
solidskytexture ) 
FOR ( fa = s ; fa ; fa = fa -> texturechain ) 
FOR ( fa = s ; fa ; fa = fa -> texturechain ) 
&v pcxbuf , INT_CONST , SIZEOF ( pcxbuf ) , f ) 
pcx -> manufacturer != INT_CONST NEW_LINE || pcx -> version != INT_CONST NEW_LINE || pcx -> encoding != INT_CONST NEW_LINE || pcx -> bits_per_pixel != INT_CONST NEW_LINE || pcx -> xmax >= INT_CONST NEW_LINE || pcx -> ymax >= INT_CONST ) 
f , -v INT_CONST , SEEK_END ) 
f , SIZEOF ( pcxbuf ) - INT_CONST , SEEK_SET ) 
pcx -> xmax + INT_CONST ) 
FOR ( y = INT_CONST ; y <= pcx -> ymax ; y v++ ) 
FOR ( x = INT_CONST ; x <= pcx -> ymax ; ) 
f ) 
SHORT ) 
f ) 
b2 << INT_CONST ) 
fin ) 
targa_header . image_type != INT_CONST NEW_LINE && targa_header . image_type != INT_CONST ) 
numPixels * INT_CONST ) 
FOR ( row = rows - INT_CONST ; row >= INT_CONST ; row v-- ) 
FOR ( column = INT_CONST ; column < columns ; column v++ ) 
FOR ( row = rows - INT_CONST ; row >= INT_CONST ; row v-- ) 
FOR ( column = INT_CONST ; column < columns ; ) 
FOR ( j = INT_CONST ; j < packetSize ; j v++ ) 
FOR ( j = INT_CONST ; j < packetSize ; j v++ ) 
targa_header . pixel_size ) 
fin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
GL_POLYGON ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , vecs += INT_CONST ) 
vec3_origin , v ) 
FOR ( i = INT_CONST , vp = vecs ; i < nump ; i v++ , vp += INT_CONST ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , vecs += INT_CONST ) 
nump > MAX_CLIP_VERTS - INT_CONST ) 
nump , vecs ) 
FOR ( i = INT_CONST , v = vecs ; i < nump ; i v++ , v += INT_CONST ) 
! front || ! back ) 
nump , vecs , stage + INT_CONST ) 
vecs , ( vecs + ( i * INT_CONST ) ) ) 
FOR ( i = INT_CONST , v = vecs ; i < nump ; i v++ , v += INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
newc [ INT_CONST ] , newv [ INT_CONST ] [ INT_CONST ] , stage + INT_CONST ) 
solidskytexture ) 
FOR ( fa = s ; fa ; fa = fa -> texturechain ) 
FOR ( p = fa -> polys ; p ; p = p -> next ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
s + INT_CONST ) 
s < FLOAT_CONST / INT_CONST ) 
GL_BLEND ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
byte * ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! solidskytexture ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
__E__O__F__
__E__O__F__
DIOBJECTDATAFORMAT ) 
MYDATA ) 
mouseinitialized ) 
mouseinitialized ) 
TRUE ) 
! hInstDI ) 
! pDirectInputCreate ) 
global_hInstance , DIRECTINPUT_VERSION , &v g_pdi , NULL ) 
FAILED ( hr ) ) 
g_pdi , &v GUID_SysMouse , &v g_pMouse , NULL ) 
FAILED ( hr ) ) 
g_pMouse , &v df ) 
FAILED ( hr ) ) 
g_pMouse , mainwindow , NEW_LINE DISCL_EXCLUSIVE | DISCL_FOREGROUND ) 
g_pMouse , DIPROP_BUFFERSIZE , &v dipdw . diph ) 
FAILED ( hr ) ) 
COM_CheckParm ( STRING ) ) 
! dinput ) 
mouseactivatetoggle ) 
&v m_filter ) 
&v in_joystick ) 
STRING , Force_CenterView_f ) 
STRING ) 
) 
g_pMouse ) 
g_pdi ) 
mouseactive && ! dinput ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
! mouseactive ) 
FOR ( ; ; ) 
od . dwData & INT_CONST ) 
od . dwData & INT_CONST ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
m_filter . value ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
mx || my ) 
mouseactive ) 
window_center_x , window_center_y ) 
COM_CheckParm ( STRING ) ) 
FOR ( joy_id = INT_CONST ; joy_id < numdevs ; joy_id v++ ) 
mmr != JOYERR_NOERROR ) 
&v jc , INT_CONST , SIZEOF ( jc ) ) 
STRING ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
joy_advanced . value == FLOAT_CONST ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
! joy_avail ) 
FOR ( i = INT_CONST ; i < joy_numbuttons ; i v++ ) 
joy_haspov ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
joyGetPosEx ( joy_id , &v ji ) == JOYERR_NOERROR ) 
joy_advancedinit != true ) 
! joy_avail || ! in_joystick . value ) 
IN_ReadJoystick ( ) != true ) 
in_speed . state & INT_CONST ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
fAxisValue > FLOAT_CONST ) 
) 
) 
cl . viewangles [ PITCH ] > FLOAT_CONST ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
command ) 
*v s == CHAR_CONST || *v s == CHAR_CONST ) 
key_lines [ edit_line ] [ INT_CONST ] == CHAR_CONST || key_lines [ edit_line ] [ INT_CONST ] == CHAR_CONST ) 
key == K_TAB ) 
) 
key == K_UPARROW ) 
key == K_DOWNARROW ) 
key == K_PGUP || key == K_MWHEELUP ) 
key == K_PGDN || key == K_MWHEELDOWN ) 
key == K_HOME ) 
key == K_END ) 
key == K_ESCAPE ) 
key < INT_CONST || key > INT_CONST ) 
chat_bufferlen == SIZEOF ( chat_buffer ) - INT_CONST ) 
FOR ( kn = keynames ; kn -> name ; kn v++ ) 
keynum == -v INT_CONST ) 
FOR ( kn = keynames ; kn -> name ; kn v++ ) 
Cmd_Argc ( ) != INT_CONST ) 
b , STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
c == INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
b , cmd ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = CHAR_CONST ; i <= CHAR_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! down ) 
down ) 
key == K_SHIFT ) 
! down ) 
cls . demoplayback && down && consolekeys [ key ] && key_dest == key_game ) 
( key_dest == key_menu && menubound [ key ] ) NEW_LINE || ( key_dest == key_console && ! consolekeys [ key ] ) NEW_LINE || ( key_dest == key_game && ( cls . state == ca_active || ! consolekeys [ key ] ) ) ) 
! down ) 
key ) 
key ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
normal , normal ) 
normal , p ) 
FOR ( pos = INT_CONST , i = INT_CONST ; i < INT_CONST ; i v++ ) 
dst , tempvec , src ) 
dst ) 
vr , dir ) 
im , m , SIZEOF ( im ) ) 
zrot , INT_CONST , SIZEOF ( zrot ) ) 
DEG2RAD ( degrees ) ) 
m , zrot , tmpmat ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
p -> type < INT_CONST ) 
p -> signbits ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
-v INT_CONST * sr * sp * cy + -v INT_CONST * cr * -v sy ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
length ) 
length ) 
denom <= FLOAT_CONST ) 
numer / denom ) 
-v numer / denom ) 
__E__O__F__
UNSIGNED INT ) 
( context -> count [ INT_CONST ] += ( ( UINT4 ) inputLen << INT_CONST ) ) < ( ( UINT4 ) inputLen << INT_CONST ) ) 
inputLen >= partLen ) 
FOR ( i = partLen ; i + INT_CONST < inputLen ; i += INT_CONST ) 
( POINTER ) & context -> buffer [ index ] , ( POINTER ) & input [ i ] , inputLen - i ) 
bits , context -> count , INT_CONST ) 
UNSIGNED INT ) 
context , bits , INT_CONST ) 
( POINTER ) context , INT_CONST , SIZEOF ( *v context ) ) 
x , block , INT_CONST ) 
a , b , c , d , x [ INT_CONST ] , S11 ) 
FOR ( i = INT_CONST , j = INT_CONST ; j < len ; i v++ , j += INT_CONST ) 
FOR ( i = INT_CONST , j = INT_CONST ; j < len ; i v++ , j += INT_CONST ) 
&v ctx ) 
&v ctx ) 
__E__O__F__
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
top < INT_CONST ) 
dest + TOP_RANGE , source + top , INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
INT x , INT y , qpic_t * pic ) 
STRING ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
width > INT_CONST ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
STRING ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
key_dest == key_menu ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
INT ) 
STRING ) 
STRING ) 
m_main_cursor ) 
options_cursor ) 
scr_viewsize . value < INT_CONST ) 
v_gamma . value < FLOAT_CONST ) 
sensitivity . value < INT_CONST ) 
bgmvolume . value < INT_CONST ) 
volume . value < INT_CONST ) 
cl_forwardspeed . value > INT_CONST ) 
STRING , -v m_pitch . value ) 
STRING , ! lookspring . value ) 
STRING , ! lookstrafe . value ) 
STRING , ! cl_sbar . value ) 
STRING , ! cl_hudswap . value ) 
STRING , ! _windowed_mouse . value ) 
range < INT_CONST ) 
FOR ( i = INT_CONST ; i < SLIDER_RANGE ; i v++ ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
vid_menudrawfn ) 
options_cursor ) 
STRING ) 
INT_CONST ) 
options_cursor == INT_CONST && vid_menudrawfn == NULL ) 
( options_cursor == INT_CONST ) NEW_LINE # #IFDEF _WIN32 NEW_LINE && ( modestate != MS_WINDOWED ) NEW_LINE # #ENDIF NEW_LINE ) 
command ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
command ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
STRING ) 
bind_grab ) 
FOR ( i = INT_CONST ; i < NUMCOMMANDS ; i v++ ) 
STRING ) 
STRING ) 
STRING ) 
bindnames [ keys_cursor ] [ INT_CONST ] , keys ) 
STRING ) 
++v help_page >= NUM_HELP_PAGES ) 
--v help_page < INT_CONST ) 
) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
wasInMenus ) 
FOR ( p = cmsg ; *v p ; p v++ , y += INT_CONST ) 
STRING , M_Menu_Main_f ) 
m_state ) 
) 
) 
) 
) 
) 
) 
) 
) 
m_entersound ) 
) 
__E__O__F__
model -> numleafs + INT_CONST ) 
row ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
! mod -> needload ) 
! crash ) 
UNSIGNED *p ) 
mod -> name , loadname ) 
mod , buf ) 
mod , buf ) 
! l -> filelen ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
anims , INT_CONST , SIZEOF ( anims ) ) 
FOR ( j = i + INT_CONST ; j < m -> nummiptex ; j v++ ) 
num + INT_CONST > altmax ) 
FOR ( j = INT_CONST ; j < max ; j v++ ) 
FOR ( j = INT_CONST ; j < altmax ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( surfnum = INT_CONST ; surfnum < count ; surfnum v++ , in v++ , out v++ ) 
in -> planenum ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
corner ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < HEADER_LUMPS ; i v++ ) 
&v header -> lumps [ LUMP_VERTEXES ] ) 
) 
FOR ( i = INT_CONST ; i < mod -> numsubmodels ; i v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
daliasframe_t * ) 
name , pdaliasframe -> name ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
trivertx_t * ) 
byte * ) 
FOR ( j = INT_CONST ; j < numv ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
VOID *p ) 
SIZEOF ( maliasgroup_t ) + NEW_LINE ( numframes - INT_CONST ) * SIZEOF ( paliasgroup -> frames [ INT_CONST ] ) , loadname ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
byte * ) 
daliasinterval_t * ) 
numframes * SIZEOF ( FLOAT ) , loadname ) 
byte * ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
skinsize * r_pixbytes , loadname ) 
r_pixbytes == INT_CONST ) 
FOR ( i = INT_CONST ; i < skinsize ; i v++ ) 
( VOID *p ) pinskin ) 
daliasskingroup_t * ) 
pinskingroup -> numskins ) 
SIZEOF ( maliasskingroup_t ) + NEW_LINE ( numskins - INT_CONST ) * SIZEOF ( paliasskingroup -> skindescs [ INT_CONST ] ) , NEW_LINE loadname ) 
byte * ) 
daliasskininterval_t * ) 
numskins * SIZEOF ( FLOAT ) , loadname ) 
byte * ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
FOR ( len = com_filesize , p = buffer ; len ; len v-- , p v++ ) 
) 
mdl_t * ) 
pinmodel -> version ) 
pinmodel -> flags ) 
pinmodel -> boundingradius ) 
pmodel -> skinheight > MAX_LBM_HEIGHT ) 
pmodel -> numverts <= INT_CONST ) 
pmodel -> numtris <= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pmodel -> skinwidth & INT_CONST ) 
numskins < INT_CONST ) 
numskins * SIZEOF ( maliasskindesc_t ) , NEW_LINE loadname ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
stvert_t * ) 
byte * ) 
FOR ( i = INT_CONST ; i < pmodel -> numverts ; i v++ ) 
pinstverts [ i ] . s ) 
mtriangle_t * ) 
byte * ) 
FOR ( i = INT_CONST ; i < pmodel -> numtris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
numframes < INT_CONST ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
) 
start ) 
dspriteframe_t * ) 
pinframe -> width ) 
SIZEOF ( mspriteframe_t ) + size * r_pixbytes , NEW_LINE loadname ) 
pinframe -> origin [ INT_CONST ] ) 
r_pixbytes == INT_CONST ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
VOID *p ) 
dspritegroup_t * ) 
pingroup -> numframes ) 
SIZEOF ( mspritegroup_t ) + NEW_LINE ( numframes - INT_CONST ) * SIZEOF ( pspritegroup -> frames [ INT_CONST ] ) , loadname ) 
mspriteframe_t * ) 
dspriteinterval_t * ) 
numframes * SIZEOF ( FLOAT ) , loadname ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
msprite_t ) 
size , loadname ) 
pin -> type ) 
numframes < INT_CONST ) 
dspriteframetype_t * ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
__E__O__F__
( INT ) ( timeGetTime ( ) * INT_CONST ) * time ( NULL ) ) 
send_buf ) 
! cls . demoplayback ) 
argptr , format ) 
adr , strlen ( string ) , ( byte * ) string ) 
chan -> message . overflowed ) 
chan -> incoming_acknowledged > chan -> last_reliable_sequence NEW_LINE && chan -> incoming_reliable_acknowledged != chan -> reliable_sequence ) 
send_buf ) 
send_reliable << INT_CONST ) 
&v send , w1 ) 
&v send , cls . qport ) 
send . maxsize - send . cursize >= length ) 
! cls . demoplayback ) 
NEW_LINE # #IFNDEF SERVERONLY NEW_LINE ! cls . demoplayback && NEW_LINE # #ENDIF NEW_LINE ! NET_CompareAdr ( net_from , chan -> remote_address ) ) 
) 
) 
INT_CONST << INT_CONST ) 
chan -> incoming_sequence + INT_CONST ) 
reliable_ack == ( UNSIGNED ) chan -> reliable_sequence ) 
reliable_message ) 
__E__O__F__
INT *p ) 
FOR ( colon = copy ; *v colon ; colon v++ ) 
adr -> ip [ INT_CONST ] == INT_CONST ) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
bind ( newsocket , ( VOID *p ) & sadr , SIZEOF ( sadr ) ) == -v INT_CONST ) 
from ) 
errno == ECONNREFUSED ) 
STRING , strerror ( errno ) ) 
&v from , &v net_from ) 
&v to , &v addr ) 
net_socket , data , length , INT_CONST , ( STRUCT sockaddr * ) & addr , SIZEOF ( addr ) ) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
buff , MAXHOSTNAMELEN ) 
buff , &v net_local_adr ) 
address ) 
STRING , NET_AdrToString ( net_local_adr ) ) 
port ) 
net_message_buffer ) 
) 
STRING ) 
__E__O__F__
INT *p ) 
FOR ( colon = copy ; *v colon ; colon v++ ) 
adr -> ip [ INT_CONST ] == INT_CONST ) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
bind ( newsocket , ( VOID *p ) & sadr , SIZEOF ( sadr ) ) == -v INT_CONST ) 
from ) 
ret == -v INT_CONST ) 
errno == WSAEMSGSIZE ) 
ret == SIZEOF ( net_message_buffer ) ) 
&v to , &v addr ) 
net_socket , data , length , INT_CONST , ( STRUCT sockaddr * ) & addr , SIZEOF ( addr ) ) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
buff , INT_CONST ) 
buff , &v net_local_adr ) 
address ) 
STRING , NET_AdrToString ( net_local_adr ) ) 
MAKEWORD ( INT_CONST , INT_CONST ) , &v winsockdata ) 
port ) 
net_message_buffer ) 
) 
STRING ) 
__E__O__F__
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( bumpcount = INT_CONST ; bumpcount < numbumps ; bumpcount v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numplanes ; i v++ ) 
FOR ( j = INT_CONST ; j < numplanes ; j v++ ) 
pmove . waterjumptime ) 
! pmove . velocity [ INT_CONST ] && ! pmove . velocity [ INT_CONST ] && ! pmove . velocity [ INT_CONST ] ) 
dest , start ) 
pmove . origin , original ) 
) 
pmove . origin , down ) 
original , pmove . origin ) 
pmove . origin , dest ) 
) 
pmove . origin , dest ) 
down [ INT_CONST ] - original [ INT_CONST ] ) 
onground != -v INT_CONST ) 
waterlevel >= INT_CONST ) 
onground != -v INT_CONST ) 
newspeed < INT_CONST ) 
pmove . dead ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pmove . waterjumptime ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
wishspeed > movevars . maxspeed ) 
wishdir , wishspeed , movevars . wateraccelerate ) 
pmove . origin , frametime , pmove . velocity , dest ) 
trace . endpos , pmove . origin ) 
forward ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
wishvel , wishdir ) 
wishspeed > movevars . maxspeed ) 
onground != -v INT_CONST ) 
wishdir , wishspeed , movevars . accelerate ) 
pmove . velocity [ INT_CONST ] > INT_CONST ) 
point ) 
pmove . waterjumptime ) 
waterlevel >= INT_CONST ) 
watertype == CONTENTS_WATER ) 
onground == -v INT_CONST ) 
pmove . waterjumptime ) 
pmove . velocity [ INT_CONST ] < -v INT_CONST ) 
flatforward ) 
pmove . origin , INT_CONST , flatforward , spot ) 
flatforward , INT_CONST , pmove . velocity ) 
pmove . origin , base ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( z = INT_CONST ; z <= INT_CONST ; z v++ ) 
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
pmove . velocity ) 
pmove . velocity , newspeed , pmove . velocity ) 
forward ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
wishvel , wishdir ) 
wishspeed > movevars . spectatormaxspeed ) 
pmove . velocity , wishdir ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pmove . angles , forward , right , up ) 
pmove . spectator ) 
) 
pmove . cmd . angles , pmove . angles ) 
) 
waterlevel == INT_CONST ) 
waterlevel >= INT_CONST ) 
) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vec3_t mins , vec3_t maxs ) 
num >= INT_CONST ) 
num >= INT_CONST ) 
num < INT_CONST ) 
num < hull -> firstclipnode || num > hull -> lastclipnode ) 
plane -> type < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! PM_RecursiveHullCheck ( hull , node -> children [ side ] , p1f , midf , p1 , mid , trace ) ) 
PM_HullPointContents ( hull , hull -> firstclipnode , mid ) NEW_LINE == CONTENTS_SOLID ) 
frac < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mid , trace -> endpos ) 
FOR ( i = INT_CONST ; i < pmove . numphysent ; i v++ ) 
pe -> model ) 
&v total , INT_CONST , SIZEOF ( pmtrace_t ) ) 
FOR ( i = INT_CONST ; i < pmove . numphysent ; i v++ ) 
pe -> model ) 
pe -> origin , offset ) 
start , offset , start_l ) 
&v trace , INT_CONST , SIZEOF ( pmtrace_t ) ) 
hull , hull -> firstclipnode , INT_CONST , INT_CONST , start_l , end_l , &v trace ) 
trace . fraction < total . fraction ) 
__E__O__F__
finalvert_t * pfv0 , finalvert_t * pfv1 , finalvert_t * out ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
out , &v avout ) 
out -> v [ INT_CONST ] < r_refdef . aliasvrect . x ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; j = i , i v++ ) 
ptri -> facesfront ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
clipflags & ALIAS_Z_CLIP ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
clipflags & ALIAS_LEFT_CLIP ) 
clipflags & ALIAS_RIGHT_CLIP ) 
k == INT_CONST ) 
clipflags & ALIAS_BOTTOM_CLIP ) 
clipflags & ALIAS_TOP_CLIP ) 
FOR ( i = INT_CONST ; i < k ; i v++ ) 
FOR ( i = INT_CONST ; i < k - INT_CONST ; i v++ ) 
__E__O__F__
pmodel ) 
INT_CONST ) 
( frame >= pmdl -> numframes ) || ( frame < INT_CONST ) ) 
FLOAT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
zfullyclipped ) 
zclipped ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numv ; i v++ ) 
viewpts [ i ] . flags & ALIAS_Z_CLIP ) 
viewaux [ i ] . fv [ INT_CONST ] * xscale * zi ) 
allclip ) 
currententity -> trivial_accept ) 
stvert_t * ) 
FOR ( i = INT_CONST ; i < r_anumverts ; i v++ , fv v++ , av v++ , r_apverts v++ , pstverts v++ ) 
mtriangle_t * ) 
FOR ( i = INT_CONST ; i < pmdl -> numtris ; i v++ , ptri v++ ) 
angles , alias_forward , alias_right , alias_up ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
t2matrix , tmatrix , rotationmatrix ) 
vright , viewmatrix [ INT_CONST ] ) 
viewmatrix , rotationmatrix , aliastransform ) 
trivial_accept ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pverts -> v , aliastransform [ INT_CONST ] ) 
plightnormal , r_plightvec ) 
lightcos < INT_CONST ) 
temp < INT_CONST ) 
FOR ( i = INT_CONST ; i < r_anumverts ; i v++ , fv v++ , pverts v++ , pstverts v++ ) 
DotProduct ( pverts -> v , aliastransform [ INT_CONST ] ) + NEW_LINE aliastransform [ INT_CONST ] [ INT_CONST ] ) 
( DotProduct ( pverts -> v , aliastransform [ INT_CONST ] ) + NEW_LINE aliastransform [ INT_CONST ] [ INT_CONST ] ) * zi ) 
plightnormal , r_plightvec ) 
av -> fv [ INT_CONST ] * aliasxscale * zi ) 
stvert_t * ) 
fv , pstverts ) 
r_affinetridesc . drawtype ) 
) 
( skinnum >= pmdl -> numskins ) || ( skinnum < INT_CONST ) ) 
( maliasskindesc_t * ) NEW_LINE ( ( byte * ) paliashdr + paliashdr -> skindesc ) ) 
pskindesc -> type == ALIAS_SKIN_GROUP ) 
( INT ) ( skintime / fullskininterval ) ) 
FOR ( i = INT_CONST ; i < ( numskins - INT_CONST ) ; i v++ ) 
VOID *p ) 
currententity -> scoreboard ) 
r_ambientlight < LIGHT_MIN ) 
r_ambientlight < LIGHT_MIN ) 
r_shadelight < INT_CONST ) 
plighting -> plightvec , alias_forward ) 
( frame >= pmdl -> numframes ) || ( frame < INT_CONST ) ) 
paliashdr -> frames [ frame ] . type == ALIAS_SINGLE ) 
( INT ) ( time / fullinterval ) ) 
FOR ( i = INT_CONST ; i < ( numframes - INT_CONST ) ; i v++ ) 
trivertx_t * ) 
finalvert_t * ) 
aliashdr_t * ) 
) 
! currententity -> colormap ) 
currententity != &v cl . viewent ) 
__E__O__F__
vec , tvec ) 
angle ) 
angle ) 
temp2 , temp1 , temp3 ) 
angle ) 
temp1 , temp3 , entity_rotation ) 
modelorg ) 
) 
r_entorigin , splitplane -> normal ) 
FOR ( ; pedges ; pedges = pnextedge ) 
plastvert -> position , tplane . normal ) 
pvert -> position , tplane . normal ) 
makeclippededge ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
FOR ( j = INT_CONST ; j < psurf -> numedges ; j v++ ) 
FOR ( i = INT_CONST ; i < numsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
node -> contents == CONTENTS_SOLID ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
node -> contents < INT_CONST ) 
pleaf -> efrags ) 
plane -> type ) 
node -> children [ side ] , clipflags ) 
c ) 
node -> children [ ! side ] , clipflags ) 
r_origin , modelorg ) 
clmodel -> nodes , INT_CONST ) 
r_worldpolysbacktofront ) 
FOR ( i = numbtofpolys - INT_CONST ; i >= INT_CONST ; i v-- ) 
__E__O__F__
r_lastvertvalid ) 
world , modelorg , local ) 
transformed [ INT_CONST ] < NEAR_CLIP ) 
xcenter + scale * transformed [ INT_CONST ] ) 
r_nearzionly ) 
INT ) 
ceilv0 == r_ceilv1 ) 
cacheoffset != INT_CONST ) 
side == INT_CONST ) 
( r_u1 - u0 ) / ( r_v1 - v0 ) ) 
( u0 - r_u1 ) / ( v0 - r_v1 ) ) 
edge -> u < r_refdef . vrect_x_adj_shift20 ) 
clip ) 
pv0 , pv1 ) 
edge_t * ) 
! pedge_t -> surfs [ INT_CONST ] ) 
( surface_p ) >= surf_max ) 
( edge_p + fa -> numedges + INT_CONST ) >= edge_max ) 
FOR ( i = INT_CONST , mask = INT_CONST ; i >= INT_CONST ; i v-- , mask >>= INT_CONST ) 
FOR ( i = INT_CONST ; i < fa -> numedges ; i v++ ) 
r_rightclipped ) 
r_rightclipped ) 
makeleftedge ) 
makerightedge ) 
! r_emitted ) 
VOID *p ) 
pplane -> normal , p_normal ) 
surface_p >= surf_max ) 
( edge_p + psurf -> numedges + INT_CONST ) >= edge_max ) 
FOR ( i = INT_CONST , mask = INT_CONST ; i >= INT_CONST ; i v-- , mask >>= INT_CONST ) 
FOR ( ; pedges ; pedges = pedges -> pnext ) 
makeleftedge ) 
makerightedge ) 
! r_emitted ) 
VOID *p ) 
pplane -> normal , p_normal ) 
FOR ( i = INT_CONST , mask = INT_CONST ; i >= INT_CONST ; i v-- , mask >>= INT_CONST ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
pclip ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
pplane -> type ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
verts [ vertpage ] [ i ] . position , modelorg , local ) 
xcenter + scale * transformed [ INT_CONST ] ) 
) 
FOR ( i = INT_CONST ; i < numsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
__E__O__F__
FOR ( bad ) 
r_worldpolysbacktofront ) 
FOR ( s = surface_p - INT_CONST ; s > &v surfaces [ INT_CONST ] ; s v-- ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
r_draworder . value ) 
FOR ( v = r_refdef . vrect . y ; v < r_refdef . vrectbottom ; v v++ ) 
edgelist -> u >= edgestoadd -> u ) 
edgelist -> u >= edgestoadd -> u ) 
edgelist -> u >= edgestoadd -> u ) 
edge_t * pedge ) 
INT_CONST ) 
pwedge -> u > pedge -> u ) 
pedge == &v edge_tail ) 
iu > surf -> last_u ) 
++v surf -> spanstate == INT_CONST ) 
surf -> insubmodel && ( surf -> key == surf2 -> key ) ) 
iu > surf2 -> last_u ) 
--v surf -> spanstate == INT_CONST ) 
edge -> surfs [ INT_CONST ] ) 
++v surf -> spanstate == INT_CONST ) 
FOR ( edge = edge_head . next ; edge != &v edge_tail ; edge = edge -> next ) 
) 
FOR ( edge = edge_head . next ; edge != &v edge_tail ; edge = edge -> next ) 
) 
espan_t * ) 
r_refdef . vrectright << INT_CONST ) 
FOR ( iv = r_refdef . vrect . y ; iv < bottom ; iv v++ ) 
newedges [ iv ] ) 
span_p > max_span_p ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
FLOAT ) 
newedges [ iv ] ) 
r_drawculledpolys ) 
__E__O__F__
! walk ) 
node -> contents < INT_CONST ) 
r_emins , r_emaxs , splitplane ) 
! r_pefragtopnode ) 
sides & INT_CONST ) 
node -> visframe != r_visframecount ) 
sides & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . worldmodel -> nodes ) 
( pefrag = *v ppefrag ) != NULL ) 
__E__O__F__
INT ) 
FOR ( j = INT_CONST ; j < MAX_LIGHTSTYLES ; j v++ ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
light , bit , node -> children [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , l v++ ) 
node -> contents < INT_CONST ) 
start , plane -> normal ) 
node -> children [ side ] , start , mid ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
lightmap ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
node -> children [ ! side ] , mid , end ) 
r < r_refdef . ambientlight ) 
__E__O__F__
SIZEOF ( texture_t ) + INT_CONST * INT_CONST + INT_CONST * INT_CONST + INT_CONST * INT_CONST + INT_CONST * INT_CONST , STRING ) 
FOR ( m = INT_CONST ; m < INT_CONST ; m v++ ) 
FOR ( y = INT_CONST ; y < ( INT_CONST >> m ) ; y v++ ) 
FOR ( x = INT_CONST ; x < ( INT_CONST >> m ) ; x v++ ) 
byte * ) 
STRING , ( FLOAT ) NUMSTACKEDGES ) 
) 
( LONG ) R_EdgeCodeStart , NEW_LINE ( LONG ) R_EdgeCodeEnd - ( LONG ) R_EdgeCodeStart ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numleafs ; i v++ ) 
r_cnumsurfs <= MINSURFACES ) 
) 
r_numallocatededges < MINEDGES ) 
scr_viewsize . value >= FLOAT_CONST ) 
! cl_sbar . value && full ) 
pvrectin -> width - pvrect -> width ) 
pvrect , &v r_refdef . vrect , lineadj ) 
r_refdef . fov_x / INT_CONST * M_PI ) 
INT ) 
( FLOAT ) r_refdef . vrect . width * XCENTERING ) 
r_refdef . vrect . width - INT_CONST ) 
xOrigin * r_refdef . horizontalFieldOfView ) 
( FLOAT_CONST - xOrigin ) * r_refdef . horizontalFieldOfView ) 
yOrigin * verticalFieldOfView ) 
( FLOAT_CONST - yOrigin ) * verticalFieldOfView ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
scr_fov . value <= FLOAT_CONST ) 
r_oldviewleaf == r_viewleaf ) 
r_viewleaf , cl . worldmodel ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numleafs ; i v++ ) 
! r_drawentities . value ) 
FOR ( i = INT_CONST ; i < cl_numvisedicts ; i v++ ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
vup , viewlightvec ) 
currententity -> origin ) 
j < INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
r_viewlighting . ambientlight > INT_CONST ) 
&v r_viewlighting ) 
currententity -> angles [ INT_CONST ] || currententity -> angles [ INT_CONST ] NEW_LINE || currententity -> angles [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! r_drawentities . value ) 
FOR ( i = INT_CONST ; i < cl_numvisedicts ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < MAX_DLIGHTS ; k v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
r_surfsonstack ) 
) 
) 
r_dspeeds . value ) 
) 
r_drawculledpolys ) 
r_dspeeds . value ) 
) 
r_dspeeds . value ) 
! r_dspeeds . value ) 
r_timegraph . value || r_speeds . value || r_dspeeds . value ) 
) 
) 
! r_worldentity . model || ! cl . worldmodel ) 
) 
r_dspeeds . value ) 
) 
r_dspeeds . value ) 
) 
r_dspeeds . value ) 
r_timegraph . value ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
r_fullbright . value != oldbright ) 
&v vr ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
h == INT_CONST ) 
FOR ( i = INT_CONST ; i < h ; i v++ , dest -= vid . rowbytes * INT_CONST ) 
FOR ( ; i < s ; i v++ , dest -= vid . rowbytes * INT_CONST ) 
r_refdef . vrect . width <= MAX_TIMINGS ) 
timex + INT_CONST ) 
vid . width - INT_CONST <= NET_TIMINGS ) 
x , y , ( w + INT_CONST ) / INT_CONST , ( ( INT ) r_graphheight . value * INT_CONST + INT_CONST ) / INT_CONST + INT_CONST ) 
) 
FOR ( a = NET_TIMINGS - w ; a < w ; a v++ ) 
r_refdef . vrect . width <= INT_CONST ) 
FOR ( a = INT_CONST ; a < w ; a v++ ) 
) 
r_time2 - r_time1 ) 
) 
dp_time2 - dp_time1 ) 
STRING , NEW_LINE ( INT ) ms , dp_time , ( INT ) rw_time , db_time , ( INT ) se_time , de_time , NEW_LINE dv_time ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mplane_t * p , FLOAT *p normal , FLOAT *p dist ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
r_numsurfs . value ) 
r_numedges . value ) 
r_refdef . ambientlight < INT_CONST ) 
r_refdef . vieworg , modelorg ) 
r_refdef . viewangles , vpn , vright , vup ) 
r_origin , cl . worldmodel ) 
r_viewleaf -> contents <= CONTENTS_WATER ) 
( r_dowarp != r_dowarpold ) || r_viewchanged ) 
) 
vpn , base_vpn ) 
) 
) 
) 
__E__O__F__
STRING ) 
i ) 
particle_t * ) 
FOR ( i = INT_CONST ; i < r_numparticles ; i v++ ) 
name , &v f ) 
FOR ( ; ; ) 
f ) 
vec3_t org ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
count > INT_CONST ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = -v INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = -v INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
FOR ( i = -v INT_CONST ; i < INT_CONST ; i += INT_CONST ) 
FOR ( j = -v INT_CONST ; j < INT_CONST ; j += INT_CONST ) 
FOR ( k = -v INT_CONST ; k < INT_CONST ; k += INT_CONST ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
end , start , vec ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
vup , FLOAT_CONST , up ) 
vright , xscaleshrink , r_pright ) 
FOR ( ; ; ) 
FOR ( p = active_particles ; p ; p = p -> next ) 
FOR ( ; ; ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
__E__O__F__
byte * ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
( xshift == xlast ) && ( yshift == ylast ) ) 
FOR ( y = INT_CONST ; y < SKYSIZE ; y v++ ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x += INT_CONST ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x v++ ) 
UNSIGNED *p ) 
FOR ( y = INT_CONST ; y < SKYSIZE ; y v++ ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x += INT_CONST ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x v++ ) 
byte * ) 
FOR ( y = INT_CONST ; y < SKYSIZE ; y v++ ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x v++ ) 
iskyspeed , iskyspeed2 ) 
( INT ) ( cl . time / temp ) * temp ) 
__E__O__F__
clip_current ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , instep += SIZEOF ( vec5_t ) / SIZEOF ( FLOAT ) ) 
instep , in , SIZEOF ( vec5_t ) ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , instep += SIZEOF ( vec5_t ) / SIZEOF ( FLOAT ) ) 
r_spritedesc . vpn , modelorg ) 
dot >= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < nump ; i v++ ) 
) 
( frame >= psprite -> numframes ) || ( frame < INT_CONST ) ) 
psprite -> frames [ frame ] . type == SPR_SINGLE ) 
( INT ) ( time / fullinterval ) ) 
FOR ( i = INT_CONST ; i < ( numframes - INT_CONST ) ; i v++ ) 
psprite ) 
psprite -> type == SPR_FACING_UPRIGHT ) 
tvec ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( dot > FLOAT_CONST ) || ( dot < -v FLOAT_CONST ) ) 
currententity -> angles , r_spritedesc . vpn , NEW_LINE r_spritedesc . vright , r_spritedesc . vup ) 
M_PI * INT_CONST / INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
psprite -> beamlength ) 
) 
__E__O__F__
surf -> extents [ INT_CONST ] >> INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( t = INT_CONST ; t < tmax ; t v++ ) 
FOR ( s = INT_CONST ; s < smax ; s v++ ) 
rad - dist ) 
surf -> extents [ INT_CONST ] >> INT_CONST ) 
COMMENT ! cl . worldmodel -> lightdata ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
currententity -> frame ) 
base -> anim_min > reletive || base -> anim_max <= reletive ) 
) 
INT_CONST << blockdivshift ) 
r_pixbytes == INT_CONST ) 
tmax * smax ) 
( soffset >> r_drawsurf . surfmip ) + ( smax << INT_CONST ) ) 
FOR ( u = INT_CONST ; u < r_numhblocks ; u v++ ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
UNSIGNED SHORT *p ) 
FOR ( k = INT_CONST ; k < blocksize ; k v++ ) 
FOR ( b = INT_CONST ; b < blocksize ; b v++ ) 
FOR ( i = INT_CONST ; i < TILE_SIZE ; i v++ ) 
FOR ( j = INT_CONST ; j < TILE_SIZE ; j v++ ) 
( INT ) ( cl . time * SPEED ) & ( CYCLE - INT_CONST ) ) 
FOR ( i = INT_CONST ; i < TILE_SIZE ; i v++ ) 
FOR ( j = INT_CONST ; j < TILE_SIZE ; j v++ ) 
__E__O__F__
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
STRING ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING , Sbar_ShowScores ) 
FOR ( pow10 = INT_CONST ; num >= pow10 ; pow10 *= INT_CONST ) 
num , str ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
FOR ( i = INT_CONST ; i < scoreboardlines ; i v++ ) 
FOR ( j = INT_CONST ; j < scoreboardlines - INT_CONST - i ; j v++ ) 
Info_ValueForKey ( cl . serverinfo , STRING ) ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
FOR ( j = INT_CONST ; j < scoreboardteams ; j v++ ) 
FOR ( i = INT_CONST ; i < scoreboardteams ; i v++ ) 
FOR ( i = INT_CONST ; i < scoreboardteams - INT_CONST ; i v++ ) 
FOR ( j = i + INT_CONST ; j < scoreboardteams ; j v++ ) 
INT_CONST , INT_CONST , sb_scorebar ) 
str , STRING , minutes , tens , units ) 
cl_sbar . value || scr_viewsize . value < INT_CONST ) 
! headsup ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
top < INT_CONST ) 
x * INT_CONST + INT_CONST , y , INT_CONST , INT_CONST , top ) 
num , STRING , f ) 
( cl . stats [ STAT_ITEMS ] & ( IT_INVISIBILITY | IT_INVULNERABILITY ) ) NEW_LINE == ( IT_INVISIBILITY | IT_INVULNERABILITY ) ) 
cl . stats [ STAT_HEALTH ] >= INT_CONST ) 
cl . time <= cl . faceanimtime ) 
cl . stats [ STAT_ITEMS ] & IT_INVULNERABILITY ) 
) 
INT_CONST , INT_CONST , cl . stats [ STAT_HEALTH ] , INT_CONST NEW_LINE , cl . stats [ STAT_HEALTH ] <= INT_CONST ) 
cl . stats [ STAT_ITEMS ] & IT_SHELLS ) 
cl_sbar . value || scr_viewsize . value < INT_CONST ) 
sb_lines > INT_CONST ) 
cl . stats [ STAT_HEALTH ] <= INT_CONST && ! cl . spectator ) 
num , str ) 
Info_ValueForKey ( cl . serverinfo , STRING ) ) 
! teamplay ) 
STRING ) 
x , y , STRING ) 
) 
FOR ( i = INT_CONST ; i < scoreboardteams && y <= vid . height - INT_CONST ; i v++ ) 
plow < INT_CONST || plow > INT_CONST ) 
team , tm -> team , INT_CONST ) 
num , STRING , tm -> frags ) 
num , STRING , tm -> players ) 
largegame ) 
Info_ValueForKey ( cl . serverinfo , STRING ) ) 
! start ) 
true ) 
start ) 
x , y , STRING ) 
FOR ( i = INT_CONST ; i < l && y <= vid . height - INT_CONST ; i v++ ) 
x + INT_CONST + INT_CONST , y , s -> name ) 
x + INT_CONST , y + INT_CONST , INT_CONST , INT_CONST , top ) 
num , STRING , f ) 
y >= vid . height - INT_CONST ) 
vid . width < INT_CONST || ! sb_lines ) 
false ) 
FOR ( i = INT_CONST ; i < scoreboardlines ; i v++ ) 
i > scoreboardlines - numlines ) 
FOR ( COMMENT ; i < scoreboardlines && y < vid . height - INT_CONST + INT_CONST ; i v++ ) 
top ) 
num , STRING , f ) 
name , s -> name , INT_CONST ) 
vid . width < INT_CONST || ! teamplay ) 
FOR ( y = vid . height - sb_lines ; y < vid . height - INT_CONST ; y += INT_CONST ) 
FOR ( i = INT_CONST ; i < scoreboardteams && y <= vid . height ; i v++ ) 
team , tm -> team , INT_CONST ) 
num , STRING , tm -> frags ) 
atoi ( Info_ValueForKey ( cl . serverinfo , STRING ) ) > INT_CONST && ! sb_showscores ) 
STRING ) 
__E__O__F__
*v str ) 
scr_erase_center v++ > vid . numpages ) 
scr_center_lines <= INT_CONST ) 
cl . intermission ) 
scr_center_lines <= INT_CONST ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
fov_x < INT_CONST || fov_x > INT_CONST ) 
height / x ) 
) 
scr_viewsize . value < INT_CONST ) 
cl . intermission ) 
&v vrect , &v scr_vrect , sb_lines ) 
scr_con_current > vid . height ) 
STRING , SCR_ScreenShot_f ) 
STRING ) 
count < INT_CONST ) 
! show_fps . value ) 
st , STRING , lastfps ) 
! scr_showpause . value ) 
! cl . paused ) 
cls . state != ca_active ) 
clearconsole v++ < vid . numpages ) 
( SHORT ) ( width - INT_CONST ) ) 
( SHORT ) width ) 
pcx -> filler , INT_CONST , SIZEOF ( pcx -> filler ) ) 
FOR ( i = INT_CONST ; i < height ; i v++ ) 
FOR ( j = INT_CONST ; j < width ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
pcxname , vid . buffer , vid . width , vid . height , vid . rowbytes , NEW_LINE host_basepal , false ) 
STRING , pcxname ) 
r == lr && g == lg && b == lb ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
row << INT_CONST ) 
drawline v-- ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
( y * width ) + x ) 
CONST UNSIGNED CHAR *p ) 
CL_IsUploading ( ) ) 
STRING ) 
pcxname , STRING ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
vid . width < RSSHOT_WIDTH ) 
FLOAT ) 
w * h ) 
FOR ( y = INT_CONST ; y < h ; y v++ ) 
FOR ( x = INT_CONST ; x < w ; x v++ ) 
FOR ( COMMENT ; dy < dey ; dy v++ ) 
FOR ( nx = dx ; nx < dex ; nx v++ ) 
&v now ) 
st , cls . servername , SIZEOF ( st ) ) 
st , name . string , SIZEOF ( st ) ) 
pcxname , newbuf , w , h , w , host_basepal , true ) 
newbuf ) 
) 
STRING ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST && scr_conlines != scr_con_current ; i v++ ) 
host_basepal ) 
scr_skipupdate || block_drawing ) 
Minimized ) 
! scr_initialized || ! con_initialized ) 
oldfov != scr_fov . value ) 
oldsbar != cl_sbar . value ) 
) 
scr_fullupdate v++ < vid . numpages ) 
INT_CONST , INT_CONST , vid . width , vid . height ) 
) 
) 
scr_drawdialog ) 
) 
pconupdate ) 
) 
scr_copyeverything ) 
__E__O__F__
allskins [ INT_CONST ] ) 
strstr ( name , STRING ) || *v name == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
numskins == MAX_CACHED_SKINS ) 
) 
skin , INT_CONST , SIZEOF ( *v skin ) ) 
cls . downloadtype == dl_skin ) 
skin -> failedload ) 
pcx_t * ) 
pcx -> manufacturer != INT_CONST NEW_LINE || pcx -> version != INT_CONST NEW_LINE || pcx -> encoding != INT_CONST NEW_LINE || pcx -> bits_per_pixel != INT_CONST NEW_LINE || pcx -> xmax >= INT_CONST NEW_LINE || pcx -> ymax >= INT_CONST ) 
FOR ( y = INT_CONST ; y < pcx -> ymax ; y v++ , pix += INT_CONST ) 
FOR ( x = INT_CONST ; x <= pcx -> xmax ; ) 
raw - ( byte * ) pcx > com_filesize ) 
cls . downloadnumber == INT_CONST ) 
FOR ( NEW_LINE ; cls . downloadnumber != MAX_CLIENTS NEW_LINE ; cls . downloadnumber v++ ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
cls . state != ca_active ) 
&v cls . netchan . message , clc_stringcmd ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
) 
__E__O__F__
! snd_initialized ) 
&v nosound ) 
host_parms . memsize < INT_CONST ) 
) 
) 
MAX_SFX * SIZEOF ( sfx_t ) , STRING ) 
fakedma ) 
STRING ) 
true ) 
! fakedma ) 
! name ) 
FOR ( i = INT_CONST ; i < num_sfx ; i v++ ) 
! sound_started || nosound . value ) 
precache . value ) 
FOR ( ch_idx = NUM_AMBIENTS ; ch_idx < NUM_AMBIENTS + MAX_DYNAMIC_CHANNELS ; ch_idx v++ ) 
ch -> entnum == cl . viewentity ) 
ch -> origin , listener_origin , source_vec ) 
FLOAT_CONST - dist ) 
! sound_started ) 
entnum , entchannel ) 
! target_chan -> leftvol && ! target_chan -> rightvol ) 
FOR ( ch_idx = NUM_AMBIENTS ; ch_idx < NUM_AMBIENTS + MAX_DYNAMIC_CHANNELS ; ch_idx v++ , check v++ ) 
FOR ( i = INT_CONST ; i < MAX_DYNAMIC_CHANNELS ; i v++ ) 
! sound_started ) 
FOR ( i = INT_CONST ; i < MAX_CHANNELS ; i v++ ) 
clear ) 
! sfx ) 
sfx ) 
! snd_ambient ) 
FOR ( ambient_channel = INT_CONST ; ambient_channel < NUM_AMBIENTS ; ambient_channel v++ ) 
FOR ( ambient_channel = INT_CONST ; ambient_channel < NUM_AMBIENTS ; ambient_channel v++ ) 
chan -> master_vol < vol ) 
! sound_started || ( snd_blocked > INT_CONST ) ) 
) 
FOR ( i = NUM_AMBIENTS ; i < total_channels ; i v++ , ch v++ ) 
i >= MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS ) 
FOR ( j = MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS ; j < i ; j v++ , combine v++ ) 
FOR ( i = INT_CONST ; i < total_channels ; i v++ , ch v++ ) 
) 
samplepos < oldsamplepos ) 
paintedtime < soundtime ) 
shm -> channels - INT_CONST ) 
) 
FOR ( sfx = known_sfx , i = INT_CONST ; i < num_sfx ; i v++ , sfx v++ ) 
nosound . value ) 
__E__O__F__
STRING , O_RDWR ) 
audio_fd , SNDCTL_DSP_RESET , INT_CONST ) 
ioctl ( audio_fd , SNDCTL_DSP_GETCAPS , &v caps ) == -v INT_CONST ) 
! ( caps & DSP_CAP_TRIGGER ) || ! ( caps & DSP_CAP_MMAP ) ) 
ioctl ( audio_fd , SNDCTL_DSP_GETOSPACE , &v info ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < SIZEOF ( tryrates ) / INT_CONST ; i v++ ) 
UNSIGNED CHAR *p ) 
shm -> channels == INT_CONST ) 
audio_fd , SNDCTL_DSP_SETTRIGGER , &v tmp ) 
! snd_inited ) 
ioctl ( audio_fd , SNDCTL_DSP_GETOPTR , &v count ) == -v INT_CONST ) 
__E__O__F__
sc -> loopstart != -v INT_CONST ) 
stepscale == INT_CONST && inwidth == INT_CONST && sc -> width == INT_CONST ) 
FOR ( i = INT_CONST ; i < outcount ; i v++ ) 
FOR ( i = INT_CONST ; i < outcount ; i v++ ) 
&v s -> cache ) 
! data ) 
s -> name , data , com_filesize ) 
FLOAT ) 
&v s -> cache , len + SIZEOF ( sfxcache_t ) , s -> name ) 
s , sc -> speed , sc -> width , data + info . dataofs ) 
&v info , INT_CONST , SIZEOF ( info ) ) 
! wav ) 
STRING ) 
STRING ) 
) 
STRING ) 
STRING ) 
) 
info . samples ) 
__E__O__F__
FOR ( i = INT_CONST ; i < snd_linear_count ; i += INT_CONST ) 
pDSBuf ) 
lpaintedtime < endtime ) 
( shm -> samples >> INT_CONST ) - INT_CONST ) 
) 
pDSBuf ) 
pDSBuf ) 
shm -> samplebits == INT_CONST ) 
out_idx + INT_CONST ) 
val >> INT_CONST ) 
pDSBuf ) 
paintedtime < endtime ) 
endtime - paintedtime > PAINTBUFFER_SIZE ) 
paintbuffer , INT_CONST , ( end - paintedtime ) * SIZEOF ( portable_samplepair_t ) ) 
FOR ( i = INT_CONST ; i < total_channels ; i v++ , ch v++ ) 
! ch -> leftvol && ! ch -> rightvol ) 
end ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
ch -> leftvol > INT_CONST ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
SIGNED SHORT *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
__E__O__F__
pDSBuf ) 
pDSPBuf && ( pDSBuf != pDSPBuf ) ) 
pDS ) 
hWaveOut ) 
FOR ( i = INT_CONST ; i < WAV_BUFFERS ; i v++ ) 
( VOID *p ) & sn , INT_CONST , SIZEOF ( sn ) ) 
&v format , INT_CONST , SIZEOF ( format ) ) 
( hresult = iDirectSoundCreate ( NULL , &v pDS , NULL ) ) != DS_OK ) 
dscaps ) 
DS_OK != pDS -> lpVtbl -> GetCaps ( pDS , &v dscaps ) ) 
dscaps . dwFlags & DSCAPS_EMULDRIVER ) 
DS_OK != pDS -> lpVtbl -> SetCooperativeLevel ( pDS , mainwindow , DSSCL_EXCLUSIVE ) ) 
&v dsbuf , INT_CONST , SIZEOF ( dsbuf ) ) 
&v dsbcaps , INT_CONST , SIZEOF ( dsbcaps ) ) 
! COM_CheckParm ( STRING ) ) 
! primary_format_set || ! COM_CheckParm ( STRING ) ) 
&v dsbuf , INT_CONST , SIZEOF ( dsbuf ) ) 
pDSBuf , INT_CONST , INT_CONST , DSBPLAY_LOOPING ) 
( hresult = pDSBuf -> lpVtbl -> Lock ( pDSBuf , INT_CONST , gSndBufSize , &v lpData , &v dwSize , NULL , NULL , INT_CONST ) ) != DS_OK ) 
lpData , INT_CONST , dwSize ) 
pDSBuf ) 
shm -> samplebits / INT_CONST ) 
&v format , INT_CONST , SIZEOF ( format ) ) 
GMEM_MOVEABLE | GMEM_SHARE , gSndBufSize ) 
FOR ( i = INT_CONST ; i < WAV_BUFFERS ; i v++ ) 
shm -> samplebits / INT_CONST ) 
COM_CheckParm ( STRING ) ) 
! wavonly ) 
snd_firsttime ) 
! dsound_init && ( stat != SIS_NOTAVAIL ) ) 
! dsound_init && ! wav_init ) 
dsound_init ) 
shm -> samples - INT_CONST ) 
! wav_init ) 
INT_CONST ) 
( ( snd_sent - snd_completed ) >> sample16 ) < INT_CONST ) 
__E__O__F__
argptr , fmt ) 
strlen ( text ) > SIZEOF ( text ) ) 
FOR ( p = ( UNSIGNED CHAR *p ) text ; *v p ; p v++ ) 
) 
INT_CONST ) 
handle == -v INT_CONST ) 
STRING ) 
SIGFPE , SIG_IGN ) 
&v parms , INT_CONST , SIZEOF ( parms ) ) 
c , v ) 
STRING ) 
STRING ) 
&v parms ) 
time ) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
__E__O__F__
f ) 
STRING ) 
INT_CONST ) 
parms . memsize ) 
argc , argv ) 
STRING ) 
__E__O__F__
f ) 
) 
! VirtualProtect ( ( LPVOID ) startaddr , length , PAGE_READWRITE , &v flOldProtect ) ) 
NEW_LINE NULL , COMMENT NEW_LINE INT_CONST , COMMENT NEW_LINE STRING ) 
NEW_LINE NULL , COMMENT NEW_LINE INT_CONST , COMMENT NEW_LINE INT_CONST , COMMENT NEW_LINE STRING ) 
! QueryPerformanceFrequency ( &v PerformanceFreq ) ) 
highpart || ( lowpart > FLOAT_CONST ) ) 
DOUBLE ) 
) 
INT_CONST ) 
vinfo ) 
! GetVersionEx ( &v vinfo ) ) 
) 
argptr , error ) 
NULL , text , STRING , INT_CONST COMMENT ) 
qwclsemaphore ) 
) 
) 
&v PerformanceCount ) 
( UNSIGNED INT ) PerformanceCount . LowPart >> lowshift ) 
( temp <= oldtime ) && ( ( oldtime - temp ) < INT_CONST ) ) 
) 
) 
STRING ) 
j ) 
) 
first ) 
FOR ( ; ; ) 
! GetMessage ( &v msg , NULL , INT_CONST , INT_CONST ) ) 
hPrevInstance ) 
MEMORYSTATUS ) 
! GetCurrentDirectory ( SIZEOF ( cwd ) , cwd ) ) 
*v lpCmdLine && ( parms . argc < MAX_NUM_ARGVS ) ) 
*v lpCmdLine && ( ( *v lpCmdLine > INT_CONST ) && ( *v lpCmdLine <= INT_CONST ) ) ) 
parms . argc , parms . argv ) 
hInstance , MAKEINTRESOURCE ( IDD_DIALOG1 ) , NULL , NULL ) 
hwnd_dialog ) 
parms . memsize < MINIMUM_WIN_MEMORY ) 
parms . memsize ) 
! parms . membase ) 
! tevent ) 
) 
STRING ) 
) 
INT_CONST ) 
( cl . paused && ( ! ActiveApp && ! DDActive ) ) || Minimized || block_drawing ) 
__E__O__F__
__E__O__F__
! svgalib_inited || ! vid . direct || ! vga_oktowrite ( ) ) 
vid . aspect > FLOAT_CONST ) 
INT_CONST ) 
VGA_planar ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( k = INT_CONST ; k < reps ; k v++ ) 
FOR ( j = INT_CONST ; j < ( width >> INT_CONST ) ; j v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
! svgalib_inited || ! vid . direct || ! vga_oktowrite ( ) ) 
vid . aspect > FLOAT_CONST ) 
INT_CONST ) 
VGA_planar ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( k = INT_CONST ; k < reps ; k v++ ) 
FOR ( j = INT_CONST ; j < ( width >> INT_CONST ) ; j v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
! ! width ) 
name ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
FOR ( i = INT_CONST ; i < num_mice ; i v++ ) 
STRING , O_RDONLY ) 
scantokey [ sc ] , state == KEY_EVENTPRESS ) 
UseKeyboard ) 
! svgalib_inited ) 
vga_getcolors ( ) == INT_CONST ) 
FOR ( i = INT_CONST * INT_CONST ; i ; i v-- ) 
( modenum >= num_modes ) || ( modenum < INT_CONST ) || ! modes [ modenum ] . width ) 
STRING , ( FLOAT ) modenum ) 
VGA_planar ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
d_pzbuffer ) 
vid . width , vid . height ) 
) 
bsize + tsize + zsize , STRING ) 
( byte * ) d_pzbuffer ) 
pixel_t * ) 
vid_surfcache , tsize ) 
current_mode ) 
CHAR *p ) 
) 
svgalib_inited ) 
getenv ( STRING ) ) 
current_mode , palette ) 
UseKeyboard ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( offset = INT_CONST ; offset < total ; offset += INT_CONST ) 
&v m_filter ) 
UseMouse ) 
mouse_update ( ) ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
modenum == INT_CONST ) 
__E__O__F__
GetWindowRect ( mainwindow , &v rect ) ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
*v d_pzbuffer ) 
width , height ) 
( host_parms . memsize - tbuffersize + SURFCACHE_SIZE_AT_320X200 + NEW_LINE INT_CONST * INT_CONST ) < MINIMUM_MEMORY ) 
*v d_pzbuffer ) 
width , height ) 
( host_parms . memsize - tbuffersize + SURFCACHE_SIZE_AT_320X200 + NEW_LINE INT_CONST * INT_CONST ) < MINIMUM_MEMORY ) 
d_pzbuffer ) 
) 
tbuffersize , STRING ) 
byte * ) 
block_switch . value && ! WinNT ) 
) 
useDirectDraw ) 
COM_CheckParm ( STRING ) || COM_CheckParm ( STRING ) || COM_CheckParm ( STRING ) ) 
) 
m [ INT_CONST ] != INT_CONST ) 
FOR ( i = INT_CONST ; m [ i ] != INT_CONST ; i v++ ) 
lowstretchedres < lowres ) 
FOR ( i = INT_CONST ; m [ i ] != INT_CONST ; i v++ ) 
VID_Suspend ) 
! MGL_changeDisplayMode ( mode ) ) 
npages > INT_CONST ) 
( dc = MGL_createDisplayDC ( npages ) ) == NULL ) 
forcemem ) 
vid . numpages == INT_CONST ) 
hInstance , MAKEINTRESOURCE ( IDI_ICON2 ) ) 
WNDPROC ) 
modelist [ INT_CONST ] . modedesc , STRING ) 
modelist [ INT_CONST ] . modedesc , STRING ) 
modelist [ INT_CONST ] . modedesc , STRING ) 
NULL ) 
( GetDeviceCaps ( hdc , HORZRES ) > INT_CONST ) && ! COM_CheckParm ( STRING ) ) 
NULL , hdc ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE modelist [ nummodes ] . width , NEW_LINE modelist [ nummodes ] . height ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
nummodes == originalnummodes ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE devmode . dmPelsWidth , devmode . dmPelsHeight ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
lowresmodes ) 
ChangeDisplaySettings ( &v devmode , CDS_TEST | CDS_FULLSCREEN ) == NEW_LINE DISP_CHANGE_SUCCESSFUL ) 
! done ) 
FOR ( j = INT_CONST ; ( j < numlowresmodes ) && ( nummodes < MAX_MODE_LIST ) ; j v++ ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE devmode . dmPelsWidth , devmode . dmPelsHeight ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
! is_mode0x13 ) 
FOR ( i = originalnummodes , cstretch = INT_CONST ; i < nummodes ; i v++ ) 
FOR ( i = ( nummodes - INT_CONST ) ; i >= originalnummodes ; i v-- ) 
nummodes != originalnummodes ) 
mode == MODE_SETTABLE_WINDOW ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
mode ) 
VID_CheckAdequateMem ( pv -> width , pv -> height ) ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
mode ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
mode ) 
modelist [ mode ] . type == MS_FULLSCREEN ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
mode ) 
windc ) 
mgldc ) 
windc ) 
! windowed_mode_set ) 
modenum ) 
) 
windc ) 
! MGL_changeDisplayMode ( grWINDOWED ) ) 
stretched ) 
&v WindowRect , WindowStyle , FALSE , INT_CONST ) 
! vid_mode_set ) 
mainwindow ) 
! SetWindowPos ( mainwindow , NEW_LINE NULL , NEW_LINE INT_CONST , INT_CONST , NEW_LINE WindowRect . right - WindowRect . left , NEW_LINE WindowRect . bottom - WindowRect . top , NEW_LINE SWP_NOCOPYBITS | SWP_NOZORDER | NEW_LINE SWP_HIDEWINDOW ) ) 
mainwindow ) 
( windc = MGL_createWindowedDC ( mainwindow ) ) == NULL ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
mainwindow , WM_SETICON , ( WPARAM ) TRUE , ( LPARAM ) hIcon ) 
) 
mgldc ) 
( mgldc = createDisplayDC ( modelist [ modenum ] . stretched || NEW_LINE ( INT ) vid_nopageflip . value ) ) == NULL ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
mainwindow , WM_SETICON , ( WPARAM ) INT_CONST , ( LPARAM ) hIcon ) 
true , false ) 
) 
windc ) 
! MGL_changeDisplayMode ( grWINDOWED ) ) 
ChangeDisplaySettings ( &v gdevmode , CDS_FULLSCREEN ) != DISP_CHANGE_SUCCESSFUL ) 
NULL ) 
NULL , hdc ) 
&v WindowRect , WindowStyle , FALSE , INT_CONST ) 
mainwindow , GWL_STYLE , WindowStyle | WS_VISIBLE ) 
! SetWindowPos ( mainwindow , NEW_LINE NULL , NEW_LINE INT_CONST , INT_CONST , NEW_LINE WindowRect . right - WindowRect . left , NEW_LINE WindowRect . bottom - WindowRect . top , NEW_LINE SWP_NOCOPYBITS | SWP_NOZORDER ) ) 
mainwindow ) 
( windc = MGL_createWindowedDC ( mainwindow ) ) == NULL ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
inerror ) 
! VID_SetMode ( original_mode , vid_curpal ) ) 
( modenum >= nummodes ) || ( modenum < INT_CONST ) ) 
! force_mode_set && ( modenum == vid_modenum ) ) 
) 
vid_modenum == NO_MODE ) 
modelist [ modenum ] . type == MS_WINDOWED ) 
) 
) 
! stat ) 
hide_window ) 
GetDeviceCaps ( hdc , RASTERCAPS ) & RC_PALETTE ) 
NULL , hdc ) 
STRING , ( FLOAT ) vid_modenum ) 
! VID_AllocBuffers ( vid . width , vid . height ) ) 
original_mode ) 
vid_surfcache , vid_surfcachesize ) 
PeekMessage ( &v msg , NULL , INT_CONST , INT_CONST , PM_REMOVE ) ) 
INT_CONST ) 
! force_minimized ) 
) 
! msg_suppress_1 ) 
lockcount > INT_CONST ) 
memdc ) 
r_dowarp ) 
lockcount > INT_CONST ) 
! lockcount ) 
dibdc ) 
NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vid_curpal , palette , SIZEOF ( vid_curpal ) ) 
syscolchg ) 
) 
FOR ( i = INT_CONST ; i < lnummodes ; i v++ ) 
na ) 
! vid_testingmode ) 
! vid_testingmode ) 
&v vid_mode ) 
STRING , VID_TestMode_f ) 
COM_CheckParm ( STRING ) ) 
! dibonly ) 
*v ( ( INT *p ) vid . colormap + INT_CONST ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST , ptmp = vid . colormap ; i < ( INT_CONST << ( VID_CBITS + INT_CONST ) ) ; i v++ , ptmp v++ ) 
COM_CheckParm ( STRING ) ) 
hwnd_dialog ) 
vid_default , palette ) 
palette ) 
badmode . modedesc , STRING ) 
vid_initialized ) 
DDActive ) 
! vid_palettized && palette_changed ) 
firstupdate ) 
rects ) 
vid_testingmode ) 
modestate == MS_WINDOWED ) 
) 
! vid_initialized ) 
vid . numpages == INT_CONST ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
width ) 
lockcount > INT_CONST ) 
mgldc , vPage ) 
) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
width ) 
) 
mgldc , aPage ) 
lockcount > INT_CONST ) 
! vid_initialized ) 
vid . numpages == INT_CONST ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
lockcount > INT_CONST ) 
mgldc , vPage ) 
) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
) 
mgldc , aPage ) 
lockcount > INT_CONST ) 
vid_fulldib_on_focus_mode ) 
Minimized ) 
windc , ActiveApp ) 
vid_initialized ) 
NULL ) 
! ActiveApp && sound_active ) 
! in_mode_set ) 
) 
) 
uMsg == uiWheelMessage ) 
uMsg ) 
! in_mode_set ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < lnummodes ; i v++ ) 
ptr && ( ( pv -> width != INT_CONST ) || COM_CheckParm ( STRING ) ) ) 
FOR ( j = INT_CONST ; j < vid_wmodes ; j v++ ) 
FOR ( i = INT_CONST ; i < ( vid_wmodes - INT_CONST ) ; i v++ ) 
FOR ( j = ( i + INT_CONST ) ; j < vid_wmodes ; j v++ ) 
INT_CONST * INT_CONST , INT_CONST , STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vid_wmodes > INT_CONST ) 
FOR ( i = INT_CONST ; i < vid_wmodes ; i v++ ) 
vid_testingmode ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
! VID_SetMode ( modedescs [ vid_line ] . modenum , vid_curpal ) ) 
STRING ) 
__E__O__F__
FOR ( r_shift = -v INT_CONST , x = INT_CONST ; x < r_mask ; x = x << INT_CONST ) 
FOR ( g_shift = -v INT_CONST , x = INT_CONST ; x < g_mask ; x = x << INT_CONST ) 
FOR ( b_shift = -v INT_CONST , x = INT_CONST ; x < b_mask ; x = x << INT_CONST ) 
( x < INT_CONST ) || ( y < INT_CONST ) ) 
FOR ( yi = y ; yi < ( y + height ) ; yi v++ ) 
FOR ( xi = ( x + width - INT_CONST ) ; xi >= x ; xi v-- ) 
x_framebuffer [ INT_CONST ] ) 
d_pzbuffer ) 
*v d_pzbuffer ) 
vid . width , vid . height ) 
X11_buffersize , STRING ) 
pwidth == INT_CONST ) 
x_disp , NEW_LINE x_vis , NEW_LINE x_visinfo -> depth , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE malloc ( mem ) , NEW_LINE vid . width , vid . height , NEW_LINE INT_CONST , NEW_LINE INT_CONST ) 
d_pzbuffer ) 
) 
*v d_pzbuffer ) 
vid . width , vid . height ) 
X11_buffersize , STRING ) 
FOR ( frm = INT_CONST ; frm < INT_CONST ; frm v++ ) 
x_framebuffer [ frm ] ) 
x_disp , NEW_LINE x_vis , NEW_LINE x_visinfo -> depth , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE &v x_shminfo [ frm ] , NEW_LINE vid . width , NEW_LINE vid . height ) 
size < minsize ) 
! XShmAttach ( x_disp , &v x_shminfo [ frm ] ) ) 
INT_CONST ) 
x_disp ) 
x_disp , True ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
x_disp , template_mask , &v template , &v num_visuals ) 
FOR ( i = INT_CONST ; i < num_visuals ; i v++ ) 
verbose ) 
CPP_COMMENT NEW_LINE vid . width , vid . height , NEW_LINE INT_CONST , COMMENT_NL CPP_COMMENT NEW_LINE x_visinfo -> depth , NEW_LINE InputOutput , NEW_LINE x_vis , NEW_LINE attribmask , NEW_LINE &v attribs ) 
x_visinfo -> depth == INT_CONST ) 
x_visinfo -> class == PseudoColor ) 
x_disp , x_win , CreateNullCursor ( x_disp , x_win ) ) 
x_disp , x_win ) 
doShm ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
&v x_event . xkey ) 
_windowed_mouse . value ) 
x_disp , None , x_win , INT_CONST , INT_CONST , INT_CONST , INT_CONST , NEW_LINE ( vid . width / INT_CONST ) , ( vid . height / INT_CONST ) ) 
x_event . xbutton . button == INT_CONST ) 
x_event . xbutton . button == INT_CONST ) 
doShm && x_event . type == x_shmeventtype ) 
doShm ) 
rects ) 
&v readfds ) 
ready > INT_CONST ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
VOID ) 
view_message -> onground == -v INT_CONST || cls . demoplayback ) 
cl . nodrift ) 
delta > INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . cshifts [ CSHIFT_DAMAGE ] . percent < INT_CONST ) 
from , cl . simorg , from ) 
contents ) 
FOR ( j = INT_CONST ; j < NUM_CSHIFTS ; j v++ ) 
v_blend [ INT_CONST ] > INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < NUM_CSHIFTS ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
cl . cshifts [ CSHIFT_DAMAGE ] . percent <= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pal ) 
) 
FOR ( i = INT_CONST ; i < NUM_CSHIFTS ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
cl . cshifts [ CSHIFT_DAMAGE ] . percent <= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < NUM_CSHIFTS ; j v++ ) 
pal ) 
yaw - r_refdef . viewangles [ YAW ] ) 
r_refdef . viewangles [ PITCH ] + pitch ) 
cl . time * v_iroll_cycle . value ) 
v_dmg_time > INT_CONST ) 
cl . simorg , r_refdef . vieworg ) 
) 
) 
) 
cl . simorg , r_refdef . vieworg ) 
cl . simangles , r_refdef . viewangles ) 
view_message -> flags & PF_GIB ) 
cl . simangles , forward , right , up ) 
cl . simangles , view -> angles ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
scr_viewsize . value == INT_CONST ) 
( view_message -> onground != -v INT_CONST ) && ( cl . simorg [ INT_CONST ] - oldz > INT_CONST ) ) 
) 
) 
) 
&v v_centermove ) 
&v v_iyaw_cycle ) 
&v v_contentblend ) 
&v v_idlescale ) 
&v v_kicktime ) 
FLOAT_CONST ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST , lump_p = wad_lumps ; i < wad_numlumps ; i v++ , lump_p v++ ) 
FOR ( lump_p = wad_lumps , i = INT_CONST ; i < wad_numlumps ; i v++ , lump_p v++ ) 
__E__O__F__
memblock_t * ) 
memzone_t ) 
! other -> tag ) 
block == mainzone -> rover ) 
other == mainzone -> rover ) 
size , INT_CONST ) 
! tag ) 
size + INT_CONST ) 
extra > MINFRAGMENT ) 
memblock_t * ) 
VOID *p ) 
FOR ( block = zone -> blocklist . next ; ; block = block -> next ) 
FOR ( block = mainzone -> blocklist . next ; ; block = block -> next ) 
FOR ( h = ( hunk_t * ) hunk_base ; ( byte * ) h != hunk_base + hunk_low_used ; ) 
hunk_t * ) 
STRING , hunk_size ) 
INT_CONST ) 
h == endlow ) 
h == endhigh ) 
h -> sentinal != HUNK_SENTINAL ) 
name , h -> name , INT_CONST ) 
next == endlow || next == endhigh || NEW_LINE strncmp ( h -> name , next -> name , INT_CONST ) ) 
STRING ) 
INT size , CHAR *p name ) 
hunk_low_used ) 
h , INT_CONST , size ) 
size < INT_CONST ) 
) 
hunk_size - hunk_low_used - hunk_high_used < size ) 
hunk_high_used ) 
hunk_t * ) 
h , INT_CONST , size ) 
VOID *p ) 
size + INT_CONST ) 
c -> size , true ) 
! nobottom && cache_head . prev == &v cache_head ) 
cache_system_t * ) 
cache_system_t * ) 
hunk_base + hunk_size - hunk_high_used - ( byte * ) new >= size ) 
FOR ( cd = cache_head . next ; cd != &v cache_head ; cd = cd -> next ) 
STRING , Cache_Flush ) 
! c -> data ) 
cs ) 
! c -> data ) 
cs ) 
c -> data ) 
INT_CONST ) 
) 
__E__O__F__
pt [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < numregs ; i v++ ) 
pt [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST ; ( pt [ i ] != CHAR_CONST ) || ( parencount > INT_CONST ) ; i v++ ) 
temp , type ) 
FOR ( i = INT_CONST ; i < numregs ; i v++ ) 
FOR ( i = INT_CONST ; i < ( tokennum - INT_CONST ) ; i v++ ) 
tokens [ INT_CONST ] [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < len ; i v++ ) 
tokens [ INT_CONST ] [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < len ; i v++ ) 
tokennum == INT_CONST ) 
stderr , STRING ) 
FOR ( j = INT_CONST ; j < tokennum ; j v++ ) 
tokennum == INT_CONST ) 
stderr , STRING ) 
FOR ( j = INT_CONST ; j < tokennum ; j v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < ( tokennum - INT_CONST ) ; i v++ ) 
i , STRING , INT_CONST ) 
c == CHAR_CONST ) 
c == CHAR_CONST ) 
FOR ( ; ; ) 
FOR ( ; ; ) 
FOR ( i = INT_CONST ; i < numparse ; i v++ ) 
FOR ( j = INT_CONST ; j < tokennum ; j v++ ) 
FOR ( j = INT_CONST ; j < tokennum ; j v++ ) 
STRING NEW_LINE STRING ) 
FOR ( ; ; ) 
__E__O__F__
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
FOR ( ; msg_readcount < packet_length ; msg_readcount v++ ) 
c == CHAR_CONST && data [ INT_CONST ] == CHAR_CONST ) 
c == CHAR_CONST ) 
INT_CONST ) 
CHAR *p s , CHAR *p key ) 
! *v s ) 
strstr ( key , STRING ) ) 
INT_CONST ) 
INT_CONST ) 
strstr ( key , STRING ) || strstr ( value , STRING ) ) 
s , key ) 
strlen ( new ) + strlen ( s ) > MAX_INFO_STRING ) 
*v s == CHAR_CONST ) 
__E__O__F__
STRING ) 
&v sin , INT_CONST , SIZEOF ( sin ) ) 
pse = getservbyname ( service , protocol ) ) 
phe = gethostbyname ( host ) ) 
( ppe = getprotobyname ( protocol ) ) == INT_CONST ) 
strcmp ( protocol , STRING ) == INT_CONST ) 
connect ( s , ( STRUCT sockaddr * ) & sin , SIZEOF ( sin ) ) < INT_CONST ) 
argc < INT_CONST ) 
) 
( s = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
( UNSIGNED SHORT ) atoi ( argv [ INT_CONST ] ) ) 
FOR ( p = peers ; p ; p = p -> next ) 
s , buffer , INT_CONST , INT_CONST , ( STRUCT sockaddr * ) & fsin , &v alen ) 
FOR ( p = peers ; p ; p = p -> next ) 
FOR ( p = peers ; p ; p = p -> next ) 
__E__O__F__
model -> numleafs + INT_CONST ) 
row ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
! mod -> needload ) 
UNSIGNED *p ) 
mod -> name , loadname ) 
! l -> filelen ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
anims , INT_CONST , SIZEOF ( anims ) ) 
FOR ( j = i + INT_CONST ; j < m -> nummiptex ; j v++ ) 
num + INT_CONST > altmax ) 
FOR ( j = INT_CONST ; j < max ; j v++ ) 
FOR ( j = INT_CONST ; j < altmax ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( surfnum = INT_CONST ; surfnum < count ; surfnum v++ , in v++ , out v++ ) 
in -> planenum ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < HEADER_LUMPS ; i v++ ) 
&v header -> lumps [ LUMP_VERTEXES ] ) 
) 
FOR ( i = INT_CONST ; i < mod -> numsubmodels ; i v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
__E__O__F__
FOR ( i = first ; i < pr_argc ; i v++ ) 
STRING ) 
OFS_PARM0 ) 
FOR ( i = INT_CONST , check = sv . model_precache ; *v check ; i v++ , check v++ ) 
m [ INT_CONST ] == CHAR_CONST ) 
INT_CONST ) 
OFS_RETURN ) 
OFS_RETURN + INT_CONST ) 
OFS_PARM0 ) 
FOR ( soundnum = INT_CONST , check = sv . sound_precache ; *v check ; check v++ , soundnum v++ ) 
&v sv . signon , svc_spawnstaticsound ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v sv . signon , vol * INT_CONST ) 
OFS_PARM0 ) 
v1 , vec3_origin , vec3_origin , v2 , nomonsters , ent ) 
trace . endpos , pr_global_struct -> trace_endpos ) 
check < INT_CONST ) 
FOR ( ; ; i v++ ) 
ent -> v . origin , ent -> v . view_ofs , org ) 
sv . time - sv . lastchecktime >= FLOAT_CONST ) 
sv . lastcheck ) 
pr_global_struct -> self ) 
ent ) 
cl , svc_stufftext , INT_CONST + strlen ( str ) ) 
edict_t * ) 
sv . edicts ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ , ent = NEXT_EDICT ( ent ) ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
chain ) 
chain ) 
FOR ( e v++ ; e < sv . num_edicts ; e v++ ) 
FOR ( i = INT_CONST ; i < MAX_SOUNDS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_MODELS ; i v++ ) 
yaw ) 
OFS_RETURN ) 
sv . state != ss_active ) 
FOR ( j = INT_CONST , client = svs . clients ; j < MAX_CLIENTS ; j v++ , client v++ ) 
OFS_PARM0 ) 
ent -> v . origin , start ) 
ent ) 
pr_global_struct -> v_forward , dir ) 
dir , bestdir ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ , check = NEXT_EDICT ( check ) ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
OFS_PARM0 ) 
pr_global_struct -> msg_entity ) 
&v sv . signon , SV_ModelIndex ( PR_GetString ( ent -> v . model ) ) ) 
&v sv . signon , ent -> v . frame ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent ) 
OFS_PARM0 ) 
i - INT_CONST ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
svs . spawncount == last_spawncount ) 
OFS_PARM0 ) 
ent1 ) 
OFS_PARM0 ) 
e1 == INT_CONST ) 
svs . clients [ e1 - INT_CONST ] . userinfo , key ) 
OFS_PARM0 ) 
OFS_RETURN ) 
OFS_PARM0 ) 
o , to ) 
__E__O__F__
FOR ( i = MAX_CLIENTS + INT_CONST ; i < sv . num_edicts ; i v++ ) 
vec3_origin , ed -> v . origin ) 
FOR ( i = INT_CONST ; i < progs -> numglobaldefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numglobaldefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfunctions ; i v++ ) 
FOR ( i = INT_CONST ; i < GEFV_CACHESIZE ; i v++ ) 
field ) 
strlen ( field ) < MAX_FIELD_LEN ) 
! def ) 
line , STRING , NUM_FOR_EDICT ( PROG_TO_EDICT ( val -> edict ) ) ) 
line , STRING , PR_GetString ( f -> s_name ) ) 
val -> _int ) 
line , STRING ) 
line , STRING , val -> _float ) 
line , STRING , val -> vector [ INT_CONST ] , val -> vector [ INT_CONST ] , val -> vector [ INT_CONST ] ) 
line , STRING ) 
line , STRING , type ) 
line , STRING , NUM_FOR_EDICT ( PROG_TO_EDICT ( val -> edict ) ) ) 
line , STRING , PR_GetString ( f -> s_name ) ) 
val -> _int ) 
line , STRING ) 
line , STRING , val -> _float ) 
line , STRING , val -> vector [ INT_CONST ] , val -> vector [ INT_CONST ] , val -> vector [ INT_CONST ] ) 
line , STRING , type ) 
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( ; i < INT_CONST ; i v++ ) 
ed -> free ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( j = INT_CONST ; j < type_size [ type ] ; j v++ ) 
f , STRING ) 
ed -> free ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( j = INT_CONST ; j < type_size [ type ] ; j v++ ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ ) 
STRING , sv . num_edicts ) 
f , STRING ) 
FOR ( i = INT_CONST ; i < progs -> numglobaldefs ; i v++ ) 
INT_CONST ) 
data ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
FLOAT *p ) 
string , s ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT *p ) 
s ) 
s ) 
ent != sv . edicts ) 
&v ent -> v , INT_CONST , progs -> entityfields * INT_CONST ) 
! strcmp ( com_token , STRING ) ) 
keyname , com_token ) 
data ) 
! init ) 
INT_CONST ) 
STRING , inhibit ) 
FOR ( i = INT_CONST ; i < GEFV_CACHESIZE ; i v++ ) 
num , STRING , CRC_Block ( ( byte * ) progs , com_filesize ) ) 
FOR ( i = INT_CONST ; i < SIZEOF ( *v progs ) / INT_CONST ; i v++ ) 
globalvars_t * ) 
FOR ( i = INT_CONST ; i < progs -> numstatements ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfunctions ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numglobaldefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numglobals ; i v++ ) 
( f = ED_FindFunction ( STRING ) ) != NULL ) 
__E__O__F__
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( i = pr_depth ; i >= INT_CONST ; i v-- ) 
FOR ( i = INT_CONST ; i < progs -> numfunctions ; i v++ ) 
STRING , best -> profile , PR_GetString ( best -> s_name ) ) 
argptr , error ) 
pr_statements + pr_xstatement ) 
pr_depth >= MAX_STACK_DEPTH ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( i = INT_CONST ; i < f -> numparms ; i v++ ) 
FOR ( j = INT_CONST ; j < f -> parm_size [ i ] ; j v++ ) 
pr_depth <= INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
! fnum || fnum >= progs -> numfunctions ) 
f ) 
eval_t * ) 
INT ) 
INT ) 
a -> string ) 
PROG_TO_EDICT ( a -> edict ) == sv . edicts ) 
a -> vector [ INT_CONST ] == b -> vector [ INT_CONST ] ) 
PR_GetString ( a -> string ) , PR_GetString ( b -> string ) ) 
a -> vector [ INT_CONST ] != b -> vector [ INT_CONST ] ) 
PR_GetString ( a -> string ) , PR_GetString ( b -> string ) ) 
eval_t * ) 
eval_t * ) 
a -> edict ) 
a -> edict ) 
a -> edict ) 
! a -> _int ) 
a -> _int ) 
! a -> function ) 
) 
pr_global_struct -> self ) 
STRING , st -> op ) 
s - pr_strings < INT_CONST ) 
FOR ( i = INT_CONST ; i <= num_prstr ; i v++ ) 
__E__O__F__
VOID ) 
&v master_adr , INT_CONST , SIZEOF ( master_adr ) ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
sv_logfile ) 
name , STRING , com_gamedir ) 
sv_fraglogfile ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING , name ) 
Cmd_Argv ( INT_CONST ) ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
! SV_SetPlayer ( ) ) 
! SV_SetPlayer ( ) ) 
Cmd_Argc ( ) != INT_CONST ) 
! strcmp ( level , STRING ) ) 
PRINT_HIGH , STRING ) 
expanded , STRING , level ) 
STRING ) 
level ) 
STRING ) 
Cmd_Argv ( INT_CONST ) ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
STRING , uid ) 
svs . stats . latched_active + svs . stats . latched_idle ) 
STRING , NET_AdrToString ( net_local_adr ) ) 
sv_redirected != RD_NONE ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ ) 
Cmd_Argc ( ) < INT_CONST ) 
*v p == CHAR_CONST ) 
text , p ) 
FOR ( j = INT_CONST , client = svs . clients ; j < MAX_CLIENTS ; j v++ , client v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
Cmd_Argc ( ) != INT_CONST ) 
Cmd_Argv ( INT_CONST ) [ INT_CONST ] == CHAR_CONST ) 
Cmd_Argv ( INT_CONST ) ) 
Cmd_Argv ( INT_CONST ) , Cmd_Argv ( INT_CONST ) ) 
Cmd_Argc ( ) != INT_CONST ) 
Cmd_Argv ( INT_CONST ) [ INT_CONST ] == CHAR_CONST ) 
! SV_SetPlayer ( ) ) 
Cmd_Argc ( ) == INT_CONST ) 
Cmd_Argc ( ) != INT_CONST ) 
INT_CONST ) 
strstr ( dir , STRING ) || strstr ( dir , STRING ) NEW_LINE || strstr ( dir , STRING ) || strstr ( dir , STRING ) ) 
svs . info , STRING , dir , MAX_SERVERINFO_STRING ) 
STRING ) 
Cmd_Argc ( ) != INT_CONST ) 
Cmd_Argv ( INT_CONST ) ) 
arg1 <= INT_CONST || arg2 <= INT_CONST || arg3 <= INT_CONST ) 
Cmd_Argc ( ) == INT_CONST ) 
Cmd_Argc ( ) != INT_CONST ) 
INT_CONST ) 
strstr ( dir , STRING ) || strstr ( dir , STRING ) NEW_LINE || strstr ( dir , STRING ) || strstr ( dir , STRING ) ) 
dir ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
pcxname , STRING , uid ) 
checkname , STRING , gamedirfile ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
&v cl -> snap_from , &v net_from , SIZEOF ( net_from ) ) 
Cmd_Argc ( ) != INT_CONST ) 
Cmd_Argv ( INT_CONST ) ) 
uid ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
STRING , SV_Logfile_f ) 
STRING , SV_Snap_f ) 
STRING , SV_Map_f ) 
STRING , SV_ConSay_f ) 
__E__O__F__
INT_CONST ) 
node -> contents < INT_CONST ) 
FOR ( i = INT_CONST ; i < fatbytes ; i v++ ) 
! numnails ) 
FOR ( n = INT_CONST ; n < numnails ; n v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
to -> angles [ INT_CONST ] != from -> angles [ INT_CONST ] ) 
! to -> number ) 
client -> delta_sequence != -v INT_CONST ) 
newindex < to -> num_entities || oldindex < oldmax ) 
msg , INT_CONST ) 
FOR ( j = INT_CONST , cl = svs . clients ; j < MAX_CLIENTS ; j v++ , cl v++ ) 
FOR ( i = INT_CONST ; i < ent -> num_leafs ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
clent -> v . origin , clent -> v . view_ofs , org ) 
client , clent , pvs , msg ) 
FOR ( e = MAX_CLIENTS + INT_CONST , ent = EDICT_NUM ( e ) ; e < sv . num_edicts ; e v++ , ent = NEXT_EDICT ( ent ) ) 
FOR ( i = INT_CONST ; i < ent -> num_leafs ; i v++ ) 
client , pack , msg ) 
msg ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAX_MODELS && sv . model_precache [ i ] ; i v++ ) 
FOR ( entnum = INT_CONST ; entnum < sv . num_edicts ; entnum v++ ) 
svent -> v . origin , svent -> baseline . origin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! sv . state ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < MAX_CLIENTS ; i v++ , host_client v++ ) 
FOR ( j = INT_CONST ; j < NUM_SPAWN_PARMS ; j v++ ) 
STRING ) 
num + INT_CONST ) 
rowbytes * num ) 
FOR ( i = INT_CONST ; i < num ; i v++ , scan += rowbytes ) 
FOR ( j = INT_CONST ; j < num ; j v++ ) 
rowbytes * num ) 
FOR ( i = INT_CONST ; i < num ; i v++ , dest += rowwords , scan += rowbytes ) 
FOR ( j = INT_CONST ; j < rowbytes ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( l = INT_CONST ; l < rowwords ; l v++ ) 
FOR ( j = INT_CONST ; j < num ; j v++ ) 
STRING NEW_LINE , vcount / num , count / num , num ) 
byte * ) 
STRING , server ) 
) 
&v sv , INT_CONST , SIZEOF ( sv ) ) 
sv . datagram_buf ) 
sv . reliable_datagram_buf ) 
sv . name , server ) 
) 
MAX_EDICTS * pr_edict_size , STRING ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
sv . name , server ) 
) 
FOR ( i = INT_CONST ; i < sv . worldmodel -> numsubmodels ; i v++ ) 
STRING ) 
INT_CONST ) 
sv . name ) 
) 
sv . worldmodel -> entities ) 
) 
) 
) 
) 
svs . info , STRING , sv . name , MAX_SERVERINFO_STRING ) 
__E__O__F__
inerror ) 
argptr , error ) 
STRING , string ) 
va ( STRING , string ) ) 
STRING , string ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
&v drop -> netchan . message , svc_disconnect ) 
drop -> state == cs_spawned ) 
drop -> userinfo , INT_CONST , SIZEOF ( drop -> userinfo ) ) 
drop , &v sv . reliable_datagram ) 
FOR ( frame = cl -> frames , i = INT_CONST ; i < UPDATE_BACKUP ; i v++ , frame v++ ) 
buf , svc_updatefrags ) 
info , client -> userinfo ) 
buf , svc_updateuserinfo ) 
STRING ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
sz -> cursize > LOG_HIGHWATER NEW_LINE || ( realtime - svs . logtime > LOG_FLUSH && sz -> cursize ) ) 
Cmd_Argc ( ) == INT_CONST ) 
INT_CONST , data , net_from ) 
STRING , svs . logsequence - INT_CONST , NET_AdrToString ( net_from ) ) 
data , STRING , svs . logsequence - INT_CONST ) 
strlen ( data ) + INT_CONST , data , net_from ) 
INT_CONST , &v data , net_from ) 
FOR ( i = INT_CONST ; i < MAX_CHALLENGES ; i v++ ) 
i == MAX_CHALLENGES ) 
net_from , STRING , S2C_CHALLENGE , NEW_LINE svs . challenges [ i ] . challenge ) 
Cmd_Argv ( INT_CONST ) ) 
Cmd_Argv ( INT_CONST ) ) 
Cmd_Argv ( INT_CONST ) ) 
userinfo , Cmd_Argv ( INT_CONST ) , SIZEOF ( userinfo ) - INT_CONST ) 
FOR ( i = INT_CONST ; i < MAX_CHALLENGES ; i v++ ) 
userinfo , STRING ) 
newcl , INT_CONST , SIZEOF ( client_t ) ) 
! sv_highchars . value ) 
FOR ( p = ( byte * ) newcl -> userinfo , q = ( byte * ) userinfo ; NEW_LINE *v q && p < ( byte * ) newcl -> userinfo + SIZEOF ( newcl -> userinfo ) - INT_CONST ; q v++ ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
maxclients . value > MAX_CLIENTS ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
adr , STRING , S2C_CONNECTION ) 
newcl - svs . clients ) 
newcl -> datagram_buf ) 
edictnum ) 
newcl ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pr_global_struct -> SetNewParms ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
! Rcon_Validate ( ) ) 
STRING NEW_LINE , NET_AdrToString ( net_from ) , net_message . data + INT_CONST ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
) 
) 
) 
s ) 
INT_CONST ) 
! strcmp ( c , STRING ) || ( c [ INT_CONST ] == A2A_PING && ( c [ INT_CONST ] == INT_CONST || c [ INT_CONST ] == CHAR_CONST ) ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
! StringToFilter ( Cmd_Argv ( INT_CONST ) , &v f ) ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
FOR ( j = i + INT_CONST ; j < numipfilters ; j v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
name , STRING , com_gamedir ) 
STRING , name ) 
name , STRING ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
data , STRING ) 
FOR ( i = INT_CONST ; i < numipfilters ; i v++ ) 
NET_GetPacket ( ) ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
cl -> state != cs_zombie ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
INT_CONST ) 
password . string == pw && spectator_password . string == spw ) 
pw && pw [ INT_CONST ] && strcmp ( pw , STRING ) ) 
) 
! sv . paused ) 
) 
) 
! sv . paused ) 
) 
) 
) 
) 
) 
) 
) 
&v sv_mintic ) 
&v fraglimit ) 
&v developer ) 
&v timeout ) 
&v sv_maxvelocity ) 
&v sv_aim ) 
&v filterban ) 
&v sv_highchars ) 
&v sv_phs ) 
&v pausable ) 
STRING , SV_AddIP_f ) 
FOR ( i = INT_CONST ; i < MAX_MODELS ; i v++ ) 
svs . log_buf [ INT_CONST ] ) 
realtime - svs . last_heartbeat < HEARTBEAT_SECONDS ) 
FOR ( i = INT_CONST ; i < MAX_CLIENTS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_MASTERS ; i v++ ) 
string , STRING , S2M_SHUTDOWN ) 
FOR ( i = INT_CONST ; i < MAX_MASTERS ; i v++ ) 
cl -> userinfo , STRING ) 
newname , val , SIZEOF ( newname ) - INT_CONST ) 
FOR ( p = newname ; ( *v p == CHAR_CONST || *v p == CHAR_CONST || *v p == CHAR_CONST ) && *v p ; p v++ ) 
p != newname && *v p ) 
FOR ( q = newname ; *v p ; *v q v++ = *v p v++ ) 
FOR ( p = newname + strlen ( newname ) - INT_CONST ; p != newname && ( *v p == CHAR_CONST || *v p == CHAR_CONST || *v p == CHAR_CONST ) ; p v-- ) 
strcmp ( val , newname ) ) 
! val [ INT_CONST ] || ! stricmp ( val , STRING ) ) 
INT_CONST ) 
FOR ( i = INT_CONST , client = svs . clients ; i < MAX_CLIENTS ; i v++ , client v++ ) 
cl -> name , val , SIZEOF ( cl -> name ) - INT_CONST ) 
cl -> userinfo , STRING ) 
cl -> userinfo , STRING ) 
STRING ) 
) 
COM_CheckParm ( STRING ) ) 
parms -> memsize < MINIMUM_MEMORY ) 
) 
) 
) 
) 
INT_CONST , STRING ) 
STRING ) 
STRING __TIME__ STRING __DATE__ STRING ) 
STRING , VERSION , build_number ( ) ) 
) 
sv . state == ss_dead ) 
__E__O__F__
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
mins [ INT_CONST ] + maxs [ INT_CONST ] ) 
trace . fraction == FLOAT_CONST ) 
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
ent -> v . origin , oldorg ) 
( INT ) ent -> v . flags & ( FL_SWIM | FL_FLY ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
neworg , end ) 
neworg , ent -> v . mins , ent -> v . maxs , end , false , ent ) 
trace . allsolid ) 
( INT ) ent -> v . flags & FL_PARTIALGROUND ) 
trace . endpos , ent -> v . origin ) 
( INT ) ent -> v . flags & FL_PARTIALGROUND ) 
relink ) 
ent -> v . origin , oldorigin ) 
( INT ) ( actor -> v . ideal_yaw / INT_CONST ) * INT_CONST ) 
deltax > INT_CONST ) 
( ( rand ( ) & INT_CONST ) & INT_CONST ) || abs ( deltay ) > abs ( deltax ) ) 
d [ INT_CONST ] != DI_NODIR && d [ INT_CONST ] != turnaround NEW_LINE && SV_StepDirection ( actor , d [ INT_CONST ] , dist ) ) 
FOR ( tdir = INT_CONST ; tdir <= INT_CONST ; tdir += INT_CONST ) 
FOR ( tdir = INT_CONST ; tdir >= INT_CONST ; tdir -= INT_CONST ) 
turnaround != DI_NODIR && SV_StepDirection ( actor , turnaround , dist ) ) 
! SV_CheckBottom ( actor ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
goal -> v . absmax [ i ] < ent -> v . absmin [ i ] - dist ) 
! ( ( INT ) ent -> v . flags & ( FL_ONGROUND | FL_FLY | FL_SWIM ) ) ) 
PROG_TO_EDICT ( ent -> v . enemy ) != sv . edicts && SV_CloseEnough ( ent , goal , dist ) ) 
__E__O__F__
__E__O__F__
sv . edicts ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , check = NEXT_EDICT ( check ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( bumpcount = INT_CONST ; bumpcount < numbumps ; bumpcount v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numplanes ; i v++ ) 
FOR ( j = INT_CONST ; j < numplanes ; j v++ ) 
ent -> v . origin , ent -> v . mins , ent -> v . maxs , end , MOVE_NOMONSTERS , ent ) 
trace . ent ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pusher -> v . origin , pushorig ) 
pusher -> v . origin , move , pusher -> v . origin ) 
sv . edicts ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , check = NEXT_EDICT ( check ) ) 
! ( ( ( INT ) check -> v . flags & FL_ONGROUND ) NEW_LINE && PROG_TO_EDICT ( check -> v . groundentity ) == pusher ) ) 
check -> v . mins [ INT_CONST ] == check -> v . maxs [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < num_moved ; i v++ ) 
! pusher -> v . velocity [ INT_CONST ] && ! pusher -> v . velocity [ INT_CONST ] && ! pusher -> v . velocity [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent , false ) 
ent -> v . origin ) 
! SV_RunThink ( ent ) ) 
ent -> v . movetype != MOVETYPE_FLY NEW_LINE && ent -> v . movetype != MOVETYPE_FLYMISSILE ) 
ent -> v . velocity , host_frametime , move ) 
trace . plane . normal [ INT_CONST ] > FLOAT_CONST ) 
ent ) 
! ( ( INT ) ent -> v . flags & ( FL_ONGROUND | FL_FLY | FL_SWIM ) ) ) 
ent , INT_CONST , STRING , INT_CONST , INT_CONST ) 
ent ) 
( INT ) ent -> v . movetype ) 
ent ) 
ent ) 
ent ) 
ent ) 
STRING , ( INT ) ent -> v . movetype ) 
! pr_global_struct -> newmis ) 
VOID ) 
host_frametime < sv_mintic . value ) 
) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ , ent = NEXT_EDICT ( ent ) ) 
__E__O__F__
sv_redirected == RD_PACKET ) 
sv_redirected ) 
STRING , msg ) 
sv_logfile ) 
! developer . value ) 
cl , level , string ) 
argptr , fmt ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
&v sv . reliable_datagram , svc_stufftext ) 
origin , sv . worldmodel ) 
to ) 
( sv . worldmodel -> numleafs + INT_CONST ) >> INT_CONST ) 
( sv . worldmodel -> numleafs + INT_CONST ) >> INT_CONST ) 
STRING , to ) 
FOR ( j = INT_CONST , client = svs . clients ; j < MAX_CLIENTS ; j v++ , client v++ ) 
origin , client -> edict -> v . origin , delta ) 
&v client -> datagram , sv . multicast . data , sv . multicast . cursize ) 
&v sv . multicast ) 
volume < INT_CONST || volume > INT_CONST ) 
FOR ( sound_num = INT_CONST ; sound_num < MAX_SOUNDS NEW_LINE && sv . sound_precache [ sound_num ] ; sound_num v++ ) 
sound_num == MAX_SOUNDS || ! sv . sound_precache [ sound_num ] ) 
volume != DEFAULT_SOUND_PACKET_VOLUME ) 
entity -> v . solid == SOLID_BSP ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v sv . multicast , svc_sound ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_MODELS ; i v++ ) 
client -> chokecount ) 
ent -> v . dmg_take || ent -> v . dmg_save ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent -> v . fixangle ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
client -> spectator && client -> spec_track > INT_CONST ) 
INT ) 
FOR ( i = INT_CONST ; i < MAX_CL_STATS ; i v++ ) 
buf ) 
client , &v msg ) 
client , &v msg ) 
client -> datagram . overflowed ) 
Netchan_CanReliable ( &v client -> netchan ) ) 
&v client -> netchan , msg . cursize , buf ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < MAX_CLIENTS ; i v++ , host_client v++ ) 
FOR ( j = INT_CONST , client = svs . clients ; j < MAX_CLIENTS ; j v++ , client v++ ) 
sv . datagram . overflowed ) 
FOR ( j = INT_CONST , client = svs . clients ; j < MAX_CLIENTS ; j v++ , client v++ ) 
&v sv . reliable_datagram ) 
) 
FOR ( i = INT_CONST , c = svs . clients ; i < MAX_CLIENTS ; i v++ , c v++ ) 
FOR ( j = INT_CONST ; j < c -> num_backbuf ; j v++ ) 
FOR ( i = INT_CONST , c = svs . clients ; i < MAX_CLIENTS ; i v++ , c v++ ) 
__E__O__F__
host_client -> state == cs_spawned ) 
svs . info , STRING ) 
&v host_client -> netchan . message , svc_serverdata ) 
host_client -> edict ) 
&v host_client -> netchan . message , PR_GetString ( sv . edicts -> v . message ) ) 
&v host_client -> netchan . message , movevars . gravity ) 
&v host_client -> netchan . message , svc_cdtrack ) 
&v host_client -> netchan . message , svc_stufftext ) 
host_client -> state != cs_connected ) 
atoi ( Cmd_Argv ( INT_CONST ) ) != svs . spawncount ) 
Cmd_Argv ( INT_CONST ) ) 
host_client -> num_backbuf ) 
&v host_client -> netchan . message , svc_soundlist ) 
FOR ( s = sv . sound_precache + INT_CONST + n ; NEW_LINE *v s && host_client -> netchan . message . cursize < ( MAX_MSGLEN / INT_CONST ) ; NEW_LINE s v++ , n v++ ) 
*v s ) 
host_client -> state != cs_connected ) 
Cmd_Argv ( INT_CONST ) ) 
host_client -> num_backbuf ) 
&v host_client -> netchan . message , svc_modellist ) 
FOR ( s = sv . model_precache + INT_CONST + n ; NEW_LINE *v s && host_client -> netchan . message . cursize < ( MAX_MSGLEN / INT_CONST ) ; NEW_LINE s v++ , n v++ ) 
*v s ) 
host_client -> state != cs_connected ) 
host_client -> num_backbuf ) 
&v host_client -> netchan . message , NEW_LINE sv . signon_buffers [ buf ] , NEW_LINE sv . signon_buffer_size [ buf ] ) 
&v host_client -> netchan . message , svc_stufftext ) 
&v host_client -> netchan . message , svc_stufftext ) 
host_client -> state != cs_connected ) 
atoi ( Cmd_Argv ( INT_CONST ) ) != svs . spawncount ) 
Cmd_Argv ( INT_CONST ) ) 
n < INT_CONST || n > MAX_CLIENTS ) 
&v host_client -> netchan . message ) 
FOR ( i = n , client = svs . clients + n ; i < MAX_CLIENTS ; i v++ , client v++ ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTSTYLES ; i v++ ) 
&v ent -> v , INT_CONST , progs -> entityfields * INT_CONST ) 
host_client -> name ) 
ent , STRING ) 
host_client , svc_updatestatlong , INT_CONST ) 
host_client , svc_updatestatlong , INT_CONST ) 
host_client , svc_updatestatlong , INT_CONST ) 
host_client , svc_updatestatlong , INT_CONST ) 
host_client , svc_stufftext , INT_CONST ) 
vec3_origin , sv_player -> v . origin ) 
FOR ( i = MAX_CLIENTS - INT_CONST ; i < sv . num_edicts ; i v++ ) 
host_client -> state == cs_spawned ) 
host_client -> spectator ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
Info_ValueForKey ( host_client -> userinfo , STRING ) ) 
pmodel != sv . model_player_checksum || NEW_LINE emodel != sv . eyes_player_checksum ) 
sv . paused ) 
INT_CONST + ( host_client - svs . clients ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! host_client -> download ) 
! size ) 
host_client -> downloadcount != host_client -> downloadsize ) 
strlen ( send ) + INT_CONST , send , where ) 
! *v host_client -> uploadfn ) 
) 
! host_client -> upload ) 
net_message . data + msg_readcount , INT_CONST , size , host_client -> upload ) 
STRING , size ) 
INT_CONST ) 
host_client -> download ) 
FOR ( p = name ; *v p ; p v++ ) 
name , &v host_client -> download ) 
! host_client -> download NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE COMMENT_NL CPP_COMMENT NEW_LINE || ( strncmp ( name , STRING , INT_CONST ) == INT_CONST && file_from_pak ) ) 
) 
Cmd_Argc ( ) < INT_CONST ) 
host_client -> spectator && ( ! sv_spectalk . value || team ) ) 
fp_messages ) 
! sv . paused && NEW_LINE host_client -> whensaid [ tmp ] && ( realtime - host_client -> whensaid [ tmp ] < fp_persecond ) ) 
host_client , PRINT_CHAT , NEW_LINE STRING , fp_secondsdead ) 
) 
*v p == CHAR_CONST ) 
text , p ) 
STRING , text ) 
FOR ( j = INT_CONST , client = svs . clients ; j < MAX_CLIENTS ; j v++ , client v++ ) 
FOR ( j = INT_CONST , client = svs . clients ; j < MAX_CLIENTS ; j v++ , client v++ ) 
msg ) 
FOR ( i = INT_CONST , cl = svs . clients ; i < MAX_CLIENTS ; i v++ , cl v++ ) 
! pausable . value ) 
host_client -> spectator ) 
sv . paused ) 
host_client - svs . clients + INT_CONST ) 
Cmd_Argc ( ) == INT_CONST ) 
Cmd_Argc ( ) != INT_CONST ) 
Cmd_Argv ( INT_CONST ) [ INT_CONST ] == CHAR_CONST ) 
host_client -> userinfo , Cmd_Argv ( INT_CONST ) , Cmd_Argv ( INT_CONST ) , MAX_INFO_STRING ) 
host_client ) 
&v sv . reliable_datagram , svc_setinfo ) 
RD_CLIENT ) 
FOR ( u = ucmds ; u -> name ; u v++ ) 
areanode_t * node ) 
sv_player ) 
FOR ( l = node -> solid_edicts . next ; l != &v node -> solid_edicts ; l = next ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
node -> axis == -v INT_CONST ) 
sv_player ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , check = NEXT_EDICT ( check ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cmd . msec > INT_CONST ) 
! sv_player -> v . fixangle ) 
host_frametime > FLOAT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pmove . origin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! host_client -> spectator ) 
FOR ( i = INT_CONST ; i < pmove . numtouch ; i v++ ) 
! host_client -> spectator ) 
cl -> netchan . incoming_sequence >= cl -> netchan . outgoing_sequence ) 
INT_CONST ) 
) 
__E__O__F__
&v tp , &v tzp ) 
argptr , fmt ) 
strlen ( text ) > SIZEOF ( text ) ) 
FOR ( p = ( UNSIGNED CHAR *p ) text ; *v p ; p v++ ) 
! stdin_ready || ! do_stdin ) 
INT_CONST , text , SIZEOF ( text ) ) 
&v parms , INT_CONST , SIZEOF ( parms ) ) 
argc , argv ) 
STRING ) 
&v parms ) 
FLOAT_CONST ) 
) 
&v fdset ) 
) 
__E__O__F__
argptr , error ) 
STRING , text ) 
INT_CONST ) 
&v tstruct ) 
_kbhit ( ) ) 
len == SIZEOF ( text ) ) 
argc , argv ) 
( t = COM_CheckParm ( STRING ) ) != INT_CONST && NEW_LINE t + INT_CONST < com_argc ) 
! parms . membase ) 
&v parms ) 
FLOAT_CONST ) 
) 
&v fdset ) 
) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vec3_t mins , vec3_t maxs ) 
ent -> v . solid == SOLID_BSP ) 
ent -> v . movetype != MOVETYPE_PUSH ) 
ent -> v . mins , maxs , hullmins ) 
&v anode -> trigger_edicts ) 
depth + INT_CONST , mins2 , maxs2 ) 
FOR ( l = node -> trigger_edicts . next ; l != &v node -> trigger_edicts ; l = next ) 
node -> axis == -v INT_CONST ) 
node -> contents == CONTENTS_SOLID ) 
node -> contents < INT_CONST ) 
ent -> v . absmin , ent -> v . absmax , splitplane ) 
sides & INT_CONST ) 
ent -> v . modelindex ) 
ent -> v . solid == SOLID_TRIGGER ) 
touch_triggers ) 
num >= INT_CONST ) 
ent -> v . origin , ent -> v . mins , ent -> v . maxs , ent -> v . origin , INT_CONST , ent ) 
num < INT_CONST ) 
num < hull -> firstclipnode || num > hull -> lastclipnode ) 
plane -> type < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! SV_RecursiveHullCheck ( hull , node -> children [ side ] , p1f , midf , p1 , mid , trace ) ) 
SV_HullPointContents ( hull , hull -> firstclipnode , mid ) NEW_LINE == CONTENTS_SOLID ) 
frac < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mid , trace -> endpos ) 
&v trace , INT_CONST , SIZEOF ( trace_t ) ) 
ent , mins , maxs , offset ) 
start , offset , start_l ) 
hull , hull -> firstclipnode , INT_CONST , INT_CONST , start_l , end_l , &v trace ) 
trace . fraction != INT_CONST ) 
FOR ( l = node -> solid_edicts . next ; l != &v node -> solid_edicts ; l = next ) 
clip -> trace . allsolid ) 
node -> axis == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v clip , INT_CONST , SIZEOF ( moveclip_t ) ) 
sv . edicts , start , mins , maxs , end ) 
type == MOVE_MISSILE ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
start , clip . mins2 , clip . maxs2 , end , clip . boxmins , clip . boxmaxs ) 
sv_areanodes , &v clip ) 
SV_HullPointContents ( hull , hull -> firstclipnode , origin ) != CONTENTS_EMPTY ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , check = NEXT_EDICT ( check ) ) 
check , ent -> v . mins , ent -> v . maxs , offset ) 
__E__O__F__
rb >> INT_CONST ) 
STRUCT reset_s ) 
INT_CONST ) 
STRUCT reset_s ) 
INT_CONST ) 
STRUCT audioTrackInfo_s ) 
INT_CONST ) 
cdRequest -> status & STATUS_ERROR_BIT ) 
control & AUDIO_CONTROL_DATA_TRACK ) 
STRUCT audioDiskInfo_s ) 
INT_CONST ) 
cdRequest -> status & STATUS_ERROR_BIT ) 
FOR ( n = cd . lowTrack ; n <= cd . highTrack ; n v++ ) 
STRUCT audioStatus_s ) 
INT_CONST ) 
cdRequest -> status & STATUS_ERROR_BIT ) 
STRUCT mediaChange_s ) 
INT_CONST ) 
STRUCT audioChannelInfo_s ) 
INT_CONST ) 
INT_CONST ) 
! initialized || ! enabled ) 
playing ) 
track < cd . lowTrack || track > cd . highTrack ) 
cd . track [ track ] . isData ) 
INT ) 
INT_CONST ) 
cdRequest -> status & STATUS_ERROR_BIT ) 
INT_CONST ) 
INT_CONST ) 
Cmd_Argc ( ) < INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n <= ret ; n v++ ) 
! cd . valid ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = cd . lowTrack ; n <= cd . highTrack ; n v++ ) 
! initialized || ! enabled ) 
mediaCheck ) 
INT ) 
playing ) 
cls . state == ca_dedicated ) 
INT_CONST ) 
) 
SIZEOF ( STRUCT cd_request NEW_LINE ) + SIZEOF ( UNION readInfo_u ) ) 
STRUCT cd_request * ) 
UNION readInfo_u * ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
INT_CONST ) 
STRING , CD_f ) 
STRING ) 
__E__O__F__
ioctl ( cdfile , CDROMREADTOCHDR , &v tochdr ) == -v INT_CONST ) 
cdfile == -v INT_CONST || ! enabled ) 
track < INT_CONST || track > maxTrack ) 
ioctl ( cdfile , CDROMREADTOCENTRY , &v entry ) == -v INT_CONST ) 
playing ) 
ioctl ( cdfile , CDROMPLAYTRKIND , &v ti ) == -v INT_CONST ) 
cdvolume == FLOAT_CONST ) 
Cmd_Argc ( ) < INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n <= ret ; n v++ ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
! cdValid ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
! enabled ) 
playing && lastchk < time ( NULL ) ) 
cls . state == ca_dedicated ) 
( cdfile = open ( cd_dev , O_RDONLY ) ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
CDAudio_GetAudioDiskInfo ( ) ) 
STRING , CD_f ) 
STRING ) 
__E__O__F__
__E__O__F__
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_DOOR_OPEN , ( DWORD ) NULL ) ) 
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_DOOR_CLOSED , ( DWORD ) NULL ) ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
! enabled ) 
track < INT_CONST || track > maxTrack ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
wDeviceID , MCI_STATUS , MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT , ( DWORD ) ( LPVOID ) & mciStatusParms ) 
playing ) 
track , INT_CONST , INT_CONST , INT_CONST ) 
cdvolume == FLOAT_CONST ) 
! enabled ) 
! enabled ) 
Cmd_Argc ( ) < INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n <= ret ; n v++ ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
! cdValid ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
Q_strcasecmp ( command , STRING ) == INT_CONST ) 
cls . state == ca_dedicated ) 
dwReturn = mciSendCommand ( wDeviceID , MCI_SET , MCI_SET_TIME_FORMAT , ( DWORD ) ( LPVOID ) & mciSetParms ) ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
CDAudio_GetAudioDiskInfo ( ) ) 
STRING , CD_f ) 
STRING ) 
__E__O__F__
&v trace , INT_CONST , SIZEOF ( trace ) ) 
trace . endpos , impact ) 
cl . viewangles , forward , right , up ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
r_refdef . vieworg , INT_CONST , forward , dest ) 
stop , r_refdef . vieworg , stop ) 
chase_dest , r_refdef . vieworg ) 
__E__O__F__
cls . timedemo ) 
net_message . cursize ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cls . signon == SIGNONS ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST ) 
cls . demorecording ) 
&v net_message ) 
cls . demofile ) 
cmd_source != src_command ) 
strstr ( Cmd_Argv ( INT_CONST ) , STRING ) ) 
c == INT_CONST && cls . state == ca_connected ) 
c == INT_CONST ) 
c > INT_CONST ) 
name , STRING ) 
STRING , name ) 
cls . demofile , STRING , cls . forcetrack ) 
cmd_source != src_command ) 
) 
name , Cmd_Argv ( INT_CONST ) ) 
STRING , name ) 
( c = getc ( cls . demofile ) ) != CHAR_CONST ) 
host_framecount - cls . td_startframe ) 
) 
__E__O__F__
INT_CONST ) 
b -> down [ INT_CONST ] == k ) 
up || down ) 
&v in_moveright ) 
&v in_up ) 
! ( in_klook . state & INT_CONST ) ) 
in_speed . state & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v buf , cmd -> lightlevel ) 
__E__O__F__
! sv . active ) 
&v cls . message ) 
cl_efrags , INT_CONST , SIZEOF ( cl_efrags ) ) 
FOR ( i = INT_CONST ; i < MAX_EFRAGS - INT_CONST ; i v++ ) 
cls . demoplayback ) 
STRING ) 
host ) 
STRING , cls . signon ) 
&v cls . message , clc_stringcmd ) 
&v cls . message , clc_stringcmd ) 
) 
cls . demonum == -v INT_CONST ) 
! cls . demos [ cls . demonum ] [ INT_CONST ] || cls . demonum == MAX_DEMOS ) 
str , STRING , cls . demos [ cls . demonum ] ) 
FOR ( i = INT_CONST , ent = cl_entities ; i < cl . num_entities ; i v++ , ent v++ ) 
i == INT_CONST ) 
FOR ( c = INT_CONST ; c < INT_CONST ; c += INT_CONST ) 
FOR ( c = INT_CONST ; c < INT_CONST ; c += INT_CONST ) 
key ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
dl , INT_CONST , SIZEOF ( *v dl ) ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , dl v++ ) 
! f || cl_nolerp . value || cls . timedemo || sv . active ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST , ent = cl_entities + INT_CONST ; i < cl . num_entities ; i v++ , ent v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
cls . state != ca_connected ) 
&v cmd ) 
! cls . message . cursize ) 
NET_SendMessage ( cls . netcon , &v cls . message ) == -v INT_CONST ) 
&v cl_name ) 
&v m_pitch ) 
STRING , CL_PrintEntities_f ) 
__E__O__F__
ent > MAX_EDICTS ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
net_message . data , olddata , net_message . cursize ) 
) 
STRING ) 
&v cls . message , clc_nop ) 
) 
) 
) 
) 
STRING ) 
cl . model_precache , INT_CONST , SIZEOF ( cl . model_precache ) ) 
FOR ( nummodels = INT_CONST ; ; nummodels v++ ) 
cl . sound_precache , INT_CONST , SIZEOF ( cl . sound_precache ) ) 
FOR ( numsounds = INT_CONST ; ; numsounds v++ ) 
FOR ( i = INT_CONST ; i < nummodels ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < numsounds ; i v++ ) 
) 
cls . signon == SIGNONS - INT_CONST ) 
) 
bits & U_MOREBITS ) 
bits & U_LONGENTITY ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent -> msgtime != cl . mtime [ INT_CONST ] ) 
model ) 
bits & U_SKIN ) 
bits & U_SKIN ) 
bits & U_ORIGIN1 ) 
ent -> msg_origins [ INT_CONST ] , ent -> msg_origins [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
bits & SU_WEAPONFRAME ) 
cl . stats [ STAT_ARMOR ] != i ) 
bits & SU_WEAPON ) 
cl . stats [ STAT_WEAPON ] != i ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
standard_quake ) 
FOR ( i = INT_CONST ; i < VID_GRADES ; i v++ , dest += INT_CONST , source += INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
ent -> baseline . origin , ent -> origin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl_shownet . value == INT_CONST ) 
cmd & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
start , b -> start ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
start , b -> start ) 
) 
) 
) 
) 
-v INT_CONST , INT_CONST , cl_sfx_ric1 , pos , INT_CONST , INT_CONST ) 
) 
-v INT_CONST , INT_CONST , cl_sfx_ric1 , pos , INT_CONST , INT_CONST ) 
) 
) 
) 
Mod_ForName ( STRING , true ) ) 
Mod_ForName ( STRING , true ) ) 
Mod_ForName ( STRING , true ) ) 
Mod_ForName ( STRING , true ) ) 
) 
) 
) 
) 
) 
STRING ) 
cl_numvisedicts == MAX_VISEDICTS ) 
FOR ( i = INT_CONST , b = cl_beams ; i < MAX_BEAMS ; i v++ , b v++ ) 
b -> entity == cl . viewentity ) 
b -> end , b -> start , dist ) 
b -> start , org ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
&v cmd_text , text , Q_strlen ( text ) ) 
templen ) 
templen ) 
FOR ( i = INT_CONST ; i < cmd_text . cursize ; i v++ ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
s + INT_CONST ) 
FOR ( i = INT_CONST ; i < s - INT_CONST ; i v++ ) 
FOR ( j = i ; ( text [ j ] != CHAR_CONST ) && ( text [ j ] != CHAR_CONST ) && ( text [ j ] != INT_CONST ) ; j v++ ) 
Cmd_Argc ( ) != INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
INT_CONST ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
! a ) 
) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( i = INT_CONST ; i < cmd_argc ; i v++ ) 
CHAR *p cmd_name , xcommand_t function ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
SIZEOF ( cmd_function_t ) ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
text ) 
FOR ( cmd = cmd_functions ; cmd ; cmd = cmd -> next ) 
FOR ( a = cmd_alias ; a ; a = a -> next ) 
! Cvar_Command ( ) ) 
VOID ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
str [ INT_CONST ] == CHAR_CONST ) 
INT_CONST ) 
str [ INT_CONST ] == CHAR_CONST ) 
INT_CONST ) 
decimal == -v INT_CONST ) 
l >> INT_CONST ) 
b1 << INT_CONST ) 
l >> INT_CONST ) 
( INT ) b1 << INT_CONST ) 
sizebuf_t * buf , CHAR *p data ) 
*v in && *v in != CHAR_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST && *v in ; i v++ , in v++ ) 
FOR ( s2 = s ; *v s2 && *v s2 != CHAR_CONST ; s2 v-- ) 
*v src != CHAR_CONST && src != path ) 
path , extension ) 
c == CHAR_CONST && data [ INT_CONST ] == CHAR_CONST ) 
c == CHAR_CONST ) 
c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST ) 
c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
STRING , &v h ) 
h == -v INT_CONST ) 
h , check , SIZEOF ( check ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; ( j < MAX_NUM_ARGVS ) && ( j < argc ) ; j v++ ) 
( n < ( CMDLINE_LENGTH - INT_CONST ) ) && argv [ j ] [ i ] ) 
FOR ( com_argc = INT_CONST ; ( com_argc < MAX_NUM_ARGVS ) && ( com_argc < argc ) ; NEW_LINE com_argc v++ ) 
safe ) 
FOR ( i = INT_CONST ; i < NUM_SAFE_ARGVS ; i v++ ) 
COM_CheckParm ( STRING ) ) 
COM_CheckParm ( STRING ) ) 
*v ( SHORT *p ) swaptest == INT_CONST ) 
&v registered ) 
) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( s = com_searchpaths ; s ; s = s -> next ) 
FOR ( ofs = path + INT_CONST ; *v ofs ; ofs v++ ) 
in ) 
file && handle ) 
! strcmp ( filename , STRING ) ) 
FOR ( ; search ; search = search -> next ) 
search -> pack ) 
FOR ( i = INT_CONST ; i < pak -> numfiles ; i v++ ) 
STRING , pak -> filename , filename ) 
FOR ( s = com_searchpaths ; s ; s = s -> next ) 
path , &v h ) 
path , base ) 
Sys_FileOpenRead ( packfile , &v packhandle ) == -v INT_CONST ) 
dpackfile_t ) 
numpackfiles > MAX_FILES_IN_PACK ) 
packhandle , header . dirofs ) 
&v crc ) 
FOR ( i = INT_CONST ; i < header . dirlen ; i v++ ) 
FOR ( i = INT_CONST ; i < numpackfiles ; i v++ ) 
SIZEOF ( pack_t ) ) 
com_gamedir , dir ) 
SIZEOF ( searchpath_t ) ) 
FOR ( i = INT_CONST ; ; i v++ ) 
STRING ) 
j > INT_CONST ) 
STRING ) 
COM_CheckParm ( STRING ) ) 
STRING ) 
COM_CheckParm ( STRING ) ) 
__E__O__F__
! hFile || ! heventParent || ! heventChild ) 
NULL , FALSE , FALSE , NULL ) 
! heventDone ) 
! CreateThread ( NULL , NEW_LINE INT_CONST , NEW_LINE ( LPTHREAD_START_ROUTINE ) RequestProc , NEW_LINE INT_CONST , NEW_LINE INT_CONST , NEW_LINE &v dwID ) ) 
STD_OUTPUT_HANDLE ) 
hStdout , INT_CONST , INT_CONST ) 
INT_CONST ) 
dwRet == WAIT_OBJECT_0 + INT_CONST ) 
hfileBuffer , NEW_LINE FILE_MAP_READ | FILE_MAP_WRITE , INT_CONST , INT_CONST , INT_CONST ) 
NEW_LINE hStdout , NEW_LINE pszText , NEW_LINE INT_CONST * ( iEndLine - iBeginLine + INT_CONST ) , NEW_LINE coord , NEW_LINE &v dwRead ) 
bRet ) 
LPTSTR ) 
*v sz ) 
*v sz == INT_CONST ) 
isalpha ( c ) ) 
! SetConsoleScreenBufferSize ( hStdout , info . dwSize ) ) 
! SetConsoleWindowInfo ( hStdout , TRUE , &v info . srWindow ) ) 
! SetConsoleScreenBufferSize ( hStdout , info . dwSize ) ) 
! SetConsoleWindowInfo ( hStdout , TRUE , &v info . srWindow ) ) 
__E__O__F__
FOR ( i = INT_CONST ; i < NUM_CON_TIMES ; i v++ ) 
vid . width >> INT_CONST ) 
width == con_linewidth ) 
FOR ( i = INT_CONST ; i < numlines ; i v++ ) 
FOR ( j = INT_CONST ; j < numchars ; j v++ ) 
STRING ) 
con_debuglog ) 
CON_TEXTSIZE , STRING ) 
STRING , Con_ToggleConsole_f ) 
FOR ( l = INT_CONST ; l < con_linewidth ; l v++ ) 
l != con_linewidth && ( con_x + l > con_linewidth ) ) 
cr ) 
STRING , msg ) 
con_debuglog ) 
cls . signon != SIGNONS && ! scr_disabled_for_loading ) 
! inupdate ) 
STRING , msg ) 
key_dest != key_console && ! con_forcedup ) 
( INT ) ( realtime * con_cursorspeed ) & INT_CONST ) 
FOR ( i = key_linepos + INT_CONST ; i < con_linewidth ; i v++ ) 
FOR ( i = INT_CONST ; i < con_linewidth ; i v++ ) 
FOR ( i = con_current - NUM_CON_TIMES + INT_CONST ; i <= con_current ; i v++ ) 
FOR ( x = INT_CONST ; x < con_linewidth ; x v++ ) 
key_dest == key_message ) 
lines - INT_CONST ) 
rows << INT_CONST ) 
FOR ( i = con_current - rows + INT_CONST ; i <= con_current ; i v++ , y += INT_CONST ) 
FOR ( x = INT_CONST ; x < con_linewidth ; x v++ ) 
drawinput ) 
STRING ) 
text ) 
STRING ) 
STRING ) 
__E__O__F__
__E__O__F__
FOR ( var = cvar_vars ; var ; var = var -> next ) 
FOR ( cvar = cvar_vars ; cvar ; cvar = cvar -> next ) 
STRING , var_name ) 
var -> string , value ) 
Cvar_FindVar ( variable -> name ) ) 
Cmd_Exists ( variable -> name ) ) 
Cmd_Argv ( INT_CONST ) ) 
v -> name , Cmd_Argv ( INT_CONST ) ) 
FOR ( var = cvar_vars ; var ; var = var -> next ) 
__E__O__F__
firsttime ) 
size + INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ptr ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
intr , &v oldstuff -> pm_oldvec ) 
INT ) 
intr , &v info ) 
FOR ( i = INT_CONST ; i < handlercount ; i v++ ) 
__E__O__F__
FOR ( pic = menu_cachepics , i = INT_CONST ; i < menu_numcachepics ; pic v++ , i v++ ) 
&v pic -> cache ) 
dat ) 
dat ) 
STRING ) 
y < INT_CONST ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
source [ INT_CONST ] ) 
UNSIGNED SHORT *p ) 
! vid . direct ) 
row << INT_CONST ) 
drawline v-- ) 
( x < INT_CONST ) || NEW_LINE ( x + pic -> width > vid . width ) || NEW_LINE ( y < INT_CONST ) || NEW_LINE ( y + pic -> height > vid . height ) ) 
r_pixbytes == INT_CONST ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
UNSIGNED SHORT *p ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
x < INT_CONST || ( UNSIGNED ) ( x + pic -> width ) > vid . width || y < INT_CONST || NEW_LINE ( UNSIGNED ) ( y + pic -> height ) > vid . height ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u += INT_CONST ) 
UNSIGNED SHORT *p ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
x < INT_CONST || ( UNSIGNED ) ( x + pic -> width ) > vid . width || y < INT_CONST || NEW_LINE ( UNSIGNED ) ( y + pic -> height ) > vid . height ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u += INT_CONST ) 
UNSIGNED SHORT *p ) 
FOR ( v = INT_CONST ; v < pic -> height ; v v++ ) 
FOR ( u = INT_CONST ; u < pic -> width ; u v++ ) 
row << INT_CONST ) 
drawline v-- ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
STRING ) 
ver , STRING , ( FLOAT ) VERSION ) 
FOR ( x = INT_CONST ; x < strlen ( ver ) ; x v++ ) 
r_pixbytes == INT_CONST ) 
FOR ( y = INT_CONST ; y < lines ; y v++ , dest += vid . conrowbytes ) 
FOR ( x = INT_CONST ; x < vid . conwidth ; x += INT_CONST ) 
FOR ( y = INT_CONST ; y < lines ; y v++ , pusdest += ( vid . conrowbytes >> INT_CONST ) ) 
FOR ( x = INT_CONST ; x < vid . conwidth ; x += INT_CONST ) 
prect -> y * vid . rowbytes ) 
transparent ) 
FOR ( i = INT_CONST ; i < prect -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < prect -> width ; j v++ ) 
FOR ( i = INT_CONST ; i < prect -> height ; i v++ ) 
UNSIGNED SHORT *p ) 
transparent ) 
FOR ( i = INT_CONST ; i < prect -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < prect -> width ; j v++ ) 
FOR ( i = INT_CONST ; i < prect -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < prect -> width ; j v++ ) 
height > INT_CONST ) 
r_pixbytes == INT_CONST ) 
FOR ( v = INT_CONST ; v < h ; v v++ , dest += vid . rowbytes ) 
FOR ( u = INT_CONST ; u < w ; u v++ ) 
FOR ( v = INT_CONST ; v < h ; v v++ , pusdest += ( vid . rowbytes >> INT_CONST ) ) 
FOR ( u = INT_CONST ; u < w ; u v++ ) 
) 
FOR ( y = INT_CONST ; y < vid . height ; y v++ ) 
byte * ) 
FOR ( x = INT_CONST ; x < vid . width ; x v++ ) 
) 
__E__O__F__
scale >= d_scalemip [ INT_CONST ] ) 
FOR ( span = surf -> spans ; span ; span = span -> pnext ) 
FOR ( u v++ ; u <= u2 ; u v++ ) 
FOR ( u v++ ; u & INT_CONST ; u v++ ) 
FOR ( ; u <= u2 ; u += INT_CONST ) 
FOR ( ; u <= u2 ; u v++ ) 
FLOAT ) 
pface -> texinfo -> vecs [ INT_CONST ] , p_saxis ) 
transformed_modelorg , mipscale , p_temp1 ) 
( fixed16_t ) ( DotProduct ( p_temp1 , p_saxis ) * INT_CONST + FLOAT_CONST ) ) 
modelorg , transformed_modelorg ) 
r_drawflat . value ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
pface -> texinfo -> texture -> offsets [ INT_CONST ] ) 
base_vup , vup ) 
base_vright , vright ) 
base_vup , vup ) 
base_vright , vright ) 
__E__O__F__
rx < INT_CONST ) 
( ( rwidth & INT_CONST ) == INT_CONST ) && ( ( ( LONG ) dest & INT_CONST ) == INT_CONST ) ) 
UNSIGNED *p ) 
FOR ( ry = INT_CONST ; ry < rheight ; ry v++ ) 
FOR ( rx = INT_CONST ; rx < rwidth ; rx v++ ) 
FOR ( ry = INT_CONST ; ry < rheight ; ry v++ ) 
FOR ( rx = INT_CONST ; rx < rwidth ; rx v++ ) 
__E__O__F__
&v d_subdiv16 ) 
r_dowarp ) 
d_minmip > INT_CONST ) 
FOR ( i = INT_CONST ; i < ( NUM_MIPS - INT_CONST ) ; i v++ ) 
__E__O__F__
! protectset8 ) 
r_dowarp ) 
d_pix_min < INT_CONST ) 
FOR ( i = INT_CONST ; i < vid . height ; i v++ ) 
) 
__E__O__F__
pparticle -> org , r_origin , local ) 
local , r_pright ) 
transformed [ INT_CONST ] < PARTICLE_Z_CLIP ) 
( v > d_vrectbottom_particle ) || NEW_LINE ( u > d_vrectright_particle ) || NEW_LINE ( v < d_vrecty ) || NEW_LINE ( u < d_vrectx ) ) 
d_zwidth * v ) 
pix < d_pix_min ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( ; count ; count v-- , pz += d_zwidth , pdest += screenwidth ) 
FOR ( i = INT_CONST ; i < pix ; i v++ ) 
__E__O__F__
FLOAT ) 
FOR ( v = INT_CONST ; v < scr_vrect . height + AMP2 * INT_CONST ; v v++ ) 
FOR ( u = INT_CONST ; u < scr_vrect . width + AMP2 * INT_CONST ; u v++ ) 
( INT ) ( cl . time * SPEED ) & ( CYCLE - INT_CONST ) ) 
FOR ( v = INT_CONST ; v < scr_vrect . height ; v v++ , dest += vid . rowbytes ) 
FOR ( u = INT_CONST ; u < scr_vrect . width ; u += INT_CONST ) 
UNSIGNED CHAR *p ) 
FLOAT ) 
INT ) 
INT ) 
snext - r_turb_s ) 
INT ) 
r_turb_spancount > INT_CONST ) 
UNSIGNED CHAR *p ) 
FLOAT ) 
INT ) 
FLOAT ) 
INT ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numverts ; i v++ , fv v++ ) 
( fv -> v [ INT_CONST ] < r_refdef . vrectright ) && NEW_LINE ( fv -> v [ INT_CONST ] < r_refdef . vrectbottom ) ) 
FOR ( i = INT_CONST ; i < lnumtriangles ; i v++ ) 
FOR ( i = INT_CONST ; i < lnumtriangles ; i v++ , ptri v++ ) 
d < -v INT_CONST || d > INT_CONST ) 
lp1 [ INT_CONST ] + lp2 [ INT_CONST ] ) 
lp2 [ INT_CONST ] > lp1 [ INT_CONST ] ) 
lp3 , lp1 , new ) 
FOR ( i = INT_CONST ; i < MAX_LBM_HEIGHT ; i v++ , s += skinwidth ) 
errorterm >= INT_CONST ) 
( ( tm <= INT_CONST ) && ( tm >= -v INT_CONST ) ) && NEW_LINE ( ( tn <= INT_CONST ) && ( tn >= -v INT_CONST ) ) ) 
FLOAT ) 
INT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST ) 
r_affinetridesc . skinwidth ) 
byte * ) 
byte * ) 
initialleftheight == INT_CONST ) 
ubasestep < INT_CONST ) 
pedgetable -> numleftedges == INT_CONST ) 
ubasestep < INT_CONST ) 
prighttop [ INT_CONST ] , prighttop [ INT_CONST ] , NEW_LINE prightbottom [ INT_CONST ] , prightbottom [ INT_CONST ] ) 
a_spans ) 
pedgetable -> numrightedges == INT_CONST ) 
r_p0 [ INT_CONST ] >= r_p1 [ INT_CONST ] ) 
r_p0 [ INT_CONST ] == r_p2 [ INT_CONST ] ) 
r_p0 [ INT_CONST ] > r_p2 [ INT_CONST ] ) 
lp1 [ INT_CONST ] + lp2 [ INT_CONST ] ) 
new [ INT_CONST ] > d_pzbuffer [ ofs ] ) 
lp1 , new ) 
lp1 [ INT_CONST ] + lp2 [ INT_CONST ] ) 
new , lp3 ) 
lp1 , new , lp3 ) 
__E__O__F__
r_refdef . vrect . width >= r_refdef . vrect . height ) 
end ) 
INT ) 
u , v , &v s , &v t ) 
__E__O__F__
INT ) 
FLOAT ) 
INT ) 
i == INT_CONST ) 
FOR ( v = itop ; v < ibottom ; v v++ ) 
vvert < r_refdef . fvrecty_adj ) 
FOR ( v = itop ; v < ibottom ; v v++ ) 
r_spritedesc . vpn , p_normal ) 
-v DotProduct ( modelorg , r_spritedesc . vpn ) ) 
modelorg , p_temp1 ) 
( fixed16_t ) ( DotProduct ( p_temp1 , p_saxis ) * INT_CONST + FLOAT_CONST ) ) 
FOR ( i = INT_CONST ; i < r_spritedesc . nump ; i v++ ) 
ymin ) 
ymin >= ymax ) 
) 
__E__O__F__
COM_CheckParm ( STRING ) ) 
byte * ) 
FOR ( i = INT_CONST ; i < GUARDSIZE ; i v++ ) 
FOR ( i = INT_CONST ; i < GUARDSIZE ; i v++ ) 
FOR ( c = sc_base ; c ; c = c -> next ) 
( width < INT_CONST ) || ( width > INT_CONST ) ) 
! sc_rover || ( byte * ) sc_rover - ( byte * ) sc_base > sc_size - size ) 
! sc_rover ) 
new -> size - size > INT_CONST ) 
d_roverwrapped ) 
) 
FOR ( test = sc_base ; test ; test = test -> next ) 
surface -> texinfo -> texture ) 
cache && ! cache -> dlight && surface -> dlightframe != r_framecount NEW_LINE && cache -> texture == r_drawsurf . texture NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] NEW_LINE && cache -> lightadj [ INT_CONST ] == r_drawsurf . lightadj [ INT_CONST ] ) 
! cache ) 
) 
__E__O__F__
__E__O__F__
*v pz <= izi ) 
__E__O__F__
pt [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < numregs ; i v++ ) 
pt [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST ; ( pt [ i ] != CHAR_CONST ) || ( parencount > INT_CONST ) ; i v++ ) 
temp , type ) 
FOR ( i = INT_CONST ; i < numregs ; i v++ ) 
FOR ( i = INT_CONST ; i < ( tokennum - INT_CONST ) ; i v++ ) 
tokens [ INT_CONST ] [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < len ; i v++ ) 
tokens [ INT_CONST ] [ INT_CONST ] == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < len ; i v++ ) 
tokennum == INT_CONST ) 
stderr , STRING ) 
FOR ( j = INT_CONST ; j < tokennum ; j v++ ) 
tokennum == INT_CONST ) 
stderr , STRING ) 
FOR ( j = INT_CONST ; j < tokennum ; j v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < ( tokennum - INT_CONST ) ; i v++ ) 
i , STRING , INT_CONST ) 
c == CHAR_CONST ) 
c == CHAR_CONST ) 
FOR ( ; ; ) 
FOR ( ; ; ) 
FOR ( i = INT_CONST ; i < numparse ; i v++ ) 
FOR ( j = INT_CONST ; j < tokennum ; j v++ ) 
FOR ( j = INT_CONST ; j < tokennum ; j v++ ) 
STRING NEW_LINE STRING ) 
FOR ( ; ; ) 
__E__O__F__
FOR ( texnum = INT_CONST ; texnum < MAX_SCRAPS ; texnum v++ ) 
FOR ( i = INT_CONST ; i < BLOCK_WIDTH - w ; i v++ ) 
FOR ( j = INT_CONST ; j < w ; j v++ ) 
FOR ( i = INT_CONST ; i < w ; i v++ ) 
STRING ) 
FOR ( texnum = INT_CONST ; texnum < MAX_SCRAPS ; texnum v++ ) 
name ) 
p -> width < INT_CONST && p -> height < INT_CONST ) 
FOR ( i = INT_CONST ; i < p -> height ; i v++ ) 
FOR ( j = INT_CONST ; j < p -> width ; j v++ , k v++ ) 
FOR ( pic = menu_cachepics , i = INT_CONST ; i < menu_numcachepics ; pic v++ , i v++ ) 
qpic_t * ) 
! strcmp ( path , STRING ) ) 
glpic_t * ) 
row << INT_CONST ) 
drawline v-- ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST , glt = gltextures ; i < numgltextures ; i v++ , glt v++ ) 
&v gl_nobind ) 
! Q_strncasecmp ( ( CHAR *p ) gl_renderer , STRING , INT_CONST ) || NEW_LINE strstr ( ( CHAR *p ) gl_renderer , STRING ) ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST * INT_CONST ; i v++ ) 
STRING , INT_CONST , INT_CONST , draw_chars , false , true ) 
) 
qpic_t * ) 
ver , STRING , ( FLOAT ) LINUX_VERSION , ( FLOAT ) GLQUAKE_VERSION , ( FLOAT ) VERSION ) 
FOR ( x = INT_CONST ; x < y ; x v++ ) 
vid . conwidth * vid . conheight , STRING ) 
FOR ( y = INT_CONST ; y < vid . conheight ; y v++ , dest += vid . conwidth ) 
FOR ( x = INT_CONST ; x < vid . conwidth ; x += INT_CONST ) 
glpic_t * ) 
start ) 
STRING ) 
num == INT_CONST ) 
char_texture ) 
GL_QUADS ) 
scrap_dirty ) 
scrap_dirty ) 
x < INT_CONST || ( UNSIGNED ) ( x + pic -> width ) > vid . width || y < INT_CONST || NEW_LINE ( UNSIGNED ) ( y + pic -> height ) > vid . height ) 
translate_texture ) 
FOR ( v = INT_CONST ; v < INT_CONST ; v v++ , dest += INT_CONST ) 
FOR ( u = INT_CONST ; u < INT_CONST ; u v++ ) 
GL_TEXTURE_2D , INT_CONST , gl_alpha_format , INT_CONST , INT_CONST , INT_CONST , GL_RGBA , GL_UNSIGNED_BYTE , trans ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ) 
INT_CONST , INT_CONST , INT_CONST ) 
lines > y ) 
x , y ) 
) 
INT_CONST , INT_CONST ) 
) 
) 
GL_PROJECTION ) 
GL_MODELVIEW ) 
FOR ( i = INT_CONST , glt = gltextures ; i < numgltextures ; i v++ , glt v++ ) 
FOR ( i = INT_CONST ; i < outheight ; i v++ , out += outwidth ) 
FOR ( j = INT_CONST ; j < outwidth ; j += INT_CONST ) 
FOR ( i = INT_CONST ; i < outheight ; i v++ , out += outwidth ) 
FOR ( j = INT_CONST ; j < outwidth ; j += INT_CONST ) 
FOR ( i = INT_CONST ; i < height ; i v++ , in += width ) 
FOR ( j = INT_CONST ; j < width ; j += INT_CONST , out += INT_CONST , in += INT_CONST ) 
FOR ( i = INT_CONST ; i < height ; i v++ , in += width ) 
FOR ( j = INT_CONST ; j < width ; j += INT_CONST , out += INT_CONST , in += INT_CONST ) 
FOR ( scaled_width = INT_CONST ; scaled_width < width ; scaled_width <<= INT_CONST ) 
FOR ( scaled_height = INT_CONST ; scaled_height < height ; scaled_height <<= INT_CONST ) 
scaled_width > gl_max_size . value ) 
mipmap ) 
alpha ) 
FOR ( i = INT_CONST ; i < s ; i v++ ) 
FOR ( scaled_width = INT_CONST ; scaled_width < width ; scaled_width <<= INT_CONST ) 
FOR ( scaled_height = INT_CONST ; scaled_height < height ; scaled_height <<= INT_CONST ) 
scaled_width > gl_max_size . value ) 
scaled_width == width && scaled_height == height ) 
alpha ) 
FOR ( i = INT_CONST ; i < s ; i v++ ) 
FOR ( i = INT_CONST ; i < s ; i += INT_CONST ) 
VID_Is8bit ( ) && ! alpha && ( data != scrap_texels [ INT_CONST ] ) ) 
identifier [ INT_CONST ] ) 
FOR ( i = INT_CONST , glt = gltextures ; i < numgltextures ; i v++ , glt v++ ) 
glt -> identifier , identifier ) 
texture_extension_number ) 
data , width , height , mipmap , alpha ) 
__E__O__F__
startv ) 
startv + INT_CONST ) 
FOR ( j = starttri + INT_CONST , check = &v triangles [ starttri + INT_CONST ] ; j < pheader -> numtris ; j v++ , check v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( j = starttri + INT_CONST ; j < pheader -> numtris ; j v++ ) 
startv ) 
startv + INT_CONST ) 
FOR ( j = starttri + INT_CONST , check = &v triangles [ starttri + INT_CONST ] ; j < pheader -> numtris ; j v++ , check v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( j = starttri + INT_CONST ; j < pheader -> numtris ; j v++ ) 
used , INT_CONST , SIZEOF ( used ) ) 
FOR ( i = INT_CONST ; i < pheader -> numtris ; i v++ ) 
FOR ( type = INT_CONST ; type < INT_CONST ; type v++ ) 
FOR ( startv = INT_CONST ; startv < INT_CONST ; startv v++ ) 
FOR ( j = INT_CONST ; j < bestlen + INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < bestlen ; j v++ ) 
FOR ( j = INT_CONST ; j < bestlen ; j v++ ) 
FOR ( j = INT_CONST ; j < bestlen + INT_CONST ; j v++ ) 
STRING , pheader -> numtris , numorder , numcommands ) 
cache , STRING ) 
cache , &v f ) 
numcommands * INT_CONST ) 
paliashdr -> numposes * paliashdr -> poseverts NEW_LINE * SIZEOF ( trivertx_t ) ) 
FOR ( i = INT_CONST ; i < paliashdr -> numposes ; i v++ ) 
FOR ( j = INT_CONST ; j < numorder ; j v++ ) 
__E__O__F__
model -> numleafs + INT_CONST ) 
row ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
! mod -> needload ) 
! crash ) 
UNSIGNED *p ) 
mod -> name , loadname ) 
mod , buf ) 
mod , buf ) 
! l -> filelen ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
anims , INT_CONST , SIZEOF ( anims ) ) 
FOR ( j = i + INT_CONST ; j < m -> nummiptex ; j v++ ) 
num + INT_CONST > altmax ) 
FOR ( j = INT_CONST ; j < max ; j v++ ) 
FOR ( j = INT_CONST ; j < altmax ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( surfnum = INT_CONST ; surfnum < count ; surfnum v++ , in v++ , out v++ ) 
in -> planenum ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < out -> nummarksurfaces ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
corner ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < mod -> numsubmodels ; i v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
trivertx_t * ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
daliasinterval_t * ) 
pin_intervals -> interval ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
filledcolor == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; ++v i ) 
( fillcolor == filledcolor ) || ( fillcolor == INT_CONST ) ) 
inpt + INT_CONST ) 
outpt != inpt ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
s , loadname ) 
name , STRING , loadmodel -> name , i ) 
FOR ( j = INT_CONST ; j < groupskins ; j v++ ) 
FOR ( COMMENT ; j < INT_CONST ; j v++ ) 
VOID *p ) 
pinmodel -> version ) 
pheader -> skinheight > MAX_LBM_HEIGHT ) 
pheader -> numverts <= INT_CONST ) 
pheader -> numtris <= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
daliasskintype_t * ) 
stvert_t * ) 
FOR ( i = INT_CONST ; i < pheader -> numverts ; i v++ ) 
dtriangle_t * ) 
FOR ( i = INT_CONST ; i < pheader -> numtris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
daliasframetype_t * ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
mod , pheader ) 
) 
start ) 
dspriteframe_t * ) 
pinframe -> width ) 
SIZEOF ( mspriteframe_t ) , loadname ) 
pspriteframe , INT_CONST , SIZEOF ( mspriteframe_t ) ) 
pinframe -> origin [ INT_CONST ] ) 
name , STRING , loadmodel -> name , framenum ) 
VOID *p ) 
dspritegroup_t * ) 
pingroup -> numframes ) 
SIZEOF ( mspritegroup_t ) + NEW_LINE ( numframes - INT_CONST ) * SIZEOF ( pspritegroup -> frames [ INT_CONST ] ) , loadname ) 
mspriteframe_t * ) 
dspriteinterval_t * ) 
numframes * SIZEOF ( FLOAT ) , loadname ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
msprite_t ) 
size , loadname ) 
pin -> type ) 
numframes < INT_CONST ) 
dspriteframetype_t * ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
__E__O__F__
! walk ) 
node -> contents < INT_CONST ) 
r_emins , r_emaxs , splitplane ) 
! r_pefragtopnode ) 
sides & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . worldmodel -> nodes ) 
( pefrag = *v ppefrag ) != NULL ) 
__E__O__F__
INT ) 
FOR ( j = INT_CONST ; j < MAX_LIGHTSTYLES ; j v++ ) 
INT_CONST - v_blend [ INT_CONST ] ) 
INT_CONST - a2 ) 
light -> origin , r_origin , v ) 
INT_CONST , FLOAT_CONST , INT_CONST , light -> radius * FLOAT_CONST ) 
GL_TRIANGLE_FAN ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i >= INT_CONST ; i v-- ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
v ) 
! gl_flashblend . value ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , l v++ ) 
INT_CONST , INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
light , bit , node -> children [ INT_CONST ] ) 
gl_flashblend . value ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , l v++ ) 
node -> contents < INT_CONST ) 
start , plane -> normal ) 
node -> children [ side ] , start , mid ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
lightmap ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
node -> children [ ! side ] , mid , end ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( frame >= psprite -> numframes ) || ( frame < INT_CONST ) ) 
psprite -> frames [ frame ] . type == SPR_SINGLE ) 
( INT ) ( time / fullinterval ) ) 
FOR ( i = INT_CONST ; i < ( numframes - INT_CONST ) ; i v++ ) 
e ) 
psprite -> type == SPR_ORIENTED ) 
currententity -> angles , v_forward , v_right , v_up ) 
INT_CONST , INT_CONST , INT_CONST ) 
) 
frame -> gl_texturenum ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
trivertx_t * ) 
INT_CONST ) 
trivertx_t * ) 
INT_CONST ) 
( frame >= paliashdr -> numframes ) || ( frame < INT_CONST ) ) 
numposes > INT_CONST ) 
paliashdr , pose ) 
currententity -> origin , clmodel -> mins , mins ) 
R_CullBox ( mins , maxs ) ) 
currententity -> origin ) 
e == &v cl . viewent && ambientlight < INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
ambientlight > INT_CONST ) 
i >= INT_CONST && i <= cl . maxclients COMMENT ) 
! strcmp ( clmodel -> name , STRING ) NEW_LINE || ! strcmp ( clmodel -> name , STRING ) ) 
aliashdr_t * ) 
) 
) 
! strcmp ( clmodel -> name , STRING ) && gl_doubleeyes . value ) 
INT ) 
currententity -> colormap != vid . colormap && ! gl_nocolors . value ) 
gl_smoothmodels . value ) 
gl_affinemodels . value ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
GL_FLAT ) 
r_shadows . value ) 
! r_drawentities . value ) 
FOR ( i = INT_CONST ; i < cl_numvisedicts ; i v++ ) 
FOR ( i = INT_CONST ; i < cl_numvisedicts ; i v++ ) 
! r_drawviewmodel . value ) 
j < INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
FLOAT ) 
gldepthmin , gldepthmin + FLOAT_CONST * ( gldepthmax - gldepthmin ) ) 
GL_ALPHA_TEST ) 
) 
GL_QUADS ) 
INT_CONST , INT_CONST , INT_CONST ) 
GL_BLEND ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
r_refdef . fov_x == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . maxclients > INT_CONST ) 
r_refdef . vieworg , r_origin ) 
r_refdef . viewangles , vpn , vright , vup ) 
r_origin , cl . worldmodel ) 
r_viewleaf -> contents ) 
GL_PROJECTION ) 
x > INT_CONST ) 
envmap ) 
glx + x , gly + y2 , w , h ) 
gl_cull . value ) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
gldepthmin , gldepthmax ) 
! mirror ) 
r_refdef . vieworg , mirror_plane -> normal ) 
vpn , mirror_plane -> normal ) 
vpn [ INT_CONST ] ) 
cl_numvisedicts < MAX_VISEDICTS ) 
gldepthmin , gldepthmax ) 
) 
gldepthmin , gldepthmax ) 
GL_BLEND ) 
r_base_world_matrix ) 
INT_CONST , INT_CONST , INT_CONST , r_mirroralpha . value ) 
FOR ( ; s ; s = s -> texturechain ) 
r_norefresh . value ) 
gl_finish . value ) 
) 
) 
) 
r_speeds . value ) 
__E__O__F__
SIZEOF ( texture_t ) + INT_CONST * INT_CONST + INT_CONST * INT_CONST + INT_CONST * INT_CONST + INT_CONST * INT_CONST , STRING ) 
FOR ( m = INT_CONST ; m < INT_CONST ; m v++ ) 
FOR ( y = INT_CONST ; y < ( INT_CONST >> m ) ; y v++ ) 
FOR ( x = INT_CONST ; x < ( INT_CONST >> m ) ; x v++ ) 
particletexture ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y < INT_CONST ; y v++ ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_MODULATE ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ) 
GL_FRONT ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
&v glx , &v gly , &v glwidth , &v glheight ) 
GL_BACK ) 
STRING , R_TimeRefresh_f ) 
&v gl_finish ) 
gl_mtexable ) 
&v gl_keeptjunctions ) 
&v gl_doubleeyes ) 
) 
) 
) 
cl . scores [ playernum ] . colors & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! model ) 
playertextures + playernum ) 
FOR ( i = INT_CONST ; i < s ; i += INT_CONST ) 
translated , paliashdr -> skinwidth , paliashdr -> skinheight , false , false , true ) 
INT ) 
VID_Is8bit ( ) ) 
byte * ) 
FOR ( i = INT_CONST ; i < scaled_height ; i v++ , out2 += scaled_width ) 
FOR ( j = INT_CONST ; j < scaled_width ; j += INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < scaled_height ; i v++ , out += scaled_width ) 
FOR ( j = INT_CONST ; j < scaled_width ; j += INT_CONST ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_MODULATE ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numleafs ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numtextures ; i v++ ) 
GL_FRONT ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
GL_BACK ) 
__E__O__F__
surf -> extents [ INT_CONST ] >> INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( t = INT_CONST ; t < tmax ; t v++ ) 
FOR ( s = INT_CONST ; s < smax ; s v++ ) 
rad - dist ) 
surf -> dlightframe == r_framecount ) 
surf -> extents [ INT_CONST ] >> INT_CONST ) 
r_fullbright . value || ! cl . worldmodel -> lightdata ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < tmax ; i v++ , dest += stride ) 
FOR ( j = INT_CONST ; j < smax ; j v++ ) 
FOR ( i = INT_CONST ; i < tmax ; i v++ , dest += stride ) 
FOR ( j = INT_CONST ; j < smax ; j v++ ) 
STRING ) 
currententity -> frame ) 
base -> anim_min > reletive || base -> anim_max <= reletive ) 
! ( s -> flags & ( SURF_DRAWSKY | SURF_DRAWTURB | SURF_UNDERWATER ) ) ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
s -> flags & SURF_DRAWTURB ) 
s -> flags & SURF_DRAWSKY ) 
s -> texinfo -> texture ) 
lightmap_textures + s -> lightmaptexturenum ) 
! ( s -> flags & ( SURF_DRAWSKY | SURF_DRAWTURB | SURF_UNDERWATER ) ) ) 
s -> texinfo -> texture ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
s -> texinfo -> texture ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
s -> flags & SURF_DRAWTURB ) 
s -> flags & SURF_DRAWSKY ) 
s ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
nv ) 
) 
GL_TRIANGLE_FAN ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
) 
GL_TRIANGLE_FAN ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
GL_POLYGON ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
r_fullbright . value ) 
gl_lightmap_format == GL_LUMINANCE ) 
! r_lightmap . value ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTMAPS ; i v++ ) 
FOR ( ; p ; p = p -> chain ) 
FOR ( j = INT_CONST ; j < p -> numverts ; j v++ , v += VERTEXSIZE ) 
GL_BLEND ) 
INT_CONST ) 
fa -> flags & SURF_DRAWSKY ) 
fa ) 
fa -> flags & SURF_DRAWTURB ) 
fa ) 
fa -> flags & SURF_UNDERWATER ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && fa -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
fa -> dlightframe == r_framecount COMMENT_NL CPP_COMMENT NEW_LINE || fa -> cached_dlight ) 
fa -> flags & ( SURF_DRAWSKY | SURF_DRAWTURB ) ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && fa -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
fa -> dlightframe == r_framecount COMMENT_NL CPP_COMMENT NEW_LINE || fa -> cached_dlight ) 
r_wateralpha . value == FLOAT_CONST ) 
r_world_matrix ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numtextures ; i v++ ) 
FOR ( ; s ; s = s -> texturechain ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
r_wateralpha . value == FLOAT_CONST && gl_texsort . value ) 
r_world_matrix ) 
! gl_texsort . value ) 
FOR ( s = waterchain ; s ; s = s -> texturechain ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numtextures ; i v++ ) 
FOR ( ; s ; s = s -> texturechain ) 
r_wateralpha . value < FLOAT_CONST ) 
! gl_texsort . value ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numtextures ; i v++ ) 
FOR ( ; s ; s = s -> texturechain ) 
e -> angles [ INT_CONST ] || e -> angles [ INT_CONST ] || e -> angles [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
R_CullBox ( mins , maxs ) ) 
r_refdef . vieworg , e -> origin , modelorg ) 
clmodel -> firstmodelsurface != INT_CONST && ! gl_flashblend . value ) 
FOR ( k = INT_CONST ; k < MAX_DLIGHTS ; k v++ ) 
) 
FOR ( i = INT_CONST ; i < clmodel -> nummodelsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
) 
) 
node -> contents == CONTENTS_SOLID ) 
node -> contents < INT_CONST ) 
pleaf -> efrags ) 
plane -> type ) 
modelorg , plane -> normal ) 
dot >= INT_CONST ) 
c ) 
FOR ( ; c ; c v-- , surf v++ ) 
node -> children [ ! side ] ) 
&v ent , INT_CONST , SIZEOF ( ent ) ) 
r_refdef . vieworg , modelorg ) 
INT_CONST , INT_CONST , INT_CONST ) 
) 
) 
) 
r_oldviewleaf == r_viewleaf && ! r_novis . value ) 
r_novis . value ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numleafs ; i v++ ) 
FOR ( texnum = INT_CONST ; texnum < MAX_LIGHTMAPS ; texnum v++ ) 
FOR ( i = INT_CONST ; i < BLOCK_WIDTH - w ; i v++ ) 
FOR ( j = INT_CONST ; j < w ; j v++ ) 
FOR ( i = INT_CONST ; i < w ; i v++ ) 
STRING ) 
SIZEOF ( glpoly_t ) + ( lnumverts - INT_CONST ) * VERTEXSIZE * SIZEOF ( FLOAT ) ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
! gl_keeptjunctions . value && ! ( fa -> flags & SURF_UNDERWATER ) ) 
FOR ( i = INT_CONST ; i < lnumverts ; ++v i ) 
FOR ( j = i + INT_CONST ; j < lnumverts ; ++v j ) 
FOR ( k = INT_CONST ; k < VERTEXSIZE ; ++v k ) 
surf -> flags & ( SURF_DRAWSKY | SURF_DRAWTURB ) ) 
smax , tmax , &v surf -> light_s , &v surf -> light_t ) 
allocated , INT_CONST , SIZEOF ( allocated ) ) 
! lightmap_textures ) 
isPermedia ) 
FOR ( j = INT_CONST ; j < MAX_MODELS ; j v++ ) 
FOR ( i = INT_CONST ; i < m -> numsurfaces ; i v++ ) 
! gl_texsort . value ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTMAPS ; i v++ ) 
! gl_texsort . value ) 
__E__O__F__
*v str ) 
cl . intermission ) 
scr_center_lines <= INT_CONST ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
fov_x < INT_CONST || fov_x > INT_CONST ) 
height / x ) 
) 
scr_viewsize . value < INT_CONST ) 
r_refdef . vrect . width < INT_CONST ) 
r_refdef . vrect . height > vid . height - sb_lines ) 
STRING , SCR_ScreenShot_f ) 
STRING ) 
count < INT_CONST ) 
! scr_showpause . value ) 
! cl . paused ) 
! scr_drawloading ) 
con_forcedup ) 
clearconsole v++ < vid . numpages ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
glx , gly , glwidth , glheight , GL_RGB , GL_UNSIGNED_BYTE , buffer + INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i += INT_CONST ) 
buffer ) 
cls . state != ca_connected ) 
) 
) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST && scr_conlines != scr_con_current ; i v++ ) 
host_basepal ) 
r_refdef . vrect . x , INT_CONST , NEW_LINE r_refdef . vrect . x + r_refdef . vrect . width , NEW_LINE r_refdef . vrect . y ) 
block_drawing ) 
scr_disabled_for_loading ) 
! scr_initialized || ! con_initialized ) 
oldfov != scr_fov . value ) 
oldscreensize != scr_viewsize . value ) 
vid . recalc_refdef ) 
) 
scr_drawdialog ) 
) 
) 
__E__O__F__
&v trace , INT_CONST , SIZEOF ( trace_t ) ) 
cl . worldmodel -> hulls , INT_CONST , INT_CONST , INT_CONST , start , end , &v trace ) 
FOR ( i = INT_CONST , p = puffs ; i < MAX_PUFFS ; i v++ , p v++ ) 
incoming ) 
origin , p -> origin ) 
incoming , p -> normal , p -> up ) 
p -> up , p -> normal , p -> right ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
INT_CONST , INT_CONST , INT_CONST ) 
GL_LINES ) 
pts [ INT_CONST ] [ INT_CONST ] ) 
pts [ INT_CONST ] [ INT_CONST ] ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
GL_TRIANGLES ) 
FOR ( i = INT_CONST , p = puffs ; i < MAX_PUFFS ; i v++ , p v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < num_mice ; i v++ ) 
STRING , O_RDONLY ) 
scantokey [ sc ] , state == KEY_EVENTPRESS ) 
UseKeyboard ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < ( INT_CONST << INT_CONST ) ; i v++ ) 
FOR ( v = INT_CONST , k = INT_CONST , bestdist = INT_CONST * INT_CONST ; v < INT_CONST ; v v++ , pal += INT_CONST ) 
strstr ( gl_extensions , STRING ) && ! COM_CheckParm ( STRING ) ) 
STRING ) 
GL_VERSION ) 
) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_ALPHA_TEST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
COM_CheckParm ( STRING ) ) 
UseKeyboard ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_RESOLUTIONS ; i v++ ) 
COM_CheckParm ( STRING ) ) 
strstr ( gl_extensions , STRING ) && NEW_LINE ( qgl3DfxSetPaletteEXT = dlsym ( prjobj , STRING ) ) != NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( i = COM_CheckParm ( STRING ) ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pal , palette , SIZEOF ( palette ) ) 
) 
&v vid_mode ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
vid . conwidth < INT_CONST ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
fc ) 
vid . conheight > height ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
) 
gldir , STRING , com_gamedir ) 
palette ) 
) 
STRING , width , height ) 
UseMouse ) 
&v mouse_button_commands [ INT_CONST ] ) 
mouse_update ( ) ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
dpy , win , NEW_LINE True , NEW_LINE INT_CONST , NEW_LINE GrabModeAsync , GrabModeAsync , NEW_LINE win , NEW_LINE None , NEW_LINE CurrentTime ) 
dpy , win , NEW_LINE False , NEW_LINE GrabModeAsync , GrabModeAsync , NEW_LINE CurrentTime ) 
dpy , CurrentTime ) 
dpy , win ) 
! dpy ) 
dowarp ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < ( INT_CONST << INT_CONST ) ; i v++ ) 
FOR ( v = INT_CONST , k = INT_CONST , bestdist = INT_CONST * INT_CONST ; v < INT_CONST ; v v++ , pal += INT_CONST ) 
strstr ( gl_extensions , STRING ) && ! COM_CheckParm ( STRING ) ) 
STRING ) 
GL_VERSION ) 
) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_ALPHA_TEST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
( prjobj = dlopen ( NULL , RTLD_LAZY ) ) == NULL ) 
strstr ( gl_extensions , STRING ) && NEW_LINE ( qgl3DfxSetPaletteEXT = dlsym ( prjobj , STRING ) ) != NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( i = COM_CheckParm ( STRING ) ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pal , palette , SIZEOF ( palette ) ) 
&v vid_mode ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
vid . conwidth < INT_CONST ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
dpy ) 
! XF86VidModeQueryVersion ( dpy , &v MajorVersion , &v MinorVersion ) ) 
dpy , scrnum , attrib ) 
vidmode_ext ) 
FOR ( i = INT_CONST ; i < num_vidmodes ; i v++ ) 
dpy , root , visinfo -> visual , AllocNone ) 
vidmode_active ) 
dpy ) 
dpy , visinfo , NULL , True ) 
dpy , win , ctx ) 
vid . conheight > height ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
) 
) 
gldir , STRING , com_gamedir ) 
palette ) 
) 
STRING , width , height ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
&v rect , WindowStyle , FALSE , INT_CONST ) 
NEW_LINE ExWindowStyle , NEW_LINE STRING , NEW_LINE STRING , NEW_LINE WindowStyle , NEW_LINE rect . left , rect . top , NEW_LINE width , NEW_LINE height , NEW_LINE NULL , NEW_LINE NULL , NEW_LINE global_hInstance , NEW_LINE NULL ) 
! dibwindow ) 
dibwindow , WindowRect . right - WindowRect . left , NEW_LINE WindowRect . bottom - WindowRect . top , false ) 
dibwindow ) 
vid . conheight > modelist [ modenum ] . height ) 
mainwindow , WM_SETICON , ( WPARAM ) TRUE , ( LPARAM ) hIcon ) 
! leavecurrentmode ) 
&v rect , WindowStyle , FALSE , INT_CONST ) 
NEW_LINE ExWindowStyle , NEW_LINE STRING , NEW_LINE STRING , NEW_LINE WindowStyle , NEW_LINE rect . left , rect . top , NEW_LINE width , NEW_LINE height , NEW_LINE NULL , NEW_LINE NULL , NEW_LINE global_hInstance , NEW_LINE NULL ) 
! dibwindow ) 
dibwindow ) 
vid . conheight > modelist [ modenum ] . height ) 
mainwindow , WM_SETICON , ( WPARAM ) TRUE , ( LPARAM ) hIcon ) 
( windowed && ( modenum != INT_CONST ) ) || NEW_LINE ( ! windowed && ( modenum < INT_CONST ) ) || NEW_LINE ( ! windowed && ( modenum >= nummodes ) ) ) 
) 
vid_modenum == NO_MODE ) 
modelist [ modenum ] . type == MS_WINDOWED ) 
) 
) 
! stat ) 
mainwindow ) 
PeekMessage ( &v msg , NULL , INT_CONST , INT_CONST , PM_REMOVE ) ) 
INT_CONST ) 
mainwindow , HWND_TOP , INT_CONST , INT_CONST , INT_CONST , INT_CONST , NEW_LINE SWP_DRAWFRAME | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | NEW_LINE SWP_NOCOPYBITS ) 
) 
! msg_suppress_1 ) 
) 
UNSIGNED CHAR *p ) 
! texture_ext || COM_CheckParm ( STRING ) ) 
( bindTexFunc = ( BINDTEXFUNCPTR ) NEW_LINE wglGetProcAddress ( ( LPCSTR ) STRING ) ) == NULL ) 
UNSIGNED CHAR *p ) 
STRING ) 
GL_VERSION ) 
strnicmp ( gl_renderer , STRING , INT_CONST ) == INT_CONST ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
GL_ALPHA_TEST ) 
GL_FRONT_AND_BACK , GL_FILL ) 
GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) 
GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) 
GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_REPLACE ) 
) 
GL_VERTEX_ARRAY_EXT ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < ( INT_CONST << INT_CONST ) ; i v++ ) 
FOR ( v = INT_CONST , k = INT_CONST , l = INT_CONST * INT_CONST ; v < INT_CONST ; v v++ , pal += INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
! ActiveApp && sound_active ) 
fActive ) 
! fActive ) 
uMsg == uiWheelMessage ) 
wParam & MK_LBUTTON ) 
hWnd , uMsg , wParam , lParam ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
STRING , VID_GetExtModeDescription ( modenum ) ) 
) 
FOR ( i = INT_CONST ; i < lnummodes ; i v++ ) 
WNDPROC ) 
COM_CheckParm ( STRING ) ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE modelist [ nummodes ] . width , NEW_LINE modelist [ nummodes ] . height , NEW_LINE modelist [ nummodes ] . bpp ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
lowresmodes ) 
FOR ( j = INT_CONST ; ( j < numlowresmodes ) && ( nummodes < MAX_MODE_LIST ) ; j v++ ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
nummodes == originalnummodes ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( i = COM_CheckParm ( STRING ) ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pal , palette , SIZEOF ( palette ) ) 
&v devmode , INT_CONST , SIZEOF ( devmode ) ) 
&v vid_mode ) 
STRING , VID_NumModes_f ) 
global_hInstance , MAKEINTRESOURCE ( IDI_ICON2 ) ) 
) 
global_hInstance ) 
global_hInstance ) 
COM_CheckParm ( STRING ) ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE devmode . dmPelsWidth , devmode . dmPelsHeight , NEW_LINE devmode . dmBitsPerPel ) 
FOR ( i = nummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
FOR ( i = INT_CONST , vid_default = INT_CONST ; i < nummodes ; i v++ ) 
FOR ( i = INT_CONST , vid_default = INT_CONST ; i < nummodes ; i v++ ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
vid . conwidth < INT_CONST ) 
( i = COM_CheckParm ( STRING ) ) != INT_CONST ) 
hwnd_dialog ) 
palette ) 
vid_default , palette ) 
mainwindow ) 
maindc ) 
gldir , STRING , com_gamedir ) 
) 
badmode . modedesc , STRING ) 
COM_CheckParm ( STRING ) ) 
STRING ) 
) 
FOR ( i = INT_CONST ; ( i < lnummodes ) && ( vid_wmodes < MAX_MODEDESCS ) ; i v++ ) 
vid_wmodes > INT_CONST ) 
FOR ( i = INT_CONST ; i < vid_wmodes ; i v++ ) 
INT_CONST * INT_CONST , INT_CONST + MODE_AREA_HEIGHT * INT_CONST + INT_CONST * INT_CONST , NEW_LINE STRING ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numverts ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ , v v++ ) 
numverts > INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < numverts ; j v++ , v += INT_CONST ) 
FOR ( j = INT_CONST ; j < numverts ; j v++ , v += INT_CONST ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
SIZEOF ( glpoly_t ) + ( numverts - INT_CONST ) * VERTEXSIZE * SIZEOF ( FLOAT ) ) 
FOR ( i = INT_CONST ; i < numverts ; i v++ , verts += INT_CONST ) 
FOR ( i = INT_CONST ; i < fa -> numedges ; i v++ ) 
numverts , verts [ INT_CONST ] ) 
FOR ( p = fa -> polys ; p ; p = p -> next ) 
FOR ( i = INT_CONST , v = p -> verts [ INT_CONST ] ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
FOR ( p = fa -> polys ; p ; p = p -> next ) 
FOR ( i = INT_CONST , v = p -> verts [ INT_CONST ] ; i < p -> numverts ; i v++ , v += VERTEXSIZE ) 
) 
solidskytexture ) 
fa ) 
GL_BLEND ) 
fa ) 
GL_BLEND ) 
) 
solidskytexture ) 
FOR ( fa = s ; fa ; fa = fa -> texturechain ) 
FOR ( fa = s ; fa ; fa = fa -> texturechain ) 
&v pcxbuf , INT_CONST , SIZEOF ( pcxbuf ) , f ) 
pcx -> manufacturer != INT_CONST NEW_LINE || pcx -> version != INT_CONST NEW_LINE || pcx -> encoding != INT_CONST NEW_LINE || pcx -> bits_per_pixel != INT_CONST NEW_LINE || pcx -> xmax >= INT_CONST NEW_LINE || pcx -> ymax >= INT_CONST ) 
f , -v INT_CONST , SEEK_END ) 
f , SIZEOF ( pcxbuf ) - INT_CONST , SEEK_SET ) 
pcx -> xmax + INT_CONST ) 
FOR ( y = INT_CONST ; y <= pcx -> ymax ; y v++ ) 
FOR ( x = INT_CONST ; x <= pcx -> ymax ; ) 
f ) 
SHORT ) 
f ) 
b2 << INT_CONST ) 
fin ) 
targa_header . image_type != INT_CONST NEW_LINE && targa_header . image_type != INT_CONST ) 
numPixels * INT_CONST ) 
FOR ( row = rows - INT_CONST ; row >= INT_CONST ; row v-- ) 
FOR ( column = INT_CONST ; column < columns ; column v++ ) 
FOR ( row = rows - INT_CONST ; row >= INT_CONST ; row v-- ) 
FOR ( column = INT_CONST ; column < columns ; ) 
FOR ( j = INT_CONST ; j < packetSize ; j v++ ) 
FOR ( j = INT_CONST ; j < packetSize ; j v++ ) 
targa_header . pixel_size ) 
fin ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
GL_POLYGON ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , vecs += INT_CONST ) 
vec3_origin , v ) 
FOR ( i = INT_CONST , vp = vecs ; i < nump ; i v++ , vp += INT_CONST ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , vecs += INT_CONST ) 
nump > MAX_CLIP_VERTS - INT_CONST ) 
nump , vecs ) 
FOR ( i = INT_CONST , v = vecs ; i < nump ; i v++ , v += INT_CONST ) 
! front || ! back ) 
nump , vecs , stage + INT_CONST ) 
vecs , ( vecs + ( i * INT_CONST ) ) ) 
FOR ( i = INT_CONST , v = vecs ; i < nump ; i v++ , v += INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
newc [ INT_CONST ] , newv [ INT_CONST ] [ INT_CONST ] , stage + INT_CONST ) 
solidskytexture ) 
FOR ( fa = s ; fa ; fa = fa -> texturechain ) 
FOR ( p = fa -> polys ; p ; p = p -> next ) 
FOR ( i = INT_CONST ; i < p -> numverts ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
s + INT_CONST ) 
s < FLOAT_CONST / INT_CONST ) 
GL_BLEND ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
byte * ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! solidskytexture ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
__E__O__F__
host_abortserver , INT_CONST ) 
STRING ) 
svs . maxclients > INT_CONST ) 
&v sys_ticrate ) 
&v fraglimit ) 
&v pausable ) 
&v temp1 ) 
) 
host_initialized & ! isDedicated ) 
f ) 
FOR ( i = INT_CONST ; i < svs . maxclients ; i v++ ) 
! crash ) 
host_client -> netconnection ) 
FOR ( i = INT_CONST , client = svs . clients ; i < svs . maxclients ; i v++ , client v++ ) 
! sv . active ) 
cls . state == ca_connected ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
&v buf , svc_disconnect ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
! cls . timedemo && realtime - oldrealtime < FLOAT_CONST / FLOAT_CONST ) 
host_framerate . value > INT_CONST ) 
host_frametime > FLOAT_CONST ) 
INT_CONST ) 
) 
! sv . paused && ( svs . maxclients > INT_CONST || key_dest == key_game ) ) 
) 
) 
temp_host_frametime > ( FLOAT_CONST / FLOAT_CONST ) ) 
) 
) 
) 
) 
! sv . paused && ( svs . maxclients > INT_CONST || key_dest == key_game ) ) 
setjmp ( host_abortserver ) ) 
! Host_FilterTime ( time ) ) 
) 
) 
) 
sv . active ) 
) 
cls . state == ca_connected ) 
host_speeds . value ) 
! serverprofile . value ) 
FOR ( i = INT_CONST ; i < svs . maxclients ; i v++ ) 
STRING , c , m ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
( n = COM_CheckParm ( STRING ) ) != INT_CONST ) 
FOR ( i = INT_CONST ; i < com_argc ; i v++ ) 
quakeparms_t * parms ) 
parms -> memsize < minimum_memory ) 
parms -> membase , parms -> memsize ) 
STRING __TIME__ STRING __DATE__ STRING ) 
) 
) 
STRING ) 
INT_CONST , STRING ) 
STRING ) 
) 
) 
cls . state != ca_dedicated ) 
__E__O__F__
) 
FOR ( j = INT_CONST , client = svs . clients ; j < svs . maxclients ; j v++ , client v++ ) 
pr_global_struct -> deathmatch && ! host_client -> privileged ) 
pr_global_struct -> deathmatch && ! host_client -> privileged ) 
pr_global_struct -> deathmatch && ! host_client -> privileged ) 
pr_global_struct -> deathmatch && ! host_client -> privileged ) 
STRING ) 
FOR ( i = INT_CONST , client = svs . clients ; i < svs . maxclients ; i v++ , client v++ ) 
FOR ( j = INT_CONST ; j < NUM_PING_TIMES ; j v++ ) 
cmd_source != src_command ) 
) 
) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
name , Cmd_Argv ( INT_CONST ) ) 
FOR ( i = INT_CONST ; i < Cmd_Argc ( ) ; i v++ ) 
Cmd_Argc ( ) < INT_CONST ) 
level , Cmd_Argv ( INT_CONST ) ) 
) 
Cmd_Argc ( ) != INT_CONST ) 
startspot , sv . startspot ) 
FOR ( i = INT_CONST ; i < SAVEGAME_COMMENT_LENGTH ; i v++ ) 
FOR ( i = INT_CONST ; i < SAVEGAME_COMMENT_LENGTH ; i v++ ) 
cmd_source != src_command ) 
cl . intermission ) 
svs . maxclients != INT_CONST ) 
Cmd_Argc ( ) != INT_CONST ) 
strstr ( Cmd_Argv ( INT_CONST ) , STRING ) ) 
FOR ( i = INT_CONST ; i < svs . maxclients ; i v++ ) 
name , STRING , com_gamedir , Cmd_Argv ( INT_CONST ) ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTSTYLES ; i v++ ) 
f ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ ) 
cmd_source != src_command ) 
name , STRING , com_gamedir , Cmd_Argv ( INT_CONST ) ) 
STRING , name ) 
f , STRING , &v version ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
STRING , INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < MAX_LIGHTSTYLES ; i v++ ) 
! feof ( f ) ) 
FOR ( i = INT_CONST ; i < SIZEOF ( str ) - INT_CONST ; i v++ ) 
f ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
name , STRING , com_gamedir , sv . name ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTSTYLES ; i v++ ) 
FOR ( i = svs . maxclients + INT_CONST ; i < sv . num_edicts ; i v++ ) 
f , STRING , &v version ) 
f , STRING , mapname ) 
mapname , startspot ) 
! sv . active ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTSTYLES ; i v++ ) 
! feof ( f ) ) 
FOR ( i = INT_CONST ; i < SIZEOF ( str ) - INT_CONST ; i v++ ) 
f ) 
Cmd_Argc ( ) < INT_CONST ) 
level , Cmd_Argv ( INT_CONST ) ) 
) 
) 
LoadGamestate ( level , startspot ) ) 
Cmd_Argc ( ) == INT_CONST ) 
cmd_source == src_command ) 
host_client -> name [ INT_CONST ] && strcmp ( host_client -> name , STRING ) ) 
&v sv . reliable_datagram , svc_updatename ) 
Cmd_Argc ( ) != INT_CONST ) 
FOR ( j = INT_CONST , cl = svs . clients ; j < svs . maxclients ; j v++ , cl v++ ) 
cmd_source == src_command ) 
Cmd_Argc ( ) < INT_CONST ) 
) 
! fromServer ) 
Q_strlen ( p ) > j ) 
FOR ( j = INT_CONST , client = svs . clients ; j < svs . maxclients ; j v++ , client v++ ) 
STRING , &v text [ INT_CONST ] ) 
cmd_source == src_command ) 
Cmd_Argc ( ) < INT_CONST ) 
) 
*v p == CHAR_CONST ) 
text ) 
Q_strlen ( p ) > j ) 
FOR ( j = INT_CONST , client = svs . clients ; j < svs . maxclients ; j v++ , client v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
&v sv . reliable_datagram , svc_updatecolors ) 
sv_player -> v . health <= INT_CONST ) 
&v sv . reliable_datagram , svc_setpause ) 
host_client -> spawned ) 
cmd_source == src_command ) 
host_client -> spawned ) 
sv . loadgame ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
&v host_client -> message , svc_time ) 
FOR ( i = INT_CONST , client = svs . clients ; i < svs . maxclients ; i v++ , client v++ ) 
FOR ( i = INT_CONST ; i < MAX_LIGHTSTYLES ; i v++ ) 
&v host_client -> message , svc_updatestat ) 
&v host_client -> message , svc_updatestat ) 
&v host_client -> message , svc_updatestat ) 
&v host_client -> message , svc_updatestat ) 
INT_CONST + ( host_client - svs . clients ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
sv_player , &v host_client -> message ) 
&v host_client -> message , svc_signonnum ) 
cmd_source == src_command ) 
Cmd_Argc ( ) > INT_CONST && Q_strcmp ( Cmd_Argv ( INT_CONST ) , STRING ) == INT_CONST ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
i < svs . maxclients ) 
cmd_source == src_command ) 
pr_global_struct -> deathmatch && ! host_client -> privileged ) 
rogue ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ ) 
) 
) 
Cmd_Argv ( INT_CONST ) ) 
model_t * m , INT frame ) 
aliashdr_t * ) 
e -> v . frame >= m -> numframes ) 
VOID ) 
) 
e -> v . frame < INT_CONST ) 
VOID ) 
cls . state == ca_dedicated ) 
) 
FOR ( i = INT_CONST ; i < c + INT_CONST ; i v++ ) 
STRING , Host_Startdemos_f ) 
STRING , Host_Viewmodel_f ) 
STRING , Mod_Print ) 
__E__O__F__
&v m_filter ) 
) 
STRING ) 
mouse_avail ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
FOR ( i = INT_CONST ; i < joy_numbuttons . value ; i v++ ) 
extern_avail ) 
FOR ( i = INT_CONST ; i < extern_buttons ; i v++ ) 
usercmd_t * cmd ) 
! mouse_avail ) 
INT_CONST ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
! joy_avail || ! in_joystick . value ) 
in_strafe . state & INT_CONST ) 
in_mlook . state & INT_CONST ) 
INT_CONST ) 
++v count < INT_CONST ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
! extern_avail ) 
STRING , extern_control -> viewangles [ YAW ] , extern_control -> viewangles [ PITCH ] , extern_control -> viewangles [ ROLL ] , extern_control -> forwardmove , extern_control -> sidemove , extern_control -> upmove ) 
STRING , extern_control -> viewangles [ YAW ] , extern_control -> viewangles [ PITCH ] , extern_control -> viewangles [ ROLL ] , extern_control -> forwardmove , extern_control -> sidemove , extern_control -> upmove ) 
cl . viewangles [ PITCH ] > INT_CONST ) 
freelook ) 
__E__O__F__
__E__O__F__
! x_grabbed ) 
IN_Shutdown ) 
XChangePointerControl ( x_disp , True , True , x_mouse_num , x_mouse_denom , x_mouse_thresh ) ) 
) 
! x_grabbed ) 
now - last_movement > INT_CONST ) 
! dx && ! dy ) 
__E__O__F__
DIOBJECTDATAFORMAT ) 
MYDATA ) 
mouseinitialized ) 
mouseinitialized ) 
TRUE ) 
! hInstDI ) 
! pDirectInputCreate ) 
global_hInstance , DIRECTINPUT_VERSION , &v g_pdi , NULL ) 
FAILED ( hr ) ) 
g_pdi , &v GUID_SysMouse , &v g_pMouse , NULL ) 
FAILED ( hr ) ) 
g_pMouse , &v df ) 
FAILED ( hr ) ) 
g_pMouse , mainwindow , NEW_LINE DISCL_EXCLUSIVE | DISCL_FOREGROUND ) 
g_pMouse , DIPROP_BUFFERSIZE , &v dipdw . diph ) 
FAILED ( hr ) ) 
COM_CheckParm ( STRING ) ) 
! dinput ) 
mouseactivatetoggle ) 
&v m_filter ) 
&v in_joystick ) 
STRING , Force_CenterView_f ) 
STRING ) 
) 
g_pMouse ) 
g_pdi ) 
mouseactive && ! dinput ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
! mouseactive ) 
FOR ( ; ; ) 
od . dwData & INT_CONST ) 
od . dwData & INT_CONST ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
m_filter . value ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
mx || my ) 
mouseactive ) 
COM_CheckParm ( STRING ) ) 
FOR ( joy_id = INT_CONST ; joy_id < numdevs ; joy_id v++ ) 
mmr != JOYERR_NOERROR ) 
&v jc , INT_CONST , SIZEOF ( jc ) ) 
STRING ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
joy_advanced . value == FLOAT_CONST ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
! joy_avail ) 
FOR ( i = INT_CONST ; i < joy_numbuttons ; i v++ ) 
joy_haspov ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
joyGetPosEx ( joy_id , &v ji ) == JOYERR_NOERROR ) 
joy_advancedinit != true ) 
! joy_avail || ! in_joystick . value ) 
IN_ReadJoystick ( ) != true ) 
in_speed . state & INT_CONST ) 
FOR ( i = INT_CONST ; i < JOY_MAX_AXES ; i v++ ) 
fAxisValue > FLOAT_CONST ) 
) 
) 
cl . viewangles [ PITCH ] > FLOAT_CONST ) 
__E__O__F__
key == K_TAB ) 
key_lines [ edit_line ] + INT_CONST ) 
key == K_UPARROW ) 
key == K_DOWNARROW ) 
key == K_PGUP || key == K_MWHEELUP ) 
key == K_PGDN || key == K_MWHEELDOWN ) 
key == K_HOME ) 
key == K_END ) 
key == K_ENTER ) 
key == K_ESCAPE ) 
key < INT_CONST || key > INT_CONST ) 
chat_bufferlen == INT_CONST ) 
FOR ( kn = keynames ; kn -> name ; kn v++ ) 
keynum == -v INT_CONST ) 
FOR ( kn = keynames ; kn -> name ; kn v++ ) 
Cmd_Argc ( ) != INT_CONST ) 
b , STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
c == INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
b , cmd ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = CHAR_CONST ; i <= CHAR_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! down ) 
down ) 
key == K_SHIFT ) 
! down ) 
cls . demoplayback && down && consolekeys [ key ] && key_dest == key_game ) 
( key_dest == key_menu && menubound [ key ] ) NEW_LINE || ( key_dest == key_console && ! consolekeys [ key ] ) NEW_LINE || ( key_dest == key_game && ( ! con_forcedup || ! consolekeys [ key ] ) ) ) 
! down ) 
key_dest ) 
key ) 
key ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
normal , normal ) 
normal , p ) 
FOR ( pos = INT_CONST , i = INT_CONST ; i < INT_CONST ; i v++ ) 
dst , tempvec , src ) 
dst ) 
vr , dir ) 
im , m , SIZEOF ( im ) ) 
zrot , INT_CONST , SIZEOF ( zrot ) ) 
DEG2RAD ( degrees ) ) 
m , zrot , tmpmat ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
p -> type < INT_CONST ) 
p -> signbits ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
-v INT_CONST * sr * sp * cy + -v INT_CONST * cr * -v sy ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
length ) 
length ) 
denom <= FLOAT_CONST ) 
numer / denom ) 
-v numer / denom ) 
__E__O__F__
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
top < INT_CONST ) 
dest + TOP_RANGE , source + top , INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
STRING ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
width > INT_CONST ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
STRING ) 
FOR ( n = INT_CONST ; n < lines ; n v++ ) 
key_dest == key_menu ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
INT ) 
INT_CONST , INT_CONST + m_main_cursor * INT_CONST , Draw_CachePic ( va ( STRING , f + INT_CONST ) ) ) 
STRING ) 
STRING ) 
m_main_cursor ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
INT ) 
INT_CONST , INT_CONST + m_singleplayer_cursor * INT_CONST , Draw_CachePic ( va ( STRING , f + INT_CONST ) ) ) 
STRING ) 
STRING ) 
m_singleplayer_cursor ) 
FOR ( i = INT_CONST ; i < MAX_SAVEGAMES ; i v++ ) 
FOR ( j = INT_CONST ; j < SAVEGAME_COMMENT_LENGTH ; j v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < MAX_SAVEGAMES ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < MAX_SAVEGAMES ; i v++ ) 
STRING ) 
) 
va ( STRING , load_cursor ) ) 
STRING ) 
va ( STRING , load_cursor ) ) 
STRING ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
INT ) 
INT_CONST , INT_CONST + m_multiplayer_cursor * INT_CONST , Draw_CachePic ( va ( STRING , f + INT_CONST ) ) ) 
serialAvailable || ipxAvailable || tcpipAvailable ) 
STRING ) 
STRING ) 
m_multiplayer_cursor ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST - INT_CONST , INT_CONST , INT_CONST ) 
STRING ) 
INT_CONST , setup_cursor_table [ setup_cursor ] , INT_CONST + ( ( INT ) ( realtime * INT_CONST ) & INT_CONST ) ) 
setup_cursor == INT_CONST ) 
k ) 
STRING ) 
STRING ) 
setup_cursor < INT_CONST ) 
setup_cursor < INT_CONST ) 
setup_cursor == INT_CONST || setup_cursor == INT_CONST ) 
Q_strcmp ( cl_name . string , setup_myname ) != INT_CONST ) 
setup_cursor == INT_CONST ) 
k < INT_CONST || k > INT_CONST ) 
setup_top > INT_CONST ) 
m_net_cursor >= m_net_items ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
serialAvailable ) 
p ) 
serialAvailable ) 
p ) 
tcpipAvailable ) 
m_net_items == INT_CONST ) 
INT_CONST - INT_CONST * INT_CONST ) 
INT ) 
STRING ) 
STRING ) 
m_net_cursor ) 
m_net_cursor == INT_CONST && ! serialAvailable ) 
( options_cursor == INT_CONST ) && ( modestate != MS_WINDOWED ) ) 
options_cursor ) 
scr_viewsize . value < INT_CONST ) 
v_gamma . value < FLOAT_CONST ) 
sensitivity . value < INT_CONST ) 
bgmvolume . value < INT_CONST ) 
volume . value < INT_CONST ) 
cl_forwardspeed . value > INT_CONST ) 
STRING , -v m_pitch . value ) 
STRING , ! lookspring . value ) 
STRING , ! lookstrafe . value ) 
STRING , ! _windowed_mouse . value ) 
range < INT_CONST ) 
FOR ( i = INT_CONST ; i < SLIDER_RANGE ; i v++ ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
vid_menudrawfn ) 
options_cursor ) 
STRING ) 
-v INT_CONST ) 
INT_CONST ) 
options_cursor == INT_CONST && vid_menudrawfn == NULL ) 
( options_cursor == INT_CONST ) && ( modestate != MS_WINDOWED ) ) 
command ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
command ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
STRING ) 
bind_grab ) 
FOR ( i = INT_CONST ; i < NUMCOMMANDS ; i v++ ) 
bind_grab ) 
bind_grab ) 
STRING ) 
k ) 
STRING ) 
STRING ) 
bindnames [ keys_cursor ] [ INT_CONST ] , keys ) 
STRING ) 
++v help_page >= NUM_HELP_PAGES ) 
--v help_page < INT_CONST ) 
) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
JoiningGame && SerialConfig ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
StartingGame ) 
basex , serialConfig_cursor_table [ INT_CONST ] , STRING ) 
basex , serialConfig_cursor_table [ INT_CONST ] , STRING ) 
basex , serialConfig_cursor_table [ INT_CONST ] , STRING ) 
SerialConfig ) 
JoiningGame ) 
basex - INT_CONST , serialConfig_cursor_table [ serialConfig_cursor ] , INT_CONST + ( ( INT ) ( realtime * INT_CONST ) & INT_CONST ) ) 
serialConfig_cursor == INT_CONST ) 
key ) 
STRING ) 
STRING ) 
serialConfig_cursor > INT_CONST ) 
serialConfig_cursor > INT_CONST ) 
serialConfig_cursor < INT_CONST ) 
serialConfig_cursor == INT_CONST ) 
serialConfig_cursor == INT_CONST ) 
key < INT_CONST || key > INT_CONST ) 
DirectConfig && ( serialConfig_cursor == INT_CONST || serialConfig_cursor == INT_CONST ) ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
modemConfig_dialing == CHAR_CONST ) 
basex - INT_CONST , modemConfig_cursor_table [ modemConfig_cursor ] , INT_CONST + ( ( INT ) ( realtime * INT_CONST ) & INT_CONST ) ) 
key ) 
STRING ) 
STRING ) 
modemConfig_cursor == INT_CONST ) 
modemConfig_cursor == INT_CONST ) 
modemConfig_cursor == INT_CONST ) 
key < INT_CONST || key > INT_CONST ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
StartingGame ) 
basex , INT_CONST , STRING ) 
JoiningGame ) 
basex - INT_CONST , lanConfig_cursor_table [ lanConfig_cursor ] , INT_CONST + ( ( INT ) ( realtime * INT_CONST ) & INT_CONST ) ) 
lanConfig_cursor == INT_CONST ) 
key ) 
STRING ) 
STRING ) 
lanConfig_cursor == INT_CONST ) 
lanConfig_cursor == INT_CONST ) 
key < INT_CONST || key > INT_CONST ) 
StartingGame && lanConfig_cursor == INT_CONST ) 
INT_CONST , INT_CONST , Draw_CachePic ( STRING ) ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
INT_CONST , INT_CONST , STRING ) 
m_serverInfoMessage ) 
gameoptions_cursor ) 
STRING , coop . value ? INT_CONST ?: INT_CONST ) 
rogue ) 
STRING , skill . value + dir ) 
STRING , fraglimit . value + dir * INT_CONST ) 
STRING , timelimit . value + dir * INT_CONST ) 
hipnotic ) 
rogue ) 
hipnotic ) 
rogue ) 
STRING ) 
STRING ) 
gameoptions_cursor == INT_CONST ) 
gameoptions_cursor == INT_CONST ) 
STRING ) 
va ( STRING , hipnoticlevels [ hipnoticepisodes [ startepisode ] . firstLevel + startlevel ] . name ) ) 
STRING ) 
slistInProgress ) 
! searchComplete ) 
hostCacheCount ) 
( INT_CONST / INT_CONST ) - ( ( INT_CONST * INT_CONST ) / INT_CONST ) , INT_CONST , STRING ) 
! slist_sorted ) 
FOR ( i = INT_CONST ; i < hostCacheCount ; i v++ ) 
FOR ( j = i + INT_CONST ; j < hostCacheCount ; j v++ ) 
STRING ) 
FOR ( n = INT_CONST ; n < hostCacheCount ; n v++ ) 
*v m_return_reason ) 
) 
STRING ) 
STRING ) 
STRING ) 
STRING , M_Menu_Main_f ) 
m_state ) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
) 
m_entersound ) 
) 
key ) 
IPXConfig || TCPIPConfig ) 
__E__O__F__
model -> numleafs + INT_CONST ) 
row ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
! name [ INT_CONST ] ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
mod -> type == mod_alias ) 
UNSIGNED *p ) 
mod -> name , loadname ) 
LittleLong ( *v ( UNSIGNED *p ) buf ) ) 
mod , buf ) 
mod , buf ) 
name ) 
mod , crash ) 
! l -> filelen ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( j = INT_CONST ; j < MIPLEVELS ; j v++ ) 
FOR ( i = INT_CONST ; i < m -> nummiptex ; i v++ ) 
anims , INT_CONST , SIZEOF ( anims ) ) 
FOR ( j = i + INT_CONST ; j < m -> nummiptex ; j v++ ) 
num + INT_CONST > altmax ) 
FOR ( j = INT_CONST ; j < max ; j v++ ) 
FOR ( j = INT_CONST ; j < altmax ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( surfnum = INT_CONST ; surfnum < count ; surfnum v++ , in v++ , out v++ ) 
in -> planenum ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , out v++ , in v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ , in v++ , out v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
corner ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < mod -> numsubmodels ; i v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
daliasframe_t * ) 
name , pdaliasframe -> name ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
trivertx_t * ) 
byte * ) 
FOR ( j = INT_CONST ; j < numv ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
VOID *p ) 
SIZEOF ( maliasgroup_t ) + NEW_LINE ( numframes - INT_CONST ) * SIZEOF ( paliasgroup -> frames [ INT_CONST ] ) , loadname ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
byte * ) 
daliasinterval_t * ) 
numframes * SIZEOF ( FLOAT ) , loadname ) 
byte * ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
skinsize * r_pixbytes , loadname ) 
r_pixbytes == INT_CONST ) 
FOR ( i = INT_CONST ; i < skinsize ; i v++ ) 
( VOID *p ) pinskin ) 
daliasskingroup_t * ) 
pinskingroup -> numskins ) 
SIZEOF ( maliasskingroup_t ) + NEW_LINE ( numskins - INT_CONST ) * SIZEOF ( paliasskingroup -> skindescs [ INT_CONST ] ) , NEW_LINE loadname ) 
byte * ) 
daliasskininterval_t * ) 
numskins * SIZEOF ( FLOAT ) , loadname ) 
byte * ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
pinmodel -> version ) 
pinmodel -> flags ) 
pinmodel -> boundingradius ) 
pmodel -> skinheight > MAX_LBM_HEIGHT ) 
pmodel -> numverts <= INT_CONST ) 
pmodel -> numtris <= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pmodel -> skinwidth & INT_CONST ) 
numskins < INT_CONST ) 
numskins * SIZEOF ( maliasskindesc_t ) , NEW_LINE loadname ) 
FOR ( i = INT_CONST ; i < numskins ; i v++ ) 
stvert_t * ) 
byte * ) 
FOR ( i = INT_CONST ; i < pmodel -> numverts ; i v++ ) 
pinstverts [ i ] . s ) 
mtriangle_t * ) 
byte * ) 
FOR ( i = INT_CONST ; i < pmodel -> numtris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
numframes < INT_CONST ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
) 
start ) 
dspriteframe_t * ) 
pinframe -> width ) 
SIZEOF ( mspriteframe_t ) + size * r_pixbytes , NEW_LINE loadname ) 
pinframe -> origin [ INT_CONST ] ) 
r_pixbytes == INT_CONST ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
VOID *p ) 
dspritegroup_t * ) 
pingroup -> numframes ) 
SIZEOF ( mspritegroup_t ) + NEW_LINE ( numframes - INT_CONST ) * SIZEOF ( pspritegroup -> frames [ INT_CONST ] ) , loadname ) 
mspriteframe_t * ) 
dspriteinterval_t * ) 
numframes * SIZEOF ( FLOAT ) , loadname ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
msprite_t ) 
size , loadname ) 
pin -> type ) 
numframes < INT_CONST ) 
dspriteframetype_t * ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST , mod = mod_known ; i < mod_numknown ; i v++ , mod v++ ) 
__E__O__F__
__E__O__F__
FOR ( i = INT_CONST ; i < NFREEQ ; i v++ ) 
FOR ( i = INT_CONST ; i < NFREEQ ; i v++ ) 
FOR ( i = INT_CONST ; i < ( HOSTENT_ALIAS_LIMIT - INT_CONST ) && FARPKL ( ptr ) ; i v++ , ptr v++ ) 
FOR ( i = INT_CONST ; i < ( HOSTENT_ADDR_LIST_LIMIT - INT_CONST ) && FARPKL ( ptr ) ; i v++ , ptr v++ ) 
FOR ( i = INT_CONST ; i < MAXSOCKETS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXSOCKETS ; i v++ ) 
cp , STRING , &v ha1 , &v ha2 , &v ha3 , &v ha4 ) 
buf , STRING , in . S_un . S_un_b . s_b1 , in . S_un . S_un_b . s_b2 , in . S_un . S_un_b . s_b3 , in . S_un . S_un_b . s_b4 ) 
__E__O__F__
__E__O__F__
dos_int86 ( INT_CONST ) ) 
( CHAR *p ) lowmem_buffer , STRING ) 
INT_CONST ) 
ethdevinfo ) 
INT_CONST ) 
COM_CheckParm ( STRING ) ) 
GetEthdevinfo ( ) ) 
( net_controlsocket = BW_OpenSocket ( INT_CONST ) ) == -v INT_CONST ) 
net_controlsocket , &v addr ) 
state ) 
net_acceptsocket == -v INT_CONST ) 
( CHAR *p ) lowmem_buffer , STRING ) 
INT_CONST ) 
BW_ioctl ( s , reuse_msg , INT_CONST ) ) 
BW_ioctl ( s , nonblock_msg , INT_CONST ) ) 
port ) 
INT_CONST ) 
INT_CONST ) 
dos_int86 ( INT_CONST ) ) 
BW_UDPreadInfo1_t * ) 
from ) 
len > NET_DATAGRAMSIZE ) 
INT_CONST ) 
BW_writeInfo_t * ) 
INT_CONST ) 
BW_writeInfo_t * ) 
buffer , STRING , NEW_LINE ( ( STRUCT sockaddr_in * ) addr ) -> sin_addr . s_net , NEW_LINE ( ( STRUCT sockaddr_in * ) addr ) -> sin_addr . s_host , NEW_LINE ( ( STRUCT sockaddr_in * ) addr ) -> sin_addr . s_lh , NEW_LINE ( ( STRUCT sockaddr_in * ) addr ) -> sin_addr . s_impno , NEW_LINE ntohs ( ( ( STRUCT sockaddr_in * ) addr ) -> sin_port ) NEW_LINE ) 
string , STRING , &v ha1 , &v ha2 , &v ha3 , &v ha4 , &v hp ) 
( STRUCT sockaddr_in * ) addr ) 
( STRUCT sockaddr_in * ) addr ) 
name [ INT_CONST ] < CHAR_CONST || name [ INT_CONST ] > CHAR_CONST ) 
*v b v++ == CHAR_CONST ) 
__E__O__F__
) 
( source = inportb ( p -> uart + INTERRUPT_ID_REGISTER ) & INT_CONST ) != INT_CONST ) 
) 
inportb ( p -> uart + LINE_STATUS_REGISTER ) & LSR_TRANSMITTER_EMPTY ) 
INT_CONST , INT_CONST ) 
useModem ) 
baud == INT_CONST ) 
useModem ) 
clear , p -> clear ) 
p -> clear , clear ) 
STRING , dialType ) 
p -> enabled ) 
p -> uart + INTERRUPT_ENABLE_REGISTER , INT_CONST ) 
( inportb ( p -> uart + LINE_STATUS_REGISTER ) ) & LSR_DATA_READY ) 
inportb ( p -> uart + MODEM_STATUS_REGISTER ) & MODEM_STATUS_MASK ) 
p -> uartType == UART_AUTO ) 
p -> irq + INT_CONST , &v p -> protectedModeSaveInfo ) 
p -> uartType == UART_8250 ) 
INT ) 
&v p -> protectedModeInfo ) 
) 
p -> irq + INT_CONST , &v p -> protectedModeInfo ) 
INT_CONST , inportb ( INT_CONST ) & ~ ( INT_CONST << p -> irq ) ) 
) 
INT_CONST , INT_CONST ) 
p -> uart + LINE_CONTROL_REGISTER , LCR_DLAB | p -> lineControl ) 
p -> uart + MODEM_CONTROL_REGISTER , MCR_OUT2 | MCR_RTS | MCR_DTR ) 
p -> uart + INTERRUPT_ENABLE_REGISTER , IER_RX_DATA_READY | IER_TX_HOLDING_REGISTER_EMPTY | IER_LINE_STATUS | IER_MODEM_STATUS ) 
p -> uart + INTERRUPT_ENABLE_REGISTER , INT_CONST ) 
INT_CONST , inportb ( INT_CONST ) | ( INT_CONST << p -> irq ) ) 
) 
p -> irq + INT_CONST , &v p -> protectedModeSaveInfo ) 
) 
p -> statusUpdated ) 
STRING ) 
p -> uart + MODEM_CONTROL_REGISTER , INT_CONST ) 
*v p -> startup ) 
m_return_onerror ) 
p -> enabled ) 
p -> useModem && ! p -> modemInitialized ) 
) 
( ret = CheckStatus ( p ) ) != INT_CONST ) 
FULL ( p -> outputQueue ) ) 
inportb ( p -> uart + LINE_STATUS_REGISTER ) & LSR_TRANSMITTER_EMPTY ) 
( p -> modemStatus & MODEM_STATUS_MASK ) != MODEM_STATUS_MASK ) 
! EMPTY ( p -> inputQueue ) ) 
p -> useModem ) 
) 
p -> useModem && p -> modemConnected ) 
p ) 
p -> useModem ) 
EMPTY ( p -> inputQueue ) ) 
Cmd_Argv ( INT_CONST ) + INT_CONST ) 
Cmd_Argc ( ) == INT_CONST ) 
Cmd_CheckParm ( STRING ) ) 
Cmd_CheckParm ( STRING ) ) 
( i = Cmd_CheckParm ( STRING ) ) != INT_CONST ) 
( i = Cmd_CheckParm ( STRING ) ) != INT_CONST ) 
( i = Cmd_CheckParm ( STRING ) ) != INT_CONST ) 
Cmd_CheckParm ( STRING ) ) 
Cmd_CheckParm ( STRING ) ) 
( i = Cmd_CheckParm ( STRING ) ) != INT_CONST ) 
( i = Cmd_CheckParm ( STRING ) ) != INT_CONST ) 
Cmd_CheckParm ( STRING ) ) 
Cmd_CheckParm ( STRING ) ) 
Cmd_CheckParm ( STRING ) ) 
Cmd_CheckParm ( STRING ) ) 
Cmd_CheckParm ( STRING ) ) 
Cmd_CheckParm ( STRING ) ) 
Cmd_CheckParm ( STRING ) ) 
FOR ( n = INT_CONST ; n < NUM_COM_PORTS ; n v++ ) 
FOR ( n = INT_CONST ; n < NUM_COM_PORTS ; n v++ ) 
CheckStatus ( p ) ) 
*v commandString ) 
p -> outputQueue , b ) 
CheckStatus ( p ) ) 
__E__O__F__
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
cmd_source == src_command ) 
Cmd_Argc ( ) ) 
data -> cursize == INT_CONST ) 
data -> cursize <= MAX_DATAGRAM ) 
packetLen | ( NETFLAG_DATA | eom ) ) 
sfunc . Write ( sock -> socket , ( byte * ) & packetBuffer , packetLen , &v sock -> addr ) == -v INT_CONST ) 
sock -> sendMessageLength <= MAX_DATAGRAM ) 
packetLen | ( NETFLAG_DATA | eom ) ) 
sfunc . Write ( sock -> socket , ( byte * ) & packetBuffer , packetLen , &v sock -> addr ) == -v INT_CONST ) 
sock -> sendMessageLength <= MAX_DATAGRAM ) 
packetLen | ( NETFLAG_DATA | eom ) ) 
sfunc . Write ( sock -> socket , ( byte * ) & packetBuffer , packetLen , &v sock -> addr ) == -v INT_CONST ) 
data -> cursize == INT_CONST ) 
packetLen | NETFLAG_UNRELIABLE ) 
sfunc . Write ( sock -> socket , ( byte * ) & packetBuffer , packetLen , &v sock -> addr ) == -v INT_CONST ) 
! sock -> canSend ) 
sock -> ackSequence != sock -> sendSequence ) 
sock -> sendNext ) 
Cmd_Argc ( ) == INT_CONST ) 
FOR ( s = net_activeSockets ; s ; s = s -> next ) 
FOR ( s = net_freeSockets ; s ; s = s -> next ) 
FOR ( s = net_activeSockets ; s ; s = s -> next ) 
FOR ( s = net_freeSockets ; s ; s = s -> next ) 
INT_CONST ) 
testPollCount ) 
testInProgress ) 
host && hostCacheCount ) 
FOR ( n = INT_CONST ; n < hostCacheCount ; n v++ ) 
FOR ( net_landriverlevel = INT_CONST ; net_landriverlevel < net_numlandrivers ; net_landriverlevel v++ ) 
FOR ( n = INT_CONST ; n < max ; n v++ ) 
test2Socket , net_message . data , net_message . maxsize , &v clientaddr ) 
) 
STRING , name , value ) 
&v net_message ) 
&v net_message , INT_CONST ) 
&v test2PollProcedure , FLOAT_CONST ) 
STRING ) 
test2InProgress ) 
host && hostCacheCount ) 
FOR ( n = INT_CONST ; n < hostCacheCount ; n v++ ) 
FOR ( net_landriverlevel = INT_CONST ; net_landriverlevel < net_numlandrivers ; net_landriverlevel v++ ) 
&v net_message ) 
&v net_message , INT_CONST ) 
STRING , NET_Stats_f ) 
COM_CheckParm ( STRING ) ) 
FOR ( i = INT_CONST ; i < net_numlandrivers ; i v++ ) 
FOR ( i = INT_CONST ; i < net_numlandrivers ; i v++ ) 
FOR ( i = INT_CONST ; i < net_numlandrivers ; i v++ ) 
) 
acceptsock , net_message . data , net_message . maxsize , &v clientaddr ) 
) 
command == CCREQ_PLAYER_INFO ) 
FOR ( clientNumber = INT_CONST , client = svs . clients ; clientNumber < svs . maxclients ; clientNumber v++ , client v++ ) 
command == CCREQ_RULE_INFO ) 
command != CCREQ_CONNECT ) 
clientaddr . sa_family == AF_INET ) 
FOR ( s = net_activeSockets ; s ; s = s -> next ) 
) 
INT_CONST ) 
dfunc . Connect ( newsock , &v clientaddr ) == -v INT_CONST ) 
sock -> address , dfunc . AddrToString ( &v clientaddr ) ) 
&v net_message ) 
&v net_message , INT_CONST ) 
FOR ( net_landriverlevel = INT_CONST ; net_landriverlevel < net_numlandrivers ; net_landriverlevel v++ ) 
dfunc . controlSock , &v myaddr ) 
( ret = dfunc . Read ( dfunc . controlSock , net_message . data , net_message . maxsize , &v readaddr ) ) > INT_CONST ) 
FOR ( n = INT_CONST ; n < hostCacheCount ; n v++ ) 
FOR ( i = INT_CONST ; i < hostCacheCount ; i v++ ) 
FOR ( net_landriverlevel = INT_CONST ; net_landriverlevel < net_numlandrivers ; net_landriverlevel v++ ) 
dfunc . GetAddrFromName ( host , &v sendaddr ) == -v INT_CONST ) 
dfunc . Connect ( newsock , &v sendaddr ) == -v INT_CONST ) 
STRING ) 
FOR ( reps = INT_CONST ; reps < INT_CONST ; reps v++ ) 
*v ( ( INT *p ) net_message . data ) ) 
ret == INT_CONST ) 
ret == -v INT_CONST ) 
) 
ret == CCREP_ACCEPT ) 
&v sendaddr , sock -> address ) 
STRING ) 
dfunc . Connect ( newsock , &v sock -> addr ) == -v INT_CONST ) 
sock ) 
FOR ( net_landriverlevel = INT_CONST ; net_landriverlevel < net_numlandrivers ; net_landriverlevel v++ ) 
__E__O__F__
__E__O__F__
FOR ( n = INT_CONST ; n < IPXSOCKBUFFERS ; n v++ ) 
FOR ( ecb = readlist [ s ] , prev = NULL ; ecb ; ecb = ecb -> link ) 
COM_CheckParm ( STRING ) ) 
INT_CONST , ( __dpmi_regs * ) & regs ) 
LOWMEMSIZE ) 
ipx_lowmem_area_t * ) 
FOR ( s = INT_CONST ; s < IPXSOCKETS ; s v++ ) 
FOR ( n = INT_CONST ; n < IPXSOCKBUFFERS ; n v++ ) 
( net_controlsocket = IPX_OpenSocket ( INT_CONST ) ) == -v INT_CONST ) 
&v pollProcedure , FLOAT_CONST ) 
net_controlsocket , &v addr ) 
state ) 
net_acceptsocket == -v INT_CONST ) 
handlesInUse == IPXSOCKETS ) 
port ) 
FOR ( handle = INT_CONST ; handle < IPXSOCKETS ; handle v++ ) 
FOR ( n = INT_CONST ; n < IPXSOCKBUFFERS ; n v++ ) 
STRING ) 
lma -> socketbuffer [ handle ] [ INT_CONST ] . ecb . inUse != INT_CONST ) 
( __dpmi_regs * ) & regs ) 
&v ipxaddr , &v ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr , SIZEOF ( IPXaddr ) ) 
net_acceptsocket == -v INT_CONST ) 
FOR ( n = INT_CONST ; n < IPXSOCKBUFFERS ; n v++ ) 
handle ) 
ecb -> completionCode != INT_CONST ) 
ipx_lowmem_buffer_t * ) 
rcvbuf -> header . length ) 
addr ) 
lma -> socketbuffer [ handle ] [ INT_CONST ] . ecb . immediateAddress , rcvbuf -> ecb . immediateAddress , INT_CONST ) 
IPXheader ) 
addr . sipx_addr . network , INT_CONST , INT_CONST ) 
lma -> socketbuffer [ handle ] [ INT_CONST ] . ecb . inUse != INT_CONST ) 
IPXheader ) 
&v lma -> socketbuffer [ handle ] [ INT_CONST ] . header . destination , &v ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr , SIZEOF ( IPXaddr ) ) 
lma -> socketbuffer [ handle ] [ INT_CONST ] . data , buf , len ) 
&v lma -> socketbuffer [ handle ] [ INT_CONST ] . ecb ) 
buf , STRING , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . network [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . network [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . network [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . network [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . node [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . node [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . node [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . node [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . node [ INT_CONST ] , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_addr . node [ INT_CONST ] , NEW_LINE ntohs ( ( ( STRUCT sockaddr_ipx * ) addr ) -> sipx_port ) NEW_LINE ) 
addr , INT_CONST , SIZEOF ( STRUCT qsockaddr ) ) 
INT_CONST , network [ INT_CONST ] ) 
name ) 
n == INT_CONST ) 
__E__O__F__
! loop_server ) 
VOID *p ) 
sock -> receiveMessageLength == INT_CONST ) 
&v net_message ) 
length + INT_CONST ) 
sock -> receiveMessageLength ) 
! sock -> driverdata ) 
( *v bufferLength + data -> cursize + INT_CONST ) > NET_MAXMESSAGE ) 
buffer , data -> data , data -> cursize ) 
! sock -> driverdata ) 
( *v bufferLength + data -> cursize + SIZEOF ( byte ) + SIZEOF ( SHORT ) ) > NET_MAXMESSAGE ) 
buffer , data -> data , data -> cursize ) 
__E__O__F__
net_freeSockets == NULL ) 
sock -> address , STRING ) 
sock == net_activeSockets ) 
FOR ( s = net_activeSockets ; s ; s = s -> next ) 
Cmd_Argv ( INT_CONST ) ) 
FOR ( net_driverlevel = INT_CONST ; net_driverlevel < net_numdrivers ; net_driverlevel v++ ) 
Cmd_Argc ( ) != INT_CONST ) 
sv . active ) 
Cmd_Argv ( INT_CONST ) ) 
n > svs . maxclientslimit ) 
( n == INT_CONST ) && listening ) 
Cmd_Argc ( ) != INT_CONST ) 
Cmd_Argv ( INT_CONST ) ) 
listening ) 
FOR ( n = slistLastShown ; n < hostCacheCount ; n v++ ) 
) 
&v slistSendProcedure , FLOAT_CONST ) 
FOR ( net_driverlevel = INT_CONST ; net_driverlevel < net_numdrivers ; net_driverlevel v++ ) 
( Sys_FloatTime ( ) - slistStartTime ) < FLOAT_CONST ) 
FOR ( net_driverlevel = INT_CONST ; net_driverlevel < net_numdrivers ; net_driverlevel v++ ) 
! slistSilent ) 
! slistSilent ) 
) 
host && *v host == INT_CONST ) 
FOR ( n = INT_CONST ; n < hostCacheCount ; n v++ ) 
) 
slistInProgress ) 
hostCacheCount ) 
FOR ( n = INT_CONST ; n < hostCacheCount ; n v++ ) 
FOR ( net_driverlevel = INT_CONST ; net_driverlevel < numdrivers ; net_driverlevel v++ ) 
host ) 
) 
FOR ( net_driverlevel = INT_CONST ; net_driverlevel < net_numdrivers ; net_driverlevel v++ ) 
sock ) 
sock ) 
! sock ) 
) 
sock ) 
ret == INT_CONST && sock -> driver ) 
ret > INT_CONST ) 
ret == INT_CONST ) 
) 
) 
sock ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
COM_CheckParm ( STRING ) ) 
COM_CheckParm ( STRING ) ) 
COM_CheckParm ( STRING ) || cls . state == ca_dedicated ) 
FOR ( i = INT_CONST ; i < net_numsockets ; i v++ ) 
&v net_message , NET_MAXMESSAGE ) 
&v net_messagetimeout ) 
FOR ( net_driverlevel = INT_CONST ; net_driverlevel < net_numdrivers ; net_driverlevel v++ ) 
) 
FOR ( sock = net_activeSockets ; sock ; sock = sock -> next ) 
FOR ( net_driverlevel = INT_CONST ; net_driverlevel < net_numdrivers ; net_driverlevel v++ ) 
vcrFile != -v INT_CONST ) 
! configRestored ) 
) 
FOR ( pp = pollProcedureList ; pp ; pp = pp -> next ) 
) 
FOR ( pp = pollProcedureList , prev = NULL ; pp ; pp = pp -> next ) 
prev == NULL ) 
__E__O__F__
COM_CheckParm ( STRING ) == INT_CONST ) 
gethostname ( buff , MAXHOSTNAMELEN ) == INT_CONST ) 
FOR ( p = buff ; *v p ; p v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( net_controlsocket = MPATH_OpenSocket ( INT_CONST ) ) == -v INT_CONST ) 
net_controlsocket , &v addr ) 
state ) 
net_acceptsocket == -v INT_CONST ) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
newsocket ) 
net_acceptsocket == -v INT_CONST ) 
socket , buf , len , INT_CONST , ( STRUCT sockaddr * ) addr , &v addrlen ) 
setsockopt ( socket , SOL_SOCKET , SO_BROADCAST , ( CHAR *p ) & i , SIZEOF ( i ) ) < INT_CONST ) 
socket != net_broadcastsocket ) 
socket , buf , len , &v broadcastaddr ) 
socket , buf , len , INT_CONST , ( STRUCT sockaddr * ) addr , SIZEOF ( STRUCT qsockaddr ) ) 
( ( STRUCT sockaddr_in * ) addr ) -> sin_addr . s_addr ) 
string , STRING , &v ha1 , &v ha2 , &v ha3 , &v ha4 , &v hp ) 
( STRUCT sockaddr_in * ) addr ) 
addr , INT_CONST , SIZEOF ( STRUCT qsockaddr ) ) 
( CHAR *p ) & ( ( STRUCT sockaddr_in * ) addr ) -> sin_addr , SIZEOF ( STRUCT in_addr ) , AF_INET ) 
name , MPATH_AddrToString ( addr ) ) 
name [ INT_CONST ] >= CHAR_CONST && name [ INT_CONST ] <= CHAR_CONST ) 
__E__O__F__
__E__O__F__
INT_CONST ) 
STRING ) 
STRING , p -> lengthStated ) 
STRING , p -> lengthStated ) 
STRING ) 
COM_CheckParm ( STRING ) ) 
TTY_Init ( ) ) 
FOR ( n = INT_CONST ; n < NUM_COM_PORTS ; n v++ ) 
STRING ) 
FOR ( n = INT_CONST ; n < NUM_COM_PORTS ; n v++ ) 
) 
SerialLine * ) 
p -> client ) 
p -> tty , b ) 
p -> tty , b ) 
FOR ( n = INT_CONST ; n < message -> cursize ; n v++ ) 
crc ) 
p -> tty , ESCAPE_COMMAND ) 
p -> tty ) 
sock -> sendMessage , message -> data , message -> cursize ) 
STRING ) 
SerialLine * ) 
! TTY_OutputQueueIsEmpty ( p -> tty ) ) 
&v crc ) 
p -> client ) 
b + INT_CONST ) 
p -> tty , b ) 
FOR ( n = INT_CONST ; n < message -> cursize ; n v++ ) 
crc ) 
p -> tty , ESCAPE_COMMAND ) 
p -> tty ) 
&v crc ) 
p -> client ) 
p -> tty , b ) 
crc ) 
p -> tty , ESCAPE_COMMAND ) 
p -> tty ) 
&v crc ) 
p -> client ) 
p -> tty , b ) 
FOR ( n = INT_CONST ; n < message -> cursize ; n v++ ) 
crc ) 
p -> tty , ESCAPE_COMMAND ) 
p -> tty ) 
ProcessInQueue ( p ) ) 
p -> sock -> receiveMessageLength + p -> lengthFound ) 
SerialLine * ) 
p ) 
ret == INT_CONST ) 
sv . active ) 
FOR ( n = INT_CONST ; n < hostCacheCount ; n v++ ) 
FOR ( n = INT_CONST ; n < NUM_COM_PORTS ; n v++ ) 
TTY_IsModem ( p -> tty ) ) 
TTY_Connect ( p -> tty , host ) ) 
) 
&v net_message ) 
ret == INT_CONST ) 
ret == -v INT_CONST ) 
) 
STRING ) 
p -> tty ) 
*v host == CHAR_CONST ) 
FOR ( n = INT_CONST ; n < Q_strlen ( host ) ; n v++ ) 
FOR ( n = INT_CONST ; n < NUM_COM_PORTS ; n v++ ) 
! TTY_CheckForConnection ( p -> tty ) ) 
) 
&v net_message ) 
) 
command == CCREQ_SERVER_INFO ) 
command != CCREQ_CONNECT ) 
&v net_message ) 
p -> sock -> address , STRING , ( INT ) ( ( p - serialLine ) + INT_CONST ) ) 
FOR ( n = INT_CONST ; n < NUM_COM_PORTS ; n v++ ) 
__E__O__F__
buff , MAXHOSTNAMELEN ) 
Q_strcmp ( hostname . string , STRING ) == INT_CONST ) 
( net_controlsocket = UDP_OpenSocket ( INT_CONST ) ) == -v INT_CONST ) 
net_controlsocket , &v addr ) 
state ) 
net_acceptsocket == -v INT_CONST ) 
( newsocket = socket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
newsocket ) 
net_acceptsocket == -v INT_CONST ) 
socket , buf , len , INT_CONST , ( STRUCT sockaddr * ) addr , &v addrlen ) 
setsockopt ( socket , SOL_SOCKET , SO_BROADCAST , ( CHAR *p ) & i , SIZEOF ( i ) ) < INT_CONST ) 
socket != net_broadcastsocket ) 
socket , buf , len , &v broadcastaddr ) 
socket , buf , len , INT_CONST , ( STRUCT sockaddr * ) addr , SIZEOF ( STRUCT qsockaddr ) ) 
( ( STRUCT sockaddr_in * ) addr ) -> sin_addr . s_addr ) 
string , STRING , &v ha1 , &v ha2 , &v ha3 , &v ha4 , &v hp ) 
( STRUCT sockaddr_in * ) addr ) 
addr , INT_CONST , SIZEOF ( STRUCT qsockaddr ) ) 
( CHAR *p ) & ( ( STRUCT sockaddr_in * ) addr ) -> sin_addr , SIZEOF ( STRUCT in_addr ) , AF_INET ) 
name , UDP_AddrToString ( addr ) ) 
name [ INT_CONST ] >= CHAR_CONST && name [ INT_CONST ] <= CHAR_CONST ) 
__E__O__F__
vcrFile , &v next , SIZEOF ( next ) ) 
vcrFile , &v net_message . cursize , SIZEOF ( INT ) ) 
) 
host_time != next . time || next . op != VCR_OP_SENDMESSAGE || next . session != *v ( LONG *p ) ( &v sock -> driverdata ) ) 
) 
host_time != next . time || next . op != VCR_OP_CANSENDMESSAGE || next . session != *v ( LONG *p ) ( &v sock -> driverdata ) ) 
) 
host_time != next . time || next . op != VCR_OP_CONNECT ) 
) 
vcrFile , sock -> address , NET_NAMELEN ) 
__E__O__F__
__E__O__F__
BOOL ) 
myAddr != INADDR_ANY ) 
myAddr ) 
STRING ) 
VOID *p ) 
COM_CheckParm ( STRING ) ) 
pgethostname ( buff , MAXHOSTNAMELEN ) == SOCKET_ERROR ) 
Q_strcmp ( hostname . string , STRING ) == INT_CONST ) 
FOR ( p = buff ; *v p ; p v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
( net_controlsocket = WINS_OpenSocket ( INT_CONST ) ) == -v INT_CONST ) 
( STRUCT sockaddr_in * ) & broadcastaddr ) 
STRING ) 
state ) 
net_acceptsocket == -v INT_CONST ) 
( newsocket = psocket ( PF_INET , SOCK_DGRAM , IPPROTO_UDP ) ) == -v INT_CONST ) 
net_acceptsocket == -v INT_CONST ) 
socket , buf , len , INT_CONST , ( STRUCT sockaddr * ) addr , &v addrlen ) 
psetsockopt ( socket , SOL_SOCKET , SO_BROADCAST , ( CHAR *p ) & i , SIZEOF ( i ) ) < INT_CONST ) 
socket != net_broadcastsocket ) 
socket , buf , len , &v broadcastaddr ) 
socket , buf , len , INT_CONST , ( STRUCT sockaddr * ) addr , SIZEOF ( STRUCT qsockaddr ) ) 
( ( STRUCT sockaddr_in * ) addr ) -> sin_addr . s_addr ) 
string , STRING , &v ha1 , &v ha2 , &v ha3 , &v ha4 , &v hp ) 
( STRUCT sockaddr_in * ) addr ) 
addr , INT_CONST , SIZEOF ( STRUCT qsockaddr ) ) 
( CHAR *p ) & ( ( STRUCT sockaddr_in * ) addr ) -> sin_addr , SIZEOF ( STRUCT in_addr ) , AF_INET ) 
name , WINS_AddrToString ( addr ) ) 
name [ INT_CONST ] >= CHAR_CONST && name [ INT_CONST ] <= CHAR_CONST ) 
__E__O__F__
COM_CheckParm ( STRING ) ) 
FOR ( i = INT_CONST ; i < IPXSOCKETS ; i v++ ) 
pgethostname ( buff , MAXHOSTNAMELEN ) == INT_CONST ) 
FOR ( p = buff ; *v p ; p v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( net_controlsocket = WIPX_OpenSocket ( INT_CONST ) ) == -v INT_CONST ) 
( STRUCT sockaddr_ipx * ) & broadcastaddr ) 
net_controlsocket , &v addr ) 
state ) 
net_acceptsocket == -v INT_CONST ) 
FOR ( handle = INT_CONST ; handle < IPXSOCKETS ; handle v++ ) 
STRING ) 
socket ) 
net_acceptsocket == -v INT_CONST ) 
socket , packetBuffer , len + INT_CONST , INT_CONST , ( STRUCT sockaddr * ) addr , &v addrlen ) 
ret < INT_CONST ) 
INT *p ) 
socket , packetBuffer , len , INT_CONST , ( STRUCT sockaddr * ) addr , SIZEOF ( STRUCT qsockaddr ) ) 
buf , STRING , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_netnum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_netnum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_netnum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_netnum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_nodenum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_nodenum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_nodenum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_nodenum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_nodenum [ INT_CONST ] & INT_CONST , NEW_LINE ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_nodenum [ INT_CONST ] & INT_CONST , NEW_LINE ntohs ( ( ( STRUCT sockaddr_ipx * ) addr ) -> sa_socket ) NEW_LINE ) 
addr , INT_CONST , SIZEOF ( STRUCT qsockaddr ) ) 
INT_CONST , sa_netnum [ INT_CONST ] ) 
addr , INT_CONST , SIZEOF ( STRUCT qsockaddr ) ) 
name ) 
n == INT_CONST ) 
__E__O__F__
__E__O__F__
__E__O__F__
FOR ( i = first ; i < pr_argc ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! rotate ) 
a ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j <= INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k <= INT_CONST ; k v++ ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
rmin , e -> v . mins ) 
OFS_PARM0 ) 
FOR ( i = INT_CONST , check = sv . model_precache ; *v check ; i v++ , check v++ ) 
INT ) 
mod ) 
INT_CONST ) 
OFS_RETURN ) 
OFS_RETURN + INT_CONST ) 
OFS_PARM0 ) 
FOR ( soundnum = INT_CONST , check = sv . sound_precache ; *v check ; check v++ , soundnum v++ ) 
&v sv . signon , svc_spawnstaticsound ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v sv . signon , vol * INT_CONST ) 
OFS_PARM0 ) 
v1 , vec3_origin , vec3_origin , v2 , nomonsters , ent ) 
trace . endpos , pr_global_struct -> trace_endpos ) 
OFS_PARM0 ) 
ent , ignore ) 
trace . endpos , pr_global_struct -> trace_endpos ) 
check < INT_CONST ) 
FOR ( ; ; i v++ ) 
ent -> v . origin , ent -> v . view_ofs , org ) 
sv . time - sv . lastchecktime >= FLOAT_CONST ) 
sv . lastcheck ) 
pr_global_struct -> self ) 
ent ) 
edict_t * ) 
sv . edicts ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ , ent = NEXT_EDICT ( ent ) ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
chain ) 
chain ) 
edict_t * ) 
FOR ( e v++ ; e < sv . num_edicts ; e v++ ) 
first != last ) 
OFS_PARM0 ) 
FOR ( e v++ ; e < sv . num_edicts ; e v++ ) 
sv . edicts ) 
FOR ( i = INT_CONST ; i < MAX_SOUNDS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_MODELS ; i v++ ) 
yaw ) 
OFS_RETURN ) 
sv . state != ss_active ) 
FOR ( j = INT_CONST , client = svs . clients ; j < svs . maxclients ; j v++ , client v++ ) 
ent -> v . origin , start ) 
pr_global_struct -> v_forward , dir ) 
dir , bestdir ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ , check = NEXT_EDICT ( check ) ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
OFS_PARM0 ) 
&v sv . signon , SV_ModelIndex ( pr_strings + ent -> v . model ) ) 
&v sv . signon , ent -> v . frame ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent ) 
OFS_PARM0 ) 
i - INT_CONST ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
svs . changelevel_issued ) 
OFS_PARM0 ) 
( INT ) pr_global_struct -> serverflags & ( SFL_NEW_UNIT | SFL_NEW_EPISODE ) ) 
svs . changelevel_issued ) 
pr_global_struct -> self ) 
self -> v . movetype == MOVETYPE_NOCLIP ) 
self -> v . health < INT_CONST ) 
self -> v . deadflag == DEAD_NO ) 
! ( flags & ( FL_IMMUNE_WATER + FL_GODMODE ) ) ) 
watertype == CONTENT_LAVA ) 
! ( flags & ( FL_IMMUNE_LAVA + FL_GODMODE ) ) ) 
! ( flags & ( FL_IMMUNE_SLIME + FL_GODMODE ) ) ) 
watertype == CONTENT_LAVA ) 
OFS_RETURN ) 
__E__O__F__
FOR ( i = svs . maxclients + INT_CONST ; i < sv . num_edicts ; i v++ ) 
vec3_origin , ed -> v . origin ) 
FOR ( i = INT_CONST ; i < progs -> numglobaldefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numglobaldefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfunctions ; i v++ ) 
FOR ( i = INT_CONST ; i < GEFV_CACHESIZE ; i v++ ) 
field ) 
strlen ( field ) < MAX_FIELD_LEN ) 
! def ) 
line , STRING , NUM_FOR_EDICT ( PROG_TO_EDICT ( val -> edict ) ) ) 
line , STRING , pr_strings + f -> s_name ) 
val -> _int ) 
line , STRING ) 
line , STRING , val -> _float ) 
line , STRING , val -> vector [ INT_CONST ] , val -> vector [ INT_CONST ] , val -> vector [ INT_CONST ] ) 
line , STRING ) 
line , STRING , type ) 
line , STRING , NUM_FOR_EDICT ( PROG_TO_EDICT ( val -> edict ) ) ) 
line , STRING , pr_strings + f -> s_name ) 
val -> _int ) 
line , STRING ) 
line , STRING , val -> _float ) 
line , STRING , val -> vector [ INT_CONST ] , val -> vector [ INT_CONST ] , val -> vector [ INT_CONST ] ) 
line , STRING , type ) 
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( ; i < INT_CONST ; i v++ ) 
ed -> free ) 
STRING , NUM_FOR_EDICT ( ed ) ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( j = INT_CONST ; j < type_size [ type ] ; j v++ ) 
f , STRING ) 
ed -> free ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( j = INT_CONST ; j < type_size [ type ] ; j v++ ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ ) 
STRING , sv . num_edicts ) 
f , STRING ) 
FOR ( i = INT_CONST ; i < progs -> numglobaldefs ; i v++ ) 
INT_CONST ) 
data ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
FLOAT *p ) 
string , s ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT *p ) 
s ) 
s ) 
ent != sv . edicts ) 
&v ent -> v , INT_CONST , progs -> entityfields * INT_CONST ) 
! strcmp ( com_token , STRING ) ) 
keyname , com_token ) 
data ) 
! init ) 
INT_CONST ) 
pr_strings + ent -> v . classname ) 
STRING , inhibit ) 
FOR ( i = INT_CONST ; i < GEFV_CACHESIZE ; i v++ ) 
dprograms_t * ) 
FOR ( i = INT_CONST ; i < com_filesize ; i v++ ) 
FOR ( i = INT_CONST ; i < SIZEOF ( *v progs ) / INT_CONST ; i v++ ) 
globalvars_t * ) 
FOR ( i = INT_CONST ; i < progs -> numstatements ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfunctions ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numglobaldefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numfielddefs ; i v++ ) 
FOR ( i = INT_CONST ; i < progs -> numglobals ; i v++ ) 
__E__O__F__
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( i = pr_depth ; i >= INT_CONST ; i v-- ) 
FOR ( i = INT_CONST ; i < progs -> numfunctions ; i v++ ) 
STRING , best -> profile , pr_strings + best -> s_name ) 
argptr , error ) 
pr_statements + pr_xstatement ) 
pr_depth >= MAX_STACK_DEPTH ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( i = INT_CONST ; i < f -> numparms ; i v++ ) 
FOR ( j = INT_CONST ; j < f -> parm_size [ i ] ; j v++ ) 
pr_depth <= INT_CONST ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
! fnum || fnum >= progs -> numfunctions ) 
f ) 
eval_t * ) 
INT ) 
INT ) 
PROG_TO_EDICT ( a -> edict ) == sv . edicts ) 
a -> vector [ INT_CONST ] == b -> vector [ INT_CONST ] ) 
pr_strings + a -> string , pr_strings + b -> string ) 
a -> vector [ INT_CONST ] != b -> vector [ INT_CONST ] ) 
pr_strings + a -> string , pr_strings + b -> string ) 
eval_t * ) 
eval_t * ) 
a -> edict ) 
a -> edict ) 
a -> edict ) 
! a -> _int ) 
a -> _int ) 
! a -> function ) 
) 
pr_global_struct -> self ) 
STRING , st -> op ) 
__E__O__F__
finalvert_t * pfv0 , finalvert_t * pfv1 , finalvert_t * out ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
out , &v avout ) 
out -> v [ INT_CONST ] < r_refdef . aliasvrect . x ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pfv0 -> v [ INT_CONST ] >= pfv1 -> v [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < count ; j = i , i v++ ) 
ptri -> facesfront ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
clipflags & ALIAS_Z_CLIP ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
clipflags & ALIAS_LEFT_CLIP ) 
clipflags & ALIAS_RIGHT_CLIP ) 
k == INT_CONST ) 
clipflags & ALIAS_BOTTOM_CLIP ) 
clipflags & ALIAS_TOP_CLIP ) 
FOR ( i = INT_CONST ; i < k ; i v++ ) 
FOR ( i = INT_CONST ; i < k - INT_CONST ; i v++ ) 
__E__O__F__
pmodel ) 
INT_CONST ) 
( frame >= pmdl -> numframes ) || ( frame < INT_CONST ) ) 
FLOAT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
zfullyclipped ) 
zclipped ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numv ; i v++ ) 
viewpts [ i ] . flags & ALIAS_Z_CLIP ) 
viewaux [ i ] . fv [ INT_CONST ] * xscale * zi ) 
allclip ) 
currententity -> trivial_accept ) 
stvert_t * ) 
FOR ( i = INT_CONST ; i < r_anumverts ; i v++ , fv v++ , av v++ , r_apverts v++ , pstverts v++ ) 
mtriangle_t * ) 
FOR ( i = INT_CONST ; i < pmdl -> numtris ; i v++ , ptri v++ ) 
angles , alias_forward , alias_right , alias_up ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
t2matrix , tmatrix , rotationmatrix ) 
vright , viewmatrix [ INT_CONST ] ) 
viewmatrix , rotationmatrix , aliastransform ) 
trivial_accept ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pverts -> v , aliastransform [ INT_CONST ] ) 
plightnormal , r_plightvec ) 
lightcos < INT_CONST ) 
temp < INT_CONST ) 
FOR ( i = INT_CONST ; i < r_anumverts ; i v++ , fv v++ , pverts v++ , pstverts v++ ) 
DotProduct ( pverts -> v , aliastransform [ INT_CONST ] ) + NEW_LINE aliastransform [ INT_CONST ] [ INT_CONST ] ) 
( DotProduct ( pverts -> v , aliastransform [ INT_CONST ] ) + NEW_LINE aliastransform [ INT_CONST ] [ INT_CONST ] ) * zi ) 
plightnormal , r_plightvec ) 
av -> fv [ INT_CONST ] * aliasxscale * zi ) 
stvert_t * ) 
fv , pstverts ) 
r_affinetridesc . drawtype ) 
) 
( skinnum >= pmdl -> numskins ) || ( skinnum < INT_CONST ) ) 
( maliasskindesc_t * ) NEW_LINE ( ( byte * ) paliashdr + paliashdr -> skindesc ) ) 
pskindesc -> type == ALIAS_SKIN_GROUP ) 
( INT ) ( skintime / fullskininterval ) ) 
FOR ( i = INT_CONST ; i < ( numskins - INT_CONST ) ; i v++ ) 
VOID *p ) 
r_ambientlight < LIGHT_MIN ) 
r_ambientlight < LIGHT_MIN ) 
r_shadelight < INT_CONST ) 
plighting -> plightvec , alias_forward ) 
( frame >= pmdl -> numframes ) || ( frame < INT_CONST ) ) 
paliashdr -> frames [ frame ] . type == ALIAS_SINGLE ) 
( INT ) ( time / fullinterval ) ) 
FOR ( i = INT_CONST ; i < ( numframes - INT_CONST ) ; i v++ ) 
trivertx_t * ) 
finalvert_t * ) 
aliashdr_t * ) 
) 
! currententity -> colormap ) 
currententity != &v cl . viewent ) 
__E__O__F__
vec , tvec ) 
angle ) 
angle ) 
temp2 , temp1 , temp3 ) 
angle ) 
temp1 , temp3 , entity_rotation ) 
modelorg ) 
) 
r_entorigin , splitplane -> normal ) 
FOR ( ; pedges ; pedges = pnextedge ) 
plastvert -> position , tplane . normal ) 
pvert -> position , tplane . normal ) 
makeclippededge ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
FOR ( j = INT_CONST ; j < psurf -> numedges ; j v++ ) 
FOR ( i = INT_CONST ; i < numsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
node -> contents == CONTENTS_SOLID ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
node -> contents < INT_CONST ) 
pleaf -> efrags ) 
plane -> type ) 
node -> children [ side ] , clipflags ) 
c ) 
node -> children [ ! side ] , clipflags ) 
r_origin , modelorg ) 
clmodel -> nodes , INT_CONST ) 
r_worldpolysbacktofront ) 
FOR ( i = numbtofpolys - INT_CONST ; i >= INT_CONST ; i v-- ) 
__E__O__F__
r_lastvertvalid ) 
world , modelorg , local ) 
transformed [ INT_CONST ] < NEAR_CLIP ) 
xcenter + scale * transformed [ INT_CONST ] ) 
r_nearzionly ) 
INT ) 
ceilv0 == r_ceilv1 ) 
cacheoffset != INT_CONST ) 
side == INT_CONST ) 
( r_u1 - u0 ) / ( r_v1 - v0 ) ) 
( u0 - r_u1 ) / ( v0 - r_v1 ) ) 
edge -> u < r_refdef . vrect_x_adj_shift20 ) 
clip ) 
pv0 , pv1 ) 
edge_t * ) 
! pedge_t -> surfs [ INT_CONST ] ) 
( surface_p ) >= surf_max ) 
( edge_p + fa -> numedges + INT_CONST ) >= edge_max ) 
FOR ( i = INT_CONST , mask = INT_CONST ; i >= INT_CONST ; i v-- , mask >>= INT_CONST ) 
FOR ( i = INT_CONST ; i < fa -> numedges ; i v++ ) 
r_rightclipped ) 
r_rightclipped ) 
makeleftedge ) 
makerightedge ) 
! r_emitted ) 
VOID *p ) 
pplane -> normal , p_normal ) 
surface_p >= surf_max ) 
( edge_p + psurf -> numedges + INT_CONST ) >= edge_max ) 
FOR ( i = INT_CONST , mask = INT_CONST ; i >= INT_CONST ; i v-- , mask >>= INT_CONST ) 
FOR ( ; pedges ; pedges = pedges -> pnext ) 
makeleftedge ) 
makerightedge ) 
! r_emitted ) 
VOID *p ) 
pplane -> normal , p_normal ) 
FOR ( i = INT_CONST , mask = INT_CONST ; i >= INT_CONST ; i v-- , mask >>= INT_CONST ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
pclip ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
pplane -> type ) 
FOR ( i = INT_CONST ; i < lnumverts ; i v++ ) 
verts [ vertpage ] [ i ] . position , modelorg , local ) 
xcenter + scale * transformed [ INT_CONST ] ) 
) 
FOR ( i = INT_CONST ; i < numsurfaces ; i v++ , psurf v++ ) 
modelorg , pplane -> normal ) 
( ( psurf -> flags & SURF_PLANEBACK ) && ( dot < -v BACKFACE_EPSILON ) ) || NEW_LINE ( ! ( psurf -> flags & SURF_PLANEBACK ) && ( dot > BACKFACE_EPSILON ) ) ) 
__E__O__F__
FOR ( bad ) 
r_worldpolysbacktofront ) 
FOR ( s = surface_p - INT_CONST ; s > &v surfaces [ INT_CONST ] ; s v-- ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
r_draworder . value ) 
FOR ( v = r_refdef . vrect . y ; v < r_refdef . vrectbottom ; v v++ ) 
edgelist -> u >= edgestoadd -> u ) 
edgelist -> u >= edgestoadd -> u ) 
edgelist -> u >= edgestoadd -> u ) 
edge_t * pedge ) 
INT_CONST ) 
pwedge -> u > pedge -> u ) 
pedge == &v edge_tail ) 
iu > surf -> last_u ) 
++v surf -> spanstate == INT_CONST ) 
surf -> insubmodel && ( surf -> key == surf2 -> key ) ) 
iu > surf2 -> last_u ) 
--v surf -> spanstate == INT_CONST ) 
edge -> surfs [ INT_CONST ] ) 
++v surf -> spanstate == INT_CONST ) 
FOR ( edge = edge_head . next ; edge != &v edge_tail ; edge = edge -> next ) 
) 
FOR ( edge = edge_head . next ; edge != &v edge_tail ; edge = edge -> next ) 
) 
espan_t * ) 
r_refdef . vrectright << INT_CONST ) 
FOR ( iv = r_refdef . vrect . y ; iv < bottom ; iv v++ ) 
newedges [ iv ] ) 
span_p >= max_span_p ) 
FOR ( s = &v surfaces [ INT_CONST ] ; s < surface_p ; s v++ ) 
FLOAT ) 
newedges [ iv ] ) 
r_drawculledpolys ) 
__E__O__F__
! walk ) 
node -> contents < INT_CONST ) 
r_emins , r_emaxs , splitplane ) 
! r_pefragtopnode ) 
sides & INT_CONST ) 
node -> visframe != r_visframecount ) 
sides & INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . worldmodel -> nodes ) 
( pefrag = *v ppefrag ) != NULL ) 
__E__O__F__
INT ) 
FOR ( j = INT_CONST ; j < MAX_LIGHTSTYLES ; j v++ ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
light , bit , node -> children [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < MAX_DLIGHTS ; i v++ , l v++ ) 
node -> contents < INT_CONST ) 
start , plane -> normal ) 
node -> children [ side ] , start , mid ) 
FOR ( i = INT_CONST ; i < node -> numsurfaces ; i v++ , surf v++ ) 
lightmap ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
node -> children [ ! side ] , mid , end ) 
r < r_refdef . ambientlight ) 
__E__O__F__
SIZEOF ( texture_t ) + INT_CONST * INT_CONST + INT_CONST * INT_CONST + INT_CONST * INT_CONST + INT_CONST * INT_CONST , STRING ) 
FOR ( m = INT_CONST ; m < INT_CONST ; m v++ ) 
FOR ( y = INT_CONST ; y < ( INT_CONST >> m ) ; y v++ ) 
FOR ( x = INT_CONST ; x < ( INT_CONST >> m ) ; x v++ ) 
byte * ) 
STRING , ( FLOAT ) NUMSTACKEDGES ) 
) 
( LONG ) R_EdgeCodeStart , NEW_LINE ( LONG ) R_EdgeCodeEnd - ( LONG ) R_EdgeCodeStart ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numleafs ; i v++ ) 
r_cnumsurfs <= MINSURFACES ) 
) 
r_numallocatededges < MINEDGES ) 
) 
cl . intermission ) 
pvrect -> width < INT_CONST ) 
pvrectin -> width - pvrect -> width ) 
pvrect , &v r_refdef . vrect , lineadj ) 
r_refdef . fov_x / INT_CONST * M_PI ) 
INT ) 
( FLOAT ) r_refdef . vrect . width * XCENTERING ) 
r_refdef . vrect . width - INT_CONST ) 
xOrigin * r_refdef . horizontalFieldOfView ) 
( FLOAT_CONST - xOrigin ) * r_refdef . horizontalFieldOfView ) 
yOrigin * verticalFieldOfView ) 
( FLOAT_CONST - yOrigin ) * verticalFieldOfView ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
scr_fov . value <= FLOAT_CONST ) 
r_oldviewleaf == r_viewleaf ) 
r_viewleaf , cl . worldmodel ) 
FOR ( i = INT_CONST ; i < cl . worldmodel -> numleafs ; i v++ ) 
! r_drawentities . value ) 
FOR ( i = INT_CONST ; i < cl_numvisedicts ; i v++ ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
vup , viewlightvec ) 
currententity -> origin ) 
j < INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
r_viewlighting . ambientlight > INT_CONST ) 
&v r_viewlighting ) 
currententity -> angles [ INT_CONST ] || currententity -> angles [ INT_CONST ] NEW_LINE || currententity -> angles [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! r_drawentities . value ) 
FOR ( i = INT_CONST ; i < cl_numvisedicts ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < MAX_DLIGHTS ; k v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
r_surfsonstack ) 
) 
) 
r_dspeeds . value ) 
) 
r_drawculledpolys ) 
r_dspeeds . value ) 
) 
r_dspeeds . value ) 
! r_dspeeds . value ) 
r_timegraph . value || r_speeds . value || r_dspeeds . value ) 
) 
) 
! cl_entities [ INT_CONST ] . model || ! cl . worldmodel ) 
) 
r_dspeeds . value ) 
) 
r_dspeeds . value ) 
) 
r_dspeeds . value ) 
r_timegraph . value ) 
FOR ( i = INT_CONST ; i < ( SIN_BUFFER_SIZE ) ; i v++ ) 
__E__O__F__
r_fullbright . value != oldbright ) 
&v vr ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
h > s ) 
FOR ( i = INT_CONST ; i < h ; i v++ , dest -= vid . rowbytes * INT_CONST ) 
FOR ( ; i < s ; i v++ , dest -= vid . rowbytes * INT_CONST ) 
r_refdef . vrect . width <= MAX_TIMINGS ) 
timex + INT_CONST ) 
) 
r_time2 - r_time1 ) 
) 
dp_time2 - dp_time1 ) 
STRING , NEW_LINE ( INT ) ms , dp_time , ( INT ) rw_time , db_time , ( INT ) se_time , de_time , NEW_LINE dv_time ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mplane_t * p , FLOAT *p normal , FLOAT *p dist ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
cl . maxclients > INT_CONST ) 
r_numsurfs . value ) 
r_numedges . value ) 
r_refdef . ambientlight < INT_CONST ) 
r_refdef . vieworg , modelorg ) 
r_refdef . viewangles , vpn , vright , vup ) 
r_origin , cl . worldmodel ) 
r_viewleaf -> contents <= CONTENTS_WATER ) 
( r_dowarp != r_dowarpold ) || r_viewchanged || lcd_x . value ) 
) 
vpn , base_vpn ) 
) 
) 
) 
__E__O__F__
STRING ) 
i ) 
particle_t * ) 
FOR ( i = -v INT_CONST ; i < INT_CONST ; i += INT_CONST ) 
FOR ( j = -v INT_CONST ; j < INT_CONST ; j += INT_CONST ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k += INT_CONST ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
! avelocities [ INT_CONST ] [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < NUMVERTEXNORMALS * INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMVERTEXNORMALS ; i v++ ) 
FOR ( i = INT_CONST ; i < r_numparticles ; i v++ ) 
FOR ( ; ; ) 
f ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
msgcount == INT_CONST ) 
vec3_t org ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = -v INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = -v INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
FOR ( i = -v INT_CONST ; i < INT_CONST ; i += INT_CONST ) 
FOR ( j = -v INT_CONST ; j < INT_CONST ; j += INT_CONST ) 
FOR ( k = -v INT_CONST ; k < INT_CONST ; k += INT_CONST ) 
rand ( ) & INT_CONST ) 
rand ( ) & INT_CONST ) 
end , start , vec ) 
len > INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
type == INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
particletexture ) 
vup , FLOAT_CONST , up ) 
vright , xscaleshrink , r_pright ) 
FOR ( ; ; ) 
FOR ( p = active_particles ; p ; p = p -> next ) 
FOR ( ; ; ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
__E__O__F__
byte * ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
( xshift == xlast ) && ( yshift == ylast ) ) 
FOR ( y = INT_CONST ; y < SKYSIZE ; y v++ ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x += INT_CONST ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x v++ ) 
UNSIGNED *p ) 
FOR ( y = INT_CONST ; y < SKYSIZE ; y v++ ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x += INT_CONST ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x v++ ) 
byte * ) 
FOR ( y = INT_CONST ; y < SKYSIZE ; y v++ ) 
FOR ( x = INT_CONST ; x < SKYSIZE ; x v++ ) 
iskyspeed , iskyspeed2 ) 
( INT ) ( cl . time / temp ) * temp ) 
__E__O__F__
clip_current ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , instep += SIZEOF ( vec5_t ) / SIZEOF ( FLOAT ) ) 
instep , in , SIZEOF ( vec5_t ) ) 
FOR ( i = INT_CONST ; i < nump ; i v++ , instep += SIZEOF ( vec5_t ) / SIZEOF ( FLOAT ) ) 
r_spritedesc . vpn , modelorg ) 
dot >= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < nump ; i v++ ) 
) 
( frame >= psprite -> numframes ) || ( frame < INT_CONST ) ) 
psprite -> frames [ frame ] . type == SPR_SINGLE ) 
( INT ) ( time / fullinterval ) ) 
FOR ( i = INT_CONST ; i < ( numframes - INT_CONST ) ; i v++ ) 
psprite ) 
psprite -> type == SPR_FACING_UPRIGHT ) 
tvec ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( dot > FLOAT_CONST ) || ( dot < -v FLOAT_CONST ) ) 
currententity -> angles , r_spritedesc . vpn , NEW_LINE r_spritedesc . vright , r_spritedesc . vup ) 
M_PI * INT_CONST / INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
psprite -> beamlength ) 
) 
__E__O__F__
surf -> extents [ INT_CONST ] >> INT_CONST ) 
FOR ( lnum = INT_CONST ; lnum < MAX_DLIGHTS ; lnum v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( t = INT_CONST ; t < tmax ; t v++ ) 
FOR ( s = INT_CONST ; s < smax ; s v++ ) 
surf -> extents [ INT_CONST ] >> INT_CONST ) 
r_fullbright . value || ! cl . worldmodel -> lightdata ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( maps = INT_CONST ; maps < MAXLIGHTMAPS && surf -> styles [ maps ] != INT_CONST ; NEW_LINE maps v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
currententity -> frame ) 
base -> anim_min > reletive || base -> anim_max <= reletive ) 
) 
INT_CONST << blockdivshift ) 
r_pixbytes == INT_CONST ) 
tmax * smax ) 
( soffset >> r_drawsurf . surfmip ) + ( smax << INT_CONST ) ) 
FOR ( u = INT_CONST ; u < r_numhblocks ; u v++ ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
FOR ( v = INT_CONST ; v < r_numvblocks ; v v++ ) 
r_lightptr [ INT_CONST ] - lightleft ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( b = INT_CONST ; b >= INT_CONST ; b v-- ) 
UNSIGNED SHORT *p ) 
FOR ( k = INT_CONST ; k < blocksize ; k v++ ) 
FOR ( b = INT_CONST ; b < blocksize ; b v++ ) 
FOR ( i = INT_CONST ; i < TILE_SIZE ; i v++ ) 
FOR ( j = INT_CONST ; j < TILE_SIZE ; j v++ ) 
( INT ) ( cl . time * SPEED ) & ( CYCLE - INT_CONST ) ) 
FOR ( i = INT_CONST ; i < TILE_SIZE ; i v++ ) 
FOR ( j = INT_CONST ; j < TILE_SIZE ; j v++ ) 
__E__O__F__
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING , Sbar_ShowScores ) 
STRING ) 
hipnotic ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
rogue ) 
STRING ) 
num < INT_CONST ) 
FOR ( pow10 = INT_CONST ; num >= pow10 ; pow10 *= INT_CONST ) 
num , str ) 
FOR ( i = INT_CONST ; i < cl . maxclients ; i v++ ) 
FOR ( i = INT_CONST ; i < scoreboardlines ; i v++ ) 
FOR ( j = INT_CONST ; j < scoreboardlines - INT_CONST - i ; j v++ ) 
) 
scoreboardtext , INT_CONST , SIZEOF ( scoreboardtext ) ) 
FOR ( i = INT_CONST ; i < scoreboardlines ; i v++ ) 
str , STRING , cl . stats [ STAT_MONSTERS ] , cl . stats [ STAT_TOTALMONSTERS ] ) 
str , STRING , cl . stats [ STAT_SECRETS ] , cl . stats [ STAT_TOTALSECRETS ] ) 
str , STRING , minutes , tens , units ) 
cl . levelname ) 
cl . gametype != GAME_DEATHMATCH ) 
) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
s -> colors & INT_CONST ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
rogue ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
hipnotic ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
cl . gametype == GAME_DEATHMATCH ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
s -> colors & INT_CONST ) 
num , STRING , f ) 
rogue && NEW_LINE ( cl . maxclients != INT_CONST ) && NEW_LINE ( teamplay . value > INT_CONST ) && NEW_LINE ( teamplay . value < INT_CONST ) ) 
cl . stats [ STAT_HEALTH ] >= INT_CONST ) 
cl . time <= cl . faceanimtime ) 
sb_lines && vid . width > INT_CONST ) 
sb_showscores || cl . stats [ STAT_HEALTH ] <= INT_CONST ) 
) 
INT_CONST , INT_CONST , cl . stats [ STAT_HEALTH ] , INT_CONST NEW_LINE , cl . stats [ STAT_HEALTH ] <= INT_CONST ) 
rogue ) 
vid . width > INT_CONST ) 
num , str ) 
STRING ) 
) 
( vid . width - INT_CONST ) >> INT_CONST ) 
FOR ( i = INT_CONST ; i < l ; i v++ ) 
s -> colors & INT_CONST ) 
num , STRING , f ) 
INT ) 
x + INT_CONST , y , s -> name ) 
vid . width < INT_CONST || ! sb_lines ) 
) 
numlines < INT_CONST ) 
FOR ( i = INT_CONST ; i < scoreboardlines ; i v++ ) 
FOR ( COMMENT ; i < scoreboardlines && y < vid . height - INT_CONST ; i v++ ) 
s -> colors & INT_CONST ) 
num , STRING , f ) 
INT ) 
x + INT_CONST , y , s -> name ) 
cl . gametype == GAME_DEATHMATCH ) 
STRING ) 
STRING ) 
INT_CONST , INT_CONST , dig , INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST , cl . stats [ STAT_SECRETS ] , INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST , cl . stats [ STAT_MONSTERS ] , INT_CONST , INT_CONST ) 
STRING ) 
__E__O__F__
*v str ) 
scr_erase_center v++ > vid . numpages ) 
scr_center_lines <= INT_CONST ) 
cl . intermission ) 
scr_center_lines <= INT_CONST ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
fov_x < INT_CONST || fov_x > INT_CONST ) 
height / x ) 
) 
scr_viewsize . value < INT_CONST ) 
cl . intermission ) 
&v vrect , &v scr_vrect , sb_lines ) 
scr_con_current > vid . height ) 
STRING , SCR_ScreenShot_f ) 
STRING ) 
count < INT_CONST ) 
! scr_showpause . value ) 
! cl . paused ) 
! scr_drawloading ) 
con_forcedup ) 
clearconsole v++ < vid . numpages ) 
( SHORT ) ( width - INT_CONST ) ) 
( SHORT ) width ) 
pcx -> filler , INT_CONST , SIZEOF ( pcx -> filler ) ) 
FOR ( i = INT_CONST ; i < height ; i v++ ) 
FOR ( j = INT_CONST ; j < width ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
pcxname , vid . buffer , vid . width , vid . height , vid . rowbytes , NEW_LINE host_basepal ) 
STRING , pcxname ) 
cls . state != ca_connected ) 
) 
) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < l ; j v++ , x += INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST && scr_conlines != scr_con_current ; i v++ ) 
host_basepal ) 
scr_disabled_for_loading ) 
cls . state == ca_dedicated ) 
oldfov != scr_fov . value ) 
) 
) 
scr_fullupdate v++ < vid . numpages ) 
INT_CONST , INT_CONST , vid . width , vid . height ) 
) 
) 
) 
) 
) 
) 
scr_drawdialog ) 
) 
pconupdate ) 
) 
scr_copyeverything ) 
__E__O__F__
! snd_initialized ) 
COM_CheckParm ( STRING ) ) 
&v nosound ) 
host_parms . memsize < INT_CONST ) 
) 
) 
MAX_SFX * SIZEOF ( sfx_t ) , STRING ) 
fakedma ) 
STRING , shm -> speed ) 
STRING ) 
true ) 
! fakedma ) 
! name ) 
FOR ( i = INT_CONST ; i < num_sfx ; i v++ ) 
! sound_started || nosound . value ) 
precache . value ) 
FOR ( ch_idx = NUM_AMBIENTS ; ch_idx < NUM_AMBIENTS + MAX_DYNAMIC_CHANNELS ; ch_idx v++ ) 
ch -> entnum == cl . viewentity ) 
ch -> origin , listener_origin , source_vec ) 
FLOAT_CONST - dist ) 
! sound_started ) 
entnum , entchannel ) 
! target_chan -> leftvol && ! target_chan -> rightvol ) 
FOR ( ch_idx = NUM_AMBIENTS ; ch_idx < NUM_AMBIENTS + MAX_DYNAMIC_CHANNELS ; ch_idx v++ , check v++ ) 
FOR ( i = INT_CONST ; i < MAX_DYNAMIC_CHANNELS ; i v++ ) 
! sound_started ) 
FOR ( i = INT_CONST ; i < MAX_CHANNELS ; i v++ ) 
clear ) 
! sfx ) 
sfx ) 
! snd_ambient ) 
FOR ( ambient_channel = INT_CONST ; ambient_channel < NUM_AMBIENTS ; ambient_channel v++ ) 
FOR ( ambient_channel = INT_CONST ; ambient_channel < NUM_AMBIENTS ; ambient_channel v++ ) 
chan -> master_vol < vol ) 
! sound_started || ( snd_blocked > INT_CONST ) ) 
) 
FOR ( i = NUM_AMBIENTS ; i < total_channels ; i v++ , ch v++ ) 
i >= MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS ) 
FOR ( j = MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS ; j < i ; j v++ , combine v++ ) 
FOR ( i = INT_CONST ; i < total_channels ; i v++ , ch v++ ) 
) 
samplepos < oldsamplepos ) 
paintedtime < soundtime ) 
shm -> channels - INT_CONST ) 
) 
FOR ( sfx = known_sfx , i = INT_CONST ; i < num_sfx ; i v++ , sfx v++ ) 
nosound . value ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING ) 
BLASTER , CHAR_CONST ) 
BLASTER , CHAR_CONST ) 
BLASTER , CHAR_CONST ) 
dsp_port + INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST ; i ; i v-- ) 
FOR ( i = INT_CONST ; i ; i v-- ) 
dsp_version >= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
dma_buffer ) 
high_dma && dsp_version >= INT_CONST ) 
STRING , dma ) 
dma > INT_CONST ) 
disable_reg , dma | INT_CONST ) 
INT_CONST << INT_CONST ) 
INT_CONST << INT_CONST ) 
page_reg [ dma ] , realaddr >> INT_CONST ) 
dma > INT_CONST ) 
flipflop_reg , INT_CONST ) 
flipflop_reg , INT_CONST ) 
clear_reg , INT_CONST ) 
disable_reg , dma & ~ INT_CONST ) 
! GetBLASTER ( ) ) 
ResetDSP ( ) ) 
INT_CONST ) 
dsp_version < INT_CONST ) 
STRING ) 
STRING ) 
STRING , SB_Info_f ) 
size * INT_CONST ) 
dma_buffer ) 
dma_buffer , INT_CONST , dma_size ) 
shm -> samplebits / INT_CONST ) 
) 
dsp_version >= INT_CONST ) 
shm -> samples - INT_CONST ) 
disable_reg , dma | INT_CONST ) 
) 
__E__O__F__
FOR ( i = INT_CONST ; i < NUM_SECTION_BUFFERS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_FIELD_BUFFERS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_SECTION_BUFFERS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_FIELD_BUFFERS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_FIELD_BUFFERS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_SECTION_BUFFERS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUM_FIELD_BUFFERS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST , j = INT_CONST ; i < INT_CONST && j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
GUS_GetIWData ( ) == false ) 
HaveCodec ) 
FOR ( CodecRate = CodecRates ; CodecRate -> Rate != INT_CONST ; CodecRate v++ ) 
FOR ( Gf1Rate = Gf1Rates ; Gf1Rate -> Rate != INT_CONST ; Gf1Rate v++ ) 
shm -> samples - INT_CONST ) 
DisableReg , DmaChannel | INT_CONST ) 
__E__O__F__
STRING , O_RDWR ) 
audio_fd , SNDCTL_DSP_RESET , INT_CONST ) 
ioctl ( audio_fd , SNDCTL_DSP_GETCAPS , &v caps ) == -v INT_CONST ) 
! ( caps & DSP_CAP_TRIGGER ) || ! ( caps & DSP_CAP_MMAP ) ) 
ioctl ( audio_fd , SNDCTL_DSP_GETOSPACE , &v info ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < SIZEOF ( tryrates ) / INT_CONST ; i v++ ) 
UNSIGNED CHAR *p ) 
shm -> channels == INT_CONST ) 
audio_fd , SNDCTL_DSP_SETTRIGGER , &v tmp ) 
! snd_inited ) 
ioctl ( audio_fd , SNDCTL_DSP_GETOPTR , &v count ) == -v INT_CONST ) 
__E__O__F__
sc -> loopstart != -v INT_CONST ) 
stepscale == INT_CONST && inwidth == INT_CONST && sc -> width == INT_CONST ) 
FOR ( i = INT_CONST ; i < outcount ; i v++ ) 
FOR ( i = INT_CONST ; i < outcount ; i v++ ) 
&v s -> cache ) 
! data ) 
s -> name , data , com_filesize ) 
FLOAT ) 
&v s -> cache , len + SIZEOF ( sfxcache_t ) , s -> name ) 
s , sc -> speed , sc -> width , data + info . dataofs ) 
&v info , INT_CONST , SIZEOF ( info ) ) 
! wav ) 
STRING ) 
STRING ) 
) 
STRING ) 
STRING ) 
) 
info . samples ) 
__E__O__F__
FOR ( i = INT_CONST ; i < snd_linear_count ; i += INT_CONST ) 
pDSBuf ) 
lpaintedtime < endtime ) 
( shm -> samples >> INT_CONST ) - INT_CONST ) 
) 
pDSBuf ) 
pDSBuf ) 
shm -> samplebits == INT_CONST ) 
out_idx + INT_CONST ) 
val >> INT_CONST ) 
pDSBuf ) 
paintedtime < endtime ) 
endtime - paintedtime > PAINTBUFFER_SIZE ) 
paintbuffer , INT_CONST , ( end - paintedtime ) * SIZEOF ( portable_samplepair_t ) ) 
FOR ( i = INT_CONST ; i < total_channels ; i v++ , ch v++ ) 
! ch -> leftvol && ! ch -> rightvol ) 
end ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
ch -> leftvol > INT_CONST ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
SIGNED SHORT *p ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
__E__O__F__
dma_t ) 
CHAR *p ) 
__E__O__F__
__E__O__F__
snd_inited ) 
STRING , O_WRONLY | O_NDELAY ) 
audio_fd < INT_CONST ) 
ioctl ( audio_fd , AUDIO_GETINFO , &v info ) < INT_CONST ) 
fcntl ( audio_fd , F_SETFL , O_NONBLOCK ) < INT_CONST ) 
&v info ) 
ioctl ( audio_fd , AUDIO_SETINFO , &v info ) < INT_CONST ) 
STRING ) 
dma_buffer ) 
( info . play . samples * shm -> channels ) % shm -> samples ) 
paintedtime < wbufp ) 
! bytes ) 
wbufp * bsize ) 
FOR ( b = bytes ; b ; b v-- ) 
write ( audio_fd , writebuf , bytes ) < bytes ) 
__E__O__F__
pDSBuf ) 
pDSPBuf && ( pDSBuf != pDSPBuf ) ) 
pDS ) 
hWaveOut ) 
FOR ( i = INT_CONST ; i < WAV_BUFFERS ; i v++ ) 
( VOID *p ) & sn , INT_CONST , SIZEOF ( sn ) ) 
&v format , INT_CONST , SIZEOF ( format ) ) 
( hresult = iDirectSoundCreate ( NULL , &v pDS , NULL ) ) != DS_OK ) 
dscaps ) 
DS_OK != pDS -> lpVtbl -> GetCaps ( pDS , &v dscaps ) ) 
dscaps . dwFlags & DSCAPS_EMULDRIVER ) 
DS_OK != pDS -> lpVtbl -> SetCooperativeLevel ( pDS , mainwindow , DSSCL_EXCLUSIVE ) ) 
&v dsbuf , INT_CONST , SIZEOF ( dsbuf ) ) 
&v dsbcaps , INT_CONST , SIZEOF ( dsbcaps ) ) 
! COM_CheckParm ( STRING ) ) 
! primary_format_set || ! COM_CheckParm ( STRING ) ) 
&v dsbuf , INT_CONST , SIZEOF ( dsbuf ) ) 
pDSBuf , INT_CONST , INT_CONST , DSBPLAY_LOOPING ) 
snd_firsttime ) 
( hresult = pDSBuf -> lpVtbl -> Lock ( pDSBuf , INT_CONST , gSndBufSize , &v lpData , &v dwSize , NULL , NULL , INT_CONST ) ) != DS_OK ) 
lpData , INT_CONST , dwSize ) 
pDSBuf ) 
shm -> samplebits / INT_CONST ) 
&v format , INT_CONST , SIZEOF ( format ) ) 
GMEM_MOVEABLE | GMEM_SHARE , gSndBufSize ) 
FOR ( i = INT_CONST ; i < WAV_BUFFERS ; i v++ ) 
shm -> samplebits / INT_CONST ) 
COM_CheckParm ( STRING ) ) 
! wavonly ) 
snd_firsttime ) 
! dsound_init && ( stat != SIS_NOTAVAIL ) ) 
! dsound_init && ! wav_init ) 
dsound_init ) 
shm -> samples - INT_CONST ) 
! wav_init ) 
INT_CONST ) 
( ( snd_sent - snd_completed ) >> sample16 ) < INT_CONST ) 
__E__O__F__
&v sv_maxvelocity ) 
FOR ( i = INT_CONST ; i < MAX_MODELS ; i v++ ) 
sv . datagram . cursize > MAX_DATAGRAM - INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( sound_num = INT_CONST ; sound_num < MAX_SOUNDS NEW_LINE && sv . sound_precache [ sound_num ] ; sound_num v++ ) 
sound_num == MAX_SOUNDS || ! sv . sound_precache [ sound_num ] ) 
volume != DEFAULT_SOUND_PACKET_VOLUME ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v client -> message , svc_print ) 
&v client -> message , svc_serverinfo ) 
! coop . value && deathmatch . value ) 
&v client -> message , message ) 
FOR ( s = sv . model_precache + INT_CONST ; *v s ; s v++ ) 
FOR ( s = sv . sound_precache + INT_CONST ; *v s ; s v++ ) 
&v client -> message , svc_cdtrack ) 
&v client -> message , svc_setview ) 
&v client -> message , svc_signonnum ) 
STRING , client -> netconnection -> address ) 
edictnum ) 
sv . loadgame ) 
client -> name , STRING ) 
&v client -> netconnection -> addr ) 
pr_global_struct -> SetNewParms ) 
FOR ( i = INT_CONST ; i < NUM_SPAWN_PARMS ; i v++ ) 
client ) 
FOR ( i = INT_CONST ; i < svs . maxclients ; i v++ ) 
INT_CONST ) 
node -> contents < INT_CONST ) 
FOR ( i = INT_CONST ; i < fatbytes ; i v++ ) 
clent -> v . origin , clent -> v . view_ofs , org ) 
sv . edicts ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , ent = NEXT_EDICT ( ent ) ) 
FOR ( i = INT_CONST ; i < ent -> num_leafs ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
msg , bits | U_SIGNAL ) 
msg , bits >> INT_CONST ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , ent = NEXT_EDICT ( ent ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
ent -> v . fixangle ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ent -> v . view_ofs [ INT_CONST ] != DEFAULT_VIEWHEIGHT ) 
val ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
bits & SU_VIEWHEIGHT ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
msg , items ) 
bits & SU_WEAPONFRAME ) 
standard_quake ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v msg , svc_time ) 
client -> edict , &v msg ) 
client -> edict , &v msg ) 
msg . cursize + sv . datagram . cursize < msg . maxsize ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
FOR ( j = INT_CONST , client = svs . clients ; j < svs . maxclients ; j v++ , client v++ ) 
&v client -> message , svc_updatefrags ) 
FOR ( j = INT_CONST , client = svs . clients ; j < svs . maxclients ; j v++ , client v++ ) 
&v sv . reliable_datagram ) 
&v msg , svc_nop ) 
NET_SendUnreliableMessage ( client -> netconnection , &v msg ) == -v INT_CONST ) 
) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
FOR ( i = INT_CONST ; i < MAX_MODELS && sv . model_precache [ i ] ; i v++ ) 
FOR ( entnum = INT_CONST ; entnum < sv . num_edicts ; entnum v++ ) 
entnum ) 
svent -> v . origin , svent -> baseline . origin ) 
&v sv . signon , svc_spawnbaseline ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
data ) 
&v msg , svc_stufftext ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
host_client -> edict ) 
FOR ( j = INT_CONST ; j < NUM_SPAWN_PARMS ; j v++ ) 
hostname . string [ INT_CONST ] == INT_CONST ) 
STRING , server ) 
sv . active ) 
coop . value ) 
) 
&v sv , INT_CONST , SIZEOF ( sv ) ) 
sv . name , server ) 
sv . max_edicts * pr_edict_size , STRING ) 
FOR ( i = INT_CONST ; i < svs . maxclients ; i v++ ) 
sv . name , server ) 
) 
FOR ( i = INT_CONST ; i < sv . worldmodel -> numsubmodels ; i v++ ) 
INT_CONST ) 
coop . value ) 
) 
) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
__E__O__F__
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
mins [ INT_CONST ] + maxs [ INT_CONST ] ) 
trace . fraction == FLOAT_CONST ) 
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
ent -> v . origin , oldorg ) 
( INT ) ent -> v . flags & ( FL_SWIM | FL_FLY ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
neworg , end ) 
neworg , ent -> v . mins , ent -> v . maxs , end , false , ent ) 
trace . allsolid ) 
( INT ) ent -> v . flags & FL_PARTIALGROUND ) 
trace . endpos , ent -> v . origin ) 
( INT ) ent -> v . flags & FL_PARTIALGROUND ) 
relink ) 
ent -> v . origin , oldorigin ) 
( INT ) ( actor -> v . ideal_yaw / INT_CONST ) * INT_CONST ) 
deltax > INT_CONST ) 
( ( rand ( ) & INT_CONST ) & INT_CONST ) || abs ( deltay ) > abs ( deltax ) ) 
d [ INT_CONST ] != DI_NODIR && d [ INT_CONST ] != turnaround NEW_LINE && SV_StepDirection ( actor , d [ INT_CONST ] , dist ) ) 
FOR ( tdir = INT_CONST ; tdir <= INT_CONST ; tdir += INT_CONST ) 
FOR ( tdir = INT_CONST ; tdir >= INT_CONST ; tdir -= INT_CONST ) 
turnaround != DI_NODIR && SV_StepDirection ( actor , turnaround , dist ) ) 
! SV_CheckBottom ( actor ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
goal -> v . absmax [ i ] < ent -> v . absmin [ i ] - dist ) 
! ( ( INT ) ent -> v . flags & ( FL_ONGROUND | FL_FLY | FL_SWIM ) ) ) 
ent -> v . enemy ) 
__E__O__F__
sv . edicts ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , check = NEXT_EDICT ( check ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
thinktime <= INT_CONST || thinktime > sv . time + host_frametime ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( bumpcount = INT_CONST ; bumpcount < numbumps ; bumpcount v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numplanes ; i v++ ) 
FOR ( j = INT_CONST ; j < numplanes ; j v++ ) 
ent -> v . gravity ) 
ent , STRING ) 
ent -> v . origin , ent -> v . mins , ent -> v . maxs , end , MOVE_NOMONSTERS , ent ) 
trace . ent ) 
! pusher -> v . velocity [ INT_CONST ] && ! pusher -> v . velocity [ INT_CONST ] && ! pusher -> v . velocity [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pusher -> v . origin , pushorig ) 
pusher -> v . origin , move , pusher -> v . origin ) 
sv . edicts ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , check = NEXT_EDICT ( check ) ) 
! ( ( ( INT ) check -> v . flags & FL_ONGROUND ) NEW_LINE && PROG_TO_EDICT ( check -> v . groundentity ) == pusher ) ) 
check -> v . movetype != MOVETYPE_WALK ) 
check ) 
FOR ( i = INT_CONST ; i < num_moved ; i v++ ) 
edict_t * pusher , FLOAT movetime ) 
! pusher -> v . avelocity [ INT_CONST ] && ! pusher -> v . avelocity [ INT_CONST ] && ! pusher -> v . avelocity [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pusher -> v . angles , pushorig ) 
pusher -> v . angles , amove , pusher -> v . angles ) 
sv . edicts ) 
FOR ( e = INT_CONST ; e < sv . num_edicts ; e v++ , check = NEXT_EDICT ( check ) ) 
! ( ( ( INT ) check -> v . flags & FL_ONGROUND ) NEW_LINE && PROG_TO_EDICT ( check -> v . groundentity ) == pusher ) ) 
check -> v . movetype != MOVETYPE_WALK ) 
check ) 
FOR ( i = INT_CONST ; i < num_moved ; i v++ ) 
thinktime < ent -> v . ltime + host_frametime ) 
! SV_TestEntityPosition ( ent ) ) 
ent -> v . origin , org ) 
FOR ( z = INT_CONST ; z < INT_CONST ; z v++ ) 
FOR ( i = -v INT_CONST ; i <= INT_CONST ; i v++ ) 
FOR ( j = -v INT_CONST ; j <= INT_CONST ; j v++ ) 
ent , true ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT ) 
oldorg , ent -> v . origin ) 
vec3_origin , upmove ) 
ent , upmove ) 
ent , host_frametime , &v steptrace ) 
clip ) 
clip & INT_CONST ) 
downtrace . plane . normal [ INT_CONST ] > FLOAT_CONST ) 
ent ) 
( INT ) ent -> v . movetype ) 
! SV_RunThink ( ent ) ) 
ent ) 
! SV_RunThink ( ent ) ) 
! SV_RunThink ( ent ) ) 
STRING , ( INT ) ent -> v . movetype ) 
ent , true ) 
ent ) 
ent , false ) 
ent -> v . groundentity ) 
! SV_RunThink ( ent ) ) 
! ( ( INT ) ent -> v . flags & FL_ONGROUND ) NEW_LINE && ent -> v . movetype != MOVETYPE_FLY NEW_LINE && ent -> v . movetype != MOVETYPE_BOUNCEMISSILE NEW_LINE && ent -> v . movetype != MOVETYPE_FLYMISSILE ) 
ent -> v . movetype != MOVETYPE_FLY NEW_LINE && ent -> v . movetype != MOVETYPE_FLYMISSILE ) 
ent -> v . velocity , ent -> v . basevelocity , ent -> v . velocity ) 
trace . plane . normal [ INT_CONST ] > FLOAT_CONST ) 
ent ) 
ent -> v . groundentity ) 
ent ) 
INT ) 
ent ) 
FOR ( x = INT_CONST ; x <= INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y <= INT_CONST ; y v++ ) 
ent ) 
! ( ( INT ) ent -> v . flags & ( FL_ONGROUND | FL_FLY | FL_SWIM ) ) ) 
ent , INT_CONST , STRING , INT_CONST , INT_CONST ) 
ent ) 
sv . edicts ) 
FOR ( i = INT_CONST ; i < sv . num_edicts ; i v++ , ent = NEXT_EDICT ( ent ) ) 
&v tempent , ent , SIZEOF ( edict_t ) ) 
INT_CONST ) 
__E__O__F__
! ( ( INT ) sv_player -> v . flags & FL_ONGROUND ) ) 
FOR ( i = INT_CONST ; i < MAX_FORWARD ; i v++ ) 
FOR ( j = INT_CONST ; j < i ; j v++ ) 
start , vec3_origin , vec3_origin , stop , true , sv_player ) 
trace . fraction == FLOAT_CONST ) 
wishspeed == INT_CONST ) 
accelspeed > addspeed ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
velocity , wishdir ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
sv_player -> v . v_angle , forward , right , up ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
velocity ) 
! wishspeed ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
sv_player -> v . angles , forward , right , up ) 
sv . time < sv_player -> v . teleport_time && fmove < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
wishvel , velocity ) 
wishvel ) 
VOID ) 
sv_player -> v . movetype == MOVETYPE_NONE ) 
) 
sv_player -> v . health <= INT_CONST ) 
( INT ) sv_player -> v . flags & FL_WATERJUMP ) 
) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
) 
cmd ) 
FOR ( i = INT_CONST , host_client = svs . clients ; i < svs . maxclients ; i v++ , host_client v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST * INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST * INT_CONST ; i v++ ) 
INT_CONST , &v r ) 
r . x . ax || r . h . bh < INT_CONST ) 
lockmem ) 
&v meminfo ) 
! win95 ) 
( UNSIGNED ) sbrk ( INT_CONST ) & INT_CONST ) 
extra > INT_CONST ) 
! win95 ) 
FOR ( j = allocsize ; j > ( minmem + LOCKED_FOR_MALLOC ) ; NEW_LINE j -= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
lockunlockmem ) 
byte * ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( m = INT_CONST ; m < ( working_size - INT_CONST * INT_CONST ) ; m += INT_CONST ) 
-v ( LOCKED_FOR_MALLOC ) ) 
! isDedicated ) 
ch ) 
) 
INT_CONST , INT_CONST ) 
keybuf_head != keybuf_tail ) 
KEYBUF_SIZE - INT_CONST ) 
cls . state == ca_dedicated ) 
registered . value ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
d ) 
INT_CONST ) 
handle == -v INT_CONST ) 
) 
UNSIGNED SHORT *p ) 
time < INT_CONST ) 
curtime == lastcurtime ) 
) 
) 
STRING ) 
j ) 
STRING ) 
stderr , STRING , quakeparms . memsize ) 
COM_CheckParm ( STRING ) ) 
INT ) 
lockmem ) 
lockunlockmem ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = ( INT ) & start_of_memory ; i < ( end_of_memory - INT_CONST * INT_CONST ) ; i += INT_CONST ) 
STRING , VERSION ) 
SIGNOFP , Sys_NoFPUExceptionHandler ) 
fptest_temp >= FLOAT_CONST ) 
) 
Sys_AtExit ) 
cwd ) 
COM_CheckParm ( STRING ) != INT_CONST ) 
) 
! isDedicated ) 
__E__O__F__
argptr , fmt ) 
strlen ( text ) > SIZEOF ( text ) ) 
FOR ( p = ( UNSIGNED CHAR *p ) text ; *v p ; p v++ ) 
) 
INT_CONST ) 
handle == -v INT_CONST ) 
STRING ) 
SIGFPE , SIG_IGN ) 
&v parms , INT_CONST , SIZEOF ( parms ) ) 
c , v ) 
STRING ) 
INT_CONST , F_SETFL , fcntl ( INT_CONST , F_GETFL , INT_CONST ) | FNDELAY ) 
&v parms ) 
COM_CheckParm ( STRING ) ) 
) 
cls . state == ca_dedicated ) 
time < sys_ticrate . value && ( vcrFile == -v INT_CONST || recording ) ) 
time > sys_ticrate . value * INT_CONST ) 
sys_linerefresh . value ) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAX_HANDLES ; i v++ ) 
f ) 
STRING ) 
INT_CONST ) 
parms . memsize ) 
argc , argv ) 
STRING ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAX_HANDLES ; i v++ ) 
path , STRING ) 
startaddr & ~ ( psize - INT_CONST ) ) 
( CHAR *p ) addr , length + startaddr - addr + psize , INT_CONST ) 
r < INT_CONST ) 
FLOAT_CONST ) 
__E__O__F__
byte * ) 
FOR ( n = INT_CONST ; n < INT_CONST ; n v++ ) 
FOR ( m = INT_CONST ; m < ( size - INT_CONST * INT_CONST ) ; m += INT_CONST ) 
FOR ( i = INT_CONST ; i < MAX_HANDLES ; i v++ ) 
) 
f ) 
t ) 
) 
) 
path , STRING ) 
! f ) 
t ) 
) 
) 
) 
) 
) 
) 
! VirtualProtect ( ( LPVOID ) startaddr , length , PAGE_READWRITE , &v flOldProtect ) ) 
) 
! QueryPerformanceFrequency ( &v PerformanceFreq ) ) 
highpart || ( lowpart > FLOAT_CONST ) ) 
DOUBLE ) 
) 
vinfo ) 
! GetVersionEx ( &v vinfo ) ) 
vinfo . dwPlatformId == VER_PLATFORM_WIN32_NT ) 
! in_sys_error3 ) 
argptr , error ) 
isDedicated ) 
! in_sys_error0 ) 
! in_sys_error1 ) 
! in_sys_error2 ) 
INT_CONST ) 
) 
tevent ) 
INT_CONST ) 
) 
&v PerformanceCount ) 
( UNSIGNED INT ) PerformanceCount . LowPart >> lowshift ) 
( temp <= oldtime ) && ( ( oldtime - temp ) < INT_CONST ) ) 
) 
) 
STRING ) 
j ) 
! isDedicated ) 
FOR ( ; ; ) 
! GetMessage ( &v msg , NULL , INT_CONST , INT_CONST ) ) 
hPrevInstance ) 
MEMORYSTATUS ) 
! GetCurrentDirectory ( SIZEOF ( cwd ) , cwd ) ) 
*v lpCmdLine && ( parms . argc < MAX_NUM_ARGVS ) ) 
*v lpCmdLine && ( ( *v lpCmdLine > INT_CONST ) && ( *v lpCmdLine <= INT_CONST ) ) ) 
parms . argc , parms . argv ) 
COM_CheckParm ( STRING ) != INT_CONST ) 
! isDedicated ) 
parms . memsize < MINIMUM_WIN_MEMORY ) 
parms . memsize ) 
! parms . membase ) 
NULL , FALSE , FALSE , NULL ) 
! tevent ) 
( t = COM_CheckParm ( STRING ) ) > INT_CONST ) 
) 
) 
STRING ) 
) 
INT_CONST ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAX_HANDLES ; i v++ ) 
f ) 
argptr , error ) 
STRING , text ) 
INT_CONST ) 
&v tstruct ) 
_kbhit ( ) ) 
len == SIZEOF ( text ) ) 
&v parms , INT_CONST , SIZEOF ( parms ) ) 
parms . memsize ) 
cwd , SIZEOF ( cwd ) ) 
argc , argv ) 
! COM_CheckParm ( STRING ) ) 
STRING ) 
) 
INT_CONST ) 
__E__O__F__
STRING , VID_TestMode_f ) 
! COM_CheckParm ( STRING ) ) 
vid_modenum , palette ) 
! pv ) 
modenum ) 
! pv ) 
( modenum >= numvidmodes ) || ( modenum < INT_CONST ) ) 
modenum ) 
pnewmode == pcurrentmode ) 
*v pcurrentmode -> setmode ) 
stat < INT_CONST ) 
*v pcurrentmode -> setpalette ) 
STRING , ( FLOAT ) vid_modenum ) 
STRING , VID_ModeInfo ( vid_modenum , NULL ) ) 
*v pcurrentmode -> swapbuffers ) 
! nomodecheck ) 
) 
) 
FOR ( i = INT_CONST ; i < nummodes ; i v++ ) 
na ) 
mode ) 
VGA_CheckAdequateMem ( pv -> width , pv -> height , pv -> rowbytes , NEW_LINE ( pv -> numpages == INT_CONST ) || vid_nopageflip . value ) ) 
! vid_testingmode ) 
) 
FOR ( i = INT_CONST ; i < nummodes ; i v++ ) 
FOR ( j = INT_CONST ; j < vid_wmodes ; j v++ ) 
i == vid_modenum ) 
vid_wmodes + INT_CONST ) 
FOR ( i = INT_CONST ; i < vid_wmodes ; i v++ ) 
vid_testingmode ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
__E__O__F__
viddef_t * lvid , STRUCT vmode_s * pcurrentmode , NEW_LINE INT x , INT y , byte * pbitmap , INT width , INT height ) 
lvid , pcurrentmode , x , y , pbitmap , width , height ) 
INT_CONST ) 
lvid , pcurrentmode , x , y , width , height ) 
INT_CONST ) 
lvid ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ppal ) 
regs . x . ax != INT_CONST ) 
INT ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
SIZEOF ( vbeinfoblock_t ) ) 
LONG *p ) 
pinfoblock ) 
regs . x . ax != INT_CONST ) 
SHORT *p ) 
( *v pmodenums != -v INT_CONST ) && ( nummodes < MAX_VESA_MODES ) ) 
nummodes ) 
pinfoblock ) 
INT_CONST ) 
infobuf ) 
( modeinfo . bits_per_pixel != INT_CONST ) || NEW_LINE ( modeinfo . bytes_per_pixel != INT_CONST ) || NEW_LINE ( modeinfo . width > MAXWIDTH ) || NEW_LINE ( modeinfo . height > MAXHEIGHT ) ) 
( modeinfo . mode_attributes & NEW_LINE ( MODE_SUPPORTED_IN_HW | COLOR_MODE | GRAPHICS_MODE ) ) != NEW_LINE ( MODE_SUPPORTED_IN_HW | COLOR_MODE | GRAPHICS_MODE ) ) 
! ( modeinfo . mode_attributes & LINEAR_FRAME_BUFFER ) ) 
UNSIGNED CHAR *p ) 
infobuf ) 
vid_nopageflip . value ) 
regs . x . ax != INT_CONST ) 
INT_CONST ) 
! pextra -> vga_incompatible && NEW_LINE ( lvid -> numpages == INT_CONST ) && NEW_LINE de_exists && NEW_LINE ( _vid_wait_override . value == FLOAT_CONST ) ) 
INT_CONST ) 
VID_banked ) 
lvid -> numpages > INT_CONST ) 
vid_surfcache , vid_surfcachesize ) 
rects ) 
lvid -> numpages > INT_CONST ) 
vid_wait . value != VID_WAIT_VSYNC ) 
VID_banked ) 
vsync_exists && ( vid_wait . value == VID_WAIT_VSYNC ) ) 
__E__O__F__
__E__O__F__
FOR ( r_shift = -v INT_CONST , x = INT_CONST ; x < r_mask ; x = x << INT_CONST ) 
FOR ( g_shift = -v INT_CONST , x = INT_CONST ; x < g_mask ; x = x << INT_CONST ) 
FOR ( b_shift = -v INT_CONST , x = INT_CONST ; x < b_mask ; x = x << INT_CONST ) 
( x < INT_CONST ) || ( y < INT_CONST ) ) 
FOR ( yi = y ; yi < ( y + height ) ; yi v++ ) 
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
( x < INT_CONST ) || ( y < INT_CONST ) ) 
FOR ( yi = y ; yi < ( y + height ) ; yi v++ ) 
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
Cmd_Argc ( ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
x_framebuffer [ INT_CONST ] ) 
pwidth == INT_CONST ) 
SHORT *p ) 
x_visinfo -> depth , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE Z_Malloc ( mem ) , NEW_LINE vid . width , vid . height , NEW_LINE INT_CONST , NEW_LINE INT_CONST ) 
vid . width * vid . height * SIZEOF ( *v d_pzbuffer ) , STRING ) 
FOR ( frm = INT_CONST ; frm < INT_CONST ; frm v++ ) 
x_framebuffer [ frm ] ) 
x_disp , NEW_LINE x_vis , NEW_LINE x_visinfo -> depth , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE &v x_shminfo [ frm ] , NEW_LINE vid . width , NEW_LINE vid . height ) 
size < minsize ) 
! XShmAttach ( x_disp , &v x_shminfo [ frm ] ) ) 
STRING , VID_Gamma_f ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
getpid ( ) ) 
STRING ) 
INT_CONST ) 
x_disp ) 
STRING , x_screen , x_screen_width , x_screen_height ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
x_disp , template_mask , &v template , &v num_visuals ) 
FOR ( i = INT_CONST ; i < num_visuals ; i v++ ) 
verbose ) 
CPP_COMMENT NEW_LINE vid . width , vid . height , NEW_LINE INT_CONST , COMMENT_NL CPP_COMMENT NEW_LINE x_visinfo -> depth , NEW_LINE InputOutput , NEW_LINE x_vis , NEW_LINE attribmask , NEW_LINE &v attribs ) 
x_visinfo -> depth == INT_CONST ) 
x_visinfo -> class == PseudoColor ) 
x_win , STRING ) 
x_disp , x_win ) 
doShm ) 
surfcache , SIZEOF ( surfcache ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
x_visinfo -> class == PseudoColor && x_visinfo -> depth == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mouse_grabbed ) 
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
x_disp , &v x_event ) 
x_disp , x_win , STD_EVENT_MASK & ~ PointerMotionMask ) 
count == INT_CONST ) 
doShm ) 
&v readfds ) 
ready > INT_CONST ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
Cmd_Argc ( ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( m = ( INT ) pixel_multiply . value ) != current_pixel_multiply ) 
x_disp ) 
display , root , INT_CONST , INT_CONST , INT_CONST COMMENT ) 
UNSIGNED CHAR *p ) 
x_disp , STRING , INT_CONST ) 
x_disp , win , aHints , aHints , INT_CONST , PropModeReplace , ( UNSIGNED CHAR *p ) & hints , INT_CONST ) 
x_disp , win , CWX | CWY | CWWidth | CWHeight | CWStackMode , &v changes ) 
STRING , VID_Gamma_f ) 
pipe ( render_pipeline ) < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
getpid ( ) ) 
STRING ) 
INT_CONST ) 
! x_disp ) 
x_disp ) 
STRING , x_screen , x_screen_width , x_screen_height ) 
x_disp ) 
verbose ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
FOR ( i = INT_CONST ; i < num_visuals ; i v++ ) 
verbose ) 
pixel_multiply . value < INT_CONST || pixel_multiply . value > INT_CONST ) 
desired_width < w ) 
vid . width < INT_CONST ) 
CPP_COMMENT NEW_LINE desired_width , desired_height , NEW_LINE INT_CONST , COMMENT_NL CPP_COMMENT NEW_LINE x_visinfo -> depth , NEW_LINE InputOutput , NEW_LINE x_vis , NEW_LINE attribmask , NEW_LINE &v attribs ) 
x_visinfo -> depth == INT_CONST ) 
x_visinfo -> class == PseudoColor ) 
x_win , STRING ) 
x_disp , x_win , CreateNullCursor ( x_disp , x_win ) ) 
x_disp , x_win ) 
surfcache , SIZEOF ( surfcache ) ) 
use_mt ) 
display_image ) 
quake_image ) 
state , x_disp , x_win ) 
quake_image ) 
xil_get_memory_storage ( quake_image , &v storage ) == FALSE ) 
d_pzbuffer ) 
PM ( vid . width ) * PM ( vid . height ) * SIZEOF ( *v d_pzbuffer ) ) 
) 
STRING , vid . width , vid . height ) 
state , x_disp , x_win ) 
d_pzbuffer ) 
PM ( vid . width ) * PM ( vid . height ) * SIZEOF ( *v d_pzbuffer ) ) 
x_visinfo -> class == PseudoColor && x_visinfo -> depth == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
display_image ) 
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
x_disp , &v x_event ) 
x_disp , x_win , x_std_event_mask & ~ PointerMotionMask ) 
old_windowed_mouse != _windowed_mouse . value ) 
count_frames ) 
use_mt ) 
config_notify ) 
CheckPixelMultiply ( ) ) 
quake_image , TRUE ) 
config_notify ) 
CheckPixelMultiply ( ) ) 
old ) 
state , vid . width , vid . height , INT_CONST , XIL_BYTE ) 
new ) 
xil_get_memory_storage ( new , &v storage ) == FALSE ) 
new ) 
write ( render_pipeline [ INT_CONST ] , &v image , SIZEOF ( image ) ) != SIZEOF ( image ) ) 
xil_get_memory_storage ( new , &v storage ) == FALSE ) 
new ) 
! X11_active ) 
image , TRUE ) 
x_disp ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
! svgalib_inited || ! vid . direct || ! vga_oktowrite ( ) ) 
vid . aspect > FLOAT_CONST ) 
INT_CONST ) 
VGA_planar ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( k = INT_CONST ; k < reps ; k v++ ) 
FOR ( j = INT_CONST ; j < ( width >> INT_CONST ) ; j v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
! svgalib_inited || ! vid . direct || ! vga_oktowrite ( ) ) 
vid . aspect > FLOAT_CONST ) 
INT_CONST ) 
VGA_planar ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( k = INT_CONST ; k < reps ; k v++ ) 
FOR ( j = INT_CONST ; j < ( width >> INT_CONST ) ; j v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
Cmd_Argc ( ) == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
! ! width ) 
name ) 
FOR ( i = INT_CONST ; i < num_modes ; i v++ ) 
FOR ( i = INT_CONST ; i < num_mice ; i v++ ) 
STRING , O_RDONLY ) 
scantokey [ sc ] , state == KEY_EVENTPRESS ) 
UseKeyboard ) 
! svgalib_inited ) 
vga_getcolors ( ) == INT_CONST ) 
FOR ( i = INT_CONST * INT_CONST ; i ; i v-- ) 
( modenum >= num_modes ) || ( modenum < INT_CONST ) || ! modes [ modenum ] . width ) 
STRING , ( FLOAT ) modenum ) 
VGA_planar ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
d_pzbuffer ) 
vid . width , vid . height ) 
) 
bsize + tsize + zsize , STRING ) 
( byte * ) d_pzbuffer ) 
pixel_t * ) 
vid_surfcache , tsize ) 
current_mode ) 
CHAR *p ) 
svgalib_inited ) 
getenv ( STRING ) ) 
current_mode , palette ) 
UseKeyboard ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( offset = INT_CONST ; offset < total ; offset += INT_CONST ) 
UseMouse ) 
&v mouse_button_commands [ INT_CONST ] ) 
mouse_update ( ) ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
modenum == INT_CONST ) 
__E__O__F__
! lvid -> direct ) 
pcurrentmode -> planar ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( k = INT_CONST ; k < reps ; k v++ ) 
FOR ( j = INT_CONST ; j < ( width >> INT_CONST ) ; j v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
width ) 
! lvid -> direct ) 
pcurrentmode -> planar ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( k = INT_CONST ; k < reps ; k v++ ) 
FOR ( j = INT_CONST ; j < ( width >> INT_CONST ) ; j v++ ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
FOR ( i = INT_CONST ; i < ( NUMVIDMODES - INT_CONST ) ; i v++ ) 
SC_INDEX , MAP_MASK ) 
VGA_pagebase , INT_CONST , VGA_rowbytes * VGA_height ) 
allocnewbuffer ) 
lvid -> rowbytes * ( lvid -> height + INT_CONST ) ) 
*v d_pzbuffer ) 
lvid -> width , lvid -> height ) 
( host_parms . memsize - tbuffersize + SURFCACHE_SIZE_AT_320X200 + NEW_LINE INT_CONST * INT_CONST ) < minimum_memory ) 
d_pzbuffer ) 
) 
VGA_buffersize , STRING ) 
byte * ) 
*v d_pzbuffer ) 
allocnewbuffer ) 
rowbytes * ( height + INT_CONST ) ) 
width , height ) 
( host_parms . memsize - tbuffersize + SURFCACHE_SIZE_AT_320X200 + NEW_LINE INT_CONST * INT_CONST ) < minimum_memory ) 
! VGA_FreeAndAllocVidbuffer ( lvid , pextra -> vidbuffer ) ) 
VOID *p ) 
pextra -> pregset ) 
lvid -> width + INT_CONST ) 
pcurrentmode -> planar ) 
_vid_wait_override . value ) 
vid_surfcache , vid_surfcachesize ) 
lvid ) 
INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
VGA_planar ) 
lvid -> buffer ) 
vid_wait . value == VID_WAIT_VSYNC ) 
__E__O__F__
GetWindowRect ( mainwindow , &v rect ) ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
*v d_pzbuffer ) 
width , height ) 
( host_parms . memsize - tbuffersize + SURFCACHE_SIZE_AT_320X200 + NEW_LINE INT_CONST * INT_CONST ) < minimum_memory ) 
*v d_pzbuffer ) 
width , height ) 
( host_parms . memsize - tbuffersize + SURFCACHE_SIZE_AT_320X200 + NEW_LINE INT_CONST * INT_CONST ) < minimum_memory ) 
d_pzbuffer ) 
) 
tbuffersize , STRING ) 
byte * ) 
block_switch . value && ! WinNT ) 
) 
useDirectDraw ) 
COM_CheckParm ( STRING ) || COM_CheckParm ( STRING ) || COM_CheckParm ( STRING ) ) 
) 
m [ INT_CONST ] != INT_CONST ) 
FOR ( i = INT_CONST ; m [ i ] != INT_CONST ; i v++ ) 
lowstretchedres < lowres ) 
FOR ( i = INT_CONST ; m [ i ] != INT_CONST ; i v++ ) 
VID_Suspend ) 
! MGL_changeDisplayMode ( mode ) ) 
mode ) 
npages > INT_CONST ) 
( dc = MGL_createDisplayDC ( npages ) ) == NULL ) 
forcemem ) 
vid . numpages == INT_CONST ) 
hInstance , MAKEINTRESOURCE ( IDI_ICON2 ) ) 
WNDPROC ) 
modelist [ INT_CONST ] . modedesc , STRING ) 
modelist [ INT_CONST ] . modedesc , STRING ) 
modelist [ INT_CONST ] . modedesc , STRING ) 
NULL ) 
( GetDeviceCaps ( hdc , HORZRES ) > INT_CONST ) && ! COM_CheckParm ( STRING ) ) 
NULL , hdc ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE modelist [ nummodes ] . width , NEW_LINE modelist [ nummodes ] . height ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
nummodes == originalnummodes ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE devmode . dmPelsWidth , devmode . dmPelsHeight ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
lowresmodes ) 
ChangeDisplaySettings ( &v devmode , CDS_TEST | CDS_FULLSCREEN ) == NEW_LINE DISP_CHANGE_SUCCESSFUL ) 
! done ) 
FOR ( j = INT_CONST ; ( j < numlowresmodes ) && ( nummodes < MAX_MODE_LIST ) ; j v++ ) 
modelist [ nummodes ] . modedesc , STRING , NEW_LINE devmode . dmPelsWidth , devmode . dmPelsHeight ) 
FOR ( i = originalnummodes , existingmode = INT_CONST ; i < nummodes ; i v++ ) 
! is_mode0x13 ) 
FOR ( i = originalnummodes , cstretch = INT_CONST ; i < nummodes ; i v++ ) 
FOR ( i = ( nummodes - INT_CONST ) ; i >= originalnummodes ; i v-- ) 
nummodes != originalnummodes ) 
mode == MODE_SETTABLE_WINDOW ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
mode ) 
VID_CheckAdequateMem ( pv -> width , pv -> height ) ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
mode ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
mode ) 
modelist [ mode ] . type == MS_FULLSCREEN ) 
( mode < INT_CONST ) || ( mode >= nummodes ) ) 
mode ) 
windc ) 
mgldc ) 
windc ) 
! windowed_mode_set ) 
modenum ) 
) 
windc ) 
! MGL_changeDisplayMode ( grWINDOWED ) ) 
stretched ) 
&v WindowRect , WindowStyle , FALSE , INT_CONST ) 
! vid_mode_set ) 
mainwindow ) 
! SetWindowPos ( mainwindow , NEW_LINE NULL , NEW_LINE INT_CONST , INT_CONST , NEW_LINE WindowRect . right - WindowRect . left , NEW_LINE WindowRect . bottom - WindowRect . top , NEW_LINE SWP_NOCOPYBITS | SWP_NOZORDER | NEW_LINE SWP_HIDEWINDOW ) ) 
hide_window ) 
mainwindow ) 
( windc = MGL_createWindowedDC ( mainwindow ) ) == NULL ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
mainwindow , WM_SETICON , ( WPARAM ) TRUE , ( LPARAM ) hIcon ) 
) 
mgldc ) 
( mgldc = createDisplayDC ( modelist [ modenum ] . stretched || NEW_LINE ( INT ) vid_nopageflip . value ) ) == NULL ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
mainwindow , WM_SETICON , ( WPARAM ) INT_CONST , ( LPARAM ) hIcon ) 
true , false ) 
) 
windc ) 
! MGL_changeDisplayMode ( grWINDOWED ) ) 
ChangeDisplaySettings ( &v gdevmode , CDS_FULLSCREEN ) != DISP_CHANGE_SUCCESSFUL ) 
NULL ) 
NULL , hdc ) 
&v WindowRect , WindowStyle , FALSE , INT_CONST ) 
mainwindow , GWL_STYLE , WindowStyle | WS_VISIBLE ) 
! SetWindowPos ( mainwindow , NEW_LINE NULL , NEW_LINE INT_CONST , INT_CONST , NEW_LINE WindowRect . right - WindowRect . left , NEW_LINE WindowRect . bottom - WindowRect . top , NEW_LINE SWP_NOCOPYBITS | SWP_NOZORDER ) ) 
mainwindow , HWND_TOPMOST , INT_CONST , INT_CONST , INT_CONST , INT_CONST , NEW_LINE SWP_NOSIZE | SWP_SHOWWINDOW | SWP_DRAWFRAME ) 
mainwindow ) 
( windc = MGL_createWindowedDC ( mainwindow ) ) == NULL ) 
( FLOAT ) vid . height / ( FLOAT ) vid . width ) 
inerror ) 
! VID_SetMode ( original_mode , vid_curpal ) ) 
( modenum >= nummodes ) || ( modenum < INT_CONST ) ) 
! force_mode_set && ( modenum == vid_modenum ) ) 
) 
vid_modenum == NO_MODE ) 
modelist [ modenum ] . type == MS_WINDOWED ) 
) 
) 
! stat ) 
hide_window ) 
GetDeviceCaps ( hdc , RASTERCAPS ) & RC_PALETTE ) 
NULL , hdc ) 
STRING , ( FLOAT ) vid_modenum ) 
! VID_AllocBuffers ( vid . width , vid . height ) ) 
original_mode ) 
vid_surfcache , vid_surfcachesize ) 
PeekMessage ( &v msg , NULL , INT_CONST , INT_CONST , PM_REMOVE ) ) 
INT_CONST ) 
! force_minimized ) 
) 
! msg_suppress_1 ) 
lockcount > INT_CONST ) 
memdc ) 
r_dowarp ) 
lockcount > INT_CONST ) 
! lockcount ) 
dibdc ) 
NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vid_curpal , palette , SIZEOF ( vid_curpal ) ) 
syscolchg ) 
) 
FOR ( i = INT_CONST ; i < lnummodes ; i v++ ) 
na ) 
! vid_testingmode ) 
! vid_testingmode ) 
&v vid_mode ) 
STRING , VID_TestMode_f ) 
COM_CheckParm ( STRING ) ) 
! dibonly ) 
*v ( ( INT *p ) vid . colormap + INT_CONST ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST , ptmp = vid . colormap ; i < ( INT_CONST << ( VID_CBITS + INT_CONST ) ) ; i v++ , ptmp v++ ) 
COM_CheckParm ( STRING ) ) 
hwnd_dialog ) 
vid_default , palette ) 
palette ) 
badmode . modedesc , STRING ) 
vid_initialized ) 
DDActive ) 
! vid_palettized && palette_changed ) 
firstupdate ) 
rects ) 
vid_testingmode ) 
modestate == MS_WINDOWED ) 
) 
! vid_initialized ) 
vid . numpages == INT_CONST ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
width ) 
lockcount > INT_CONST ) 
mgldc , vPage ) 
) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
width ) 
) 
mgldc , aPage ) 
lockcount > INT_CONST ) 
! vid_initialized ) 
vid . numpages == INT_CONST ) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
lockcount > INT_CONST ) 
mgldc , vPage ) 
) 
FOR ( i = INT_CONST ; i < ( height << repshift ) ; i += reps ) 
FOR ( j = INT_CONST ; j < reps ; j v++ ) 
) 
mgldc , aPage ) 
lockcount > INT_CONST ) 
vid_fulldib_on_focus_mode ) 
windc , ActiveApp ) 
vid_initialized ) 
NULL ) 
! ActiveApp && sound_active ) 
! in_mode_set ) 
) 
) 
uMsg ) 
! in_mode_set ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < lnummodes ; i v++ ) 
ptr && ( ( pv -> width != INT_CONST ) || COM_CheckParm ( STRING ) ) ) 
FOR ( j = INT_CONST ; j < vid_wmodes ; j v++ ) 
FOR ( i = INT_CONST ; i < ( vid_wmodes - INT_CONST ) ; i v++ ) 
FOR ( j = ( i + INT_CONST ) ; j < vid_wmodes ; j v++ ) 
INT_CONST * INT_CONST , INT_CONST , STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vid_wmodes > INT_CONST ) 
FOR ( i = INT_CONST ; i < vid_wmodes ; i v++ ) 
vid_testingmode ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
! VID_SetMode ( modedescs [ vid_line ] . modenum , vid_curpal ) ) 
STRING ) 
__E__O__F__
FOR ( r_shift = -v INT_CONST , x = INT_CONST ; x < r_mask ; x = x << INT_CONST ) 
FOR ( g_shift = -v INT_CONST , x = INT_CONST ; x < g_mask ; x = x << INT_CONST ) 
FOR ( b_shift = -v INT_CONST , x = INT_CONST ; x < b_mask ; x = x << INT_CONST ) 
( x < INT_CONST ) || ( y < INT_CONST ) ) 
FOR ( yi = y ; yi < ( y + height ) ; yi v++ ) 
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
( x < INT_CONST ) || ( y < INT_CONST ) ) 
FOR ( yi = y ; yi < ( y + height ) ; yi v++ ) 
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
switch block nest=2, cur block nest=4
x_framebuffer [ INT_CONST ] ) 
d_pzbuffer ) 
*v d_pzbuffer ) 
vid . width , vid . height ) 
X11_buffersize , STRING ) 
pwidth == INT_CONST ) 
x_disp , NEW_LINE x_vis , NEW_LINE x_visinfo -> depth , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE malloc ( mem ) , NEW_LINE vid . width , vid . height , NEW_LINE INT_CONST , NEW_LINE INT_CONST ) 
d_pzbuffer ) 
) 
*v d_pzbuffer ) 
vid . width , vid . height ) 
X11_buffersize , STRING ) 
FOR ( frm = INT_CONST ; frm < INT_CONST ; frm v++ ) 
x_framebuffer [ frm ] ) 
x_disp , NEW_LINE x_vis , NEW_LINE x_visinfo -> depth , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE &v x_shminfo [ frm ] , NEW_LINE vid . width , NEW_LINE vid . height ) 
size < minsize ) 
! XShmAttach ( x_disp , &v x_shminfo [ frm ] ) ) 
INT_CONST ) 
x_disp ) 
x_disp , True ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
( pnum = COM_CheckParm ( STRING ) ) ) 
x_disp , template_mask , &v template , &v num_visuals ) 
FOR ( i = INT_CONST ; i < num_visuals ; i v++ ) 
verbose ) 
CPP_COMMENT NEW_LINE vid . width , vid . height , NEW_LINE INT_CONST , COMMENT_NL CPP_COMMENT NEW_LINE x_visinfo -> depth , NEW_LINE InputOutput , NEW_LINE x_vis , NEW_LINE attribmask , NEW_LINE &v attribs ) 
x_visinfo -> depth == INT_CONST ) 
x_disp , x_win , CreateNullCursor ( x_disp , x_win ) ) 
x_disp , x_win ) 
doShm ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
x_visinfo -> class == PseudoColor && x_visinfo -> depth == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ev , buf , SIZEOF buf , &v keysym , INT_CONST ) 
keysym ) 
&v x_event . xkey ) 
_windowed_mouse . value ) 
x_disp , None , x_win , INT_CONST , INT_CONST , INT_CONST , INT_CONST , NEW_LINE ( vid . width / INT_CONST ) , ( vid . height / INT_CONST ) ) 
x_event . xbutton . button == INT_CONST ) 
x_event . xbutton . button == INT_CONST ) 
doShm && x_event . type == x_shmeventtype ) 
config_notify ) 
x_visinfo -> depth != INT_CONST ) 
doShm ) 
rects ) 
&v readfds ) 
ready > INT_CONST ) 
FOR ( i = INT_CONST ; i < mouse_buttons ; i v++ ) 
( in_strafe . state & INT_CONST ) || ( lookstrafe . value && ( in_mlook . state & INT_CONST ) ) ) 
__E__O__F__
VOID ) 
noclip_anglehack || ! cl . onground || cls . demoplayback ) 
cl . nodrift ) 
delta > INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . cshifts [ CSHIFT_DAMAGE ] . percent < INT_CONST ) 
from , ent -> origin , from ) 
FOR ( j = INT_CONST ; j < NUM_CSHIFTS ; j v++ ) 
v_blend [ INT_CONST ] > INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < NUM_CSHIFTS ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
cl . cshifts [ CSHIFT_DAMAGE ] . percent <= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
pal ) 
) 
FOR ( i = INT_CONST ; i < NUM_CSHIFTS ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
cl . cshifts [ CSHIFT_DAMAGE ] . percent <= INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < NUM_CSHIFTS ; j v++ ) 
pal ) 
yaw - r_refdef . viewangles [ YAW ] ) 
r_refdef . viewangles [ PITCH ] + pitch ) 
cl . time * v_iroll_cycle . value ) 
v_dmg_time > INT_CONST ) 
cl . stats [ STAT_HEALTH ] <= INT_CONST ) 
ent -> origin , r_refdef . vieworg ) 
) 
) 
) 
ent -> origin , r_refdef . vieworg ) 
cl . viewangles , r_refdef . viewangles ) 
angles , forward , right , up ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cl . model_precache [ cl . stats [ STAT_WEAPON ] ] && strcmp ( cl . model_precache [ cl . stats [ STAT_WEAPON ] ] -> name , STRING ) ) 
r_refdef . viewangles , cl . punchangle , r_refdef . viewangles ) 
cl . onground && ent -> origin [ INT_CONST ] - oldz > INT_CONST ) 
chase_active . value ) 
cl . intermission ) 
) 
) 
lcd_x . value ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
crosshair . value ) 
&v lcd_x ) 
&v v_centermove ) 
&v v_iyaw_cycle ) 
&v v_idlescale ) 
&v scr_ofsx ) 
&v v_kicktime ) 
__E__O__F__
FOR ( ; ; ) 
port , *v pregset v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST , lump_p = wad_lumps ; i < wad_numlumps ; i v++ , lump_p v++ ) 
FOR ( lump_p = wad_lumps , i = INT_CONST ; i < wad_numlumps ; i v++ , lump_p v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
vec3_t mins , vec3_t maxs ) 
ent -> v . solid == SOLID_BSP ) 
ent -> v . movetype != MOVETYPE_PUSH ) 
ent -> v . mins , maxs , hullmins ) 
&v anode -> trigger_edicts ) 
depth + INT_CONST , mins2 , maxs2 ) 
FOR ( l = node -> trigger_edicts . next ; l != &v node -> trigger_edicts ; l = next ) 
node -> axis == -v INT_CONST ) 
node -> contents == CONTENTS_SOLID ) 
node -> contents < INT_CONST ) 
ent -> v . absmin , ent -> v . absmax , splitplane ) 
sides & INT_CONST ) 
ent -> area . prev ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( INT ) ent -> v . flags & FL_ITEM ) 
ent -> v . modelindex ) 
ent -> v . solid == SOLID_TRIGGER ) 
touch_triggers ) 
num >= INT_CONST ) 
&v sv . worldmodel -> hulls [ INT_CONST ] , INT_CONST , p ) 
ent -> v . origin , ent -> v . mins , ent -> v . maxs , ent -> v . origin , INT_CONST , ent ) 
num < INT_CONST ) 
num < hull -> firstclipnode || num > hull -> lastclipnode ) 
plane -> type < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! SV_RecursiveHullCheck ( hull , node -> children [ side ] , p1f , midf , p1 , mid , trace ) ) 
SV_HullPointContents ( hull , hull -> firstclipnode , mid ) NEW_LINE == CONTENTS_SOLID ) 
frac < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mid , trace -> endpos ) 
&v trace , INT_CONST , SIZEOF ( trace_t ) ) 
ent , mins , maxs , offset ) 
start , offset , start_l ) 
ent -> v . solid == SOLID_BSP && NEW_LINE ( ent -> v . angles [ INT_CONST ] || ent -> v . angles [ INT_CONST ] || ent -> v . angles [ INT_CONST ] ) ) 
ent -> v . solid == SOLID_BSP && NEW_LINE ( ent -> v . angles [ INT_CONST ] || ent -> v . angles [ INT_CONST ] || ent -> v . angles [ INT_CONST ] ) ) 
FOR ( l = node -> solid_edicts . next ; l != &v node -> solid_edicts ; l = next ) 
clip -> trace . allsolid ) 
node -> axis == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v clip , INT_CONST , SIZEOF ( moveclip_t ) ) 
sv . edicts , start , mins , maxs , end ) 
type == MOVE_MISSILE ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
start , clip . mins2 , clip . maxs2 , end , clip . boxmins , clip . boxmaxs ) 
sv_areanodes , &v clip ) 
__E__O__F__
memblock_t * ) 
memzone_t ) 
! other -> tag ) 
block == mainzone -> rover ) 
other == mainzone -> rover ) 
size , INT_CONST ) 
! tag ) 
size + INT_CONST ) 
extra > MINFRAGMENT ) 
memblock_t * ) 
VOID *p ) 
FOR ( block = zone -> blocklist . next ; ; block = block -> next ) 
FOR ( block = mainzone -> blocklist . next ; ; block = block -> next ) 
FOR ( h = ( hunk_t * ) hunk_base ; ( byte * ) h != hunk_base + hunk_low_used ; ) 
hunk_t * ) 
STRING , hunk_size ) 
INT_CONST ) 
h == endlow ) 
h == endhigh ) 
h -> sentinal != HUNK_SENTINAL ) 
name , h -> name , INT_CONST ) 
next == endlow || next == endhigh || NEW_LINE strncmp ( h -> name , next -> name , INT_CONST ) ) 
STRING ) 
INT size , CHAR *p name ) 
hunk_low_used ) 
h , INT_CONST , size ) 
size < INT_CONST ) 
) 
hunk_size - hunk_low_used - hunk_high_used < size ) 
hunk_high_used ) 
hunk_t * ) 
h , INT_CONST , size ) 
VOID *p ) 
size + INT_CONST ) 
c -> size , true ) 
! nobottom && cache_head . prev == &v cache_head ) 
cache_system_t * ) 
cache_system_t * ) 
hunk_base + hunk_size - hunk_high_used - ( byte * ) new >= size ) 
FOR ( cd = cache_head . next ; cd != &v cache_head ; cd = cd -> next ) 
STRING , Cache_Flush ) 
! c -> data ) 
cs ) 
! c -> data ) 
cs ) 
c -> data ) 
INT_CONST ) 
) 
__E__O__F__
item ) 
FOR ( i = INT_CONST ; i < item -> w ; i v++ ) 
kbhit ( ) ) 
INT_CONST ) 
) 
) 
INT_CONST ) 
&v idkeyselitems [ LOOKD ] ) 
&v idkeyselitems [ FLYD ] ) 
&v idkeyselitems [ INVL ] ) 
INT_CONST , INT_CONST ) 
INT_CONST ) 
field ) 
) 
) 
kbhit ( ) ) 
) 
) 
INT_CONST ) 
INT_CONST ) 
field ) 
) 
) 
INT_CONST ) 
) 
) 
INT_CONST ) 
INT_CONST ) 
field ) 
) 
) 
INT_CONST ) 
) 
) 
) 
__E__O__F__
) 
newc . control == C_MOUSE ) 
field ) 
__E__O__F__
puplist [ i ] ) 
__E__O__F__
INT_CONST ) 
c < INT_CONST || c > INT_CONST ) 
) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < MAC_MAX ; i v++ ) 
INT_CONST ) 
) 
__E__O__F__
newc . m . port == -v INT_CONST ) 
newc . control != C_KEY ) 
newc . control == C_JOYSTICK ) 
FOR ( i = INT_CONST ; i < numdefaults ; i v++ ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
defaults ) 
FOR ( i = INT_CONST ; i < numdefaults ; i v++ ) 
FOR ( i = INT_CONST ; i < numdefaults ; i v++ ) 
__E__O__F__
keydesc , INT_CONST , SIZEOF ( keydesc ) ) 
FOR ( loop = INT_CONST ; loop < INT_CONST ; loop v++ ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
) 
INT_CONST ) 
) 
INT_CONST , &v r , &v r ) 
) 
&v newc , INT_CONST , SIZEOF ( DMXINFO ) ) 
) 
&v title ) 
! M_LoadDefaults ( ) ) 
) 
) 
INT_CONST ) 
nomonsters ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
INT_CONST ) 
__E__O__F__
INT_CONST , item -> y * INT_CONST + ( item -> x - INT_CONST ) * INT_CONST ) 
INT_CONST , item -> y * INT_CONST , FP_SEG ( &v buffer ) , FP_OFF ( &v buffer ) , INT_CONST ) 
FOR ( i = INT_CONST ; i < item -> w ; i v++ ) 
current ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numInList - INT_CONST ; i v++ ) 
FOR ( j = i + INT_CONST ; j < numInList ; j v++ ) 
FOR ( i = start ; i < max ; i v++ ) 
FOR ( j = INT_CONST ; j < len ; j v++ ) 
INT_CONST , y v++ ) 
FOR ( j = INT_CONST ; j < len ; j v++ ) 
! ParseMODOOMList ( ) ) 
FOR ( i = INT_CONST ; i < numInList ; i v++ ) 
FOR ( i = INT_CONST ; i < strlen ( phonelist [ index ] . number ) ; i v++ ) 
( hliteY < numInList - INT_CONST ) ) ) 
) 
) 
&v mskillg ) 
&v mepig ) 
&v mdeathg ) 
&v mcomportg ) 
&v mcomtypeg ) 
minfo . phonenum , STRING ) 
INT_CONST ) 
ChooseOpponentInList ( ) ) 
string [ argcount ] , STRING , level >> INT_CONST ) 
string [ argcount ] , STRING , level & INT_CONST ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
STRING ) 
) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
&v phonenum , tempstring , INT_CONST ) 
) 
__E__O__F__
) 
savenames , INT_CONST , INT_CONST * INT_CONST ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v modscomg ) 
minfo . phonenum , STRING ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
__E__O__F__
) 
card -> midiport ) 
INT_CONST ) 
field ) 
) 
) 
card -> port ) 
INT_CONST ) 
field ) 
) 
newc . m . card ) 
) 
INT_CONST ) 
field ) 
) 
) 
newc . m . card ) 
__E__O__F__
) 
INT_CONST ) 
&v netpg ) 
&v netskillg ) 
&v netepig ) 
&v netdeathg ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
STRING ) 
info . networkSocket > INT_CONST ) 
string [ argcount ] , STRING , netinfo . networkSocket ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
info . networkSocket , tempstring , INT_CONST ) 
) 
__E__O__F__
INT_CONST , y * INT_CONST + x * INT_CONST + INT_CONST ) 
FOR ( i = INT_CONST ; i < length ; i v++ ) 
STRING , STRING ) 
FOR ( i = INT_CONST ; i < numModems - INT_CONST ; i v++ ) 
FOR ( j = i + INT_CONST ; j < numModems ; j v++ ) 
max > numModems ) 
FOR ( i = start ; i < max ; i v++ ) 
FOR ( j = INT_CONST ; j < len ; j v++ ) 
! ParseMODOOM ( ) ) 
INT_CONST ) 
( hliteY < numModems - INT_CONST ) ) ) 
) 
INT_CONST ) 
) 
__E__O__F__
) 
savenames , INT_CONST , INT_CONST * INT_CONST ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v netsaveitems [ NETS_SOCKET ] ) 
&v netsdeathg ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
&v netsaveitems [ NETS_SOCKET ] ) 
) 
) 
INT_CONST ) 
) 
__E__O__F__
) 
&v sskillg ) 
&v sepig ) 
&v sdeathg ) 
&v scomg ) 
INT_CONST ) 
string [ argcount ] , STRING , level ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
) 
__E__O__F__
( window = IWD_OpenWindow ( NULL , wstr ) ) == NULL ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( ; ; ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( ; ; ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
__E__O__F__
__E__O__F__
) 
savenames , INT_CONST , INT_CONST * INT_CONST ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v serscomg ) 
&v sersdeathg ) 
INT_CONST ) 
saveslot < INT_CONST ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
__E__O__F__
rg -> master ) 
FOR ( i = INT_CONST ; i < rg -> amount ; i v++ ) 
( pup -> x + pup -> width + INT_CONST > INT_CONST ) || NEW_LINE ( pup -> y + pup -> height > INT_CONST ) ) 
FOR ( i = pup -> y + INT_CONST ; i < pup -> y + pup -> height + INT_CONST ; i v++ ) 
INT_CONST , ( pup -> y + pup -> height ) * INT_CONST + ( pup -> x + INT_CONST ) * INT_CONST ) 
FOR ( i = INT_CONST ; i < pup -> width ; i v++ ) 
pup ) 
INT_CONST ) 
! --v w ) 
FOR ( i = INT_CONST ; i < times ; i v++ ) 
) 
) 
__E__O__F__
newc . d . card ) 
) 
INT_CONST ) 
field ) 
) 
card -> dma ) 
) 
INT_CONST ) 
field ) 
) 
card -> irq > INT_CONST ) 
) 
INT_CONST ) 
field ) 
) 
) 
newc . numdig ) 
INT_CONST ) 
field ) 
) 
) 
newc . d . card ) 
__E__O__F__
) 
&v cwarpitems [ W_RESPAWN ] , respawn ) 
INT_CONST ) 
) 
field ) 
__E__O__F__
FOR ( p = thread -> pstack_head . next ; p ; p = p -> next ) 
FOR ( i = INT_CONST ; i < source -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < pass -> numpoints ; j v++ ) 
FOR ( k = INT_CONST ; k < source -> numpoints ; k v++ ) 
FOR ( k = INT_CONST ; k < pass -> numpoints ; k v++ ) 
d > ON_EPSILON ) 
! ( thread -> leafvis [ leafnum >> INT_CONST ] & ( INT_CONST << ( leafnum & INT_CONST ) ) ) ) 
FOR ( i = INT_CONST ; i < leaf -> numportals ; i v++ ) 
p -> status == stat_done ) 
FOR ( j = INT_CONST ; j < bitlongs ; j v++ ) 
p -> status != stat_working ) 
&v data , INT_CONST , SIZEOF ( data ) ) 
FOR ( i = INT_CONST ; i < leaf -> numportals ; i v++ ) 
FOR ( i = INT_CONST , p = portals ; i < numportals * INT_CONST ; i v++ , p v++ ) 
FOR ( j = INT_CONST , tp = portals ; j < numportals * INT_CONST ; j v++ , tp v++ ) 
FOR ( k = INT_CONST ; k < w -> numpoints ; k v++ ) 
FOR ( k = INT_CONST ; k < w -> numpoints ; k v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < portalleafs ; i v++ ) 
FOR ( j = INT_CONST ; j < NUM_AMBIENTS ; j v++ ) 
FOR ( j = INT_CONST ; j < portalleafs ; j v++ ) 
FOR ( k = INT_CONST ; k < hit -> nummarksurfaces ; k v++ ) 
! Q_strncasecmp ( miptex -> name , STRING , INT_CONST ) ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( j = INT_CONST ; j < NUM_AMBIENTS ; j v++ ) 
__E__O__F__
w -> points [ INT_CONST ] , w -> points [ INT_CONST ] , v1 ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < l -> numportals ; i v++ ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST , tp = portals ; j < numportals * INT_CONST ; j v++ , tp v++ ) 
p ) 
FOR ( j = INT_CONST ; j < visrow ; j v++ ) 
FOR ( j v++ ; j < visrow ; j v++ ) 
FOR ( i = INT_CONST ; i < leaf -> numportals ; i v++ ) 
FOR ( j = INT_CONST ; j < bitbytes ; j v++ ) 
outbuffer [ leafnum >> INT_CONST ] & ( INT_CONST << ( leafnum & INT_CONST ) ) ) 
FOR ( i = INT_CONST ; i < portalleafs ; i v++ ) 
portalleafs + INT_CONST ) 
dest , compressed , i ) 
fastvis ) 
FOR ( i = INT_CONST ; i < numportals * INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numthreads ; i v++ ) 
FOR ( i = INT_CONST ; i < numthreads ; i v++ ) 
pthread_mutex_destroy ( my_mutex ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < portalleafs ; i v++ ) 
fabs ( p1 -> dist - p2 -> dist ) > FLOAT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < source -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < pass -> numpoints ; j v++ ) 
FOR ( k = INT_CONST ; k < source -> numpoints ; k v++ ) 
FOR ( k = INT_CONST ; k < pass -> numpoints ; k v++ ) 
d > ON_EPSILON ) 
STRING ) 
FOR ( i = INT_CONST ; i < portalleafs ; i v++ ) 
FOR ( j = INT_CONST ; j < l -> numportals ; j v++ ) 
FOR ( k = INT_CONST ; k < l -> numportals ; k v++ ) 
STRING , count2 , count ) 
fscanf ( f , STRING , magic , &v portalleafs , &v numportals ) != INT_CONST ) 
( portalleafs + INT_CONST ) & ~ INT_CONST ) 
INT_CONST * numportals * SIZEOF ( portal_t ) ) 
( portalleafs + INT_CONST ) / INT_CONST ) 
FOR ( i = INT_CONST , p = portals ; i < numportals ; i v++ ) 
FOR ( j = INT_CONST ; j < numpoints ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
l -> numportals == MAX_PORTALS_ON_LEAF ) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
i != argc - INT_CONST ) 
source ) 
) 
STRING , c_chains ) 
) 
__E__O__F__
name ) 
STRING , expanded ) 
filename , STRING , destfile , lumpname ) 
VOID ) 
FOR ( size = INT_CONST ; size < SIZEOF ( lumpname ) ; size v++ ) 
FOR ( cmd = INT_CONST ; commands [ cmd ] . name ; cmd v++ ) 
TYP_LUMPY + cmd , INT_CONST ) 
STRING , basename ) 
destfile , ExpandPath ( basename ) ) 
script , basename ) 
! strcmp ( argv [ INT_CONST ] , STRING ) ) 
FOR ( ; i < argc ; i v++ ) 
__E__O__F__
false ) 
FOR ( y = yl ; y < yh ; y v++ ) 
FOR ( x = xl ; x < xh ; x v++ ) 
TokenAvailable ( ) ) 
end - start + INT_CONST ) 
false ) 
xh < xl || yh < yl || xl < INT_CONST || yl < INT_CONST || xh > INT_CONST || yh > INT_CONST ) 
qpic_t * ) 
byte * ) 
FOR ( y = yl ; y <= yh ; y v++ ) 
FOR ( x = xl ; x <= xh ; x v++ ) 
( INT ) r * r + ( INT ) g * g + ( INT ) b * b ) 
FOR ( i = start ; i <= stop ; i v++ ) 
FOR ( l = INT_CONST ; l < INT_CONST ; l v++ ) 
FOR ( l = INT_CONST ; l < levels ; l v++ ) 
FOR ( c = INT_CONST ; c < INT_CONST - brights ; c v++ ) 
FOR ( ; c < INT_CONST ; c v++ ) 
FOR ( l = INT_CONST ; l < levels ; l v++ ) 
FOR ( c = INT_CONST ; c < INT_CONST - brights ; c v++ ) 
FOR ( ; c < INT_CONST ; c v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
fullbright ) 
FOR ( ; i < e ; i v++ ) 
! fullbright ) 
INT ) 
( w & INT_CONST ) || ( h & INT_CONST ) ) 
miptex_t * ) 
lump_p - ( byte * ) qtex ) 
FOR ( y = yl ; y < yh ; y v++ ) 
FOR ( x = xl ; x < xh ; x v++ ) 
FOR ( miplevel = INT_CONST ; miplevel < INT_CONST ; miplevel v++ ) 
FOR ( y = INT_CONST ; y < h ; y += mipstep ) 
FOR ( x = INT_CONST ; x < w ; x += mipstep ) 
FOR ( yy = INT_CONST ; yy < mipstep ; yy v++ ) 
FOR ( xx = INT_CONST ; xx < mipstep ; xx v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numlighttargets ; i v++ ) 
FOR ( i = INT_CONST ; i < num_entities ; i v++ ) 
FOR ( j = INT_CONST ; j < num_entities ; j v++ ) 
INT_CONST ) 
data ) 
STRING ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! strncmp ( entity -> classname , STRING , INT_CONST ) && ! entity -> light ) 
STRING , num_entities ) 
) 
FOR ( ep = ent -> epairs ; ep ; ep = ep -> next ) 
FOR ( ep = ent -> epairs ; ep ; ep = ep -> next ) 
FOR ( i = INT_CONST ; i < num_entities ; i v++ ) 
FOR ( ep = entities [ i ] . epairs ; ep ; ep = ep -> next ) 
__E__O__F__
LightThread ) 
STRING , lightdatasize ) 
STRING ) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
i != argc - INT_CONST ) 
) 
source , argv [ i ] ) 
) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
texnormal , l -> facenormal ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
lightinfo_t * l ) 
FOR ( i = INT_CONST ; i < s -> numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
l -> exactmaxs [ INT_CONST ] + l -> exactmins [ INT_CONST ] ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
l -> texsize [ INT_CONST ] + INT_CONST ) 
FOR ( t = INT_CONST ; t < h ; t v++ ) 
FOR ( s = INT_CONST ; s < w ; s v++ , surf += INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
entity_t * light , lightinfo_t * l ) 
dist <= INT_CONST ) 
light -> targetent ) 
FOR ( mapnum = INT_CONST ; mapnum < l -> numlightstyles ; mapnum v++ ) 
mapnum == MAXLIGHTMAPS ) 
FOR ( i = INT_CONST ; i < size ; i v++ ) 
FOR ( c = INT_CONST ; c < l -> numsurfpt ; c v++ , surf += INT_CONST ) 
FOR ( i = INT_CONST ; i < l -> numlightstyles ; i v++ ) 
FOR ( j = INT_CONST ; j < l -> numsurfpt ; j v++ ) 
FOR ( j = INT_CONST ; j < l -> numsurfpt ; j v++ ) 
FOR ( j = INT_CONST ; j < MAXLIGHTMAPS ; j v++ ) 
&v l , INT_CONST , SIZEOF ( l ) ) 
dplanes [ f -> planenum ] . normal , l . facenormal ) 
&v l ) 
l . texsize [ INT_CONST ] + INT_CONST ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < num_entities ; i v++ ) 
&v l ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
lightmapsize ) 
l . texsize [ INT_CONST ] + INT_CONST ) 
FOR ( i = INT_CONST ; i < l . numlightstyles ; i v++ ) 
FOR ( t = INT_CONST ; t <= l . texsize [ INT_CONST ] ; t v++ ) 
FOR ( s = INT_CONST ; s <= l . texsize [ INT_CONST ] ; s v++ , c v++ ) 
t * INT_CONST + INT_CONST ) 
__E__O__F__
SIZEOF ( *v my_mutex ) ) 
FOR ( i = INT_CONST ; i < numthreads ; i v++ ) 
FOR ( i = INT_CONST ; i < numthreads ; i v++ ) 
__E__O__F__
plane -> normal , t -> normal ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
tnode -> type ) 
__E__O__F__
ftell ( packhandle ) ) 
remaining ) 
in ) 
destfile , STRING , gamedir , blocknum ) 
FOR ( i = INT_CONST ; i < numsounds ; i v++ ) 
FOR ( i = INT_CONST ; i < nummodels ; i v++ ) 
FOR ( i = INT_CONST ; i < numfiles ; i v++ ) 
&v crc ) 
FOR ( i = INT_CONST ; i < dirlen ; i v++ ) 
FOR ( i = INT_CONST ; i < nummodels ; i v++ ) 
STRING ) 
f , STRING , &v numsounds ) 
FOR ( i = INT_CONST ; i < numsounds ; i v++ ) 
FOR ( i = INT_CONST ; i < nummodels ; i v++ ) 
FOR ( i = INT_CONST ; i < numfiles ; i v++ ) 
STRING , numsounds ) 
STRING ) 
) 
! strcmp ( argv [ INT_CONST ] , STRING ) ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numfaces ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( u = -v FLOAT_CONST ; u <= FLOAT_CONST ; u += FLOAT_CONST ) 
FOR ( v = -v FLOAT_CONST ; v <= FLOAT_CONST ; v += FLOAT_CONST ) 
f -> verts [ INT_CONST ] , f -> verts [ INT_CONST ] , v1 ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
filename , argv [ INT_CONST ] ) 
) 
FOR ( i = INT_CONST ; i < numfaces ; i v++ ) 
STRING , filename ) 
__E__O__F__
vec3_origin , adjust ) 
aframe . name , frames [ framenum ] . name ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < model . numverts ; j v++ ) 
tarray [ j ] . lightnormalindex > NUMVERTEXNORMALS ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
modelouthandle , &v aframe , SIZEOF ( aframe ) ) 
modelouthandle , &v tarray [ INT_CONST ] , NEW_LINE model . numverts * SIZEOF ( tarray [ INT_CONST ] ) ) 
numframes ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < numframes ; i v++ ) 
FOR ( j = INT_CONST ; j < model . numverts ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
modelouthandle , &v dagroup , SIZEOF ( dagroup ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
dist [ INT_CONST ] * dist [ INT_CONST ] + NEW_LINE dist [ INT_CONST ] * dist [ INT_CONST ] + NEW_LINE dist [ INT_CONST ] * dist [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
model . flags ) 
modelouthandle , &v modeltemp , SIZEOF ( model ) ) 
FOR ( i = INT_CONST ; i < model . numskins ; i v++ ) 
FOR ( i = INT_CONST ; i < model . numverts ; i v++ ) 
modelouthandle , stverts , model . numverts * SIZEOF ( stverts [ INT_CONST ] ) ) 
FOR ( i = INT_CONST ; i < model . numtris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < model . numframes ; i v++ ) 
FOR ( j = INT_CONST ; j < numframes ; j v++ ) 
FOR ( j = INT_CONST ; j < numframes ; j v++ ) 
modelouthandle ) 
STRING , ( INT ) ftell ( modelouthandle ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < model . numverts ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STRING , width , height ) 
width * scale >= INT_CONST ) 
FOR ( i = INT_CONST ; i < model . numtris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
skinwidth + INT_CONST ) 
STRING , NEW_LINE model . skinwidth , skinwidth , model . skinheight ) 
false ) 
file1 , STRING , cdpartial , token ) 
file1 , STRING , cddir , token ) 
FOR ( i = INT_CONST ; i < model . numtris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < model . numverts ; k v++ ) 
ptri [ i ] . verts [ j ] , baseverts [ model . numverts ] ) 
STRING , model . numverts ) 
) 
false ) 
file1 , STRING , cddir , token ) 
file1 , &v pskinbitmap , &v ppal ) 
model . skinwidth * model . skinheight ) 
FOR ( i = INT_CONST ; i < model . skinheight ; i v++ ) 
skincount > MAXSKINS ) 
file1 , STRING , cdpartial , frame ) 
file1 , STRING , cddir , frame ) 
file1 , &v ptri , &v numtris ) 
numtris != model . numtris ) 
FOR ( i = INT_CONST ; i < model . numverts ; i v++ ) 
FOR ( i = INT_CONST ; i < numtris ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( i = INT_CONST ; i < model . numverts ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < vnorms [ i ] . numnormals ; k v++ ) 
FOR ( j = INT_CONST ; j < NUMVERTEXNORMALS ; j v++ ) 
framecount >= MAXFRAMES ) 
skincount >= MAXFRAMES ) 
INT_CONST ) 
skins [ groupskin ] . numgroupskins == INT_CONST ) 
framecount >= MAXFRAMES ) 
INT_CONST ) 
frames [ groupframe ] . numgroupframes == INT_CONST ) 
false ) 
false ) 
false ) 
false ) 
false ) 
argc != INT_CONST && argc != INT_CONST ) 
path , argv [ i ] ) 
&v model , INT_CONST , SIZEOF ( model ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
) 
__E__O__F__
dspriteframe_t * ) 
spriteouthandle , &v frametemp , SIZEOF ( frametemp ) ) 
( ( framesmaxs [ INT_CONST ] >> INT_CONST ) * NEW_LINE ( framesmaxs [ INT_CONST ] >> INT_CONST ) ) + NEW_LINE ( ( framesmaxs [ INT_CONST ] >> INT_CONST ) * NEW_LINE ( framesmaxs [ INT_CONST ] >> INT_CONST ) ) ) 
spriteouthandle , &v spritetemp , SIZEOF ( spritetemp ) ) 
FOR ( i = INT_CONST ; i < sprite . numframes ; i v++ ) 
FOR ( j = INT_CONST ; j < numframes ; j v++ ) 
FOR ( j = INT_CONST ; j < numframes ; j v++ ) 
stdout ) 
( xl & INT_CONST ) || ( yl & INT_CONST ) || ( w & INT_CONST ) || ( h & INT_CONST ) ) 
dspriteframe_t * ) 
TokenAvailable ( ) ) 
w > framesmaxs [ INT_CONST ] ) 
FOR ( y = yl ; y < yh ; y v++ ) 
FOR ( x = xl ; x < xh ; x v++ ) 
framecount >= MAX_FRAMES ) 
INT_CONST ) 
frames [ groupframe ] . numgroupframes == INT_CONST ) 
MAX_BUFFER_SIZE * INT_CONST ) 
! lumpbuffer ) 
sprite . numframes == INT_CONST ) 
argc != INT_CONST && argc != INT_CONST ) 
argv [ i ] ) 
argv [ i ] ) 
__E__O__F__
argc == INT_CONST ) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < f -> numpoints ; j v++ ) 
FOR ( j = INT_CONST ; j < NUM_HULLS ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
normal [ INT_CONST ] == FLOAT_CONST ) 
dp -> normal [ INT_CONST ] == FLOAT_CONST ) 
dp -> normal [ INT_CONST ] ) 
ax >= ay && ax >= az ) 
FOR ( i = INT_CONST ; i < numbrushplanes ; i v++ , dp v++ ) 
numbrushplanes == MAX_MAP_PLANES ) 
FOR ( i = INT_CONST ; i < numbrushplanes ; i v++ , dp v++ ) 
numbrushplanes == MAX_MAP_PLANES ) 
FOR ( i = INT_CONST ; i < numbrushfaces ; i v++ ) 
FOR ( j = INT_CONST ; j < numbrushfaces && w ; j v++ ) 
FOR ( j = INT_CONST ; j < w -> numpoints ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( i = INT_CONST ; i < numbrushfaces ; i v++ ) 
FOR ( i = INT_CONST ; i < numbrushfaces ; i v++ ) 
FOR ( i = INT_CONST ; i < c ; i v++ , corner += INT_CONST ) 
counts [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < num_hull_points ; i v++ ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
FOR ( y = INT_CONST ; y < INT_CONST ; y v++ ) 
FOR ( z = INT_CONST ; z < INT_CONST ; z v++ ) 
FOR ( i = INT_CONST ; i < num_hull_edges ; i v++ ) 
FOR ( a = INT_CONST ; a < INT_CONST ; a v++ ) 
FOR ( d = INT_CONST ; d <= INT_CONST ; d v++ ) 
FOR ( e = INT_CONST ; e <= INT_CONST ; e v++ ) 
INT hullnum ) 
FOR ( f = brush_faces ; f ; f = f -> next ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < numbrushfaces ; i v++ ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
FOR ( s = -v INT_CONST ; s <= INT_CONST ; s += INT_CONST ) 
FOR ( f = brush_faces ; f ; f = f -> next ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
! Q_strcasecmp ( name , STRING ) && hullnum == INT_CONST ) 
FOR ( f = mb -> faces ; f ; f = f -> next ) 
hullnum ) 
) 
FOR ( b = bs -> brushes ; b ; b = b -> next ) 
FOR ( f = b -> faces ; f ; f = f -> next ) 
STRING ) 
FOR ( mbr = ent -> brushes ; mbr ; mbr = mbr -> next ) 
FOR ( b = water ; b ; b = next ) 
bset ) 
__E__O__F__
FOR ( ; list ; list = list -> next ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
newf -> numpoints > MAXEDGES || new2 -> numpoints > MAXEDGES ) 
FOR ( f = inside ; f ; f = next ) 
FOR ( f = outside ; f ; f = next ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
FOR ( f = inside ; f ; f = next ) 
FOR ( i = INT_CONST ; i < numbrushplanes ; i v++ , f v++ ) 
FOR ( count = s -> faces ; count ; count = count -> next ) 
FOR ( f = b -> faces ; f ; f = f -> next ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
STRING ) 
validfaces , INT_CONST , SIZEOF ( validfaces ) ) 
FOR ( b1 = bs -> brushes ; b1 ; b1 = b1 -> next ) 
b1 ) 
FOR ( b2 = bs -> brushes ; b2 ; b2 = b2 -> next ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( f = b2 -> faces ; f ; f = f -> next ) 
! csgfaces ) 
__E__O__F__
FOR ( i = INT_CONST ; i < nummiptex ; i v++ ) 
FOR ( i = INT_CONST ; i < numtexinfo ; i v++ , tex v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
numtexinfo == MAX_MAP_TEXINFO ) 
unget ) 
*v script_p <= INT_CONST ) 
script_p [ INT_CONST ] == CHAR_CONST && script_p [ INT_CONST ] == CHAR_CONST ) 
*v script_p == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
&v tx , INT_CONST , SIZEOF ( tx ) ) 
FOR ( f2 = b -> faces ; f2 ; f2 = f2 -> next ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
&v f -> plane , vecs [ INT_CONST ] , vecs [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( ep = ent -> epairs ; ep ; ep = ep -> next ) 
FOR ( ep = ent -> epairs ; ep ; ep = ep -> next ) 
FOR ( ep = ent -> epairs ; ep ; ep = ep -> next ) 
ent , key ) 
FOR ( i = INT_CONST ; i < num_entities ; i v++ ) 
FOR ( ep = entities [ i ] . epairs ; ep ; ep = ep -> next ) 
__E__O__F__
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
face_t * f1 , face_t * f2 ) 
FOR ( i = INT_CONST ; i < f1 -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < f2 -> numpoints ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
j + f2 -> numpoints - INT_CONST ) 
f1 -> numpoints + f2 -> numpoints > MAXEDGES ) 
f1 ) 
FOR ( k = ( i + INT_CONST ) % f1 -> numpoints ; k != i ; k = ( k + INT_CONST ) % f1 -> numpoints ) 
FOR ( l = ( j + INT_CONST ) % f2 -> numpoints ; l != j ; l = ( l + INT_CONST ) % f2 -> numpoints ) 
FOR ( f = list ; f ; f = f -> next ) 
FOR ( ; merged ; merged = next ) 
FOR ( f1 = plane -> faces ; f1 ; f1 = next ) 
merged ) 
FOR ( surf = surfhead ; surf ; surf = surf -> next ) 
FOR ( f = surf -> faces ; f ; f = f -> next ) 
__E__O__F__
__E__O__F__
hullnum ) 
FOR ( i = INT_CONST ; i < n2 -> winding -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < n1 -> winding -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
l -> contents == CONTENTS_SOLID || l -> contents == CONTENTS_SKY ) 
FOR ( p = l -> portals ; p ; ) 
FOR ( fp = node -> markfaces ; *v fp ; fp v++ ) 
*v fp ) 
FOR ( i = INT_CONST ; i < num_entities ; i v++ ) 
! inside ) 
outside_node . portals -> nodes [ INT_CONST ] == &v outside_node ) 
! hullnum ) 
RecursiveFillOutside ( outside_node . portals -> nodes [ s ] , false ) ) 
node ) 
__E__O__F__
INT_CONST ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
w -> points [ INT_CONST ] , w -> points [ INT_CONST ] , v1 ) 
FOR ( p = node -> portals ; p ; p = p -> next [ side ] ) 
p -> winding , &v plane2 ) 
FOR ( p2 = node -> portals ; p2 ; p2 = p2 -> next [ side2 ] ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
node -> contents ) 
) 
FOR ( p = node -> portals ; p ; p = p -> next [ side ] ) 
new_portal , f , b ) 
FOR ( p = node -> portals ; p ; p = next_portal ) 
headnode ) 
FOR ( p = node -> portals ; p ; p = nextp ) 
! node -> contents ) 
FOR ( p = node -> portals ; p ; ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
! node -> contents ) 
node -> children [ INT_CONST ] ) 
FOR ( p = node -> portals ; p ; ) 
STRING , portfilename ) 
__E__O__F__
! verbose ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
maxpts ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! ent -> brushes ) 
ent , hullnum ) 
hullnum != INT_CONST ) 
surfs , entnum == INT_CONST ) 
entnum == INT_CONST && ! nofill ) 
FOR ( entnum = INT_CONST ; entnum < num_entities ; entnum v++ ) 
STRING ) 
hullfilename ) 
STRING ) 
hullfilename , STRING ) 
FOR ( i = INT_CONST ; i < nummodels ; i v++ ) 
FOR ( i = INT_CONST ; i < numclipnodes ; i v++ ) 
hullfilename ) 
hullfilename , STRING ) 
FOR ( i = INT_CONST ; i < n ; i v++ ) 
FOR ( i = INT_CONST ; i < n ; i v++ ) 
VOID ) 
FOR ( entnum = INT_CONST ; entnum < num_entities ; entnum v++ ) 
hullnum ) 
usehulls ) 
noclip ) 
STRING ) 
hullnum ) 
STRING ) 
) 
hullfilename , bspfilename1 ) 
portfilename , bspfilename1 ) 
! onlyents ) 
sourcebase ) 
) 
) 
INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < argc ; i v++ ) 
sourcename , argv [ i ] ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
f2 -> planenum != f -> planenum NEW_LINE || f2 -> planeside != f -> planeside NEW_LINE || f2 -> texturenum != f -> texturenum ) 
STRING ) 
! ( texinfo [ f -> texturenum ] . flags & TEX_SPECIAL ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < df -> numedges ; i v++ ) 
FOR ( i = firstmodelface ; i < numfaces ; i v++ ) 
FOR ( j = INT_CONST ; j < df -> numedges ; j v++ ) 
FOR ( i = firstmodelface ; i < numfaces ; i v++ ) 
FOR ( j = INT_CONST ; j < df -> numedges ; j v++ ) 
dvertexes [ ed -> v [ INT_CONST ] ] . point , dvertexes [ ed -> v [ INT_CONST ] ] . point , v1 ) 
FOR ( i = firstmodelface ; i < numfaces ; i v++ ) 
FOR ( j = INT_CONST ; j < df -> numedges ; j v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j v++ ; j < df -> numedges ; j v++ ) 
FOR ( i = INT_CONST ; i < numedges ; i v++ ) 
FOR ( i = firstmodeledge ; i < numedges ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < numvertexes ; i v++ ) 
STRING , c2 ) 
FOR ( i = firstmodelface ; i < numfaces ; i v++ ) 
FOR ( i = firstmodeledge ; i < numedges ; i v++ ) 
node -> planenum == PLANENUM_LEAF ) 
FOR ( f = node -> faces ; f ; f = f -> next ) 
FOR ( i = INT_CONST ; i < MAXLIGHTMAPS ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
node -> children [ INT_CONST ] ) 
__E__O__F__
split -> type < INT_CONST ) 
FOR ( i = INT_CONST , p = in -> pts [ INT_CONST ] + split -> type ; i < in -> numpoints ; i v++ , p += INT_CONST ) 
FOR ( i = INT_CONST , p = in -> pts [ INT_CONST ] ; i < in -> numpoints ; i v++ , p += INT_CONST ) 
FOR ( p = surfaces ; p ; p = p -> next ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
! bestsurface ) 
FOR ( p = surfaces ; p ; p = p -> next ) 
FOR ( p = surfaces ; p ; p = p -> next ) 
! usefloors && plane -> normal [ INT_CONST ] == INT_CONST ) 
FOR ( p2 = surfaces ; p2 ; p2 = p2 -> next ) 
FOR ( f = p2 -> faces ; f ; f = f -> next ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( p = surfaces ; p ; p = p -> next ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( p = surfaces ; p ; p = p -> next ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
surfaces , mins , maxs ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( f = surf -> faces ; f ; f = f -> next ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
VectorCompare ( inplane -> normal , split -> normal ) ) 
FOR ( ; facet ; facet = next ) 
FOR ( facet = in -> faces ; facet ; facet = next ) 
frontlist == NULL ) 
backlist == NULL ) 
) 
news ) 
split -> type > INT_CONST ) 
FOR ( surf = planelist ; surf ; surf = surf -> next ) 
FOR ( f = surf -> faces ; f ; f = f -> next ) 
! leafnode -> contents ) 
STRING ) 
SIZEOF ( face_t * ) * ( count + INT_CONST ) ) 
FOR ( surf = planelist ; surf ; surf = pnext ) 
FOR ( f = surf -> faces ; f ; f = next ) 
FOR ( f = surface -> faces ; f ; f = f -> next ) 
surfaces , node ) 
node , splitplane ) 
FOR ( p = surfaces ; p ; p = next ) 
frontlist , node -> children [ INT_CONST ] ) 
FOR ( f = surf -> faces ; f ; f = f -> next ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
surfhead , headnode ) 
STRING , splitnodes ) 
__E__O__F__
tex -> flags & TEX_SPECIAL ) 
FOR ( axis = INT_CONST ; axis < INT_CONST ; axis v++ ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
tex -> vecs [ axis ] , plane . normal ) 
STRING ) 
FOR ( surf = surfhead ; surf ; surf = surf -> next ) 
! f ) 
STRING , subdivides ) 
node_t * node ) 
FOR ( f = node -> faces ; f ; f = next ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
volume / NUM_HASH ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( hv = hashverts [ h ] ; hv ; hv = hv -> next ) 
FOR ( i = INT_CONST ; i < hv -> numplanes ; i v++ ) 
! f -> contents [ INT_CONST ] ) 
FOR ( i = firstmodeledge ; i < numedges ; i v++ ) 
numedges == MAX_MAP_EDGES ) 
face -> numpoints > MAXEDGES ) 
FOR ( i = INT_CONST ; i < face -> numpoints ; i v++ ) 
FOR ( hv = hvertex ; hv != hvert_p ; hv v++ ) 
FOR ( i = INT_CONST ; i < numedges ; i v++ ) 
FOR ( f = node -> faces ; f ; f = f -> next ) 
__E__O__F__
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
vec [ INT_CONST ] - hash_min [ INT_CONST ] ) 
p1 , dir ) 
p1 , -v *v t1 , dir , origin ) 
*v t1 > *v t2 ) 
FOR ( w = wedge_hash [ h ] ; w ; w = w -> next ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
FOR ( lastcorner = f -> numpoints - INT_CONST ; lastcorner > INT_CONST ; lastcorner v-- ) 
FOR ( firstcorner = INT_CONST ; firstcorner < f -> numpoints - INT_CONST ; firstcorner v++ ) 
FOR ( i = INT_CONST ; i < f -> numpoints ; i v++ ) 
f ) 
FOR ( i = INT_CONST ; i < new -> numpoints ; i v++ ) 
FOR ( i = new -> numpoints - INT_CONST ; i < f -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < superface -> numpoints ; i v++ ) 
FOR ( v = w -> head . next ; v -> t < t1 + T_EPSILON ; v = v -> next ) 
FOR ( k = superface -> numpoints ; k > j ; k v-- ) 
superface -> numpoints <= MAXPOINTS ) 
superface , f ) 
node -> planenum == PLANENUM_LEAF ) 
FOR ( f = node -> faces ; f ; f = f -> next ) 
node -> planenum == PLANENUM_LEAF ) 
FOR ( f = node -> faces ; f ; f = next ) 
node -> children [ INT_CONST ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
headnode ) 
STRING , tjuncs ) 
__E__O__F__
FOR ( i = INT_CONST , dplane = dplanes ; i < numplanes ; i v++ , dplane v++ ) 
numplanes == MAX_MAP_PLANES ) 
node -> planenum == -v INT_CONST ) 
numplanes == MAX_MAP_PLANES ) 
node -> children [ INT_CONST ] ) 
node -> planenum == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
node -> mins , leaf_p -> mins ) 
FOR ( fp = node -> markfaces ; *v fp ; fp v++ ) 
nummarksurfaces == MAX_MAP_MARKSURFACES ) 
numnodes == MAX_MAP_NODES ) 
node -> mins , n -> mins ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
headnode -> contents < INT_CONST ) 
headnode -> contents < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
nummodels == MAX_MAP_MODELS ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < wadinfo . numlumps ; i v++ ) 
FOR ( i = INT_CONST ; i < wadinfo . numlumps ; i v++ ) 
FOR ( i = INT_CONST ; i < base ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < wadinfo . numlumps ; k v++ ) 
&v entities [ INT_CONST ] , STRING ) 
FOR ( i = INT_CONST ; i < nummiptex ; i v++ ) 
__E__O__F__
SIZEOF ( def_t ) ) 
op -> right_associative ) 
FOR ( cn = pr . def_head . next ; cn ; cn = cn -> next ) 
SIZEOF ( def_t ) ) 
pr_immediate_type == &v type_string ) 
FOR ( i = INT_CONST ; i < numsounds ; i v++ ) 
FOR ( i = INT_CONST ; i < nummodels ; i v++ ) 
FOR ( i = INT_CONST ; i < numfiles ; i v++ ) 
! PR_Check ( STRING ) ) 
STRING , arg ) 
pr_token_type == tt_immediate ) 
NULL , name , pr_scope , false ) 
FOR ( op = pr_opcodes ; op -> name ; op v++ ) 
FOR ( i = INT_CONST ; i < type -> num_parms ; i v++ ) 
! PR_Check ( STRING ) ) 
pr_opcodes , INT_CONST , INT_CONST ) 
FOR ( def = *v old ; def ; old = &v def -> search_next , def = *v old ) 
strlen ( name ) + INT_CONST ) 
type -> type == ev_vector ) 
) 
FOR ( i = INT_CONST ; i < df -> numparms ; i v++ ) 
pr_globals + def -> ofs , &v pr_immediate , INT_CONST * type_size [ pr_immediate_type -> type ] ) 
filename ) 
) 
pr_token_type != tt_eof ) 
__E__O__F__
STRING , pr_source_line ) 
FOR ( t = pr_line_start ; *v t && *v t != CHAR_CONST ; t v++ ) 
m ) 
c == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; ( p = pr_punctuation [ i ] ) != NULL ; i v++ ) 
( c = *v pr_file_p ) <= CHAR_CONST ) 
FOR ( i = INT_CONST ; i < pr_nummacros ; i v++ ) 
( c = *v pr_file_p ) <= CHAR_CONST ) 
! strcmp ( pr_token , STRING ) ) 
PR_SimpleGetToken ( ) ) 
! pr_file_p ) 
) 
! c ) 
c == CHAR_CONST ) 
c == CHAR_CONST ) 
( c >= CHAR_CONST && c <= CHAR_CONST ) || ( c == CHAR_CONST && pr_file_p [ INT_CONST ] >= CHAR_CONST && pr_file_p [ INT_CONST ] <= CHAR_CONST ) ) 
) 
argptr , error ) 
STRING , strings + s_file , pr_source_line , string ) 
FOR ( check = pr . types ; check ; check = check -> next ) 
FOR ( i = INT_CONST ; i < type -> num_parms ; i v++ ) 
SIZEOF ( *v check ) ) 
SIZEOF ( def_t ) ) 
&v new , INT_CONST , SIZEOF ( new ) ) 
! PR_Check ( STRING ) ) 
__E__O__F__
filename , STRING , sourcedir ) 
FOR ( i = INT_CONST ; i < numsounds ; i v++ ) 
FOR ( i = INT_CONST ; i < nummodels ; i v++ ) 
FOR ( i = INT_CONST ; i < numfiles ; i v++ ) 
FOR ( i = INT_CONST ; i < strofs ; i += l ) 
FOR ( j = INT_CONST ; j < l ; j v++ ) 
FOR ( i = INT_CONST ; i < numfunctions ; i v++ ) 
FOR ( j = INT_CONST ; j < d -> numparms ; j v++ ) 
FOR ( i = INT_CONST ; i < numfielddefs ; i v++ ) 
FOR ( i = INT_CONST ; i < numglobaldefs ; i v++ ) 
FOR ( i = INT_CONST ; i < MAX_PARMS ; i v++ ) 
FOR ( def = pr . def_head . next ; def ; def = def -> next ) 
strofs + INT_CONST ) 
h ) 
h ) 
FOR ( i = INT_CONST ; i < numstatements ; i v++ ) 
h ) 
FOR ( i = INT_CONST ; i < numfunctions ; i v++ ) 
FOR ( i = INT_CONST ; i < numglobaldefs ; i v++ ) 
h ) 
FOR ( i = INT_CONST ; i < numfielddefs ; i v++ ) 
h ) 
FOR ( i = INT_CONST ; i < numpr_globals ; i v++ ) 
STRING , ( INT ) ftell ( h ) ) 
FOR ( i = INT_CONST ; i < SIZEOF ( progs ) / INT_CONST ; i v++ ) 
CHAR *p string ) 
FOR ( d = pr . def_head . next ; d ; d = d -> next ) 
line , STRING , *v ( INT *p ) val ) 
INT *p ) 
*v ( INT *p ) val ) 
line , STRING ) 
line , STRING , *v ( FLOAT *p ) val ) 
line , STRING , ( ( FLOAT *p ) val ) [ INT_CONST ] , ( ( FLOAT *p ) val ) [ INT_CONST ] , ( ( FLOAT *p ) val ) [ INT_CONST ] ) 
line , STRING ) 
line , STRING , type ) 
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( ; i < INT_CONST ; i v++ ) 
FOR ( d = pr . def_head . next ; d ; d = d -> next ) 
FOR ( i = INT_CONST ; i < RESERVED_OFS ; i v++ ) 
FOR ( d = pr . def_head . next ; d ; d = d -> next ) 
f , STRING , RESERVED_OFS ) 
FOR ( d = pr . def_head . next ; d ; d = d -> next ) 
f , STRING ) 
FOR ( d = pr . def_head . next ; d ; d = d -> next ) 
d -> type -> aux_type -> type ) 
&v crc ) 
FOR ( i = INT_CONST ; i < numfunctions ; i v++ ) 
) 
CheckParm ( STRING ) || CheckParm ( STRING ) ) 
FOR ( p v++ ; p < argc ; p v++ ) 
crc ) 
) 
) 
__E__O__F__
FOR ( i = INT_CONST ; i < nummodels ; i v++ ) 
FOR ( j = INT_CONST ; j < MAX_MAP_HULLS ; j v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < numvertexes ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < numplanes ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < numtexinfo ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < numfaces ; i v++ ) 
FOR ( i = INT_CONST ; i < numnodes ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < numleafs ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < numclipnodes ; i v++ ) 
texdatasize ) 
FOR ( i = INT_CONST ; i < c ; i v++ ) 
FOR ( i = INT_CONST ; i < nummarksurfaces ; i v++ ) 
FOR ( i = INT_CONST ; i < numsurfedges ; i v++ ) 
FOR ( i = INT_CONST ; i < numedges ; i v++ ) 
length % size ) 
filename , ( VOID *p *p ) & header ) 
FOR ( i = INT_CONST ; i < SIZEOF ( dheader_t ) / INT_CONST ; i v++ ) 
LUMP_TEXTURES , dtexdata , INT_CONST ) 
header ) 
false ) 
ftell ( wadfile ) ) 
LUMP_PLANES , dplanes , numplanes * SIZEOF ( dplane_t ) ) 
LUMP_LIGHTING , dlightdata , lightdatasize ) 
__E__O__F__
STRING ) 
argptr , error ) 
! ( path [ INT_CONST ] == CHAR_CONST || path [ INT_CONST ] == CHAR_CONST || path [ INT_CONST ] == CHAR_CONST ) ) 
temp ) 
FOR ( c = path ; *v c ; c v++ ) 
path ) 
archive ) 
&v tp , &v tzp ) 
c == CHAR_CONST && data [ INT_CONST ] == CHAR_CONST ) 
c == CHAR_CONST ) 
c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST ) 
c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST || c == CHAR_CONST ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
f ) 
filename , STRING ) 
! f ) 
filename , STRING ) 
! f ) 
filename ) 
filename ) 
*v src != PATHSEPERATOR && src != path ) 
path , extension ) 
path [ INT_CONST ] == PATHSEPERATOR ) 
path ) 
path ) 
path ) 
src != path && *v ( src - INT_CONST ) != PATHSEPERATOR ) 
dest , path , src - path ) 
path ) 
src != path && *v ( src - INT_CONST ) != PATHSEPERATOR ) 
*v src && *v src != CHAR_CONST ) 
path ) 
src != path && *v ( src - INT_CONST ) != CHAR_CONST ) 
src == path ) 
dest , src ) 
*v str ) 
l >> INT_CONST ) 
b1 << INT_CONST ) 
l >> INT_CONST ) 
( INT ) b1 << INT_CONST ) 
l >> INT_CONST ) 
b1 << INT_CONST ) 
l >> INT_CONST ) 
( INT ) b1 << INT_CONST ) 
FOR ( ofs = path + INT_CONST ; *v ofs ; ofs v++ ) 
from , &v buffer ) 
__E__O__F__
count > bpwidth ) 
STRING ) 
STRING ) 
STRING ) 
STRING ) 
*v mungecall ) 
filename , ( VOID *p *p ) & LBMbuffer ) 
*v ( INT *p ) LBMbuffer != LittleLong ( FORMID ) ) 
*v ( INT *p ) LBM_P ) 
formtype != ILBMID && formtype != PBMID ) 
LBM_P < LBMEND_P ) 
FOR ( y = INT_CONST ; y < bmhd . h ; y v++ , pic_p += bmhd . w ) 
FOR ( y = INT_CONST ; y < bmhd . h ; y v++ , pic_p += bmhd . w ) 
FOR ( p = INT_CONST ; p < planes ; p v++ ) 
, bitplanes [ p ] , rowsize ) 
LBMbuffer ) 
width * height + INT_CONST ) 
INT *p ) 
INT *p ) 
&v basebmhd , INT_CONST , SIZEOF ( basebmhd ) ) 
lbmptr , &v basebmhd , SIZEOF ( basebmhd ) ) 
byte * ) 
INT *p ) 
lbmptr , palette , INT_CONST ) 
byte * ) 
INT *p ) 
lbmptr , data , width * height ) 
byte * ) 
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
vec_t ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
nump == w -> numpoints ) 
w -> p [ INT_CONST ] , w -> p [ INT_CONST ] , v1 ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
vec3_origin , center ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
maxpts ) 
FOR ( i = INT_CONST ; i < in -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
in , normal , dist , &v f , &v b ) 
w -> numpoints < INT_CONST ) 
FOR ( i = INT_CONST ; i < w -> numpoints ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < w -> numpoints ; j v++ ) 
__E__O__F__
filename , ( VOID *p *p ) & scriptbuffer ) 
tokenready ) 
script_p >= scriptend_p ) 
*v script_p <= INT_CONST ) 
script_p >= scriptend_p ) 
*v script_p == CHAR_CONST || *v script_p == CHAR_CONST ) 
! crossline ) 
*v script_p > INT_CONST && *v script_p != CHAR_CONST ) 
search_p >= scriptend_p ) 
search_p == scriptend_p ) 
*v search_p == CHAR_CONST ) 
__E__O__F__
) 
dispatch == workcount ) 
f != oldf ) 
) 
&v crit ) 
FOR ( i = INT_CONST ; i < numthreads ; i v++ ) 
FOR ( i = INT_CONST ; i < numthreads ; i v++ ) 
! my_mutex ) 
pthread_attr_create ( &v attrib ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < numthreads ; i v++ ) 
FOR ( i = INT_CONST ; i < numthreads ; i v++ ) 
pacifier ) 
INT_CONST ) 
pacifier ) 
__E__O__F__
FOR ( i = INT_CONST ; i < SIZEOF ( tf_triangle ) / INT_CONST ; i v++ ) 
( UNSIGNED CHAR *p ) & exitpattern + INT_CONST ) 
( input = fopen ( filename , STRING ) ) == INT_CONST ) 
&v magic , SIZEOF ( INT ) , INT_CONST , input ) 
MAXTRIANGLES * SIZEOF ( triangle_t ) ) 
feof ( input ) == INT_CONST ) 
&v count , SIZEOF ( INT ) , INT_CONST , input ) 
FOR ( i = INT_CONST ; i < count ; ++v i ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
input ) 
__E__O__F__
filename ) 
strncmp ( header . identification , STRING , INT_CONST ) ) 
lumpinfo_t ) 
FOR ( i = INT_CONST ; i < numlumps ; i v++ , lump_p v++ ) 
FOR ( i = INT_CONST ; i < SIZEOF ( ( ( lumpinfo_t * ) INT_CONST ) -> name ) ; i v++ ) 
FOR ( ; i < SIZEOF ( ( ( lumpinfo_t * ) INT_CONST ) -> name ) ; i v++ ) 
INT *p ) 
FOR ( i = INT_CONST ; i < numlumps ; i v++ , lump_p v++ ) 
name ) 
info , INT_CONST , SIZEOF ( info ) ) 
outwad , buffer , length ) 
outwad ) 
outwad , outinfo , outlumps * SIZEOF ( lumpinfo_t ) ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numvertexes ; i v++ ) 
vertexes [ i ] . y < min_y ) 
FOR ( pnum = INT_CONST ; pnum < MAXPLAYERS ; pnum v++ ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < AM_NUMMARKPOINTS ; i v++ ) 
followplayer ) 
ftom_zoommul != FRACUNIT ) 
m_paninc . x || m_paninc . y ) 
ml -> a . y > m_y2 ) 
ml -> b . y > m_y2 ) 
ml -> a . x < m_x ) 
ml -> a . x ) 
outcode1 | outcode2 ) 
outcode1 ) 
outside == outcode1 ) 
fl -> a . x < INT_CONST || fl -> a . x >= f_w NEW_LINE || fl -> a . y < INT_CONST || fl -> a . y >= f_h NEW_LINE || fl -> b . x < INT_CONST || fl -> b . x >= f_w NEW_LINE || fl -> b . y < INT_CONST || fl -> b . y >= f_h ) 
FOR ( x = start ; x < end ; x += ( MAPBLOCKUNITS << FRACBITS ) ) 
FOR ( y = start ; y < end ; y += ( MAPBLOCKUNITS << FRACBITS ) ) 
FOR ( i = INT_CONST ; i < numlines ; i v++ ) 
FOR ( i = INT_CONST ; i < lineguylines ; i v++ ) 
scale ) 
angle ) 
scale ) 
angle ) 
&v l , color ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
( deathmatch && ! singledemo ) && p != plr ) 
FOR ( i = INT_CONST ; i < numsectors ; i v++ ) 
FOR ( i = INT_CONST ; i < AM_NUMMARKPOINTS ; i v++ ) 
__E__O__F__
FOR ( ; eventtail != eventhead ; eventtail = ( ++v eventtail ) & ( MAXEVENTS - INT_CONST ) ) 
setsizeneeded ) 
gamestate == GS_LEVEL && gametic ) 
gamestate ) 
) 
) 
) 
) 
gamestate == GS_LEVEL && ! automapactive && gametic ) 
gamestate == GS_LEVEL && gametic ) 
gamestate != oldgamestate && gamestate != GS_LEVEL ) 
gamestate == GS_LEVEL && oldgamestate != GS_LEVEL ) 
) 
paused ) 
INT_CONST , INT_CONST , SCREENWIDTH , SCREENHEIGHT ) 
) 
) 
) 
) 
) 
STRING ) 
FOR ( numwadfiles = INT_CONST ; wadfiles [ numwadfiles ] ; numwadfiles v++ ) 
strlen ( file ) + INT_CONST ) 
strlen ( doomwaddir ) + INT_CONST + INT_CONST + INT_CONST ) 
strlen ( doomwaddir ) + INT_CONST + INT_CONST + INT_CONST ) 
strlen ( doomwaddir ) + INT_CONST + INT_CONST + INT_CONST ) 
STRING ) 
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
FOR ( index = INT_CONST , k = i + INT_CONST ; k < myargc ; k v++ ) 
FOR ( k = INT_CONST ; k < index ; k v++ ) 
FOR ( k = INT_CONST ; k < myargc ; k v++ ) 
gamemode ) 
devparm ) 
STRING ) 
gamemode ) 
++v p != myargc && myargv [ p ] [ INT_CONST ] != CHAR_CONST ) 
p && p < myargc - INT_CONST ) 
STRING ) 
STRING ) 
STRING ) 
modifiedgame ) 
gamemode == registered ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
modifiedgame ) 
VOID *p ) 
STRING ) 
myargv [ p + INT_CONST ] ) 
__E__O__F__
FOR ( i = INT_CONST ; i < l ; i v++ ) 
! netgame ) 
FOR ( i = INT_CONST ; i < doomcom -> datalength ; i v++ ) 
demoplayback ) 
doomcom -> datalength != NetbufferSize ( ) ) 
FOR ( i = INT_CONST ; i < doomcom -> datalength ; i v++ ) 
netbuffer -> starttic ) 
) 
skiptics <= newtics ) 
FOR ( i = INT_CONST ; i < newtics ; i v++ ) 
FOR ( i = INT_CONST ; i < doomcom -> numnodes ; i v++ ) 
FOR ( j = INT_CONST ; j < netbuffer -> numtics ; j v++ ) 
) 
) 
FOR ( ; eventtail != eventhead NEW_LINE ; eventtail = ( ++v eventtail ) & ( MAXEVENTS - INT_CONST ) ) 
STRING ) 
STRING ) 
FOR ( i = INT_CONST ; i < doomcom -> numnodes ; i v++ ) 
FOR ( i = INT_CONST ; i && HGetPacket ( ) ; --v i ) 
FOR ( i = INT_CONST ; i < doomcom -> numnodes ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXNETNODES ; i v++ ) 
STRING , NEW_LINE startskill , deathmatch , startmap , startepisode ) 
FOR ( i = INT_CONST ; i < doomcom -> numplayers ; i v++ ) 
FOR ( i = INT_CONST ; i < doomcom -> numnodes ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < doomcom -> numnodes ; j v++ ) 
) 
) 
FOR ( i = INT_CONST ; i < doomcom -> numnodes ; i v++ ) 
realtics < availabletics - INT_CONST ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
consoleplayer == i ) 
FOR ( i = INT_CONST ; i < doomcom -> numnodes ; i v++ ) 
I_GetTime ( ) / ticdup - entertic >= INT_CONST ) 
counts v-- ) 
FOR ( i = INT_CONST ; i < ticdup ; i v++ ) 
FOR ( j = INT_CONST ; j < MAXPLAYERS ; j v++ ) 
__E__O__F__
event_t * event ) 
( gamemode == commercial ) NEW_LINE && ( finalecount > INT_CONST ) ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
finalestage == INT_CONST ) 
gameepisode == INT_CONST ) 
finaleflat , PU_CACHE ) 
FOR ( y = INT_CONST ; y < SCREENHEIGHT ; y v++ ) 
FOR ( x = INT_CONST ; x < SCREENWIDTH / INT_CONST ; x v++ ) 
finalecount - INT_CONST ) 
FOR ( ; count ; count v-- ) 
caststate -> tics == -v INT_CONST || caststate -> nextstate == S_NULL ) 
castorder [ castnum ] . name == NULL ) 
caststate == &v states [ S_PLAY_ATK1 ] ) 
castonmelee ) 
mobjinfo [ castorder [ castnum ] . type ] . deathsound ) 
ch ) 
ch ) 
INT x , INT y , INT scrn , patch_t * patch ) 
INT_CONST , INT_CONST , INT_CONST , W_CacheLumpName ( STRING , PU_CACHE ) ) 
boolean ) 
FOR ( x = INT_CONST ; x < SCREENWIDTH ; x v++ ) 
finalecount < INT_CONST ) 
__E__O__F__
FOR ( y = INT_CONST ; y < height ; y v++ ) 
FOR ( x = INT_CONST ; x < width ; x v++ ) 
wipe_scr , wipe_scr_start , width * height ) 
( SHORT *p ) wipe_scr_start , width / INT_CONST , height ) 
INT *p ) 
FOR ( i = INT_CONST ; i < width ; i v++ ) 
FOR ( i = INT_CONST ; i < width ; i v++ ) 
FOR ( j = dy ; j ; j v-- ) 
FOR ( j = height - y [ i ] ; j ; j v-- ) 
*v wipes [ wipeno * INT_CONST ] ) 
__E__O__F__
FOR ( i = INT_CONST ; i < SIZEOF ( *v cmd ) / INT_CONST - INT_CONST ; i v++ ) 
) 
joyxmove < INT_CONST NEW_LINE || joyxmove > INT_CONST NEW_LINE || gamekeydown [ key_right ] NEW_LINE || gamekeydown [ key_left ] ) 
strafe ) 
) 
gamekeydown [ key_use ] || joybuttons [ joybuse ] ) 
FOR ( i = INT_CONST ; i < NUMWEAPONS - INT_CONST ; i v++ ) 
mousebuttons [ mousebforward ] ) 
mousebuttons [ mousebforward ] != dclickstate && dclicktime > INT_CONST ) 
bstrafe != dclickstate2 && dclicktime2 > INT_CONST ) 
sendpause ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
) 
gamekeydown , INT_CONST , SIZEOF ( gamekeydown ) ) 
gameaction == ga_nothing && ! singledemo && NEW_LINE ( demoplayback || gamestate == GS_DEMOSCREEN ) NEW_LINE ) 
ev -> data1 < NUMKEYS ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
gameaction != ga_nothing ) 
gametic / ticdup ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
! savedescription [ INT_CONST ] ) 
gamestate ) 
) 
INT player ) 
FOR ( i = INT_CONST ; i < NUMAMMO ; i v++ ) 
FOR ( i = INT_CONST ; i < playernum ; i v++ ) 
bodyqueslot >= BODYQUESIZE ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
deathmatch ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
gamemode != commercial ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
gamemode == commercial ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
) 
vcheck , INT_CONST , SIZEOF ( vcheck ) ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
savebuffer ) 
) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = S_SARG_RUN1 ; i <= S_SARG_PAIN2 ; i v++ ) 
FOR ( i = S_SARG_RUN1 ; i <= S_SARG_PAIN2 ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
gamemode == commercial ) 
) 
) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < l -> len ; i v++ ) 
x , l -> y , FG , l -> f [ c - l -> sc ] ) 
FOR ( y = l -> y , yoffset = y * SCREENWIDTH ; y < l -> y + lh ; y v++ , yoffset += SCREENWIDTH ) 
FOR ( i = INT_CONST ; i < h ; i v++ ) 
FOR ( i = INT_CONST ; i < s -> h ; i v++ ) 
FOR ( i = INT_CONST ; i < s -> h ; i v++ ) 
l , false ) 
FOR ( i = INT_CONST ; i < s -> h ; i v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < HU_FONTSIZE ; i v++ ) 
&v w_message , NEW_LINE HU_MSGX , HU_MSGY , HU_MSGHEIGHT , NEW_LINE hu_font , NEW_LINE HU_FONTSTART , &v message_on ) 
&v w_chat , NEW_LINE HU_INPUTX , HU_INPUTY , NEW_LINE hu_font , NEW_LINE HU_FONTSTART , &v chat_on ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
( plr -> message && ! message_nottobefuckedwith ) NEW_LINE || ( plr -> message && message_dontfuckwithme ) ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
ev -> data1 == KEY_RSHIFT ) 
! chat_on ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
altdown ) 
__E__O__F__
FOR ( c = INT_CONST ; c < netbuffer -> numtics ; c v++ ) 
FOR ( i = INT_CONST ; i < doomcom -> numnodes ; i v++ ) 
FOR ( c = INT_CONST ; c < netbuffer -> numtics ; c v++ ) 
STRING ) 
STRING ) 
) 
__E__O__F__
__E__O__F__
) 
X_event . xbutton . state & Button1Mask ) 
X_event . xbutton . state & Button1Mask ) 
X_event . xbutton . button == Button1 ? INT_CONST ?: INT_CONST ) 
X_event . xmotion . state & Button1Mask ) 
event . data2 || event . data3 ) 
XPending ( X_display ) ) 
grabMouse ) 
INT_CONST , INT_CONST , NEW_LINE INT_CONST , INT_CONST , NEW_LINE X_width / INT_CONST , X_height / INT_CONST ) 
FOR ( i = INT_CONST ; i < tics * INT_CONST ; i += INT_CONST ) 
FOR ( ; i < INT_CONST * INT_CONST ; i += INT_CONST ) 
multiply == INT_CONST ) 
UNSIGNED INT *p ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
UNSIGNED INT *p ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
UNSIGNED *p , DOUBLE *p ) 
X_display , NEW_LINE X_mainWindow , NEW_LINE X_gc , NEW_LINE image , NEW_LINE INT_CONST , INT_CONST , NEW_LINE INT_CONST , INT_CONST , NEW_LINE X_width , X_height ) 
X_display , False ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
! firsttime ) 
M_CheckParm ( STRING ) ) 
M_CheckParm ( STRING ) ) 
( pnum = M_CheckParm ( STRING ) ) ) 
STRING ) 
myargv [ pnum + INT_CONST ] , STRING , &v xsign , &v x , &v ysign , &v y ) 
X_display , NEW_LINE RootWindow ( X_display , X_screen ) , NEW_LINE x , y , NEW_LINE X_width , X_height , NEW_LINE INT_CONST , COMMENT_NL CPP_COMMENT NEW_LINE INT_CONST , COMMENT_NL CPP_COMMENT NEW_LINE InputOutput , NEW_LINE X_visual , NEW_LINE attribmask , NEW_LINE &v attribs ) 
valuemask , NEW_LINE &v xgcvalues ) 
X_display , X_mainWindow ) 
X_display , NEW_LINE X_visual , NEW_LINE INT_CONST , NEW_LINE ZPixmap , NEW_LINE INT_CONST , NEW_LINE &v X_shminfo , NEW_LINE X_width , NEW_LINE X_height ) 
! image -> data ) 
! XShmAttach ( X_display , &v X_shminfo ) ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
__E__O__F__
name , STRING , sfxname ) 
UNSIGNED CHAR *p ) 
( size - INT_CONST + ( SAMPLECOUNT - INT_CONST ) ) / SAMPLECOUNT ) 
FOR ( i = size ; i < paddedsize + INT_CONST ; i v++ ) 
sfx ) 
VOID *p ) 
FOR ( i = INT_CONST ; i < NUM_CHANNELS ; i v++ ) 
FOR ( i = INT_CONST ; ( i < NUM_CHANNELS ) && ( channels [ i ] ) ; i v++ ) 
UNSIGNED CHAR *p ) 
( volume * seperation * seperation ) >> INT_CONST ) 
( volume * seperation * seperation ) >> INT_CONST ) 
rightvol < INT_CONST || rightvol > INT_CONST ) 
FOR ( i = -v INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
id , vol , steptable [ pitch ] , sep ) 
leftout != leftend ) 
FOR ( chan = INT_CONST ; chan < NUM_CHANNELS ; chan v++ ) 
dl > INT_CONST ) 
dr > INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST && ! channels [ i ] ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMSFX ; i v++ ) 
FOR ( i = INT_CONST ; i < MIXBUFFERSIZE ; i v++ ) 
__E__O__F__
__E__O__F__
FOR ( i = INT_CONST ; i < numChannels ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMSFX ; i v++ ) 
FOR ( cnum = INT_CONST ; cnum < numChannels ; cnum v++ ) 
FOR ( i = first_saw ; i != next_saw ; i = ( i + INT_CONST ) % INT_CONST ) 
FOR ( n = i = INT_CONST ; i < numChannels ; i v++ ) 
FOR ( i = INT_CONST ; i < numChannels ; i v++ ) 
FOR ( cnum = INT_CONST ; cnum < numChannels ; cnum v++ ) 
FOR ( cnum = INT_CONST ; cnum < numChannels ; cnum v++ ) 
c -> sfxinfo ) 
mus_playing == music ) 
) 
I_SoundIsPlaying ( c -> handle ) ) 
FOR ( i = INT_CONST ; i < numChannels ; i v++ ) 
listener -> x , NEW_LINE listener -> y , NEW_LINE source -> x , NEW_LINE source -> y ) 
FixedMul ( S_STEREO_SWING , finesine [ angle ] ) >> FRACBITS ) 
snd_SfxVolume NEW_LINE * ( ( S_CLIPPING_DIST - approx_dist ) >> FRACBITS ) ) 
FOR ( cnum = INT_CONST ; cnum < numChannels ; cnum v++ ) 
FOR ( cnum = INT_CONST ; cnum < numChannels ; cnum v++ ) 
__E__O__F__
FOR ( i = INT_CONST ; i < myargc ; i v++ ) 
__E__O__F__
__E__O__F__
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
*v cht -> p == INT_CONST ) 
*v cht -> p == INT_CONST ) 
__E__O__F__
*v messageRoutine ) 
*v routine ) 
FOR ( i = INT_CONST ; i < load_end ; i v++ ) 
FOR ( i = INT_CONST ; i < load_end ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < load_end ; i v++ ) 
INT_CONST , INT_CONST , INT_CONST , W_CacheLumpName ( STRING , PU_CACHE ) ) 
FOR ( i = INT_CONST ; i < thermWidth ; i v++ ) 
FOR ( i = INT_CONST ; i < strlen ( string ) ; i v++ ) 
FOR ( i = INT_CONST ; i < strlen ( string ) ; i v++ ) 
saveStringEnter ) 
&v savegamestrings [ saveSlot ] [ INT_CONST ] , saveOldString ) 
savegamestrings [ saveSlot ] [ INT_CONST ] ) 
ch ) 
ch >= INT_CONST && ch <= INT_CONST && NEW_LINE saveCharIndex < SAVESTRINGSIZE - INT_CONST && NEW_LINE M_StringWidth ( savegamestrings [ saveSlot ] ) < NEW_LINE ( SAVESTRINGSIZE - INT_CONST ) * INT_CONST ) 
messageToPrint ) 
automapactive || chat_on ) 
) 
NULL , sfx_swtchn ) 
) 
) 
) 
INT_CONST ) 
NULL , sfx_swtchn ) 
NULL , sfx_swtchn ) 
INT_CONST ) 
NULL , sfx_swtchn ) 
NULL , sfx_swtchn ) 
usegamma > INT_CONST ) 
! menuactive ) 
ch ) 
currentMenu -> menuitems [ itemOn ] . routine && NEW_LINE currentMenu -> menuitems [ itemOn ] . status == INT_CONST ) 
currentMenu -> menuitems [ itemOn ] . routine && NEW_LINE currentMenu -> menuitems [ itemOn ] . status ) 
FOR ( i = itemOn + INT_CONST ; i < currentMenu -> numitems ; i v++ ) 
FOR ( i = INT_CONST ; i <= itemOn ; i v++ ) 
messageToPrint ) 
FOR ( i = INT_CONST ; i < strlen ( messageString + start ) ; i v++ ) 
string ) 
currentMenu -> routine ) 
FOR ( i = INT_CONST ; i < max ; i v++ ) 
x + SKULLXOFF , currentMenu -> y - INT_CONST + itemOn * LINEHEIGHT , INT_CONST , NEW_LINE W_CacheLumpName ( skullName [ whichSkull ] , PU_CACHE ) ) 
__E__O__F__
handle , source , length ) 
FOR ( i = INT_CONST ; i < numdefaults ; i v++ ) 
defaults ) 
FOR ( i = INT_CONST ; i < numdefaults ; i v++ ) 
STRING ) 
defaultfile , STRING ) 
FOR ( i = INT_CONST ; i < numdefaults ; i v++ ) 
FOR ( i = INT_CONST ; i < width * height ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
byte * ) 
linear ) 
lbmname , STRING ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
lbmname , linear , NEW_LINE SCREENWIDTH , SCREENHEIGHT , NEW_LINE W_CacheLumpName ( STRING , PU_CACHE ) ) 
__E__O__F__
__E__O__F__
ceiling -> sector , NEW_LINE ceiling -> speed , NEW_LINE ceiling -> topheight , NEW_LINE false , INT_CONST , ceiling -> direction ) 
( mobj_t * ) & ceiling -> sector -> soundorg , NEW_LINE sfx_stnmov ) 
( mobj_t * ) & ceiling -> sector -> soundorg , NEW_LINE sfx_pstop ) 
ceiling -> sector , NEW_LINE ceiling -> speed , NEW_LINE ceiling -> bottomheight , NEW_LINE ceiling -> crush , INT_CONST , ceiling -> direction ) 
ceiling ) 
type ) 
FOR ( i = INT_CONST ; i < MAXCEILINGS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXCEILINGS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXCEILINGS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXCEILINGS ; i v++ ) 
__E__O__F__
! --v door -> topcountdown ) 
( mobj_t * ) & door -> sector -> soundorg , NEW_LINE sfx_dorcls ) 
( mobj_t * ) & door -> sector -> soundorg , NEW_LINE sfx_doropn ) 
! --v door -> topcountdown ) 
door -> sector , NEW_LINE door -> speed , NEW_LINE door -> sector -> floorheight , NEW_LINE false , INT_CONST , door -> direction ) 
&v door -> thinker ) 
( mobj_t * ) & door -> sector -> soundorg , NEW_LINE sfx_doropn ) 
door -> sector , NEW_LINE door -> speed , NEW_LINE door -> topheight , NEW_LINE false , INT_CONST , door -> direction ) 
&v door -> thinker ) 
actionf_p1 ) 
sec ) 
sec ) 
&v door -> thinker ) 
actionf_p1 ) 
FOR ( i = INT_CONST ; i < MAXSLIDEDOORS ; i v++ ) 
slideFrameNames [ i ] . backFrame1 ) 
FOR ( i = INT_CONST ; i < MAXSLIDEDOORS ; i v++ ) 
! door -> timer v-- ) 
! door -> timer v-- ) 
sec -> specialdata ) 
! door ) 
door -> whichDoorIndex < INT_CONST ) 
__E__O__F__
FOR ( i = INT_CONST ; i < sec -> linecount ; i v++ ) 
mobj_t * actor ) 
actor -> x - actor -> target -> x , NEW_LINE actor -> y - actor -> target -> y ) 
actor -> type == MT_VILE ) 
actor -> movedir == DI_NODIR ) 
actor -> flags & MF_FLOAT && floatok ) 
! actor -> target ) 
deltay < -v INT_CONST * FRACUNIT ) 
d [ INT_CONST ] != DI_NODIR NEW_LINE && d [ INT_CONST ] != DI_NODIR ) 
P_TryWalk ( actor ) ) 
P_TryWalk ( actor ) ) 
FOR ( tdir = DI_EAST ; NEW_LINE tdir <= DI_SOUTHEAST ; NEW_LINE tdir v++ ) 
FOR ( tdir = DI_SOUTHEAST ; NEW_LINE tdir != ( DI_EAST - INT_CONST ) ; NEW_LINE tdir v-- ) 
FOR ( ; ; actor -> lastlook = ( actor -> lastlook + INT_CONST ) & INT_CONST ) 
player -> health <= INT_CONST ) 
FOR ( th = thinkercap . next ; th != &v thinkercap ; th = th -> next ) 
actor -> flags & MF_AMBUSH ) 
actor -> type == MT_SPIDER NEW_LINE || actor -> type == MT_CYBORG ) 
actor -> threshold ) 
actor -> movedir < INT_CONST ) 
P_LookForPlayers ( actor , true ) ) 
actor -> flags & MF_JUSTATTACKED ) 
actor -> info -> meleestate NEW_LINE && P_CheckMeleeRange ( actor ) ) 
actor -> info -> missilestate ) 
--v actor -> movecount < INT_CONST NEW_LINE || ! P_Move ( actor ) ) 
actor -> info -> activesound NEW_LINE && P_Random ( ) < INT_CONST ) 
actor , sfx_shotgn ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
actor , sfx_shotgn ) 
! actor -> target NEW_LINE || actor -> target -> health <= INT_CONST NEW_LINE || ! P_CheckSight ( actor , actor -> target ) ) 
! actor -> target NEW_LINE || actor -> target -> health <= INT_CONST NEW_LINE || ! P_CheckSight ( actor , actor -> target ) ) 
actor , actor -> target , MT_TROOPSHOT ) 
actor , actor -> target , MT_HEADSHOT ) 
actor , actor -> target , MT_BRUISERSHOT ) 
actor -> x , actor -> y , actor -> z ) 
! dest || dest -> health <= INT_CONST ) 
actor -> x , NEW_LINE actor -> y , NEW_LINE dest -> x , NEW_LINE dest -> y ) 
dest -> x - actor -> x , NEW_LINE dest -> y - actor -> y ) 
dist < INT_CONST ) 
thing -> tics != -v INT_CONST ) 
thing -> info -> raisestate == S_NULL ) 
abs ( thing -> x - viletryx ) > maxdist NEW_LINE || abs ( thing -> y - viletryy ) > maxdist ) 
corpsehit , corpsehit -> x , corpsehit -> y ) 
viletryx - bmaporgx - MAXRADIUS * INT_CONST ) 
FOR ( bx = xl ; bx <= xh ; bx v++ ) 
FOR ( by = yl ; by <= yh ; by v++ ) 
actor ) 
actor ) 
! P_CheckSight ( actor , actor -> target ) ) 
actor , sfx_barexp ) 
actor -> info -> radius + mobjinfo [ MT_SKULL ] . radius ) 
newmobj , actor , actor , INT_CONST ) 
actor ) 
NULL , sound ) 
mo -> type != MT_SPIDER ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
i == MAXPLAYERS ) 
FOR ( th = thinkercap . next ; th != &v thinkercap ; th = th -> next ) 
&v junk , lowerFloorToLowest ) 
FOR ( thinker = thinkercap . next ; NEW_LINE thinker != &v thinkercap ; NEW_LINE thinker = thinker -> next ) 
m -> type == MT_BOSSTARGET ) 
FOR ( x = mo -> x - INT_CONST * FRACUNIT ; x < mo -> x + INT_CONST * FRACUNIT ; x += FRACUNIT * INT_CONST ) 
th , S_BRAINEXPLODE1 ) 
) 
NULL , sfx_bospit ) 
targ -> x , targ -> y , targ -> z , MT_SPAWNFIRE ) 
targ -> x , targ -> y , targ -> z , type ) 
__E__O__F__
direction ) 
direction ) 
floor -> direction == INT_CONST ) 
( mobj_t * ) & floor -> sector -> soundorg , NEW_LINE sfx_pstop ) 
floortype ) 
FOR ( i = INT_CONST ; i < sec -> linecount ; i v++ ) 
FOR ( i = INT_CONST ; i < sec -> linecount ; i v++ ) 
FOR ( i = INT_CONST ; i < sec -> linecount ; i v++ ) 
__E__O__F__
gameskill == sk_baby NEW_LINE || gameskill == sk_nightmare ) 
oldammo ) 
ammo ) 
player -> weaponowned [ weapon ] ) 
deathmatch ) 
player == &v players [ consoleplayer ] ) 
dropped ) 
special -> sprite ) 
! P_GiveArmor ( player , INT_CONST ) ) 
player -> health > INT_CONST ) 
player -> armorpoints > INT_CONST ) 
! player -> cards [ it_bluecard ] ) 
! P_GivePower ( player , pw_invulnerability ) ) 
special -> flags & MF_DROPPED ) 
FOR ( i = INT_CONST ; i < NUMAMMO ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMAMMO ; i v++ ) 
! P_GiveWeapon ( player , wp_chaingun , special -> flags & MF_DROPPED ) ) 
! P_GiveWeapon ( player , wp_chainsaw , false ) ) 
! P_GiveWeapon ( player , wp_missile , false ) ) 
! P_GiveWeapon ( player , wp_plasma , false ) ) 
! P_GiveWeapon ( player , wp_shotgun , special -> flags & MF_DROPPED ) ) 
STRING ) 
source && source -> player ) 
target -> flags & MF_COUNTKILL ) 
! source ) 
target -> player == &v players [ consoleplayer ] NEW_LINE && automapactive ) 
target -> health <= INT_CONST ) 
target -> flags & MF_SKULLFLY ) 
inflictor NEW_LINE && ! ( target -> flags & MF_NOCLIP ) NEW_LINE && ( ! source NEW_LINE || ! source -> player NEW_LINE || source -> player -> readyweapon != wp_chainsaw ) ) 
damage < INT_CONST NEW_LINE && damage > target -> health NEW_LINE && target -> z - inflictor -> z > INT_CONST * FRACUNIT NEW_LINE && ( P_Random ( ) & INT_CONST ) ) 
player ) 
target -> subsector -> sector -> special == INT_CONST NEW_LINE && damage >= target -> health ) 
damage < INT_CONST NEW_LINE && ( ( player -> cheats & CF_GODMODE ) NEW_LINE || player -> powers [ pw_invulnerability ] ) ) 
player -> health < INT_CONST ) 
player -> damagecount > INT_CONST ) 
target -> health <= INT_CONST ) 
target , target -> info -> painstate ) 
target -> state == &v states [ target -> info -> spawnstate ] NEW_LINE && target -> info -> seestate != S_NULL ) 
__E__O__F__
flick -> sector -> lightlevel - amount < flick -> minlight ) 
! inSync ) 
FOR ( j = INT_CONST ; j < numsectors ; j v++ , sector v++ ) 
FOR ( i = INT_CONST ; i < sector -> linecount ; i v++ ) 
FOR ( i = INT_CONST ; i < numsectors ; i v++ , sector v++ ) 
FOR ( j = INT_CONST ; j < sector -> linecount ; j v++ ) 
g -> sector -> lightlevel <= g -> minlight ) 
g -> sector -> lightlevel >= g -> maxlight ) 
__E__O__F__
thing == tmthing ) 
! tmthing -> player && gamemap != INT_CONST ) 
x , y ) 
tmbbox [ BOXLEFT ] - bmaporgx - MAXRADIUS ) 
FOR ( bx = xl ; bx <= xh ; bx v++ ) 
FOR ( by = yl ; by <= yh ; by v++ ) 
thing ) 
P_BoxOnLineSide ( tmbbox , ld ) != -v INT_CONST ) 
! ld -> backsector ) 
! ( tmthing -> flags & MF_MISSILE ) ) 
lowfloor < tmdropoffz ) 
abs ( thing -> x - tmx ) >= blockdist NEW_LINE || abs ( thing -> y - tmy ) >= blockdist ) 
thing == tmthing ) 
tmthing -> flags & MF_SKULLFLY ) 
tmthing -> flags & MF_MISSILE ) 
tmthing -> z > thing -> z + thing -> height ) 
( P_Random ( ) % INT_CONST ) + INT_CONST ) 
thing -> flags & MF_SPECIAL ) 
tmflags & MF_NOCLIP ) 
tmbbox [ BOXLEFT ] - bmaporgx - MAXRADIUS ) 
FOR ( bx = xl ; bx <= xh ; bx v++ ) 
FOR ( by = yl ; by <= yh ; by v++ ) 
tmbbox [ BOXLEFT ] - bmaporgx ) 
FOR ( bx = xl ; bx <= xh ; bx v++ ) 
FOR ( by = yl ; by <= yh ; by v++ ) 
! ( thing -> flags & MF_NOCLIP ) ) 
thing ) 
! ( thing -> flags & ( MF_TELEPORT | MF_NOCLIP ) ) ) 
thing -> z + thing -> height > thing -> ceilingz ) 
INT_CONST , INT_CONST , tmxmove , tmymove ) 
opentop - slidemo -> z < slidemo -> height ) 
openbottom - slidemo -> z > INT_CONST * FRACUNIT ) 
in -> frac < bestslidefrac ) 
mo -> momx > INT_CONST ) 
bestslidefrac == FRACUNIT + INT_CONST ) 
! P_TryMove ( mo , mo -> x , mo -> y + mo -> momy ) ) 
bestslidefrac + INT_CONST ) 
li ) 
th == shootthing ) 
! ( th -> flags & MF_SHOOTABLE ) ) 
attackrange , in -> frac ) 
th -> z - shootz , dist ) 
thingtopslope > topslope ) 
thingtopslope + thingbottomslope ) 
in -> isaline ) 
INT_CONST * FRACUNIT , attackrange ) 
li -> frontsector -> ceilingpic == skyflatnum ) 
x , y , z ) 
th == shootthing ) 
! ( th -> flags & MF_SHOOTABLE ) ) 
attackrange , in -> frac ) 
th -> z - shootz , dist ) 
INT_CONST * FRACUNIT , attackrange ) 
la_damage ) 
mobj_t * t1 , NEW_LINE angle_t angle , NEW_LINE fixed_t distance ) 
P_PointOnLineSide ( usething -> x , usething -> y , in -> d . line ) == INT_CONST ) 
usething , in -> d . line , side ) 
thing -> type == MT_CYBORG NEW_LINE || thing -> type == MT_SPIDER ) 
dist >= bombdamage ) 
P_CheckSight ( thing , bombspot ) ) 
thing , bombspot , bombsource , bombdamage - dist ) 
FOR ( y = yl ; y <= yh ; y v++ ) 
FOR ( x = xl ; x <= xh ; x v++ ) 
thing -> health <= INT_CONST ) 
thing -> flags & MF_DROPPED ) 
! ( thing -> flags & MF_SHOOTABLE ) ) 
crushchange && ! ( leveltime & INT_CONST ) ) 
thing -> x , NEW_LINE thing -> y , NEW_LINE thing -> z + thing -> height / INT_CONST , MT_BLOOD ) 
FOR ( x = sector -> blockbox [ BOXLEFT ] ; x <= sector -> blockbox [ BOXRIGHT ] ; x v++ ) 
FOR ( y = sector -> blockbox [ BOXBOTTOM ] ; y <= sector -> blockbox [ BOXTOP ] ; y v++ ) 
__E__O__F__
num , den ) 
v1x - v2x ) 
front -> floorheight > back -> floorheight ) 
thing -> snext ) 
thing -> bnext ) 
thing -> x , thing -> y ) 
sec -> thinglist ) 
! ( thing -> flags & MF_NOBLOCKMAP ) ) 
thing -> x - bmaporgx ) 
blockx >= INT_CONST NEW_LINE && blockx < bmapwidth NEW_LINE && blocky >= INT_CONST NEW_LINE && blocky < bmapheight ) 
FOR ( list = blockmaplump + offset ; *v list != -v INT_CONST ; list v++ ) 
ld -> validcount == validcount ) 
FOR ( mobj = blocklinks [ y * bmapwidth + x ] ; NEW_LINE mobj ; NEW_LINE mobj = mobj -> bnext ) 
ld , &v dl ) 
earlyout NEW_LINE && frac < FRACUNIT NEW_LINE && ! ld -> backsector ) 
trace . dx ^ trace . dy ) 
&v trace , &v dl ) 
frac < INT_CONST ) 
count v-- ) 
FOR ( scan = intercepts ; scan < intercept_p ; scan v++ ) 
FOR ( scan = intercepts ; scan < intercept_p ; scan v++ ) 
( ( y1 - bmaporgy ) & ( MAPBLOCKSIZE - INT_CONST ) ) == INT_CONST ) 
xt2 > xt1 ) 
FOR ( count = INT_CONST ; count < INT_CONST ; count v++ ) 
&& mapy == yt2 ) 
__E__O__F__
st -> action . acp1 ) 
mo -> info -> deathsound ) 
mo -> momy > MAXMOVE ) 
player && player -> cheats & CF_NOMOMENTUM ) 
mo -> z > mo -> floorz ) 
mo -> flags & MF_CORPSE ) 
mo -> momx > FRACUNIT / INT_CONST NEW_LINE || mo -> momx < -v FRACUNIT / INT_CONST NEW_LINE || mo -> momy > FRACUNIT / INT_CONST NEW_LINE || mo -> momy < -v FRACUNIT / INT_CONST ) 
player && ( UNSIGNED ) ( ( player -> mo -> state - states ) - S_PLAY_RUN1 ) < INT_CONST ) 
mo -> player && mo -> z < mo -> floorz ) 
VIEWHEIGHT - mo -> player -> viewheight ) 
mo -> flags & MF_FLOAT NEW_LINE && mo -> target ) 
! ( mo -> flags & MF_SKULLFLY ) NEW_LINE && ! ( mo -> flags & MF_INFLOAT ) ) 
mo -> z <= mo -> floorz ) 
mo -> flags & MF_SKULLFLY ) 
( mo -> flags & MF_MISSILE ) NEW_LINE && ! ( mo -> flags & MF_NOCLIP ) ) 
mo -> momz > INT_CONST ) 
mo -> flags & MF_SKULLFLY ) 
x , y , z , mobj -> type ) 
mobj ) 
mobj -> thinker . function . acv == ( actionf_v ) ( -v INT_CONST ) ) 
mobj -> tics != -v INT_CONST ) 
! ( mobj -> flags & MF_COUNTKILL ) ) 
mobj -> movecount < INT_CONST * INT_CONST ) 
iquehead == iquetail ) 
mobj ) 
( thinker_t * ) mobj ) 
deathmatch != INT_CONST ) 
iquehead == iquetail ) 
leveltime - itemrespawntime [ iquetail ] < INT_CONST * INT_CONST ) 
x , y ) 
FOR ( i = INT_CONST ; i < NUMMOBJTYPES ; i v++ ) 
mobjinfo [ i ] . flags & MF_SPAWNCEILING ) 
x , y , z , i ) 
x , y , z , MT_PLAYER ) 
deathmatch ) 
FOR ( i = INT_CONST ; i < NUMCARDS ; i v++ ) 
) 
) 
! deathmatch ) 
! ( mthing -> options & bit ) ) 
FOR ( i = INT_CONST ; i < NUMMOBJTYPES ; i v++ ) 
mobjinfo [ i ] . flags & MF_SPAWNCEILING ) 
th -> momx >> INT_CONST ) 
source -> x , source -> y , dest -> x , dest -> y ) 
th -> info -> speed , finecosine [ an ] ) 
dest -> z - source -> z ) 
source , an , INT_CONST * INT_CONST * FRACUNIT ) 
! linetarget ) 
! linetarget ) 
th -> info -> speed , NEW_LINE finecosine [ an >> ANGLETOFINESHIFT ] ) 
__E__O__F__
plat ) 
res == pastdest ) 
type ) 
sec -> specialdata ) 
FOR ( i = INT_CONST ; i < MAXPLATS ; i v++ ) 
FOR ( j = INT_CONST ; j < MAXPLATS ; j v++ ) 
FOR ( i = INT_CONST ; i < MAXPLATS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLATS ; i v++ ) 
__E__O__F__
state -> misc1 ) 
state -> action . acp2 ) 
ammo == am_noammo || player -> ammo [ ammo ] >= count ) 
player -> mo -> state == &v states [ S_PLAY_ATK1 ] NEW_LINE || player -> mo -> state == &v states [ S_PLAY_ATK2 ] ) 
player -> pendingweapon != wp_nochange || ! player -> health ) 
player , ps_weapon , newstate ) 
player -> cmd . buttons & BT_ATTACK ) 
INT_CONST * leveltime ) 
( player -> cmd . buttons & BT_ATTACK ) NEW_LINE && player -> pendingweapon == wp_nochange NEW_LINE && player -> health ) 
player -> playerstate == PST_DEAD ) 
! player -> health ) 
player , ps_weapon , S_NULL ) 
player , ps_weapon , newstate ) 
player -> mo , angle , MELEERANGE + INT_CONST ) 
mo , an , INT_CONST * INT_CONST * FRACUNIT ) 
mo , angle , MISSILERANGE , bulletslope , damage ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
MISSILERANGE , NEW_LINE bulletslope + ( ( P_Random ( ) - P_Random ( ) ) << INT_CONST ) , damage ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mo -> target , an , INT_CONST * INT_CONST * FRACUNIT ) 
! linetarget ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i < NUMPSPRITES ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMPSPRITES ; i v++ , psp v++ ) 
( state = psp -> state ) ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numvertexes ; i v++ , li v++ , ml v++ ) 
FOR ( i = INT_CONST ; i < numsegs ; i v++ , li v++ , ml v++ ) 
FOR ( i = INT_CONST ; i < numsubsectors ; i v++ , ss v++ , ms v++ ) 
FOR ( i = INT_CONST ; i < numsectors ; i v++ , ss v++ , ms v++ ) 
FOR ( i = INT_CONST ; i < numnodes ; i v++ , no v++ , mn v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
FOR ( i = INT_CONST ; i < numthings ; i v++ , mt v++ ) 
gamemode != commercial ) 
mt -> x ) 
FOR ( i = INT_CONST ; i < numlines ; i v++ , mld v++ , ld v++ ) 
v1 -> y < v2 -> y ) 
mld -> sidenum [ INT_CONST ] ) 
ld -> sidenum [ INT_CONST ] != -v INT_CONST ) 
FOR ( i = INT_CONST ; i < numsides ; i v++ , msd v++ , sd v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( i = INT_CONST ; i < numsubsectors ; i v++ , ss v++ ) 
FOR ( i = INT_CONST ; i < numlines ; i v++ , li v++ ) 
li -> backsector && li -> backsector != li -> frontsector ) 
FOR ( i = INT_CONST ; i < numsectors ; i v++ , sector v++ ) 
FOR ( j = INT_CONST ; j < numlines ; j v++ , li v++ ) 
bbox [ BOXBOTTOM ] - bmaporgy - MAXRADIUS ) 
bbox [ BOXRIGHT ] - bmaporgx + MAXRADIUS ) 
bbox [ BOXLEFT ] - bmaporgx - MAXRADIUS ) 
INT episode , NEW_LINE INT map , NEW_LINE INT playermask , NEW_LINE skill_t skill ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
) 
deathmatch ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
__E__O__F__
left == right ) 
FOR ( ; count ; seg v++ , count v-- ) 
line -> validcount == validcount ) 
s1 == s2 ) 
s1 == s2 ) 
! ( line -> flags & ML_TWOSIDED ) ) 
front -> floorheight == back -> floorheight NEW_LINE && front -> ceilingheight == back -> ceilingheight ) 
front -> ceilingheight < back -> ceilingheight ) 
front -> floorheight > back -> floorheight ) 
INT bspnum ) 
strace . x , strace . y , ( divline_t * ) bsp ) 
! P_CrossBSPNode ( bsp -> children [ side ] ) ) 
bsp -> children [ side ^ INT_CONST ] ) 
t1 -> subsector -> sector - sectors ) 
__E__O__F__
FOR ( i = INT_CONST ; animdefs [ i ] . istexture != -v INT_CONST ; i v++ ) 
lastanim -> numpics < INT_CONST ) 
INT currentSector , NEW_LINE INT line , NEW_LINE INT side ) 
FOR ( i = INT_CONST ; i < sec -> linecount ; i v++ ) 
! other ) 
FOR ( i = INT_CONST ; i < sec -> linecount ; i v++ ) 
FOR ( i = INT_CONST , h = INT_CONST ; i < sec -> linecount ; i v++ ) 
! other ) 
h >= MAX_ADJOINING_SECTORS ) 
! h ) 
FOR ( i = INT_CONST ; i < h ; i v++ ) 
FOR ( i = INT_CONST ; i < sec -> linecount ; i v++ ) 
! other ) 
FOR ( i = INT_CONST ; i < sec -> linecount ; i v++ ) 
! other ) 
FOR ( i = start + INT_CONST ; i < numsectors ; i v++ ) 
FOR ( i = INT_CONST ; i < sector -> linecount ; i v++ ) 
! check ) 
! thing -> player ) 
thing -> type ) 
line -> special ) 
line , open ) 
line , close ) 
line , normal ) 
line , raiseFloor ) 
line , fastCrushAndRaise ) 
line , build8 ) 
line , downWaitUpStay , INT_CONST ) 
line , INT_CONST ) 
line , INT_CONST ) 
line , close30ThenOpen ) 
line ) 
line , lowerFloor ) 
line , raiseToNearestAndChange , INT_CONST ) 
line , crushAndRaise ) 
line , raiseToTexture ) 
line , INT_CONST ) 
line , turboLower ) 
line , lowerAndChange ) 
line , lowerFloorToLowest ) 
line , side , thing ) 
line , raiseToHighest ) 
line , lowerAndCrush ) 
) 
line , perpetualRaise , INT_CONST ) 
line ) 
line , raiseFloorCrush ) 
line ) 
line , raiseFloor24 ) 
line , raiseFloor24AndChange ) 
line ) 
line , blazeRaise ) 
line , blazeOpen ) 
line , turbo16 ) 
line , blazeClose ) 
line , raiseFloorToNearest ) 
line , blazeDWUS , INT_CONST ) 
) 
! thing -> player ) 
line , raiseFloorTurbo ) 
line , silentCrushAndRaise ) 
line , lowerAndCrush ) 
line , crushAndRaise ) 
line ) 
line , close ) 
line , close30ThenOpen ) 
line , fastCrushAndRaise ) 
line , INT_CONST ) 
line , INT_CONST ) 
line , INT_CONST ) 
line , lowerFloorToLowest ) 
line , lowerFloor ) 
line , lowerAndChange ) 
line , open ) 
line , perpetualRaise , INT_CONST ) 
line , downWaitUpStay , INT_CONST ) 
line ) 
line , normal ) 
line , raiseFloor ) 
line , raiseFloor24 ) 
line , raiseFloor24AndChange ) 
line , raiseFloorCrush ) 
line , raiseToNearestAndChange , INT_CONST ) 
line , raiseToTexture ) 
line , side , thing ) 
line , turboLower ) 
line , blazeRaise ) 
line , blazeOpen ) 
line , blazeClose ) 
line , blazeDWUS , INT_CONST ) 
! thing -> player ) 
line , raiseFloorToNearest ) 
line , raiseFloorTurbo ) 
! thing -> player ) 
line , raiseFloor ) 
line , open ) 
line , raiseToNearestAndChange , INT_CONST ) 
sector -> special ) 
! player -> powers [ pw_ironfeet ] ) 
! player -> powers [ pw_ironfeet ] ) 
! player -> powers [ pw_ironfeet ] NEW_LINE || ( P_Random ( ) < INT_CONST ) ) 
! ( leveltime & INT_CONST ) ) 
levelTimer == true ) 
FOR ( anim = anims ; anim < lastanim ; anim v++ ) 
FOR ( i = anim -> basepic ; i < anim -> basepic + anim -> numpics ; i v++ ) 
FOR ( i = INT_CONST ; i < numlinespecials ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXBUTTONS ; i v++ ) 
line_t * line ) 
FOR ( i = INT_CONST ; i < s2 -> linecount ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < numsectors ; i v++ , sector v++ ) 
FOR ( i = INT_CONST ; i < numlines ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXCEILINGS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLATS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXBUTTONS ; i v++ ) 
__E__O__F__
FOR ( index = INT_CONST , i = INT_CONST ; i < MAXSWITCHES ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXBUTTONS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXBUTTONS ; i v++ ) 
line -> special == INT_CONST ) 
FOR ( i = INT_CONST ; i < numswitches * INT_CONST ; i v++ ) 
! thing -> player ) 
line -> flags & ML_SECRET ) 
line -> special ) 
line , thing ) 
EV_BuildStairs ( line , build8 ) ) 
EV_DoDonut ( line ) ) 
line , INT_CONST ) 
EV_DoPlat ( line , raiseAndChange , INT_CONST ) ) 
EV_DoPlat ( line , raiseAndChange , INT_CONST ) ) 
EV_DoFloor ( line , raiseFloorToNearest ) ) 
EV_DoPlat ( line , raiseToNearestAndChange , INT_CONST ) ) 
EV_DoPlat ( line , downWaitUpStay , INT_CONST ) ) 
EV_DoFloor ( line , lowerFloorToLowest ) ) 
EV_DoDoor ( line , normal ) ) 
EV_DoCeiling ( line , lowerToFloor ) ) 
EV_DoFloor ( line , turboLower ) ) 
EV_DoCeiling ( line , crushAndRaise ) ) 
EV_DoDoor ( line , close ) ) 
line , INT_CONST ) 
EV_DoFloor ( line , raiseFloorCrush ) ) 
EV_DoFloor ( line , raiseFloor ) ) 
EV_DoFloor ( line , lowerFloor ) ) 
EV_DoDoor ( line , open ) ) 
EV_DoDoor ( line , blazeRaise ) ) 
EV_DoDoor ( line , blazeOpen ) ) 
EV_DoDoor ( line , blazeClose ) ) 
EV_DoPlat ( line , blazeDWUS , INT_CONST ) ) 
EV_BuildStairs ( line , turbo16 ) ) 
EV_DoFloor ( line , raiseFloorTurbo ) ) 
EV_DoLockedDoor ( line , blazeOpen , thing ) ) 
EV_DoFloor ( line , raiseFloor512 ) ) 
EV_DoDoor ( line , close ) ) 
EV_DoCeiling ( line , lowerToFloor ) ) 
EV_DoFloor ( line , lowerFloor ) ) 
EV_DoFloor ( line , lowerFloorToLowest ) ) 
EV_DoDoor ( line , open ) ) 
EV_DoPlat ( line , downWaitUpStay , INT_CONST ) ) 
EV_DoDoor ( line , normal ) ) 
EV_DoFloor ( line , raiseFloor ) ) 
EV_DoPlat ( line , raiseAndChange , INT_CONST ) ) 
EV_DoPlat ( line , raiseAndChange , INT_CONST ) ) 
EV_DoFloor ( line , raiseFloorCrush ) ) 
EV_DoPlat ( line , raiseToNearestAndChange , INT_CONST ) ) 
EV_DoFloor ( line , raiseFloorToNearest ) ) 
EV_DoFloor ( line , turboLower ) ) 
EV_DoDoor ( line , blazeRaise ) ) 
EV_DoDoor ( line , blazeOpen ) ) 
EV_DoDoor ( line , blazeClose ) ) 
EV_DoPlat ( line , blazeDWUS , INT_CONST ) ) 
EV_DoFloor ( line , raiseFloorTurbo ) ) 
EV_DoLockedDoor ( line , blazeOpen , thing ) ) 
line , INT_CONST ) 
line , INT_CONST ) 
__E__O__F__
side == INT_CONST ) 
FOR ( i = INT_CONST ; i < numsectors ; i v++ ) 
FOR ( thinker = thinkercap . next ; NEW_LINE thinker != &v thinkercap ; NEW_LINE thinker = thinker -> next ) 
__E__O__F__
paused ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
__E__O__F__
player -> mo -> momx , player -> mo -> momx ) 
player -> bob > MAXBOB ) 
( player -> cheats & CF_NOMOMENTUM ) || ! onground ) 
player -> viewz > player -> mo -> ceilingz - INT_CONST * FRACUNIT ) 
player -> playerstate == PST_LIVE ) 
player -> viewheight > VIEWHEIGHT ) 
player -> viewheight < VIEWHEIGHT / INT_CONST ) 
( cmd -> forwardmove || cmd -> sidemove ) NEW_LINE && player -> mo -> state == &v states [ S_PLAY ] ) 
player -> viewheight < INT_CONST * FRACUNIT ) 
player -> mo -> z <= player -> mo -> floorz ) 
player -> attacker -> y ) 
player -> cmd . buttons & BT_USE ) 
player -> mo -> flags & MF_JUSTATTACKED ) 
player -> mo -> reactiontime ) 
player -> mo -> subsector -> sector -> special ) 
cmd -> buttons & BT_SPECIAL ) 
cmd -> buttons & BT_WEAPONMASK ) 
player -> weaponowned [ newweapon ] NEW_LINE && newweapon != player -> readyweapon ) 
cmd -> buttons & BT_USE ) 
player ) 
player -> powers [ pw_strength ] ) 
player -> powers [ pw_invisibility ] ) 
player -> powers [ pw_invulnerability ] ) 
__E__O__F__
first < start -> first ) 
next -> last + INT_CONST , ( next + INT_CONST ) -> first - INT_CONST ) 
first < start -> first ) 
start -> last + INT_CONST , ( start + INT_CONST ) -> first - INT_CONST ) 
line -> v1 -> x , line -> v1 -> y ) 
span >= ANG180 ) 
tspan > INT_CONST * clipangle ) 
tspan >= span ) 
tspan >= span ) 
angle1 + ANG90 ) 
backsector -> ceilingheight <= frontsector -> floorheight NEW_LINE || backsector -> floorheight >= frontsector -> ceilingheight ) 
backsector -> ceilingheight != frontsector -> ceilingheight NEW_LINE || backsector -> floorheight != frontsector -> floorheight ) 
viewx <= bspcoord [ BOXLEFT ] ) 
x1 , y1 ) 
tspan > INT_CONST * clipangle ) 
tspan >= span ) 
tspan >= span ) 
bspnum & ( ~ NF_SUBSECTOR ) ) 
viewx , viewy , bsp ) 
__E__O__F__
position < INT_CONST ) 
position + count > cacheheight ) 
FOR ( i = INT_CONST , patch = texture -> patches ; NEW_LINE i < texture -> patchcount ; NEW_LINE i v++ , patch v++ ) 
x1 < INT_CONST ) 
FOR ( ; x < x2 ; x v++ ) 
byte * ) 
FOR ( i = INT_CONST , patch = texture -> patches ; NEW_LINE i < texture -> patchcount ; NEW_LINE i v++ , patch v++ ) 
FOR ( ; x < x2 ; x v++ ) 
FOR ( x = INT_CONST ; x < texture -> width ; x v++ ) 
patchcount [ x ] > INT_CONST ) 
texturecompositesize [ texnum ] > INT_CONST - texture -> height ) 
! texturecomposite [ tex ] ) 
STRING , PU_STATIC ) 
FOR ( i = INT_CONST ; i < nummappatches ; i v++ ) 
STRING , PU_STATIC ) 
STRING ) 
FOR ( i = INT_CONST ; i < temp3 ; i v++ ) 
FOR ( i = INT_CONST ; i < temp3 ; i v++ ) 
FOR ( i = INT_CONST ; i < numtextures ; i v++ , directory v++ ) 
texture -> name , mtexture -> name , SIZEOF ( texture -> name ) ) 
FOR ( j = INT_CONST ; j < texture -> patchcount ; j v++ , mpatch v++ , patch v++ ) 
j * INT_CONST <= texture -> width ) 
FOR ( i = INT_CONST ; i < numtextures ; i v++ ) 
( numtextures + INT_CONST ) * INT_CONST , PU_STATIC , INT_CONST ) 
FOR ( i = INT_CONST ; i < numtextures ; i v++ ) 
FOR ( i = INT_CONST ; i < numflats ; i v++ ) 
FOR ( i = INT_CONST ; i < numspritelumps ; i v++ ) 
STRING ) 
FOR ( i = INT_CONST ; i < numtextures ; i v++ ) 
numflats ) 
FOR ( i = INT_CONST ; i < numsectors ; i v++ ) 
FOR ( i = INT_CONST ; i < numflats ; i v++ ) 
numtextures ) 
FOR ( i = INT_CONST ; i < numsides ; i v++ ) 
FOR ( i = INT_CONST ; i < numtextures ; i v++ ) 
FOR ( j = INT_CONST ; j < texture -> patchcount ; j v++ ) 
numsprites ) 
FOR ( th = thinkercap . next ; th != &v thinkercap ; th = th -> next ) 
FOR ( i = INT_CONST ; i < numsprites ; i v++ ) 
FOR ( j = INT_CONST ; j < sprites [ i ] . numframes ; j v++ ) 
FOR ( k = INT_CONST ; k < INT_CONST ; k v++ ) 
__E__O__F__
frac >> FRACBITS ) 
frac + fracstep ) 
frac >> FRACBITS ) 
dc_yl - centery ) 
++v fuzzpos == FUZZTABLE ) 
dc_yl - centery ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
( yfrac >> ( INT_CONST - INT_CONST ) ) & ( INT_CONST * INT_CONST ) ) 
FOR ( i = INT_CONST ; i < width ; i v++ ) 
FOR ( i = INT_CONST ; i < height ; i v++ ) 
FOR ( y = INT_CONST ; y < SCREENHEIGHT - SBARHEIGHT ; y v++ ) 
FOR ( x = INT_CONST ; x < SCREENWIDTH / INT_CONST ; x v++ ) 
FOR ( x = INT_CONST ; x < scaledviewwidth ; x += INT_CONST ) 
FOR ( x = INT_CONST ; x < scaledviewwidth ; x += INT_CONST ) 
FOR ( y = INT_CONST ; y < viewheight ; y += INT_CONST ) 
FOR ( y = INT_CONST ; y < viewheight ; y += INT_CONST ) 
viewwindowx - INT_CONST , NEW_LINE viewwindowy - INT_CONST , NEW_LINE INT_CONST , NEW_LINE W_CacheLumpName ( STRING , PU_CACHE ) ) 
FOR ( i = INT_CONST ; i < viewheight ; i v++ ) 
__E__O__F__
x >= INT_CONST ) 
y >= INT_CONST ) 
y >= INT_CONST ) 
FOR ( i = INT_CONST ; i <= SLOPERANGE ; i v++ ) 
scale > INT_CONST * FRACUNIT ) 
FOR ( i = INT_CONST ; i < FINEANGLES / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST * FINEANGLES / INT_CONST ; i v++ ) 
i + FLOAT_CONST ) 
centerxfrac , NEW_LINE finetangent [ FINEANGLES / INT_CONST + FIELDOFVIEW / INT_CONST ] ) 
FOR ( i = INT_CONST ; i < FINEANGLES / INT_CONST ; i v++ ) 
FOR ( x = INT_CONST ; x <= viewwidth ; x v++ ) 
FOR ( i = INT_CONST ; i < FINEANGLES / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < LIGHTLEVELS ; i v++ ) 
FOR ( j = INT_CONST ; j < MAXLIGHTZ ; j v++ ) 
FOR ( i = INT_CONST ; i < viewwidth ; i v++ ) 
FOR ( i = INT_CONST ; i < viewheight ; i v++ ) 
FOR ( i = INT_CONST ; i < viewwidth ; i v++ ) 
FOR ( i = INT_CONST ; i < LIGHTLEVELS ; i v++ ) 
FOR ( j = INT_CONST ; j < MAXLIGHTSCALE ; j v++ ) 
FOR ( i = INT_CONST ; i < MAXLIGHTSCALE ; i v++ ) 
) 
) 
) 
) 
__E__O__F__
FOR ( i = INT_CONST ; i < viewwidth ; i v++ ) 
cachedheight , INT_CONST , SIZEOF ( cachedheight ) ) 
FOR ( check = visplanes ; check < lastvisplane ; check v++ ) 
FOR ( x = intrl ; x <= intrh ; x v++ ) 
pl -> top , INT_CONST , SIZEOF ( pl -> top ) ) 
FOR ( pl = visplanes ; pl < lastvisplane ; pl v++ ) 
FOR ( x = pl -> minx ; x <= pl -> maxx ; x v++ ) 
light >= LIGHTLEVELS ) 
FOR ( x = pl -> minx ; x <= stop ; x v++ ) 
__E__O__F__
frontsector -> lightlevel >> LIGHTSEGSHIFT ) 
lightnum < INT_CONST ) 
x1 - ds -> x1 ) 
curline -> linedef -> flags & ML_DONTPEGBOTTOM ) 
FOR ( dc_x = x1 ; dc_x <= x2 ; dc_x v++ ) 
maskedtexturecol [ dc_x ] != MAXSHORT ) 
VOID ) 
FOR ( ; rw_x < rw_stopx ; rw_x v++ ) 
topfrac + HEIGHTUNIT - INT_CONST ) 
yl < ceilingclip [ rw_x ] + INT_CONST ) 
start >= viewwidth || start > stop ) 
rw_normalangle - rw_angle1 ) 
curline -> v1 -> x , curline -> v1 -> y ) 
viewangle + xtoviewangle [ start ] ) 
rw_distance < FRACUNIT / INT_CONST ) 
! backsector ) 
linedef -> flags & ML_DONTPEGBOTTOM ) 
frontsector -> floorheight > backsector -> floorheight ) 
worldhigh < worldtop ) 
segtextured ) 
rw_normalangle - rw_angle1 < ANG180 ) 
! fixedcolormap ) 
frontsector -> floorheight >= viewz ) 
rw_scalestep , worldtop ) 
worldhigh < worldtop ) 
markceiling ) 
) 
( ( ds_p -> silhouette & SIL_TOP ) || maskedtexture ) NEW_LINE && ! ds_p -> sprtopclip ) 
__E__O__F__
sprtemp [ frame ] . rotate == false ) 
FOR ( r = INT_CONST ; r < INT_CONST ; r v++ ) 
! numsprites ) 
FOR ( i = INT_CONST ; i < numsprites ; i v++ ) 
FOR ( l = start + INT_CONST ; l < end ; l v++ ) 
FOR ( frame = INT_CONST ; frame < maxframe ; frame v++ ) 
FOR ( rotation = INT_CONST ; rotation < INT_CONST ; rotation v++ ) 
FOR ( i = INT_CONST ; i < SCREENWIDTH ; i v++ ) 
FOR ( ; column -> topdelta != INT_CONST ; ) 
topscreen + FRACUNIT - INT_CONST ) 
FOR ( dc_x = vis -> x1 ; dc_x <= vis -> x2 ; dc_x v++ , frac += vis -> xiscale ) 
tr_x , viewcos ) 
tz < MINZ ) 
( UNSIGNED ) thing -> sprite >= numsprites ) 
thing -> x , thing -> y ) 
boolean ) 
centerxfrac + FixedMul ( tx , xscale ) ) 
) 
thing -> flags & MF_SHADOW ) 
LIGHTSCALESHIFT - detailshift ) 
index >= MAXLIGHTSCALE ) 
sec -> lightlevel >> LIGHTSEGSHIFT ) 
FOR ( thing = sec -> thinglist ; thing ; thing = thing -> snext ) 
( UNSIGNED ) psp -> state -> sprite >= numsprites ) 
centerxfrac + FixedMul ( tx , pspritescale ) ) 
( centerxfrac + FixedMul ( tx , pspritescale ) ) >> FRACBITS ) 
BASEYCENTER << FRACBITS ) 
viewplayer -> powers [ pw_invisibility ] > INT_CONST * INT_CONST NEW_LINE || viewplayer -> powers [ pw_invisibility ] & INT_CONST ) 
viewplayer -> mo -> subsector -> sector -> lightlevel >> LIGHTSEGSHIFT ) 
FOR ( i = INT_CONST , psp = viewplayer -> psprites ; NEW_LINE i < NUMPSPRITES ; NEW_LINE i v++ , psp v++ ) 
FOR ( ds = vissprites ; ds < vissprite_p ; ds v++ ) 
FOR ( i = INT_CONST ; i < count ; i v++ ) 
FOR ( ds = unsorted . next ; ds != &v unsorted ; ds = ds -> next ) 
FOR ( x = spr -> x1 ; x <= spr -> x2 ; x v++ ) 
FOR ( ds = ds_p - INT_CONST ; ds >= drawsegs ; ds v-- ) 
ds -> x1 > spr -> x2 NEW_LINE || ds -> x2 < spr -> x1 NEW_LINE || ( ! ds -> silhouette NEW_LINE && ! ds -> maskedtexturecol ) ) 
ds -> scale1 > ds -> scale2 ) 
FOR ( x = r1 ; x <= r2 ; x v++ ) 
FOR ( x = r1 ; x <= r2 ; x v++ ) 
FOR ( x = r1 ; x <= r2 ; x v++ ) 
FOR ( x = spr -> x1 ; x <= spr -> x2 ; x v++ ) 
FOR ( spr = vsprsortedhead . next ; NEW_LINE spr != &v vsprsortedhead ; NEW_LINE spr = spr -> next ) 
FOR ( ds = ds_p - INT_CONST ; ds >= drawsegs ; ds v-- ) 
! viewangleoffset ) 
__E__O__F__
__E__O__F__
__E__O__F__
__E__O__F__
neg ) 
x , n -> y - ST_Y , BG , w * numdigits , h , x , n -> y , FG ) 
! num ) 
num && numdigits v-- ) 
y - ST_Y < INT_CONST ) 
__E__O__F__
netgame ) 
FOR ( i = INT_CONST ; i < NUMWEAPONS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMAMMO ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMWEAPONS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMAMMO ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMCARDS ; i v++ ) 
plyr -> cheats & CF_NOCLIP ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
cht_CheckCheat ( &v cheat_clev , ev -> data1 ) ) 
map < INT_CONST ) 
( gamemode == registered ) NEW_LINE && ( ( epsd > INT_CONST ) || ( map > INT_CONST ) ) ) 
( gamemode == shareware ) NEW_LINE && ( ( epsd > INT_CONST ) || ( map > INT_CONST ) ) ) 
( gamemode == commercial ) NEW_LINE && ( ( epsd > INT_CONST ) || ( map > INT_CONST ) ) ) 
gameskill , epsd , map ) 
health != oldhealth ) 
! plyr -> health ) 
FOR ( i = INT_CONST ; i < NUMWEAPONS ; i v++ ) 
plyr -> damagecount ) 
plyr -> attackdown ) 
( plyr -> cheats & CF_GODMODE ) NEW_LINE || plyr -> powers [ pw_invulnerability ] ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
plyr -> cards [ i + INT_CONST ] ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
plyr -> powers [ pw_strength ] >> INT_CONST ) 
palette >= NUMBONUSPALS ) 
palette != st_palette ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v w_faces , refresh ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v w_frags , refresh ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
namebuf , STRING , i ) 
FOR ( i = INT_CONST ; i < NUMCARDS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
patch_t * ) 
FOR ( i = INT_CONST ; i < ST_NUMPAINFACES ; i v++ ) 
FOR ( j = INT_CONST ; j < ST_NUMSTRAIGHTFACES ; j v++ ) 
namebuf , PU_STATIC ) 
namebuf , PU_STATIC ) 
namebuf , PU_STATIC ) 
namebuf , PU_STATIC ) 
namebuf , PU_STATIC ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMCARDS ; i v++ ) 
sbar , PU_CACHE ) 
FOR ( i = INT_CONST ; i < ST_NUMFACES ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMWEAPONS ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
&v st_faceindex , NEW_LINE &v st_statusbaron ) 
) 
W_CacheLumpNum ( lu_palette , PU_CACHE ) ) 
__E__O__F__
num << INT_CONST ) 
__E__O__F__
FOR ( ; height > INT_CONST ; height v-- ) 
patch -> width ) 
FOR ( ; col < w ; x v++ , col v++ , desttop v++ ) 
column -> topdelta != INT_CONST ) 
patch -> width ) 
FOR ( ; col < w ; x v++ , col v++ , desttop v++ ) 
column -> topdelta != INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
__E__O__F__
src != path NEW_LINE && *v ( src - INT_CONST ) != CHAR_CONST NEW_LINE && *v ( src - INT_CONST ) != CHAR_CONST ) 
dest , INT_CONST , INT_CONST ) 
filename [ INT_CONST ] == CHAR_CONST ) 
filelength ( handle ) ) 
handle , &v header , SIZEOF ( header ) ) 
lumpinfo , numlumps * SIZEOF ( lumpinfo_t ) ) 
FOR ( i = startlump ; i < numlumps ; i v++ , lump_p v++ , fileinfo v++ ) 
handle , &v header , SIZEOF ( header ) ) 
FOR ( i = reloadlump ; NEW_LINE i < reloadlump + lumpcount ; NEW_LINE i v++ , lump_p v++ , fileinfo v++ ) 
INT_CONST ) 
FOR ( ; *v filenames ; filenames v++ ) 
! numlumps ) 
*v lumpcache ) 
lumpcache , INT_CONST , size ) 
name8 . s , name , INT_CONST ) 
l -> handle == -v INT_CONST ) 
( handle = open ( reloadname , O_RDONLY | O_BINARY ) ) == -v INT_CONST ) 
W_LumpLength ( lump ) , tag , &v lumpcache [ lump ] ) 
lumpcache [ lump ] , tag ) 
FOR ( i = INT_CONST ; i < numlumps ; i v++ ) 
FOR ( i = INT_CONST ; i < numlumps ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( ; j < INT_CONST ; j v++ ) 
FOR ( j = INT_CONST ; j < profilecount ; j v++ ) 
__E__O__F__
) 
__E__O__F__
left >= INT_CONST NEW_LINE && right < SCREENWIDTH NEW_LINE && top >= INT_CONST NEW_LINE && bottom < SCREENHEIGHT ) 
STRING , n + INT_CONST ) 
wbs -> epsd > INT_CONST ) 
FOR ( i = INT_CONST ; i < NUMANIMS [ wbs -> epsd ] ; i v++ ) 
a -> type == ANIM_ALWAYS ) 
wbs -> epsd > INT_CONST ) 
FOR ( i = INT_CONST ; i < NUMANIMS [ wbs -> epsd ] ; i v++ ) 
bcnt == a -> nexttic ) 
a -> ctr == a -> nanims ) 
! ( state == StatCount && i == INT_CONST ) NEW_LINE && wbs -> next == a -> data1 ) 
wbs -> epsd > INT_CONST ) 
FOR ( i = INT_CONST ; i < NUMANIMS [ wbs -> epsd ] ; i v++ ) 
a -> ctr >= INT_CONST ) 
n == INT_CONST ) 
digits v-- ) 
x , y , FB , percent ) 
t <= INT_CONST * INT_CONST ) 
x - SHORT ( sucks -> width ) , y , FB , sucks ) 
FOR ( i = INT_CONST ; i <= last ; i v++ ) 
wbs -> didsecret ) 
snl_pointeron ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( j = INT_CONST ; j < MAXPLAYERS ; j v++ ) 
) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( j = INT_CONST ; j < MAXPLAYERS ; j v++ ) 
INT_CONST , sfx_barexp ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( j = INT_CONST ; j < MAXPLAYERS ; j v++ ) 
) 
) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
playeringame [ i ] ) 
FOR ( j = INT_CONST ; j < MAXPLAYERS ; j v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
i ) 
) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
i == me ) 
dofrags ) 
! ( bcnt & INT_CONST ) ) 
! ( bcnt & INT_CONST ) ) 
! ( bcnt & INT_CONST ) ) 
cnt_time >= plrs [ me ] . stime / TICRATE ) 
cnt_par >= wbs -> partime / TICRATE ) 
SP_STATSX , SP_STATSY , FB , kills ) 
FOR ( i = INT_CONST , player = players ; i < MAXPLAYERS ; i v++ , player v++ ) 
gamemode == commercial ) 
gamemode == commercial ) 
FOR ( i = INT_CONST ; i < NUMCMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMMAPS ; i v++ ) 
STRING , PU_STATIC ) 
STRING , PU_STATIC ) 
STRING , PU_STATIC ) 
FOR ( j = INT_CONST ; j < NUMANIMS [ wbs -> epsd ] ; j v++ ) 
FOR ( i = INT_CONST ; i < a -> nanims ; i v++ ) 
name , STRING , wbs -> epsd , j , i ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
netgame && ! deathmatch ) 
STRING , PU_STATIC ) 
STRING , PU_STATIC ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
name , STRING , i ) 
name , STRING , i + INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMCMAPS ; i v++ ) 
splat , PU_CACHE ) 
FOR ( i = INT_CONST ; i < NUMMAPS ; i v++ ) 
FOR ( j = INT_CONST ; j < NUMANIMS [ wbs -> epsd ] ; j v++ ) 
FOR ( i = INT_CONST ; i < anims [ wbs -> epsd ] [ j ] . nanims ; i v++ ) 
percent , PU_CACHE ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
! wbs -> maxitems ) 
! wbs -> maxsecret ) 
gamemode != retail ) 
__E__O__F__
memzone_t ) 
VOID *p ) 
block == mainzone -> rover ) 
other == mainzone -> rover ) 
memblock_t ) 
! base -> prev -> user ) 
extra > MINFRAGMENT ) 
memblock_t * ) 
VOID *p *p ) 
VOID *p ) 
VOID *p ) 
FOR ( block = mainzone -> blocklist . next ; NEW_LINE block != &v mainzone -> blocklist ; NEW_LINE block = next ) 
! block -> user ) 
STRING , NEW_LINE lowtag , hightag ) 
FOR ( block = mainzone -> blocklist . next ; ; block = block -> next ) 
FOR ( block = mainzone -> blocklist . next ; ; block = block -> next ) 
FOR ( block = mainzone -> blocklist . next ; ; block = block -> next ) 
tag >= PU_PURGELEVEL && ( UNSIGNED ) block -> user < INT_CONST ) 
FOR ( block = mainzone -> blocklist . next ; NEW_LINE block != &v mainzone -> blocklist ; NEW_LINE block = block -> next ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( j = INT_CONST ; j < NUMPSPRITES ; j v++ ) 
FOR ( i = INT_CONST ; i < MAXPLAYERS ; i v++ ) 
FOR ( j = INT_CONST ; j < NUMPSPRITES ; j v++ ) 
FOR ( i = INT_CONST , sec = sectors ; i < numsectors ; i v++ , sec v++ ) 
FOR ( i = INT_CONST , li = lines ; i < numlines ; i v++ , li v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( i = INT_CONST , sec = sectors ; i < numsectors ; i v++ , sec v++ ) 
FOR ( i = INT_CONST , li = lines ; i < numlines ; i v++ , li v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
FOR ( th = thinkercap . next ; th != &v thinkercap ; th = th -> next ) 
currentthinker != &v thinkercap ) 
FOR ( th = thinkercap . next ; th != &v thinkercap ; th = th -> next ) 
FOR ( i = INT_CONST ; i < MAXCEILINGS ; i v++ ) 
i < MAXCEILINGS ) 
) 
) 
) 
) 
) 
) 
STRING NEW_LINE STRING , tclass ) 
__E__O__F__
__E__O__F__
__E__O__F__
__E__O__F__
__E__O__F__
__E__O__F__
FOR ( i = INT_CONST ; i <= maxscaleheight ; i v++ ) 
FOR ( i = INT_CONST ; i <= maxscaleheight ; i v++ ) 
FOR ( i = maxscaleheight ; i < MAXSCALEHEIGHT ; i v++ ) 
t_compscale far * ) 
( LONG ) height << INT_CONST ) 
FOR ( src = INT_CONST ; src <= INT_CONST ; src v++ ) 
FOR ( ; startpix < endpix ; startpix v++ ) 
code ) 
shapenum ) 
! scale || scale > maxscale ) 
( ( UNSIGNED *p ) & linescale ) + INT_CONST ) 
( ( UNSIGNED *p ) & linecmds ) + INT_CONST ) 
--v srcx >= stopx && slinex > INT_CONST ) 
) 
shape -> leftpix < INT_CONST ) 
++v srcx <= stopx && ( slinex += slinewidth ) < viewwidth ) 
shapenum ) 
( ( UNSIGNED *p ) & linescale ) + INT_CONST ) 
( ( UNSIGNED *p ) & linecmds ) + INT_CONST ) 
--v srcx >= stopx ) 
shape -> leftpix < INT_CONST ) 
++v srcx <= stopx ) 
__E__O__F__
sbReset , true ) 
sbReset , false ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
false ) 
port == INT_CONST ) 
port == -v INT_CONST ) 
SDL_CheckSB ( INT_CONST ) ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
__E__O__F__
LONG far * ) 
value == INT_CONST ) 
( handle = open ( filename , O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
filename , O_CREAT | O_BINARY | O_WRONLY , NEW_LINE S_IREAD | S_IWRITE | S_IFREG ) 
( handle = open ( filename , O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
length ) 
FOR ( i = INT_CONST ; i <= count ; i v++ ) 
FOR ( i = INT_CONST ; i <= count ; i v++ ) 
huffnode * ) 
grhuffman ) 
fname , gdictname ) 
( handle = open ( fname , NEW_LINE O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
fname , gheadname ) 
( handle = open ( fname , NEW_LINE O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
handle ) 
fname , gfilename ) 
fname , O_RDONLY | O_BINARY ) 
&v compseg , chunkcomplen ) 
fname , mheadname ) 
( handle = open ( fname , NEW_LINE O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
fname , STRING ) 
( maphandle = open ( fname , NEW_LINE O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
( maphandle = open ( fname , NEW_LINE O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < NUMMAPS ; i v++ ) 
FOR ( i = INT_CONST ; i < MAPPLANES ; i v++ ) 
fname , aheadname ) 
( handle = open ( fname , NEW_LINE O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
( audiohandle = open ( fname , NEW_LINE O_RDONLY | O_BINARY , S_IREAD ) ) == -v INT_CONST ) 
audiohandle , pos , SEEK_SET ) 
&v ( memptr ) audiosegs [ chunk ] , compressed ) 
compressed <= BUFFERSIZE ) 
LONG far * ) 
&v ( memptr ) audiosegs [ chunk ] , expanded ) 
compressed > BUFFERSIZE ) 
oldsoundmode ) 
FOR ( i = INT_CONST ; i < NUMSOUNDS ; i v++ , start v++ ) 
FOR ( i = INT_CONST ; i < NUMSOUNDS ; i v++ , start v++ ) 
chunk >= STARTTILE8 && chunk < STARTEXTERNS ) 
chunk < STARTTILE8M ) 
LONG far * ) 
&v grsegs [ chunk ] , expanded ) 
grsegs [ chunk ] ) 
chunk ) 
GRFILEPOS ( next ) == -v INT_CONST ) 
next ) 
grhandle , pos , SEEK_SET ) 
compressed <= BUFFERSIZE ) 
chunk , source ) 
compressed > BUFFERSIZE ) 
chunk ) 
next ) 
grhandle , pos , SEEK_SET ) 
&v bigbufferseg , compressed ) 
LONG far * ) 
source , MK_FP ( SCREENSEG , bufferofs ) , expanded , grhuffman , true ) 
FOR ( plane = INT_CONST ; plane < MAPPLANES ; plane v++ ) 
ca_levelnum == INT_CONST ) 
FOR ( i = INT_CONST ; i < NUMCHUNKS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMCHUNKS ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < NUMCHUNKS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMSNDCHUNKS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMCHUNKS ; i v++ ) 
FOR ( i = INT_CONST ; i < NUMCHUNKS ; i v++ ) 
&& bufferend >= endpos ) 
__E__O__F__
INT_CONST , ( temp = inportb ( INT_CONST ) ) | INT_CONST ) 
k == INT_CONST ) 
k == INT_CONST ) 
INL_KeyHook && ! special ) 
MButtons ) 
x < def -> threshMinX ) 
result ) 
) 
KeyInt ) 
KeyInt , OldKeyVect ) 
def -> threshMinX - def -> joyMinX ) 
( r / INT_CONST ) - d ) 
( r / INT_CONST ) - d ) 
joy ) 
joy , &v x , &v y ) 
NEW_LINE ( ( x == INT_CONST ) || ( x > MaxJoyValue - INT_CONST ) ) NEW_LINE || ( ( y == INT_CONST ) || ( y > MaxJoyValue - INT_CONST ) ) NEW_LINE ) 
IN_Started ) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
) 
FOR ( i = INT_CONST ; i < MaxJoys ; i v++ ) 
! IN_Started ) 
FOR ( i = INT_CONST ; i < MaxJoys ; i v++ ) 
Keyboard , INT_CONST , SIZEOF ( Keyboard ) ) 
DemoMode == demo_Playback ) 
realdelta ) 
INT_CONST << INT_CONST ) 
DemoMode == demo_Record ) 
! ( result = LastScan ) ) 
! ( result = LastASCII ) ) 
) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , buttons >>= INT_CONST ) 
LastScan ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , buttons >>= INT_CONST ) 
! IN_CheckAck ( ) ) 
) 
INT_CONST ) 
__E__O__F__
FOR ( i = INT_CONST ; i < numUMBs ; i v++ ) 
scan -> start + scan -> length < segstart ) 
segstart + seglength ) 
scan ) 
STRING ) 
mmstarted ) 
FOR ( i = INT_CONST ; i < MAXBLOCKS - INT_CONST ; i v++ ) 
) 
FP_OFF ( start ) & INT_CONST ) 
start ) 
) 
start ) 
&v bufferseg , BUFFERSIZE ) 
farheap ) 
size + INT_CONST ) 
FOR ( search = INT_CONST ; search < INT_CONST ; search v++ ) 
search == INT_CONST && mmrover == mmhead ) 
bombonerror ) 
UNSIGNED width , UNSIGNED height ) 
baseptr == mmrover -> useptr ) 
scan -> useptr != baseptr && scan ) 
! scan ) 
scan ) 
) 
) 
beforesort ) 
scan ) 
aftersort ) 
scan ) 
) 
nearheap ) 
dumpfile ) 
scan -> next ) 
scan -> next ) 
__E__O__F__
VOID ) 
word ) 
INT_CONST ) 
! _DX ) 
! _AL ) 
EMS_INT ) 
EMS_INT ) 
EMS_INT ) 
LONG ) 
EMS_INT ) 
LONG ) 
FOR ( i = INT_CONST ; i < EMSFrameCount ; i v++ ) 
EMSPresent ) 
_AL != INT_CONST ) 
! _AX ) 
PMPageSizeKB - INT_CONST ) 
XMSAvail < ( PMPageSizeKB * INT_CONST ) ) 
XMS_ALLOC ) 
! _AX ) 
XMSPresent ) 
! addr ) 
length + INT_CONST ) 
word ) 
FOR ( i = INT_CONST ; i < PMMaxMainMem ; i v++ ) 
! MainPresent ) 
FOR ( i = INT_CONST , page = PMPages ; i < ChunksInFile ; i v++ , page v++ ) 
) 
FOR ( i = INT_CONST , p = MainMemPages , used = MainMemUsed ; i < PMMaxMainMem ; i v++ , p v++ , used v++ ) 
false ) 
FOR ( i = INT_CONST , p = MainMemPages ; i < PMMaxMainMem ; i v++ , p v++ ) 
FOR ( i = INT_CONST , p = MainMemPages ; i < PMMaxMainMem ; i v++ , p v++ ) 
PageFileName , O_RDONLY + O_BINARY ) 
PageFile , &v ChunksInFile , SIZEOF ( ChunksInFile ) ) 
&v ( memptr ) PMSegPages , SIZEOF ( PageListStruct ) * PMNumBlocks ) 
longword ) 
FOR ( i = INT_CONST , page = PMPages ; i < ChunksInFile ; i v++ , page v++ ) 
word ) 
FOR ( i = INT_CONST , page = PMPages ; i < ChunksInFile ; i v++ , page v++ ) 
PMEMSSubPage - INT_CONST ) 
FOR ( i = INT_CONST ; i < EMSFrameCount ; i v++ ) 
emspage == -v INT_CONST ) 
FOR ( i = INT_CONST ; i < EMSFrameCount ; i v++ ) 
emspage == -v INT_CONST ) 
lock < pml_EMSLock ) 
page / PMEMSSubPage , emspage ) 
( memptr ) ( EMSPageFrame + ( emspage * EMSPageSizeSeg ) NEW_LINE + ( ( page & ( PMEMSSubPage - INT_CONST ) ) * PMPageSizeSeg ) ) ) 
page -> mainPage != -v INT_CONST ) 
FOR ( i = INT_CONST , page = PMPages , lru = -v INT_CONST , last = MAXLONG ; i < ChunksInFile ; i v++ , page v++ ) 
lru == -v INT_CONST ) 
FOR ( i = INT_CONST , page = PMPages , lru = -v INT_CONST , last = MAXLONG ; i < ChunksInFile ; i v++ , page v++ ) 
! XMSPresent ) 
orig == new ) 
origpage -> locked != pml_Unlocked ) 
orig ) 
orig ) 
! addr ) 
( EMSPagesUsed < EMSPagesAvail ) && ! mainonly ) 
FOR ( i = INT_CONST , n = -v INT_CONST , used = MainMemUsed ; i < PMMaxMainMem ; i v++ , used v++ ) 
XMSPresent && ( page -> xmsPage != -v INT_CONST ) ) 
addr ) 
pagenum , mainonly ) 
pagenum >= ChunksInFile ) 
result ) 
MainPagesAvail - MainPagesUsed ) 
FOR ( i = INT_CONST ; i < ChunksInFile ; i v++ ) 
! total ) 
maintotal ) 
xmstotal ) 
FOR ( oogypage = INT_CONST ; PMPages [ oogypage ] . mainPage == -v INT_CONST ; oogypage v++ ) 
total , total ) 
++v PMFrameCount >= MAXLONG - INT_CONST ) 
FOR ( i = INT_CONST ; i < PMNumBlocks ; i v++ ) 
FOR ( i = INT_CONST ; i < PMSoundStart ; i v++ ) 
buf , STRING , i ) 
EMSPageSizeKB / PMPageSizeKB ) 
FOR ( i = INT_CONST , page = PMPages ; i < PMNumBlocks ; i v++ , page v++ ) 
PMStarted ) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
) 
! noems ) 
! PMStarted ) 
) 
__E__O__F__
INT_CONST , speed ) 
TimerDivisor == ( INT_CONST / ( TickBase * INT_CONST ) ) ) 
( DigiMode == sds_PC ) && DigiPlaying ) 
rate != TimerRate ) 
sbSamplePlaying ) 
data ) 
dataofs + uselen > INT_CONST ) 
INT_CONST , sbDMA | INT_CONST ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
sbDMAa2 , ( byte ) dataofs ) 
sbDMAa2 , ( byte ) ( dataofs >> INT_CONST ) ) 
sbDMAa1 , ( byte ) datapage ) 
sbDMAa3 , ( byte ) uselen ) 
sbDMAa3 , ( byte ) ( uselen >> INT_CONST ) ) 
INT_CONST , sbDMA ) 
) 
sbDataAvail ) 
sbNextSegPtr ) 
INT_CONST , INT_CONST ) 
) 
data , len ) 
INT_CONST ) 
) 
! SBProPresent ) 
sbpMixerAddr , sbpmVoiceVol ) 
sbReset , true ) 
sbReset , false ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
false ) 
port == INT_CONST ) 
port == -v INT_CONST ) 
SDL_CheckSB ( INT_CONST ) ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
sbIntVec < INT_CONST ) 
sbIntVec , SDL_SBService ) 
) 
INT_CONST / INT_CONST ) 
sbNoProCheck ) 
sbpMixerAddr , sbpmFMVol ) 
SBProPresent ) 
sbIntVec , sbOldIntHand ) 
ssSample ) 
! ( --v ssLengthLeft ) ) 
ssIsTandy ) 
) 
TimeCount < lasttime + INT_CONST ) 
) 
FOR ( ssPort = INT_CONST ; ssPort <= INT_CONST ; ssPort v++ ) 
false ) 
VOLATILE byte far * ) 
false ) 
pcSound ) 
page ) 
addr ) 
addr , len ) 
addr , len ) 
( DigiMode == sds_PC ) && ( SoundMode == sdm_PC ) ) 
) 
) 
FOR ( i = DigiLastStart ; i < DigiLastEnd ; i v++ ) 
! DigiMode ) 
which * INT_CONST ) 
( DigiLeft + ( PMPageSize - INT_CONST ) ) / PMPageSize ) 
DigiLeft >= PMPageSize ) 
addr , len ) 
mode == DigiMode ) 
mode ) 
! SoundSourcePresent ) 
! devicenotpresent ) 
mode == sds_SoundSource ) 
) 
FOR ( i = INT_CONST ; i < PMPageSize / ( SIZEOF ( word ) * INT_CONST ) ; i v++ , p += INT_CONST ) 
FOR ( i = INT_CONST ; i < LASTSOUND ; i v++ ) 
percussive ) 
m + alChar , inst -> mChar ) 
c != INT_CONST ) 
which + alFeedCon , inst -> nConn ) 
m + alChar , inst -> mChar ) 
alFeedCon , INT_CONST ) 
) 
byte far * ) 
! ( inst -> mSus | inst -> cSus ) ) 
&v alZeroInst ) 
inst ) 
alSound ) 
! sqActive ) 
alEffects , INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
) 
INT_CONST , INT_CONST ) 
TimerDelay100 ) 
( ( status1 & INT_CONST ) == INT_CONST ) && ( ( status2 & INT_CONST ) == INT_CONST ) ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
( MusicMode == smm_AdLib ) || ( DigiMode == sds_SoundSource ) ) 
) 
INT_CONST , INT_CONST ) 
) 
) 
( mode == sdm_AdLib ) && ! AdLibPresent ) 
AdLibPresent ) 
) 
result ) 
) 
AdLibPresent ) 
result ) 
result ) 
SD_Started ) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
INT_CONST ) 
sdm_Off ) 
! ssNoCheck ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
gotsd ) 
SoundBlasterPresent ) 
INT_CONST ) 
INT_CONST , t0OldService ) 
sound == -v INT_CONST ) 
SoundMode == sdm_Off ) 
( VOID far * ) s ) 
false ) 
SoundMode ) 
result ) 
) 
) 
MusicMode ) 
FOR ( i = INT_CONST ; i < sqMaxTracks ; i v++ ) 
MusicMode ) 
result ) 
__E__O__F__
ax < INT_CONST ) 
FOR ( t = buf ; *v s ; s v++ , t v++ ) 
INT_CONST , INT_CONST ) 
( c < INT_CONST ) || ( c == INT_CONST ) ) 
&v wr ) 
true ) 
) 
US_Started ) 
true ) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
! isalpha ( *v parm ) ) 
FOR ( i = INT_CONST ; *v strings && *v *v strings ; i v++ ) 
FOR ( s = *v strings v++ , p = parm , cs = cp = INT_CONST ; cs == cp ; ) 
*v s ) 
ultoa ( n , buffer , INT_CONST ) ) 
ltoa ( n , buffer , INT_CONST ) ) 
( rw - w ) / INT_CONST ) 
s , r ) 
s , &v w , &v h ) 
w > WindowW ) 
*v s ) 
x - INT_CONST ) 
) 
sx , sy , INT_CONST ) 
FOR ( i = sx + INT_CONST ; i <= sx + sw - INT_CONST ; i += INT_CONST ) 
FOR ( i = sy + INT_CONST ; i <= sy + sh - INT_CONST ; i += INT_CONST ) 
buf , s ) 
status ^= INT_CONST ) 
def ) 
! done ) 
sc ) 
s [ cursor ] ) 
s ) 
buf , s ) 
escok ) 
cursor ) 
s [ cursor ] ) 
FOR ( i = len + INT_CONST ; i > cursor ; i v-- ) 
cursorvis ) 
) 
__E__O__F__
fontstruct far * ) 
( ch = *v string v++ ) != INT_CONST ) 
fontstruct far * ) 
( ch = *v string v++ ) != INT_CONST ) 
width & INT_CONST ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( y = INT_CONST ; y < height ; y v++ ) 
FOR ( x = INT_CONST ; x < pwidth ; x v++ ) 
&v ( memptr ) temp ) 
FOR ( *v width = INT_CONST ; *v string ; string v++ ) 
xt1 < INT_CONST ) 
xt1 >= UPDATEWIDE ) 
yt1 > UPDATEHIGH ) 
FOR ( y = yt1 ; y <= yt2 ; y v++ ) 
FOR ( x = xt1 ; x <= xt2 ; x v++ ) 
VW_MarkUpdateBlock ( x , y , x + width - INT_CONST , y + height - INT_CONST ) ) 
source , wide / INT_CONST , height , x * INT_CONST , y ) 
STARTTILE8 ) 
FOR ( i = INT_CONST ; i < NUMTILE8 ; i v++ ) 
byte _seg * ) 
FOR ( i = INT_CONST ; i < NUMTILE16 ; i v++ ) 
FOR ( i = start ; i <= end ; i v++ ) 
INT_CONST ) 
) 
FOR ( p = INT_CONST ; p < pixperframe ; p v++ ) 
x > width || y > height ) 
__E__O__F__
) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
SC_INDEX , SC_MAPMASK ) 
GC_INDEX , GC_MODE ) 
GC_INDEX , GC_MISCELLANEOUS ) 
INT_CONST ) 
CRTC_INDEX , CRTC_UNDERLINE ) 
CRTC_INDEX , CRTC_MODE ) 
CRTC_INDEX , CRTC_OFFSET + width * INT_CONST ) 
FOR ( i = INT_CONST ; i < MAXSCANLINES ; i v++ ) 
PEL_WRITE_ADR , INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
PEL_READ_ADR , INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < steps ; i v++ ) 
FOR ( j = start ; j <= end ; j v++ ) 
red , green , blue ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i < steps ; i v++ ) 
FOR ( j = start ; j <= end ; j v++ ) 
palette ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
mask ) 
x + width - INT_CONST ) 
SCREENSEG , bufferofs + ylookup [ y ] + xbyte ) 
midbytes < INT_CONST ) 
leftmask & rightmask ) 
leftmask ) 
INT_CONST ) 
rightmask ) 
INT_CONST ) 
mask ) 
SCREENSEG , bufferofs + ylookup [ y ] + ( x >> INT_CONST ) ) 
height v-- ) 
INT_CONST ) 
x + width - INT_CONST ) 
SCREENSEG , bufferofs + ylookup [ y ] + ( x >> INT_CONST ) ) 
midbytes < INT_CONST ) 
leftmask & rightmask ) 
height v-- ) 
INT_CONST ) 
( width + INT_CONST ) / INT_CONST ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
SCREENSEG , bufferofs + ylookup [ y ] + ( x >> INT_CONST ) ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( y = INT_CONST ; y < height ; y v++ , screen += linewidth , source += width ) 
SCREENSEG , bufferofs + ylookup [ y ] + ( x >> INT_CONST ) ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( y = INT_CONST ; y < height ; y v++ , screen += linewidth , source += width ) 
INT_CONST ) 
INT_CONST ) 
SCREENSEG , bufferofs + ylookup [ printy ] + ( printx >> INT_CONST ) ) 
*v str ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , screen += linewidth ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , screen += linewidth ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , screen += linewidth ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ , screen += linewidth ) 
printx >> INT_CONST ) 
INT_CONST ) 
*v str ) 
INT_CONST ) 
__E__O__F__
width & INT_CONST ) 
FOR ( plane = INT_CONST ; plane < INT_CONST ; plane v++ ) 
FOR ( y = INT_CONST ; y < height ; y v++ ) 
FOR ( x = INT_CONST ; x < pwidth ; x v++ ) 
temp ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAXSCALEHEIGHT ; i v++ ) 
) 
&v ( memptr ) work , INT_CONST ) 
FOR ( i = INT_CONST ; i <= maxscaleheight ; i v++ ) 
) 
FOR ( i = INT_CONST ; i <= maxscaleheight ; i v++ ) 
FOR ( i = maxscaleheight ; i < MAXSCALEHEIGHT ; i v++ ) 
( LONG ) height << INT_CONST ) 
FOR ( src = INT_CONST ; src <= INT_CONST ; src v++ ) 
FOR ( ; startpix < endpix ; startpix v++ ) 
code ) 
shapenum ) 
! scale || scale > maxscale ) 
( ( UNSIGNED *p ) & linescale ) + INT_CONST ) 
( ( UNSIGNED *p ) & linecmds ) + INT_CONST ) 
--v srcx >= stopx && slinex > INT_CONST ) 
) 
shape -> leftpix < INT_CONST ) 
++v srcx <= stopx && ( slinex += slinewidth ) < viewwidth ) 
shapenum ) 
( ( UNSIGNED *p ) & linescale ) + INT_CONST ) 
( ( UNSIGNED *p ) & linecmds ) + INT_CONST ) 
--v srcx >= stopx ) 
shape -> leftpix < INT_CONST ) 
++v srcx <= stopx ) 
__E__O__F__
statinfo [ type ] . type ) 
! loadedgame ) 
laststatobj == &v statobjlist [ MAXSTATS ] ) 
FOR ( type = INT_CONST ; ; type v++ ) 
FOR ( spot = &v statobjlist [ INT_CONST ] ; ; spot v++ ) 
FOR ( i = INT_CONST ; i < NUMAREAS ; i v++ ) 
doornum == INT_CONST ) 
UNSIGNED ) 
vertical ) 
actorat [ tilex ] [ tiley ] ) 
mapsegs [ INT_CONST ] + farmapylookup [ doorobjlist [ door ] . tiley ] NEW_LINE + doorobjlist [ door ] . tilex ) 
UNSIGNED ) 
lock >= dr_lock1 && lock <= dr_lock4 ) 
doorobjlist [ door ] . action ) 
door ) 
! position ) 
doorobjlist [ door ] . vertical ) 
position >= INT_CONST ) 
( ( UNSIGNED ) actorat [ tilex ] [ tiley ] != ( door | INT_CONST ) ) NEW_LINE || ( player -> tilex == tilex && player -> tiley == tiley ) ) 
door ) 
position <= INT_CONST ) 
doorobjlist [ door ] . vertical ) 
gamestate . victoryflag ) 
FOR ( door = INT_CONST ; door < doornum ; door v++ ) 
pwallstate ) 
actorat [ checkx + INT_CONST ] [ checky ] ) 
actorat [ checkx ] [ checky + INT_CONST ] ) 
actorat [ checkx - INT_CONST ] [ checky ] ) 
mapsegs [ INT_CONST ] + farmapylookup [ pwally ] + pwallx ) 
PUSHWALLSND ) 
! pwallstate ) 
pwallstate / INT_CONST != oldblock ) 
UNSIGNED ) 
actorat [ pwallx + INT_CONST ] [ pwally ] ) 
actorat [ pwallx - INT_CONST ] [ pwally ] ) 
pwallstate / INT_CONST ) 
__E__O__F__
ob -> x - PROJSIZE ) 
ob -> x + PROJSIZE ) 
FOR ( y = yl ; y <= yh ; y v++ ) 
FOR ( x = xl ; x <= xh ; x v++ ) 
LONG ) 
speed , costable [ ob -> angle ] ) 
deltax > INT_CONST ) 
ob -> x - player -> x ) 
! ProjectileTryMove ( ob ) ) 
deltax < PROJECTILESIZE && deltay < PROJECTILESIZE ) 
ob -> obclass ) 
which ) 
tilex , tiley , &v s_ofcstand ) 
tilex , tiley , &v s_mutstand ) 
tilex , tiley , &v s_ssstand ) 
*v map == AMBUSHTILE ) 
tilex , tiley , &v s_bossstand ) 
! loadedgame ) 
tilex , tiley , &v s_gretelstand ) 
! loadedgame ) 
tilex , tiley , &v s_ofcpath1 ) 
tilex , tiley , &v s_sspath1 ) 
tilex , tiley , &v s_mutpath1 ) 
tilex , tiley , &v s_dogpath1 ) 
dir ) 
NEINSOVASSND , ob ) 
LEBENSND , ob ) 
DOGDEATHSND , ob ) 
MUTTISND ) 
MEINGOTTSND ) 
HITLERHASND ) 
SCHEISTSND ) 
EVASND ) 
MEINSND ) 
DONNERSND ) 
ROSESND ) 
GHOSTFADESND ) 
ANGELDEATHSND ) 
TRANSDEATHSND ) 
UBERDEATHSND ) 
WILHELMDEATHSND ) 
KNIGHTDEATHSND ) 
SoundBlasterPresent && DigiMode != sds_Off ) 
SoundBlasterPresent && DigiMode != sds_Off ) 
ob ) 
ob -> tilex - player -> tilex ) 
SoundBlasterPresent && DigiMode != sds_Off ) 
ob -> tilex - player -> tilex ) 
CheckLine ( ob ) ) 
ob -> dir == nodir ) 
move ) 
SoundBlasterPresent && DigiMode != sds_Off ) 
deltay , deltax ) 
) 
ob -> obclass ) 
ANGELFIRESND , new ) 
MISSILEFIRESND , new ) 
SoundBlasterPresent && DigiMode != sds_Off ) 
US_RndT ( ) & INT_CONST ) 
tilex , tiley , &v s_spectrewait1 ) 
! loadedgame ) 
deltax < -v MINACTORDIST || deltax > MINACTORDIST ) 
FOR ( y = yl ; y <= yh ; y v++ ) 
FOR ( x = xl ; x <= xh ; x v++ ) 
( ( objtype * ) tile ) -> flags & FL_SHOOTABLE ) 
which ) 
! loadedgame ) 
DigiMode != sds_Off ) 
! loadedgame ) 
DigiMode != sds_Off ) 
! loadedgame ) 
DigiMode != sds_Off ) 
! loadedgame ) 
deltay , deltax ) 
) 
SCHABBSTHROWSND , new ) 
deltay , deltax ) 
) 
MISSILEFIRESND , new ) 
ob -> tilex - player -> tilex ) 
CheckLine ( ob ) ) 
US_RndT ( ) < ( tics << INT_CONST ) ) 
ob -> dir == nodir ) 
move ) 
ob -> tilex - player -> tilex ) 
CheckLine ( ob ) ) 
US_RndT ( ) < ( tics << INT_CONST ) ) 
ob -> dir == nodir ) 
move ) 
ob -> tilex - player -> tilex ) 
CheckLine ( ob ) ) 
US_RndT ( ) < ( tics << INT_CONST ) ) 
ob -> dir == nodir ) 
move ) 
DigiMode != sds_Off ) 
! loadedgame ) 
DigiMode != sds_Off ) 
! loadedgame ) 
ob -> tilex , ob -> tiley , &v s_hitlerchase1 ) 
deltay , deltax ) 
) 
FLAMETHROWERSND , new ) 
CheckLine ( ob ) ) 
ob -> dir == nodir ) 
move ) 
gamestate . victoryflag ) 
tics << INT_CONST ) 
ob , &v s_bossshoot1 ) 
ob , &v s_ubershoot1 ) 
ob , &v s_willshoot1 ) 
ob -> dir == nodir ) 
move ) 
ob -> dir == nodir ) 
move ) 
ob -> dir == nodir ) 
move ) 
dx < INT_CONST ) 
ob -> tilex , ob -> tiley , INT_CONST ) 
spot < INT_CONST ) 
! TryWalk ( ob ) ) 
SightPlayer ( ob ) ) 
move ) 
! areabyplayer [ ob -> areanumber ] ) 
ob -> tilex - player -> tilex ) 
ob -> obclass == ssobj || ob -> obclass == bossobj ) 
US_RndT ( ) < hitchance ) 
ob -> obclass ) 
DOGATTACKSND , ob ) 
dx < INT_CONST ) 
player -> tilex , player -> tiley + INT_CONST , &v s_bjrun1 ) 
move ) 
ob , move ) 
ob -> x - PLAYERSIZE ) 
ob -> x + PLAYERSIZE ) 
FOR ( y = yl ; y <= yh ; y v++ ) 
FOR ( x = xl ; x <= xh ; x v++ ) 
) 
INT_CONST ) 
gamestate . victoryflag ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST - STATUSLINES , INT_CONST ) 
) 
) 
INT_CONST ) 
player , &v s_deathcam ) 
dy , dx ) 
fangle < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
ob -> obclass ) 
ob , &v s_hitlerdeathcam ) 
ob , &v s_giftdeathcam ) 
ob , &v s_fatdeathcam ) 
__E__O__F__
! gamestate . ammo ) 
FOR ( i = wp_knife ; i <= gamestate . bestweapon ; i v++ ) 
buttonstate [ bt_strafe ] ) 
controlx > INT_CONST ) 
ob -> angle >= ANGLES ) 
controly < INT_CONST ) 
gamestate . victoryflag ) 
INT_CONST - STATUSLINES ) 
INT_CONST , INT_CONST , FACE1APIC + INT_CONST * ( ( INT_CONST - gamestate . health ) / INT_CONST ) + gamestate . faceframe ) 
number , str , INT_CONST ) 
str ) 
length < width ) 
c < length ) 
gamestate . victoryflag ) 
points ) 
) 
points > INT_CONST && gamestate . health != INT_CONST && ! godmode ) 
) 
gamestate . bestweapon < weapon ) 
check -> itemnumber - bo_key1 ) 
BONUS1SND ) 
BONUS2SND ) 
BONUS3SND ) 
BONUS4SND ) 
gamestate . ammo == INT_CONST ) 
gamestate . ammo == INT_CONST ) 
gamestate . ammo == INT_CONST ) 
GETMACHINESND ) 
GETGATLINGSND ) 
BONUS1UPSND ) 
gamestate . health == INT_CONST ) 
gamestate . health == INT_CONST ) 
gamestate . health > INT_CONST ) 
) 
ob -> x - PLAYERSIZE ) 
ob -> x + PLAYERSIZE ) 
FOR ( y = yl ; y <= yh ; y v++ ) 
FOR ( x = xl ; x <= xh ; x v++ ) 
FOR ( y = yl ; y <= yh ; y v++ ) 
FOR ( x = xl ; x <= xh ; x v++ ) 
TryMove ( ob ) ) 
speed ) 
speed >= MINDIST * INT_CONST ) 
player , xmove , ymove ) 
mapsegs [ INT_CONST ] + offset ) 
*v ( mapsegs [ INT_CONST ] + offset ) == EXITTILE ) 
player -> angle < ANGLES / INT_CONST || player -> angle > INT_CONST * ANGLES / INT_CONST ) 
*v ( mapsegs [ INT_CONST ] + farmapylookup [ checky ] + checkx ) == PUSHABLETILE ) 
checkx , checky , dir ) 
*v ( mapsegs [ INT_CONST ] + farmapylookup [ player -> tiley ] + player -> tilex ) == ALTELEVATORTILE ) 
) 
ATKKNIFESND ) 
FOR ( check = ob -> next ; check ; check = check -> next ) 
closest , US_RndT ( ) >> INT_CONST ) 
gamestate . weapon ) 
ATKMACHINEGUNSND ) 
ATKGATLINGSND ) 
INT_CONST ) 
FOR ( check = ob -> next ; check ; check = check -> next ) 
CheckLine ( closest ) ) 
closest -> tilex - player -> tilex ) 
dist < INT_CONST ) 
closest , damage ) 
player -> angle > INT_CONST ) 
( ( LONG ) player -> tiley - INT_CONST ) << TILESHIFT ) 
player -> y > desty ) 
) 
gamestate . victoryflag ) 
buttonstate [ bt_use ] && ! buttonheld [ bt_use ] ) 
gamestate . attackcount <= INT_CONST ) 
) 
buttonstate [ bt_use ] ) 
__E__O__F__
INT_CONST , INT_CONST ) 
STRING ) 
INT_CONST , INT_CONST ) 
STRING ) 
STRING ) 
FOR ( i = INT_CONST ; i < total ; i v++ ) 
STRING ) 
FOR ( obj = player -> next ; obj ; obj = obj -> next ) 
STRING ) 
STRING ) 
) 
INT_CONST ) 
! LastScan ) 
INT_CONST ) 
FOR ( p = INT_CONST ; p < INT_CONST ; p v++ ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ , dest += INT_CONST ) 
FOR ( p = INT_CONST ; p < INT_CONST ; p v++ ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ , dest += INT_CONST ) 
INT_CONST , INT_CONST ) 
&v gamepal ) 
) 
INT_CONST ) 
INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST , done = false ; ! done ; ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ , postx v++ , postsource += INT_CONST ) 
FOR ( l = j = k = INT_CONST ; j < NumDigi ; j v++ ) 
DigiList [ ( j * INT_CONST ) + INT_CONST ] + ( PMPageSize - INT_CONST ) ) 
STRING ) 
FOR ( j = INT_CONST ; j < NumDigi ; j v++ ) 
FOR ( j = INT_CONST ; j < page -> length ; j += INT_CONST ) 
FOR ( j = INT_CONST ; j < ChunksInFile ; j v++ ) 
Keyboard [ sc_B ] ) 
Keyboard [ sc_C ] ) 
Keyboard [ sc_E ] ) 
Keyboard [ sc_F ] ) 
Keyboard [ sc_G ] ) 
NULL ) 
FOR ( y = maporgy ; y < endy ; y v++ ) 
FOR ( x = maporgx ; x < endx ; x v++ ) 
mapsegs [ INT_CONST ] + farmapylookup [ y ] + x ) 
UNSIGNED ) 
maporgx < INT_CONST ) 
) 
__E__O__F__
gx , viewcos ) 
gx , viewsin ) 
nx < mindist ) 
( LONG ) tx << TILESHIFT ) 
gx , viewcos ) 
gx , viewsin ) 
nx < mindist ) 
nx < TILEGLOBAL && ny > -v TILEGLOBAL / INT_CONST && ny < TILEGLOBAL / INT_CONST ) 
gx , viewcos ) 
gy , viewsin ) 
nx < mindist ) 
yintercept >> INT_CONST ) 
lastside == INT_CONST && lastintercept == xtile && lasttilehit == tilehit ) 
UNSIGNED ) 
lastside != -v INT_CONST ) 
tilehit & INT_CONST ) 
xintercept >> INT_CONST ) 
lastside == INT_CONST && lastintercept == ytile && lasttilehit == tilehit ) 
UNSIGNED ) 
lastside != -v INT_CONST ) 
tilehit & INT_CONST ) 
( xintercept - doorposition [ doornum ] ) >> INT_CONST ) 
) 
lasttilehit == tilehit ) 
texture == ( UNSIGNED ) postsource ) 
UNSIGNED ) 
doorobjlist [ doornum ] . lock ) 
( yintercept - doorposition [ doornum ] ) >> INT_CONST ) 
) 
lasttilehit == tilehit ) 
texture == ( UNSIGNED ) postsource ) 
UNSIGNED ) 
doorobjlist [ doornum ] . lock ) 
xintercept >> INT_CONST ) 
) 
lasttilehit == tilehit ) 
UNSIGNED ) 
lastside != -v INT_CONST ) 
( ( UNSIGNED *p ) & postsource ) + INT_CONST ) 
yintercept >> INT_CONST ) 
lasttilehit == tilehit ) 
UNSIGNED ) 
lastside != -v INT_CONST ) 
( ( UNSIGNED *p ) & postsource ) + INT_CONST ) 
centerx - ob -> viewx ) 
ob -> obclass == rocketobj || ob -> obclass == hrocketobj ) 
angle / ( ANGLES / INT_CONST ) ) 
FOR ( statptr = &v statobjlist [ INT_CONST ] ; statptr != laststatobj ; statptr v++ ) 
FOR ( obj = player -> next ; obj ; obj = obj -> next ) 
! numvisable ) 
FOR ( i = INT_CONST ; i < numvisable ; i v++ ) 
FOR ( visstep = &v vislist [ INT_CONST ] ; visstep < visptr ; visstep v++ ) 
VOID ) 
gamestate . victoryflag ) 
demorecord || demoplayback ) 
lasttimecount > TimeCount ) 
scratch , STRING ) 
TILEGLOBAL - INT_CONST ) 
) 
SC_INDEX , SC_MAPMASK ) 
) 
) 
) 
) 
fizzlein ) 
bufferofs > PAGE3START ) 
__E__O__F__
gx , viewcos ) 
gx , viewsin ) 
y >= ATABLEMAX ) 
INT_CONST , INT_CONST ) 
FOR ( y = INT_CONST ; y < mapheight ; y v++ ) 
FOR ( x = INT_CONST ; x < mapwidth ; x v++ ) 
! loadedgame ) 
demoplayback || demorecord ) 
mapwidth != INT_CONST || mapheight != INT_CONST ) 
FOR ( y = INT_CONST ; y < mapheight ; y v++ ) 
FOR ( x = INT_CONST ; x < mapwidth ; x v++ ) 
UNSIGNED ) 
UNSIGNED ) 
) 
FOR ( y = INT_CONST ; y < mapheight ; y v++ ) 
FOR ( x = INT_CONST ; x < mapwidth ; x v++ ) 
FOR ( y = INT_CONST ; y < mapheight ; y v++ ) 
FOR ( x = INT_CONST ; x < mapwidth ; x v++ ) 
INT_CONST - STATUSLINES - viewheight ) 
INT_CONST , INT_CONST , xl - INT_CONST , INT_CONST - STATUSLINES , INT_CONST ) 
yl - INT_CONST , yl + viewheight , xl - INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST - STATUSLINES , INT_CONST ) 
INT_CONST - STATUSLINES - viewheight ) 
xl - INT_CONST , xl + viewwidth , yl - INT_CONST , INT_CONST ) 
) 
STATUSBARPIC ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
STATUSBARPIC ) 
) 
CHAR far * ) 
( CHAR far * ) demobuffer ) 
INT_CONST , INT_CONST ) 
US_LineInput ( px , py , str , NULL , true , INT_CONST , INT_CONST ) ) 
&v demobuffer ) 
INT_CONST , INT_CONST ) 
INT_CONST , INT_CONST ) 
gd_hard , level / INT_CONST ) 
) 
) 
) 
) 
) 
) 
INT_CONST , INT_CONST ) 
) 
) 
dems [ demonumber ] ) 
) 
PLAYERDEATHSND ) 
dy , dx ) 
fangle < INT_CONST ) 
player -> angle > iangle ) 
clockwise < counter ) 
curangle > iangle ) 
curangle < iangle ) 
) 
INT_CONST , INT_CONST , viewwidth , viewheight , INT_CONST ) 
tedlevel == false ) 
gamestate . lives > -v INT_CONST ) 
) 
playstate == ex_secretlevel ) 
MainMenu [ viewscores ] . string , STR_VS ) 
MainMenu [ viewscores ] . string , STR_VS ) 
__E__O__F__
ENDSCREEN3PIC ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST , INT_CONST ) 
) 
END4PALETTE , ENDSCREEN4PIC ) 
END2PALETTE , ENDSCREEN12PIC ) 
XTHEEND_MUS ) 
BJCOLLAPSE1PIC ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST , VIEWCOLOR ) 
BJCOLLAPSE1PIC ) 
C_TIMECODEPIC ) 
TIMEX , TIMEY - INT_CONST , STR_TOTALTIME ) 
INT_CONST , RATIOY - INT_CONST , STRING ) 
RATIOX + INT_CONST , RATIOY , STR_RATKILL ) 
INT_CONST , INT_CONST , L_BJWINSPIC ) 
FOR ( kr = sr = tr = sec = i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( kr = sr = tr = sec = i = INT_CONST ; i < INT_CONST ; i v++ ) 
min > INT_CONST ) 
kr , tempstr , INT_CONST ) 
sr , tempstr , INT_CONST ) 
tr , tempstr , INT_CONST ) 
gamestate . difficulty >= gd_medium ) 
) 
) 
Keyboard [ sc_P ] && MS_CheckParm ( STRING ) ) 
) 
C_TIMECODEPIC ) 
) 
PG13PIC ) 
PG13PIC ) 
) 
) 
FOR ( i = INT_CONST ; i < strlen ( string ) ; i v++ ) 
string [ i ] ) 
TimeCount > max ) 
LEVELEND_LUMP_START , LEVELEND_LUMP_END ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST - STATUSLINES , INT_CONST ) 
) 
C_INTERMISSIONPIC ) 
mapon < INT_CONST ) 
FOR ( i = INT_CONST ; i <= timeleft ; i v++ ) 
FOR ( i = INT_CONST ; i <= ratio ; i v++ ) 
FOR ( i = INT_CONST ; i <= ratio ; i v++ ) 
FOR ( i = INT_CONST ; i <= ratio ; i v++ ) 
) 
) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
LEVELEND_LUMP_START , LEVELEND_LUMP_END ) 
WindowX + INT_CONST , WindowY + WindowH - INT_CONST , w , INT_CONST , BLACK ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST - STATUSLINES , INT_CONST ) 
INT_CONST - INT_CONST , INT_CONST - INT_CONST * INT_CONST , GETPSYCHEDPIC ) 
) 
PreloadUpdate ) 
) 
) 
HIGHSCORESPIC ) 
) 
INT_CONST , INT_CONST , HIGHSCORESPIC ) 
INT_CONST * INT_CONST , INT_CONST , C_NAMEPIC ) 
BACKDROP_LUMP_START , BACKDROP_LUMP_END ) 
HIGHSCORES_LUMP_START , HIGHSCORES_LUMP_END ) 
INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST , s = Scores ; i < MaxScores ; i v++ , s v++ ) 
FOR ( str = buffer ; *v str ; str v++ ) 
FOR ( str = buffer ; *v str ; str v++ ) 
) 
HIGHSCORES_LUMP_START , HIGHSCORES_LUMP_END ) 
myscore . name , STRING ) 
FOR ( i = INT_CONST , n = -v INT_CONST ; i < MaxScores ; i v++ ) 
FOR ( j = MaxScores ; --v j > i ; ) 
XAWARD_MUS ) 
) 
n != -v INT_CONST ) 
INT_CONST * n ) 
) 
STARTFONT + INT_CONST ) 
READHCOLOR , BKGDCOLOR ) 
STRING ) 
HIGHLIGHT , BKGDCOLOR ) 
) 
s ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
INT_CONST , INT_CONST * INT_CONST , COPYPROTBOXPIC ) 
) 
try < INT_CONST ) 
FOR ( i = INT_CONST ; i < _fstrlen ( bossstrs [ whichboss ] ) ; i v++ ) 
STR_MAN2 ) 
message , STR_MAN3 STRING ) 
_fstrcmp ( inputbuffer , WordCorrect [ whichword ] ) != INT_CONST ) 
memberpicked [ whichmem = US_RndT ( ) % INT_CONST ] ) 
FOR ( i = INT_CONST ; i < _fstrlen ( MemberCorrect [ whichmem ] ) ; i v++ ) 
_fstrcmp ( inputbuffer , MiscCorrect [ whichone ] ) != INT_CONST ) 
INT_CONST , INT_CONST * INT_CONST , COPYPROTBOXPIC ) 
FOR ( i = INT_CONST ; i < NUMSOUNDS ; i v++ , start v++ ) 
) 
message , DosMessages [ US_RndT ( ) % INT_CONST ] ) 
INT_CONST ) 
STRING , message ) 
__E__O__F__
CHAR *p error ) 
( file = open ( configname , O_BINARY | O_RDONLY ) ) != -v INT_CONST ) 
file , Scores , SIZEOF ( HighScore ) * MaxScores ) 
SoundBlasterPresent || AdLibPresent ) 
sm ) 
configname , O_CREAT | O_BINARY | O_WRONLY , NEW_LINE S_IREAD | S_IWRITE | S_IFREG ) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
FOR ( i = INT_CONST ; i < size - INT_CONST ; i v++ ) 
_dos_getdiskfree ( INT_CONST , &v dfree ) ) 
FOR ( ob = player ; ob ; ob = ob -> next ) 
gamestate ) 
x , y ) 
x , y ) 
file , ( VOID far * ) areaconnect , SIZEOF ( areaconnect ) ) 
FOR ( ob = player ; ob ; ob = ob -> next ) 
x , y ) 
x , y ) 
x , y ) 
x , y ) 
file , ( VOID far * ) & checksum , SIZEOF ( checksum ) ) 
true ) 
x , y ) 
x , y ) 
x , y ) 
file , ( VOID far * ) areaconnect , SIZEOF ( areaconnect ) ) 
) 
INT_CONST ) 
x , y ) 
x , y ) 
x , y ) 
file , ( VOID far * ) & oldchecksum , SIZEOF ( oldchecksum ) ) 
oldchecksum != checksum ) 
FOR ( i = INT_CONST ; i < FINEANGLES / INT_CONST ; i v++ ) 
FOR ( i = INT_CONST ; i <= ANGLEQUAD ; i v++ ) 
VIEWGLOBAL / INT_CONST ) 
TILEGLOBAL * scale ) 
FOR ( i = INT_CONST ; i < halfview ; i v++ ) 
LONG ) 
FOR ( i = INT_CONST ; i < MAXWALLTILES ; i v++ ) 
) 
! virtualreality ) 
&v introscn ) 
INT_CONST , INT_CONST ) 
STRING ) 
! NoWait ) 
INT_CONST , INT_CONST ) 
STRING ) 
INT_CONST , INT_CONST ) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
! _fstricmp ( check , parm ) ) 
FOR ( map = wolfdigimap ; *v map != LASTSOUND ; map += INT_CONST ) 
) 
&v time ) 
) 
CTL_X - INT_CONST , CTL_Y - INT_CONST , INT_CONST , INT_CONST * INT_CONST , BKGDCOLOR ) 
READHCOLOR , BKGDCOLOR ) 
TEXTCOLOR , BKGDCOLOR ) 
) 
MS_CheckParm ( STRING ) ) 
) 
) 
mminfo . mainmem < INT_CONST ) 
) 
FOR ( i = INT_CONST ; i < MAPSIZE ; i v++ ) 
FOR ( i = INT_CONST ; i < PORTTILESHIGH ; i v++ ) 
FOR ( y = INT_CONST ; y < UPDATEHIGH ; y v++ ) 
FOR ( x = INT_CONST ; x < UPDATEWIDE ; x v++ ) 
) 
Keyboard [ sc_M ] ) 
) 
) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
) 
virtualreality ) 
( INT_CONST - STATUSLINES - viewheight ) / INT_CONST * SCREENWIDTH + ( INT_CONST - viewwidth ) / INT_CONST ) 
FOCALLENGTH ) 
viewwidth * FLOAT_CONST ) 
) 
virtualreality ) 
) 
error && *v error ) 
INT_CONST ) 
tedlevel ) 
FOR ( i = INT_CONST ; i < _argc ; i v++ ) 
! NoWait ) 
) 
INTROSONG ) 
! NoWait ) 
CREDITSPIC ) 
IN_UserInput ( TickBase * INT_CONST ) ) 
IN_UserInput ( TickBase * INT_CONST ) ) 
playstate == ex_abort ) 
INTROSONG ) 
&v d ) 
) 
) 
) 
STRING ) 
__E__O__F__
ingame ) 
scancode ) 
) 
OPTIONS_LUMP_START , OPTIONS_LUMP_END ) 
XJAZNAZI_MUS ) 
BACKDROP_LUMP_START , BACKDROP_LUMP_END ) 
which ) 
FOR ( i = INT_CONST ; i < NUMSOUNDS ; i v++ , start v++ ) 
) 
startgame || loadedgame ) 
OPTIONS_LUMP_START , OPTIONS_LUMP_END ) 
INT_CONST , INT_CONST , C_MOUSELBACKPIC ) 
MENU_X - INT_CONST , MENU_Y - INT_CONST , MENU_W + INT_CONST , MENU_H , BKGDCOLOR ) 
ingame ) 
C_MRETGAMEPIC ) 
C_MRETDEMOPIC ) 
&v MainItems , &v MainMenu [ INT_CONST ] ) 
) 
SaveGamesAvail [ LSItems . curpos ] && pickquick ) 
INT_CONST ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
MainMenu [ viewscores ] . string , STR_VS ) 
OPTIONS_LUMP_START , OPTIONS_LUMP_END ) 
) 
MENUSONG ) 
BACKDROP_LUMP_START , BACKDROP_LUMP_END ) 
OPTIONS_LUMP_START , OPTIONS_LUMP_END ) 
) 
ingame ) 
NEWGAME_LUMP_START , NEWGAME_LUMP_END ) 
) 
NEWGAME_LUMP_START , NEWGAME_LUMP_END ) 
S_EPISODEPIC ) 
NE_X - INT_CONST , NE_Y - INT_CONST , NE_W + INT_CONST , NE_H + INT_CONST , BKGDCOLOR ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
READHCOLOR , BKGDCOLOR ) 
STRING ) 
OPTIONS_LUMP_START , OPTIONS_LUMP_END ) 
) 
) 
) 
SOUND_LUMP_START , SOUND_LUMP_END ) 
S_SOUNDPIC ) 
) 
SM_X - INT_CONST , SM_Y1 - INT_CONST , SM_W , SM_H1 , BKGDCOLOR ) 
! AdLibPresent && ! SoundBlasterPresent ) 
! SoundSourcePresent ) 
FOR ( i = INT_CONST ; i < SndItems . amount ; i v++ ) 
LSA_X , LSA_Y , LSA_W , LSA_H , TEXTCOLOR ) 
INT_CONST , TEXTCOLOR ) 
! which ) 
name , SaveName ) 
quick ) 
) 
) 
OPTIONS_LUMP_START , OPTIONS_LUMP_END ) 
) 
LOADSAVE_LUMP_START , LOADSAVE_LUMP_END ) 
lastgameon , TEXTCOLOR ) 
) 
! loadsave ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
SaveGamesAvail [ w ] ) 
name , SaveName ) 
quick ) 
name , S_IREAD | S_IWRITE ) 
OPTIONS_LUMP_START , OPTIONS_LUMP_END ) 
! SaveGamesAvail [ which ] ) 
) 
LOADSAVE_LUMP_START , LOADSAVE_LUMP_END ) 
CALX , CALY , C_JOY0PIC ) 
STRING STR_CALIB STRING STR_JOYST STRING ) 
SHOOTSND ) 
CALX , CALY , C_JOY1PIC ) 
STRING STR_CALIB STRING STR_JOYST STRING ) 
joystickport , &v xmax , &v ymax ) 
IN_JoyButtons ( ) ) 
( xmin != xmax ) && ( ymin != ymax ) ) 
OPTIONS_LUMP_START , OPTIONS_LUMP_END ) 
! CalibrateJoystick ( ) ) 
) 
CONTROL_LUMP_START , CONTROL_LUMP_END ) 
READCOLOR , BKGDCOLOR ) 
TEXTCOLOR , BKGDCOLOR ) 
) 
) 
) 
exit == INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
( ci . button0 | ci . button1 | ci . button2 | ci . button3 ) || NEW_LINE ( ( type == KEYBOARDBTNS || type == KEYBOARDMOVE ) && LastScan == sc_Enter ) ) 
type == KEYBOARDBTNS || type == KEYBOARDMOVE ) 
TimeCount > INT_CONST ) 
type ) 
FOR ( z = INT_CONST ; z < INT_CONST ; z v++ ) 
FOR ( z = INT_CONST ; z < INT_CONST ; z v++ ) 
IN_KeyDown ( sc_Escape ) ) 
ci . dir ) 
INT_CONST , INT_CONST , y - INT_CONST , DEACTIVE ) 
lastwhich >= INT_CONST ) 
S_CUSTOMPIC ) 
INT_CONST ) 
STRING ) 
STRING ) 
STRING ) 
READCOLOR , BKGDCOLOR ) 
STRING ) 
INT_CONST , PrintY - INT_CONST , INT_CONST , INT_CONST , BKGDCOLOR ) 
READCOLOR , BKGDCOLOR ) 
READCOLOR , BKGDCOLOR ) 
TEXTCOLOR , BKGDCOLOR ) 
CusItems . curpos < INT_CONST ) 
FOR ( i = INT_CONST ; i < CusItems . amount ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
hilight ) 
! mouseenabled ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
FOR ( j = INT_CONST ; j < INT_CONST ; j v++ ) 
hilight ) 
! joystickenabled ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
hilight ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
hilight ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
oldview ) 
newview > INT_CONST ) 
) 
oldview != newview ) 
) 
view ) 
HIGHLIGHT , BKGDCOLOR ) 
STR_SIZE1 STRING ) 
) 
GetYorN ( INT_CONST , INT_CONST , C_QUITMSGPIC ) ) 
Confirm ( ENDGAMESTR ) ) 
FOR ( i = INT_CONST ; i <= INT_CONST ; i v++ ) 
) 
INT_CONST + mminfo . nearheap + mminfo . farheap ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
EMSPresent ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
XMSPresent ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
MousePresent ) 
FOR ( i = lumpstart ; i <= lumpend ; i v++ ) 
FOR ( i = lumpstart ; i <= lumpend ; i v++ ) 
STARTFONT + INT_CONST ) 
! ingame ) 
name , SaveName ) 
INT_CONST ) 
x , y , C_CURSOR1PIC ) 
routine ) 
) 
Keyboard [ sc_Tab ] && Keyboard [ sc_P ] && MS_CheckParm ( STRING ) ) 
FOR ( i = which + INT_CONST ; i < item_i -> amount ; i v++ ) 
FOR ( i = INT_CONST ; i < which ; i v++ ) 
item_i , items , x , y , which ) 
) 
lastitem != which ) 
exit ) 
ESCPRESSEDSND ) 
( items + which ) -> string ) 
( items + which ) -> string ) 
routine ) 
FOR ( i = INT_CONST ; i < item_i -> amount ; i v++ ) 
INT_CONST , ci ) 
mouseenabled ) 
joystickenabled && ! mouseactive ) 
string ) 
Keyboard [ sc_S ] ) 
) 
Keyboard [ sc_S ] || Keyboard [ sc_N ] || Keyboard [ sc_Escape ] ) 
Keyboard [ sc_Y ] ) 
) 
Keyboard [ sc_Y ] || Keyboard [ sc_N ] || Keyboard [ sc_Escape ] ) 
) 
pic ) 
Keyboard [ sc_S ] ) 
) 
Keyboard [ sc_S ] || Keyboard [ sc_N ] || Keyboard [ sc_Escape ] ) 
Keyboard [ sc_Y ] ) 
) 
Keyboard [ sc_Y ] || Keyboard [ sc_N ] || Keyboard [ sc_Escape ] ) 
) 
STARTFONT + INT_CONST ) 
FOR ( i = INT_CONST ; i < _fstrlen ( string ) ; i v++ ) 
WindowX - INT_CONST , PrintY - INT_CONST , mw + INT_CONST , h + INT_CONST , TEXTCOLOR ) 
audiosegs [ STARTMUSIC + lastmusic ] ) 
( memptr * ) & audiosegs [ STARTMUSIC + lastmusic ] ) 
) 
false ) 
( memptr * ) & audiosegs [ STARTMUSIC + lastmusic ] ) 
FOR ( s = ExtScanCodes , p = ExtScanNames ; *v s ; p v++ , s v++ ) 
x , y , C_CURSOR1PIC ) 
! findfirst ( STRING , &v f , FA_ARCH ) ) 
__E__O__F__
FOR ( i = INT_CONST ; i < NUMBUTTONS ; i v++ ) 
) 
buttons & INT_CONST ) 
) 
joystickport && ! joypadenabled ) 
MDelta ) 
INT_CONST - mouseadjustment ) 
joystickport , &v joyx , &v joyy ) 
joystickprogressive ) 
demoplayback ) 
TimeCount < lasttimecount + DEMOTICS ) 
demoplayback ) 
FOR ( i = INT_CONST ; i < NUMBUTTONS ; i v++ ) 
) 
mouseenabled ) 
mouseenabled ) 
INT ) 
FOR ( i = NUMBUTTONS - INT_CONST ; i >= INT_CONST ; i v-- ) 
screenfaded || demoplayback ) 
Keyboard [ sc_Tab ] && NEW_LINE Keyboard [ sc_G ] && NEW_LINE Keyboard [ sc_F10 ] ) 
Keyboard [ sc_M ] && NEW_LINE Keyboard [ sc_L ] && NEW_LINE Keyboard [ sc_I ] ) 
Keyboard [ sc_BackSpace ] && NEW_LINE Keyboard [ sc_LShift ] && NEW_LINE Keyboard [ sc_Alt ] && NEW_LINE MS_CheckParm ( STRING ) ) 
Keyboard [ sc_B ] && NEW_LINE Keyboard [ sc_A ] && NEW_LINE Keyboard [ sc_T ] ) 
Paused ) 
NEW_LINE # #IFNDEF DEBCHECK NEW_LINE scan == sc_F10 || NEW_LINE # #ENDIF NEW_LINE scan == sc_F9 || NEW_LINE scan == sc_F7 || NEW_LINE scan == sc_F8 ) 
( scan >= sc_F1 && scan <= sc_F9 ) || scan == sc_Escape ) 
) 
Keyboard [ sc_Tab ] && DebugOk ) 
FOR ( i = INT_CONST ; i < MAXACTORS ; i v++ ) 
) 
lastobj ) 
gone == player ) 
gone == lastobj ) 
) 
FOR ( i = INT_CONST ; i < LASTMUSIC ; i v++ ) 
) 
false ) 
FOR ( i = INT_CONST ; i <= NUMREDSHIFTS ; i v++ ) 
FOR ( j = INT_CONST ; j <= INT_CONST ; j v++ ) 
FOR ( i = INT_CONST ; i <= NUMWHITESHIFTS ; i v++ ) 
FOR ( j = INT_CONST ; j <= INT_CONST ; j v++ ) 
bonuscount ) 
! ob -> active && ! areabyplayer [ ob -> areanumber ] ) 
ob -> ticcount <= INT_CONST ) 
think ) 
ob -> flags & FL_NEVERMARK ) 
buttonstate , INT_CONST , SIZEOF ( buttonstate ) ) 
MousePresent ) 
FOR ( obj = player ; obj ; obj = obj -> next ) 
) 
) 
playstate != ex_died ) 
__E__O__F__
FOR ( i = INT_CONST ; i < MAXSCALEHEIGHT ; i v++ ) 
) 
&v ( memptr ) work , INT_CONST ) 
FOR ( i = INT_CONST ; i <= maxscaleheight ; i v++ ) 
) 
FOR ( i = INT_CONST ; i <= maxscaleheight ; i v++ ) 
FOR ( i = maxscaleheight ; i < MAXSCALEHEIGHT ; i v++ ) 
( LONG ) height << INT_CONST ) 
FOR ( src = INT_CONST ; src <= INT_CONST ; src v++ ) 
FOR ( ; startpix < endpix ; startpix v++ ) 
code ) 
shapenum ) 
! scale || scale > maxscale ) 
( ( UNSIGNED *p ) & linescale ) + INT_CONST ) 
( ( UNSIGNED *p ) & linecmds ) + INT_CONST ) 
--v srcx >= stopx && slinex > INT_CONST ) 
) 
shape -> leftpix < INT_CONST ) 
++v srcx <= stopx && ( slinex += slinewidth ) < viewwidth ) 
shapenum ) 
( ( UNSIGNED *p ) & linescale ) + INT_CONST ) 
( ( UNSIGNED *p ) & linecmds ) + INT_CONST ) 
--v srcx >= stopx ) 
shape -> leftpix < INT_CONST ) 
++v srcx <= stopx ) 
__E__O__F__
mapsegs [ INT_CONST ] + farmapylookup [ new -> tiley ] + new -> tilex ) 
ob -> obclass == inertobj ) 
STRING ) 
mapsegs [ INT_CONST ] + farmapylookup [ ob -> tiley ] + ob -> tilex ) 
ob -> flags & FL_FIRSTATTACK ) 
deltax > INT_CONST ) 
deltay > INT_CONST ) 
deltax ) 
absdx > absdy ) 
US_RndT ( ) < INT_CONST ) 
FOR ( i = INT_CONST ; i < INT_CONST ; i v++ ) 
turnaround != nodir ) 
deltax > INT_CONST ) 
d [ INT_CONST ] == turnaround ) 
d [ INT_CONST ] != nodir ) 
olddir != nodir ) 
US_RndT ( ) > INT_CONST ) 
FOR ( tdir = north ; tdir <= west ; tdir v++ ) 
FOR ( tdir = west ; tdir >= north ; tdir v-- ) 
TryWalk ( ob ) ) 
turnaround != nodir ) 
deltax < INT_CONST ) 
TryWalk ( ob ) ) 
FOR ( tdir = north ; tdir <= west ; tdir v++ ) 
TryWalk ( ob ) ) 
FOR ( tdir = west ; tdir >= north ; tdir v-- ) 
TryWalk ( ob ) ) 
ob -> dir ) 
STRING ) 
areabyplayer [ ob -> areanumber ] ) 
ob -> dir ) 
! actorat [ tilex ] [ tiley ] ) 
FOR ( x = xl ; x <= xh ; x v++ ) 
FOR ( y = yl ; y <= yh ; y v++ ) 
ob -> obclass ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
INT_CONST ) 
! ( ob -> flags & FL_ATTACKMODE ) ) 
ob -> hitpoints <= INT_CONST ) 
xt2 - xt1 ) 
xdist > INT_CONST ) 
UNSIGNED ) 
yt2 - yt1 ) 
ydist > INT_CONST ) 
UNSIGNED ) 
! areabyplayer [ ob -> areanumber ] ) 
deltax > -v MINSIGHT && deltax < MINSIGHT NEW_LINE && deltay > -v MINSIGHT && deltay < MINSIGHT ) 
deltax < INT_CONST ) 
deltay < INT_CONST ) 
deltax > INT_CONST ) 
ob ) 
SPIONSND , ob ) 
ob , &v s_mutchase1 ) 
SCHUTZADSND , ob ) 
DOGBARKSND , ob ) 
GUTENTAGSND ) 
KEINSND ) 
EINESND ) 
ERLAUBENSND ) 
SCHABBSHASND ) 
TOT_HUNDSND ) 
DIESND ) 
DIESND ) 
ob , &v s_blinkychase1 ) 
GHOSTSIGHTSND ) 
ANGELSIGHTSND ) 
TRANSSIGHTSND ) 
ob , &v s_uberchase1 ) 
WILHELMSIGHTSND ) 
KNIGHTSIGHTSND ) 
ob -> distance < INT_CONST ) 
ob -> temp2 > INT_CONST ) 
ob -> flags & FL_AMBUSH ) 
ob ) 
__E__O__F__
ch < CHAR_CONST || ch > CHAR_CONST ) 
num ) 
) 
TimeCount < picdelay ) 
picx & ~ INT_CONST , picy , picnum ) 
toupper ( *v ++v text ) ) 
) 
*v ++v text ) 
) 
) 
) 
FOR ( i = top ; i <= bottom ; i v++ ) 
++v rowon == TEXTROWS ) 
ch == CHAR_CONST ) 
*v text > INT_CONST ) 
word , &v wwidth , &v wheight ) 
px + wwidth > rightmargin [ rowon ] ) 
word ) 
*v text == CHAR_CONST ) 
INT_CONST , INT_CONST , INT_CONST , INT_CONST , BACKCOLOR ) 
FOR ( i = INT_CONST ; i < TEXTROWS ; i v++ ) 
*v text <= INT_CONST ) 
shownumber ) 
numpages , str2 , INT_CONST ) 
STRING ) 
! which ) 
STARTFONT ) 
) 
) 
&v grsegs [ artnum ] ) 
) 
) 
) 
) 
INT_CONST , INT_CONST ) 
&v grsegs [ artnum ] ) 
__E__O__F__
psin << INT_CONST ) 
viewx + FixedMul ( length , pcos ) ) 
FOR ( y = INT_CONST ; y < halfheight ; y v++ ) 
INT_CONST ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
FOR ( x = INT_CONST ; x < INT_CONST ; x v++ ) 
viewheight >> INT_CONST != halfheight ) 
FOR ( x = INT_CONST ; x < viewwidth ; x v++ ) 
FOR ( ; lastheight < height ; lastheight v++ ) 
FOR ( ; lastheight < height ; lastheight v++ ) 
__E__O__F__
