
<A NAME="1">1</A>
C99 {ref Introduction}

With the introduction of new devices and extended character sets, new
features may be added to this International Standard.  Subclauses in
the language and library clauses warn implementors and programmers of
usages which, though valid in themselves, may conflict with future
additions.

Certain features are <i>obsolescent</i>, which means that they may be
considered for withdrawal in future revisions of this International
Standard.  They are retained because of their widespread use, but
their use in new implementations (for implementation features) or new
programs (for language [6.11] or library features [7.26]) is
discouraged.

This International Standard is divided into four major subdivisions:

&emdash;&nbsp; preliminary elements (clauses 1&endash;4);

&emdash;&nbsp; the characteristics of environments that translate and
execute C programs (clause 5);

&emdash;&nbsp; the language syntax, constraints, and semantics (clause 6);

&emdash;&nbsp; the library facilities (clause 7).

Examples are provided to illustrate possible forms of the
constructions described.  Footnotes are provided to emphasize
consequences of the rules described in that subclause or elsewhere in
this International Standard.  References are used to refer to other
related subclauses.  Recommendations are provided to give advice or
guidance to implementors.  Annexes provide additional information and
summarize the information contained in this International Standard.
A bibliography lists documents that were referred to during the
preparation of the standard.

The language clause (clause 6) is derived from <c99quote>The C
Reference Manual</c99quote>.

The library clause (clause 7) is based on the 1984 <i>/usr/group
Standard</i>.


.FIG
iso
<caption>
The ISO Technical Committee structure&emdash;&nbsp; JTC (Joint Technical
Committee, with the IEC in this case), TC (Technical Committee), SC
(Standards Committee), WG (Working Group).
</caption>
.E_FIG


.FIG
c_history
<caption>
Outline history of the C language and a few long-lived languages.
(Backus <book Backus_78> describes the earliest history of Fortran.)
</caption>
.E_FIG


.FIG
yi02
<caption>
Percentage of <phrase>trivial</phrase> computations during program
execution of the SPEC and MediaBench benchmarks for various kinds of
operation.  Adapted from Yi and Lilja <book Yi_02>.
</caption>
.E_FIG


.FIG
turley02
<caption>
Monthly unit sales of microprocessors having a given bus width.
Adapted from Turley <book Turley_02> (using data supplied by Turley).
</caption>
.E_FIG


.FIG
callds
<caption>
Dynamic/static frequency of <phrase>call</phrase> instructions.
Adapted from Davidson <book Davidson_89b>.
</caption>
.E_FIG


.FIG
dramcpu
<caption>
Relative performance of CPU against storage (DRAM),  1980==1.
Adapted from Hennessy <book Hennessy_96>.
</caption>
.E_FIG


.FIG
pipeline
<caption>
Simplified diagram of some typical stages in a processor instruction
pipeline: Instruction fetch, decode, execute, memory access, and
write back.
</caption>
.E_FIG


.FIG
ailamaki99
<caption>
Execution time breakdown, by four processor components (bottom of
graphs) for three different application queries (top of graphs).
Adapted from Ailamaki <book Ailamaki_99>.
</caption>
.E_FIG


.TABLE adams84
: c c c c c c c c c
Product, 19, 60, 190, 600, 1&comma;900, 6&comma;000, 19&comma;000, 60&comma;000
1, 0.7, 1.2, 2.1, 5.0, 10.3, 17.8, 28.8, 34.2
2, 0.7, 1.5, 3.2, 4.5, &z;9.7, 18.2, 28.0, 34.3
3, 0.4, 1.4, 2.8, 6.5, &z;8.7, 18.0, 28.5, 33.7
4, 0.1, 0.3, 2.0, 4.4, 11.9, 18.7, 28.5, 34.2
5, 0.7, 1.4, 2.9, 4.4, &z;9.4, 18.4, 28.5, 34.2
6, 0.3, 0.8, 2.1, 5.0, 11.5, 20.1, 28.2, 32.0
7, 0.6, 1.4, 2.7, 4.5, &z;9.9, 18.5, 28.5, 34.0
8, 1.1, 1.4, 2.7, 6.5, 11.1, 18.4, 27.1, 31.9
9, 0.0, 0.5, 1.9, 5.6, 12.8, 20.4, 27.6, 31.2
<caption>
Percentage of reported problems having a given mean time to first
problem occurrence (in months, summed over all installations of a
product) for various products (numbered 1 to 9), e.g., 28.8% of the
reported faults in product 1 were, on average, first reported after
19,000 months of program execution time (another 34.2% of problems
were first reported after 60,000 months).  From Adams <book Adams_84>.
</caption>
.E_TABLE


.FIG
nisbett_83
<caption>
Percentage of population estimated to have the sample property
against the number of cases in the sample.  Adapted from Nisbett
<book Nisbett_83>.
</caption>
.E_FIG


.TABLE perry_9a
: r 3.3cm 1.0cm 0.8cm r 3.2cm 1.0cm 0.8cm
Rank, Fault Description, % Total Faults, Fix Rank, Rank, Fault Description, % Total Faults, Fix Rank
1, internal functionality, 25.0, 13,     12, error handling, &z;3.3, &z;6
2, interface complexity, 11.4, 10,       13, primitive's misuse, &z;2.4, 11
3, unexpected dependencies, &z;8.0, &z;4, 14, dynamic data use, &z;2.1, 15
4, low-level logic, &z;7.9, 17,          15, resource allocation, &z;1.5, &z;2
5, design/code complexity, &z;7.7, &z;3, 16, static data design, &z;1.0, 19
6, other, &z;5.8, 12,                    17, performance, &z;0.9, &z;1
7, change coordinates, &z;4.9, 14,       18, unknown interactions, &z;0.7, &z;5
8, concurrent work, &z;4.4, &z;9,        19, primitives unsupported, &z;0.6, 19
9, race conditions, &z;4.3, &z;7,        20, IPC rule violated, &z;0.4, 16
10, external functionality, &z;3.6, &z;8, 21, change management complexity, &z;0.3, 21
11, language pitfalls i.e.&comma; use of <keyword>=</keyword> when <keyword>==</keyword> intended, &z;3.5, 18, 22, dynamic data design, &z;0.3, 21
<caption>
Fault categories ordered by frequency of occurrence.  The last
column is the rank position after the fault fix weighting factor
is taken into account.  Based on Perry <book Perry_93>.
</caption>
.E_TABLE


.TABLE perry_9b
: r l 1cm 1cm
Rank, Cause Description, % Total Causes, Fix Rank
1, incomplete/omitted design, 25.2, &z;3
2, none given, 20.5, 10
3, lack of knowledge, 17.8, &z;8
4, ambiguous design, &z;9.8, &z;9
5, earlier incorrect fix, &z;7.3, &z;7
6, submitted under duress, &z;6.8, &z;6
7, incomplete/omitted requirements, &z;5.4, &z;2
8, other, &z;4.1, &z;4
9, ambiguous requirements, &z;2.0, &z;1
10, incorrect modifications, &z;1.1, &z;5
<caption>
Underlying cause of faults. The <phrase>none given</phrase> category
occurs because sometimes both the fault and the underlying cause are
the same.  For instance, <phrase>language pitfalls</phrase>, or
<phrase>low-level logic</phrase>.  Based on Perry <book Perry_93>.
</caption>
.E_TABLE


.TABLE perry_9c
: r 4.8cm 1.2cm 1cm
Rank, Means Description, % Observed, Fix Rank
1, application walk-through, 24.5, &z;8
2, provide expert/clearer documentation, 15.7, &z;3
3, guideline enforcement, 13.3, 10
4, requirements/design templates, 10.0, &z;5
5, better test planning, &z;9.9, &z;9
6, formal requirements, &z;8.8, &z;2
7, formal interface specifications, &z;7.2, &z;4
8, other, &z;6.9, &z;6
9, training, &z;2.2, &z;1
10, keep document/code in sync, &z;1.5, &z;7
<caption>
Means of fault prevention.  The last column is the rank position
after the fault fix weighting factor is taken into account.  Based on
Perry <book Perry_93>.
</caption>
.E_TABLE


.FIG
kahneman_82
<caption>
Median judged probability of subjects choosing an engineer, for five
descriptions and for the null description (unfilled circle symbol).
Adapted from Kahneman <book Kahneman_73>.
</caption>
.E_FIG


.FIG
stevens_78
<caption>
Country boundaries distort judgment of relative city locations.
Adapted from Stevens <book Stevens_78>.
</caption>
.E_FIG


.FIG
collins_69
<caption>
Hypothetical memory structure for a three-level hierarchy.
Adapted from Collins <book Collins_69>.
</caption>
.E_FIG


.TABLE murphy_85
: 6cm 7.5cm
Properties of Explanations, Role in Conceptual Coherence
<phrase>Explanation</phrase> of a sort&comma; specified over some domain of observation, Constrains which attributes will be included in a concept representation
 , Focuses on certain relationships over others in detecting attribute correlations
Simplify reality, Concepts may be idealizations that impose more structure than is <phrase>objectively</phrase> present
Have an external structure&emdash; fits in with (or do not contradict) what is already known, Stresses intercategory structure; attributes are considered essential to the degree that they play a part in related theories (external structures)
Have an internal structure&emdash; defined in part by relations connecting attributes, Emphasizes mutual constraints among attributes.  May suggest how concept attributes are learned
Interact with data and observations in some way, Calls attention to inference processes in categorization and suggests that more than attribute matching is involved
<caption>
General properties of explanations and their potential role in
understanding conceptual coherence.  Adapted from Murphy <book Murphy_85>.
</caption>
.E_TABLE


.TABLE similar_1
: l c c c c c c
Attribute, 1, 2, 3, 4, 5, 6
Starling, +, +, &minus;, +, +, +
Sandpiper, +, +, +, +, &minus;, +
Attribute similarity, <equ>t</equ>,  <equ>t</equ>, <equ>s<sub>3</sub></equ>,  <equ>t</equ>, <equ>s<sub>5</sub></equ>, <equ>t</equ>
<caption>
Computation of pattern similarity.  Adapted from Estes <book Estes_94>.
</caption>
.E_TABLE


.TABLE similar_2
Object, Ro, Bl, Sw, St, Vu, Sa, Ch, Fl, Pe, Similarity to Category
Robin, <equ>1</equ>, <equ>1</equ>, <equ>1</equ>, <equ>s</equ>, <equ>s<sup>4</sup></equ>, <equ>s</equ>, <equ>s<sup>5</sup></equ>,  <equ>s<sup>6</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>3+2s+s<sup>4</sup>+2s<sup>5</sup>+s<sup>6</sup></equ>
Bluebird, <equ>1</equ>, <equ>1</equ>, <equ>1</equ>, <equ>s</equ>, <equ>s<sup>4</sup></equ>, <equ>s</equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>6</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>3+2s+s<sup>4</sup>+2s<sup>5</sup>+s<sup>6</sup></equ>
Swallow, <equ>1</equ>, <equ>1</equ>, <equ>1</equ>, <equ>s</equ>, <equ>s<sup>4</sup></equ>, <equ>s</equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>6</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>3+2s+s<sup>4</sup>+2s<sup>5</sup>+s<sup>6</sup></equ>
Starling, <equ>s</equ>, <equ>s</equ>, <equ>s</equ>, <equ>1</equ>, <equ>s<sup>3</sup></equ>, <equ>s<sup>2</sup></equ>, <equ>s<sup>6</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>6</sup></equ>, <equ>1+3s+s<sup>2</sup>+s<sup>3</sup>+s<sup>5</sup>+2s<sup>6</sup></equ>
Vulture, <equ>s<sup>4</sup></equ>, <equ>s<sup>4</sup></equ>, <equ>s<sup>4</sup></equ>, <equ>s<sup>3</sup></equ>, <equ>1</equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>3</sup></equ>, <equ>s<sup>2</sup></equ>, <equ>s<sup>3</sup></equ>, <equ>1+s<sup>2</sup>+3s<sup>3</sup>+3s<sup>4</sup>+s<sup>5</sup></equ>
Sandpiper, <equ>s</equ>, <equ>s</equ>, <equ>s</equ>, <equ>s<sup>2</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>1</equ>, <equ>s<sup>4</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>4</sup></equ>, <equ>1+3s+s<sup>2</sup>+s<sup>4</sup>+s<sup>5</sup></equ>
Chicken, <equ>s<sup>5</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>6</sup></equ>, <equ>s<sup>3</sup></equ>, <equ>s<sup>4</sup></equ>, <equ>1</equ>, <equ>s</equ>, <equ>1</equ>, <equ>2+s+s<sup>3</sup>+s<sup>4</sup>+3s<sup>5</sup>+s<sup>6</sup></equ>
Flamingo, <equ>s<sup>6</sup></equ>, <equ>s<sup>6</sup></equ>, <equ>s<sup>6</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>2</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>s</equ>, <equ>1</equ>, <equ>s</equ>, <equ>1+2s+s<sup>2</sup>+2s<sup>5</sup>+3s<sup>6</sup></equ>
Penguin, <equ>s<sup>5</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>5</sup></equ>, <equ>s<sup>6</sup></equ>, <equ>s<sup>3</sup></equ>, <equ>s<sup>4</sup></equ>, <equ>1</equ>, <equ>s</equ>, <equ>1</equ>, <equ>2+s+s<sup>3</sup>+s<sup>4</sup>+3s<sup>5</sup>+s<sup>6</sup></equ>
<caption>
Computation of similarity to category.  Adapted from Estes <book Estes_94>.
</caption>
.E_TABLE


.TABLE similar_4
: l l c c c
Object, Similarity Formula, <equ>s=0.5</equ>, Relative Frequency, Weighted Similarity
Robin, <equ>3+2s+s<sup>4</sup>+2s<sup>5</sup>+s<sup>6</sup></equ>, 4.14, 0.30, 1.24
Bluebird, <equ>3+2s+s<sup>4</sup>+2s<sup>5</sup>+s<sup>6</sup></equ>, 4.14, 0.20, 0.83
Swallow, <equ>3+2s+s<sup>4</sup>+2s<sup>5</sup>+s<sup>6</sup></equ>, 4.14, 0.10, 0.41
Starling, <equ>1+3s+s<sup>2</sup>+s<sup>3</sup>+s<sup>5</sup>+2s<sup>6</sup></equ>, 2.94, 0.15, 0.44
Vulture, <equ>1+s<sup>2</sup>+3s<sup>3</sup>+3s<sup>4</sup>+s<sup>5</sup></equ>, 1.84, 0.02, 0.04
Sandpiper, <equ>1+3s+s<sup>2</sup>+s<sup>4</sup>+s<sup>5</sup></equ>, 2.94, 0.05, 0.15
Chicken, <equ>2+s+s<sup>3</sup>+s<sup>4</sup>+3s<sup>5</sup>+s<sup>6</sup></equ>, 2.80, 0.15, 0.42
Flamingo, <equ>1+2s+s<sup>2</sup>+2s<sup>5</sup>+3s<sup>6</sup></equ>, 2.36, 0.01, 0.02
Penguin, <equ>2+s+s<sup>3</sup>+s<sup>4</sup>+3s<sup>5</sup>+s<sup>6</sup></equ>, 2.80, 0.02, 0.06
<caption>
Computation of weighted similarity to category.  From Estes <book Estes_94>.
</caption>
.E_TABLE


.TABLE similar_5
: l c c
Stimulus, Similarity to A, Similarity to B
Dark triangle, <equ>1+s</equ>, <equ>s+s<sup>2</sup></equ>
Dark square, <equ>1+s</equ>, <equ>s+s<sup>2</sup></equ>
Light triangle, <equ>s+s<sup>2</sup></equ>, <equ>1+s</equ>
Light square, <equ>s+s<sup>2</sup></equ>, <equ>1+s</equ>
<caption>
Similarity to category (black triangle and black square assigned to
category A; white triangle and white square assigned to category B).
</caption>
.E_TABLE


.TABLE similar_6
: l c c
Stimulus, Similarity to A, Similarity to B
Dark triangle, <equ>s+s<sup>2</sup></equ>, <equ>2s</equ>
Dark square, <equ>2s</equ>, <equ>s+s<sup>2</sup></equ>
Light triangle, <equ>2s</equ>, <equ>s+s<sup>2</sup></equ>
Light square, <equ>s+s<sup>2</sup></equ>, <equ>2s</equ>
<caption>
Similarity to category (black triangle and white square assigned to
category A; white triangle and black square assigned to category B).
</caption>
.E_TABLE


.FIG
shep61_f2
<caption>
Representation of stimuli with shape in the horizontal plane and
color in one of the vertical planes.  Adapted from Shepard <book
Shepard_61>.
</caption>
.E_FIG


.FIG
shep61_f3
<caption>
One of the six unique configurations (i.e., it is not possible to
rotate one configuration into another) of selecting four times from
eight possibilities.  Adapted from Shepard <book Shepard_61>.
</caption>
.E_FIG


.FIG
shep61_f1
<caption>
Example list of categories.  Adapted from Shepard <book Shepard_61>.
</caption>
.E_FIG


.TABLE decision_1
: c r c
Alternative, Storage Needed, Speed of Execution
X,  7K, Low
Y, 15K, High
Z, 10K, Medium
<caption>
Storage/Execution performance alternatives.
</caption>
.E_TABLE


.FIG
agenda
<caption>
Decisions based on different pair-wise associations.
</caption>
.E_FIG


.FIG
payne93
<caption>
Effort and accuracy levels for various decision-making strategies;
EBA (Elimination-by-aspects heuristic), EQW (equal weight heuristic),
LEX (lexicographic heuristic), MCD (majority of confirming dimensions
heuristic), RC (Random choice), and WADD (weighted additive rule).
Adapted from Payne <book Payne_93>.
</caption>
.E_FIG


.FIG
lichten77
<caption>
Calibration of hard and easy questions.
Adapted from Lichtenstein <book Lichtenstein_77>.
</caption>
.E_FIG


.TABLE decision_2
: 5.5cm 3.7cm 4.3cm
Task Characteristic, Intuition-Inducing State of Task Characteristic, Analysis-Inducing State of Task Characteristic
Number of cues, Large (>5), Small
Measurement of cues, Perceptual measurement, Objective reliable measurement
Distribution of cue values, Continuous highly variable distribution, Unknown distribution; cues are dichotomous; values are discrete
Redundancy among cues, High redundancy, Low redundancy
Decomposition of task, Low, High
Degree of certainty in task, Low certainty, High certainty
Relation between cues and criterion, Linear, Nonlinear
Weighting of cues in environmental model, Equal, Unequal
Availability of organizing principle, Unavailable, Available
Display of cues, Simultaneous display, Sequential display
Time period, Brief, Long
<caption>
Inducement of intuitive cognition and analytic cognition, by task conditions.
Adapted from Hammond <book Hammond_87>.
</caption>
.E_TABLE


.FIG
checkershadow
<caption>
Checker shadow (by Edward Adelson).
<inverted>Both squares reflect the same amount of light (this can be verified by
</inverted>
<inverted>covering all of squares except the two indicated), but the
human visual system assigns a relative brightness that is
</inverted>
<inverted>consistent with the checker pattern
</inverted>.
</caption>
.E_FIG


.FIG
thatcher
<caption>
The Thatcher illusion.  With permission from Thompson <book
Thompson_80>.  The facial images look very similar when viewed in one
orientation and very different when viewed in another (turn page
upside down).
</caption>
.E_FIG


.TABLE cog_anom
: 3.4cm 10.5cm
Effect, Description
<b>CONTEXT</b>
Anchoring, Judgments are influenced by quantitative cues contained in the statement of the decision task
Context, Prior choices and available options in the decision task influence perception and motivation
Framing, Selection between mathematically equivalent solutions to a problem depends on how their outcome is framed.
Prominence, The format in which a decision task is stated influences the weight given to different aspects
<b>REFERENCE POINT</b>
Risk asymmetry, Subjects show risk-aversion for gains&comma; risk-preference for losses&comma; and weigh losses more heavily
Reference point, Choices are evaluated in terms of changes from an endowment or status quo point
Endowment, Possessed goods are valued more highly than those not possessed; once a function has been written, developers are loath to throw it away and start again
<b>AVAILABILITY</b>
Availability, Responses rely too heavily on readily retrievable information and too little on background information
Certainty, Sure outcomes are given more weight than uncertain outcomes
Experience, Personal history is favored relative to alternatives not experienced
Focal, Quantitative information is retrieved or reported categorically
Isolation, The elements of a multiple-part or multi-stage lottery are evaluated separately
Primacy and Recency, Initial and recently experienced events are the most easily recalled
Regression, Idiosyncratic causes are attached to past fluctuations&comma; and regression to the mean is underestimated
Representativeness, High conditional probabilities induce overestimates of unconditional probabilities
Segregation, Lotteries are decomposed into a sure outcome and a gamble relative to this sure outcome
<b>SUPERSTITION</b>
Credulity, Evidence that supports patterns and causal explanations for coincidences is accepted too readily
Disjunctive, Consumers fail to reason through or accept the logical consequences of actions
Superstition, Causal structures are attached to coincidences&comma; and "quasi-magical" powers to opponents
Suspicion, Consumers mistrust offers and question the motives of opponents&comma; particularly in unfamiliar situations
<b>PROCESS</b>
Rule-Driven, Behavior is guided by principles&comma; analogies&comma; and exemplars rather than utilitarian calculus
Process, Evaluation of outcomes is sensitive to process and change
Temporal, Time discounting is temporally inconsistent&comma; with short delays discounted too sharply relative to long delays
<b>PROJECTION</b>
Misrepresentation, Subjects may misrepresent judgments for real or perceived strategic advantage
Projection, Judgments are altered to reinforce internally or project to others a self-image
<caption>
Cognitive anomalies.  Adapted from McFadden <book McFadden_98>.
</caption>
.E_TABLE


.FIG
ackerman97
<caption>
A list of and structure of ability constructs.
Adapted from Ackerman <book Ackerman_97>.
</caption>
.E_FIG


.FIG
work_mem
<caption>
Model of working memory.
Adapted from Baddeley <book Baddeley_99>.
</caption>
.E_FIG


.TABLE mem_1
List 1, List 2, List 3, List 4, List 5
one,    cat,    card,   harm,   add
bank,   lift,   list,   bank,   mark
sit,    able,   inch,   view,   bar
kind,   held,   act,    fact,   few
look,   mean,   what,   time,   sum
    ,       ,       ,       , 
ability,       basically,   encountered,  laboratory,   commitment
particular,    yesterday,   government,   acceptable,   minority
mathematical,  department,  financial,    university,   battery
categorize,    satisfied,   absolutely,   meaningful,   opportunity
inadequate,    beautiful,   together,     carefully,    accidental
<caption>
Words with either one or more than one syllable (and thus varying
in the length of time taken to speak).
</caption>
.E_TABLE


.FIG
stern69
<caption>
Judgment time (in milliseconds) as a function of the number of digits
held in memory.  Adapted from Sternberg <book Sternberg_69>.
</caption>
.E_FIG


.FIG
cavan72
<caption>
Judgment time (msec per item) as a function of the number of
different items held in memory.  Adapted from Cavanagh <book
Cavanagh_72>
</caption>
.E_FIG


.FIG
klahr83
<caption>
Semantic memory representation of alphabetic letters (the Greek names
assigned to nodes by Klahr are used by the search algorithm and are
not actually held in memory).  Readers may recognize the structure of
a nursery rhyme in the letter sequences.  Derived from Klahr <book
Klahr_83>.
</caption>
.E_FIG


.FIG 15cm
blockrot
<caption>
One of the two pairs are rotated copies of each other.
</caption>
.E_FIG


.FIG
anderson81
<caption>
Proportion of errors (left) and time to recall (right) for recall
of paired associate words.  Based on Anderson <book Anderson_81>.
</caption>
.E_FIG


.FIG
bahrick84
<caption>
Effect of level of training on the retention of recognition of
English&endash; Spanish vocabulary.  Adapted from Bahrick <book Bahrick_84>.
</caption>
.E_FIG


.TABLE anderson_1
: 2.5cm 2.5cm 2.5cm
Subject 1, Subject 2, Subject 3
Learn A&Rightarrow;B, Learn C&Rightarrow;D, Rest
Learn A&Rightarrow;D, Learn A&Rightarrow;B, Learn A&Rightarrow;D

Worse, Better

Test A&Rightarrow;D, Test A&Rightarrow;D, Test A&Rightarrow;D

Worse, Worse
<caption>
Proactive inhibition.  The third row indicates learning performance;
the fifth row indicates recall performance, relative to that of the
control.  Based on Anderson <book Anderson_00a>.
</caption>
.E_TABLE


.TABLE anderson_2
: 2.5cm 2.5cm 2.5cm
Subject 1, Subject 2, Subject 3
Learn A&Rightarrow;B, Learn A&Rightarrow;B, Learn A&Rightarrow;B
Learn A&Rightarrow;D, Learn C&Rightarrow;D, Rest
Test A&Rightarrow;B, Test A&Rightarrow;B, Test A&Rightarrow;B

Much worse, Worse
<caption>
Retroactive inhibition.  The fourth row indicates subject performance
relative to that of the control.
Based on Anderson <book Anderson_00a>.
</caption>
.E_TABLE


.FIG
bower69
<caption>
Words organized according to their properties&emdash; the
<phrase>minerals</phrase> conceptual hierarchy.  Adapted from Bower, Clark,
Lesgold, and Winzenz <book Bower_69>.
</caption>
.E_FIG


.TABLE error_1
Inattention, Over Attention
Double-capture slips, Omissions
Omissions following interruptions, Repetitions
Reduced intentionality, Reversals
Perceptual confusions, 
Interference errors, 
<caption>
Main failure modes for skill-based performance.
Adapted from Reason <book Reason_90>.
</caption>
.E_TABLE


.TABLE error_2
Misapplication of Good Rules, Application of Bad Rules
First exceptions, Encoding deficiencies
Countersigns and nosigns, Action deficiencies
Information overload, Wrong rules
Rule strength, Inelegant rules
General rules, Inadvisable rules
Redundancy, 
Rigidity, 
<caption>
Main failure modes for rule-base performance.
Adapted from Reason <book Reason_90>.
</caption>
.E_TABLE


.TABLE error_3
Knowledge-based Failure Modes
Selectivity
Workspace limitations
Out of&comma; sight out of mind
Confirmation bias
Overconfidence
Biased reviewing
Illusory correlation
Halo effects
Problems with causality
Problems with complexity
&hspace; Problems with delayed feed-back
&hspace; Insufficient consideration of processes in time
&hspace; Difficulties with exponential developments
&hspace; Thinking in causal series not causal nets (unaware of side-effects of action)
&hspace; Thematic vagabonding (flitting from issue to issue)
&hspace; Encysting (lingering in small detail over topics)
<caption>
Main failure modes for knowledge-based performance.
Adapted from Reason <book Reason_90>.
</caption>
.E_TABLE


.FIG
kahneman_00a
<caption>
Relationship between subjective value to gains and to losses.
Adapted from Kahneman <book Kahneman_79>.
</caption>
.E_FIG


.FIG
kahneman_00b
<caption>
Possible relationship between subjective and objective probability.
Adapted from Kahneman <book Kahneman_79>.
</caption>
.E_FIG


.FIG
tversky_93
<caption>
Text of background trade-off.
Adapted from Tversky <book Tversky_93>.
</caption>
.E_FIG


.TABLE tversky
Warranty, Price,  S<sub>1</sub>, S<sub>2</sub>
X<sub>1</sub>, $85, 12%
Y<sub>1</sub>, $91, 88%

X<sub>2</sub>, $25, , 84%
Y<sub>2</sub>, $49, , 16%

X, $60, 57%, 33%
Y, $75, 43%, 67%
<caption>
Percentage of each alternative selected by subject groups
<equ>S<sub>1</sub></equ> and <equ>S<sub>2</sub></equ>.
Adapted from Tversky <book Tversky_93>.
</caption>
.E_TABLE


.TABLE knetsch
Group, Yes, No
Give up mug to obtain candy, 89%, 11%
Give up candy to obtain mug, 90%, 10%
<caption>
Percentage of subjects willing to exchange what they had been
given for an equivalently priced item.  Adapted from Knetsch <book Knetsch_86>.
</caption>
.E_TABLE


.TABLE kahneman_72
: 3.6cm c c
Choice, Less than 6, More than 6
The page investigator, 20.8%<sup>*</sup>, 16.3%
The line investigator, 31.3%, 42.9%<sup>*</sup>
About the same (i.e.&comma; within 5% of each other), 47.9%, 40.8%
<caption>
Percentage of subjects giving each answer.  Correct answers are starred.
Adapted from Kahneman <book Kahneman_72>.
</caption>
.E_TABLE


.FIG
hogarth92
<caption>
Subjects belief response curves for positive weak&endash;strong,
negative weak&endash;strong, and positive&endash;negative evidence;
(a) Step-by-Step, (b) End-of-Sequence.  Adapted from Hogarth <book
Hogarth_92>.
</caption>
.E_FIG


.FIG
mccloskey83
<caption>
Two proposed trajectories of a ball dropped from a moving airplane.
Based on McCloskey <book McCloskey_83>.
</caption>
.E_FIG


.FIG
pazzani91
<caption>
Number of examples needed before <phrase>alpha</phrase> or
<phrase>inflate</phrase> condition correctly predicted in
six successive pictures.
Adapted from Pazzani <book Pazzani_91>
</caption>
.E_FIG


.FIG
klayman87
<caption>
Possible relationships between hypothesis and rule.
Adapted from Klayman <book Klayman_87>.
</caption>
.E_FIG


.TABLE progmeasure
Name, Application Domain, Version
gcc, C compiler, 2.95
idsoftware, games programs&comma; e.g.&comma; Doom, 
linux, operating system, 2.4.20
mozilla, web browser, 1.0
openafs, file system, 1.2.2a
openMotif, window manager, 2.2.2
postgresql, database system, 6.5.3
<caption>
Programs whose source code (i.e., the <file>.c</file> and
<file>.h</file> files) was used as the input to tools (operating on
either the visible or translated forms) whose measurements was used
to generate this books usage figures and tables.
</caption>
.E_TABLE


.TABLE
Files, Reason for Exclusion
gcc-2.95/libio/tests/tfformat.c, a list of approximately 4&comma;000 floating constants
gcc-2.95/libio/tests/tiformat.c, a list of approximately 5&comma;000 hexadecimal constants
<caption>
Source files excluded from the Usage measurements.
</caption>
.E_TABLE


.TABLE
Symbol, Meaning, Symbol, Meaning

<keyword>++v</keyword>, prefix <keyword>++</keyword>, <keyword>--v</keyword>, prefix <keyword>--</keyword>
<keyword>v++</keyword>, postfix <keyword>++</keyword>, <keyword>v--</keyword>, postfix <keyword>--</keyword>
<keyword>-v</keyword>, unary minus, <keyword>+v</keyword>, unary plus
<keyword>*v</keyword>, indirection operator, <keyword>*p</keyword>, star in pointer declaration
<keyword>&v</keyword>, address-of, , 
<keyword>:b</keyword>, colon in bitfield declaration, <keyword>?:</keyword>, colon in ternary operator
<caption>
Character sequences used to denote those operators and punctuators
that perform more than one role in the syntax.
</caption>
.E_TABLE


<A NAME="65">1</A> FP
C99 {ref correctly rounded result}

<b>correctly rounded result</b>

representation in the result format that is nearest in value, subject
to the effective rounding mode, to what the result would be given
unlimited range and precision


.FIG
round
<caption>
Some exactly representable values and three values (<equ>a</equ>,
<equ>b</equ>, and <equ>c</equ>) that are not exactly representable.
</caption>
.E_FIG


<A NAME="93">1</A>
C99 {ref implementation, two forms} {ref conformance, implementation}

The two forms of <i>conforming implementation</i> are hosted and
freestanding.


.FIG
conformance
<caption>
A conforming implementation (gray area) correctly handles all
strictly conforming programs, may successfully translate and execute
some of the possible conforming programs, and may include some of the
possible extensions.
</caption>
.E_FIG


<A NAME="108">1</A>
C99 {ref program, not translated at same time}

A C program need not all be translated at the same time.


.FIG
linton
<caption>
Number of programs built from a given number of translation units.
Adapted from Linton <book Linton_89>.
</caption>
.E_FIG


<A NAME="117">2</A>
C99 {ref translation phase, 1}

1. Physical source file multibyte characters are mapped, in an
implementation-defined manner, to the source character set
(introducing new-line characters for end-of-line indicators) if
necessary.


.TABLE char_cnt
: l r r
 , <file>.c</file> files, <file>.h</file> files
total characters, &zs;192165594&ze;, &zs;64429463&ze;
total new-lines, &zs;6976266&ze;, &zs;1811790&ze;
noncomment characters, &zs;144568262&ze;, &zs;43485916&ze;
noncomment new-lines, &zs;6113075&ze;, &zs;1491192&ze;
<caption>
Total number of characters and new-lines in the visible form of the
<file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


<A NAME="119">6</A>
C99 {ref translation phase, 2} {ref physical source line} {ref logical source line}

2. Each instance of a backslash character (<keyword>\</keyword>)
immediately followed by a new-line character is deleted, splicing
physical source lines to form logical source lines.


.FIG
splice
<caption>
Number of physical lines spliced together to form one logical line
and the number of logical lines, of a given length, after splicing,
based on the visible form of the <file>.c</file> and <file>.h</file>
files.
</caption>
.E_FIG


<A NAME="140">30</A>
C99 {ref program image}

All such translator output is collected into a program image which
contains information needed for execution in its execution
environment.


.TABLE lee_99
Application, Total, Touched, Utilization
acrobat,    404, 246 (&z;60), 28
netscape,   388, 388 (100),   26
photoshop,  594, 479 (&z;80), 28
powerpoint, 766, 164 (&z;21), 32
word,       743, 300 (&z;40), 47
<caption>
<phrase>Total</phrase> is the number of code pages in the
application; <phrase>Touched</phrase> the number of code pages
touched during startup; <phrase>Utilization</phrase> the average
fraction of functions used during startup in each code page.
Adapted from Lee <book Lee_99>.
</caption>
.E_TABLE


<A NAME="189">2</A>
C99 {ref expression, need not evaluate part of}

An actual implementation need not evaluate part of an expression if
it can deduce that its value is not used and that no needed side
effects are produced (including any caused by calling a function or
accessing a volatile object).


.FIG
unrefed
<caption>
Number of parameters or locally defined objects that are not
referenced in a function definition (left graph); number of objects
declared in a scope that is wider than that needed for the references
to them in a function definition (right graph) .  Based on the
translated form of the books benchmark programs.
</caption>
.E_FIG


<A NAME="220">1</A>
C99 {ref basic source character set} {ref basic execution character set}

Both the basic source and basic execution character sets shall have
the following members: the 26 <i>uppercase letters</i> of the Latin
alphabet

.ASIS
        <keyword>A  B  C  D  E  F  G  H  I  J  K  L  M
        N  O  P  Q  R  S  T  U  V  W  X  Y  Z</keyword>
.E_ASIS

the 26 <i>lowercase letters</i> of the Latin alphabet

.ASIS
        <keyword>a  b  c  d  e  f  g  h  i  j  k  l  m
        n  o  p  q  r  s  t  u  v  w  x  y  z</keyword>
.E_ASIS

the 10 decimal <i>digits</i>

.ASIS
        <keyword>0  1  2  3  4  5  6  7  8  9</keyword>
.E_ASIS

the following 29 graphic characters

.ASIS
        <keyword>!  "  #  %  &  '  (  )  *  +  ,  -  .  /  :
        ;  <  =  >  ?  [  \  ]  ^  _  {  |  }  ~</keyword>
.E_ASIS

the space character, and control characters representing horizontal
tab, vertical tab, and form feed.


.TABLE
Language,     Letters
English,      etaoinsrhldcumfpgwybvkxjqz
French,       esaitnrulodcmp&eup;vqfbghj&adown;x&edown;y&ehat;z&ahat;&ccidila;&ihat;&udown;&ohat;&uhat;&idots;k&edots;w
Norwegian,    erntsilakodgmvfupbh&oslash;jy&aa;&ae;cwzx(q)
Swedish,      eantrsildomkgv&adots;fhup&aa;&odots;bcyjxwz&eup;q
Icelandic,    anriestu&dh;lgmkfhvo&aup;&th;&iup;dj&oup;by&ae;&uup;&odots;p&eup;&ydown;cxwzq
Hungarian,    eatlnskomzrig&aup;&eup;ydbvhj&ohung;fup&odots;&oup;c&uhung;&iup;&uup;&udots;xw(q)
<caption>
Relative frequency (most common to least common, with parenthesis
used bracket extremely rare letters) of letter usage in various human
languages (the English ranking is based on the British National
Corpus).  Based on Kelk <book letter_rank_03>.
</caption>
.E_TABLE


.TABLE char_freq
: 0.8cm r 1.0cm 0.8cm r 1.0cm 0.8cm r 1.0cm 0.8cm r 1.0cm
Letter or ASCII Value, All, Non-comment, Letter or ASCII Value, All, Non-comment, Letter or ASCII Value, All, Non-comment, Letter or ASCII Value, All, Non-comment
 <b>0</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>sp</b>, &z3p;15.083&ze;, &z3p;13.927&ze;, <b>@</b>, &z3p;0.009&ze;, &z3p;0.002&ze;, <b>`</b>, &z3p;0.004&ze;, &z3p;0.002&ze;
 <b>1</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>!</b>, &z3p;0.102&ze;, &z3p;0.127&ze;, <b>A</b>, &z3p;0.592&ze;, &z3p;0.642&ze;, <b>a</b>, &z3p;3.132&ze;, &z3p;2.830&ze;
 <b>2</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>"</b>, &z3p;0.376&ze;, &z3p;0.471&ze;, <b>B</b>, &z3p;0.258&ze;, &z3p;0.287&ze;, <b>b</b>, &z3p;0.846&ze;, &z3p;0.812&ze;
 <b>3</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>#</b>, &z3p;0.175&ze;, &z3p;0.219&ze;, <b>C</b>, &z3p;0.607&ze;, &z3p;0.663&ze;, <b>c</b>, &z3p;2.168&ze;, &z3p;2.178&ze;
 <b>4</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>$</b>, &z3p;0.005&ze;, &z3p;0.003&ze;, <b>D</b>, &z3p;0.461&ze;, &z3p;0.523&ze;, <b>d</b>, &z3p;2.184&ze;, &z3p;2.176&ze;
 <b>5</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>%</b>, &z3p;0.105&ze;, &z3p;0.135&ze;, <b>E</b>, &z3p;0.869&ze;, &z3p;1.012&ze;, <b>e</b>, &z3p;5.642&ze;, &z3p;4.981&ze;
 <b>6</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>&</b>, &z3p;0.237&ze;, &z3p;0.311&ze;, <b>F</b>, &z3p;0.333&ze;, &z3p;0.355&ze;, <b>f</b>, &z3p;1.666&ze;, &z3p;1.725&ze;
 <b>7</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>'</b>, &z3p;0.101&ze;, &z3p;0.080&ze;, <b>G</b>, &z3p;0.243&ze;, &z3p;0.263&ze;, <b>g</b>, &z3p;0.923&ze;, &z3p;0.906&ze;
 <b>8</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>(</b>, &z3p;1.372&ze;, &z3p;1.751&ze;, <b>H</b>, &z3p;0.146&ze;, &z3p;0.155&ze;, <b>h</b>, &z3p;1.145&ze;, &z3p;0.777&ze;
 <b>\t</b>, &z3p;3.350&ze;, &z3p;4.116&ze;, <b>)</b>, &z3p;1.373&ze;, &z3p;1.751&ze;, <b>I</b>, &z3p;0.619&ze;, &z3p;0.643&ze;, <b>i</b>, &z3p;3.639&ze;, &z3p;3.469&ze;
 <b>\n</b>, &z3p;3.630&ze;, &z3p;4.229&ze;, <b>*</b>, &z3p;1.769&ze;, &z3p;0.769&ze;, <b>J</b>, &z3p;0.024&ze;, &z3p;0.026&ze;, <b>j</b>, &z3p;0.074&ze;, &z3p;0.077&ze;
 <b>11</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>+</b>, &z3p;0.182&ze;, &z3p;0.233&ze;, <b>K</b>, &z3p;0.098&ze;, &z3p;0.116&ze;, <b>k</b>, &z3p;0.464&ze;, &z3p;0.481&ze;
 <b>12</b>, &z3p;0.003&ze;, &z3p;0.004&ze;, <b>,</b>, &z3p;1.565&ze;, &z3p;1.914&ze;, <b>L</b>, &z3p;0.528&ze;, &z3p;0.609&ze;, <b>l</b>, &z3p;2.033&ze;, &z3p;1.915&ze;
 <b>\r</b>, &z3p;0.001&ze;, &z3p;0.001&ze;, <b>-</b>, &z3p;1.176&ze;, &z3p;0.831&ze;, <b>M</b>, &z3p;0.333&ze;, &z3p;0.366&ze;, <b>m</b>, &z3p;1.245&ze;, &z3p;1.229&ze;
 <b>14</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>.</b>, &z3p;0.512&ze;, &z3p;0.387&ze;, <b>N</b>, &z3p;0.557&ze;, &z3p;0.610&ze;, <b>n</b>, &z3p;3.225&ze;, &z3p;2.989&ze;
 <b>15</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>/</b>, &z3p;0.718&ze;, &z3p;0.519&ze;, <b>O</b>, &z3p;0.467&ze;, &z3p;0.517&ze;, <b>o</b>, &z3p;2.784&ze;, &z3p;2.328&ze;
 <b>16</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>0</b>, &z3p;1.465&ze;, &z3p;1.694&ze;, <b>P</b>, &z3p;0.460&ze;, &z3p;0.508&ze;, <b>p</b>, &z3p;1.505&ze;, &z3p;1.551&ze;
 <b>17</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>1</b>, &z3p;0.502&ze;, &z3p;0.551&ze;, <b>Q</b>, &z3p;0.033&ze;, &z3p;0.037&ze;, <b>q</b>, &z3p;0.121&ze;, &z3p;0.135&ze;
 <b>18</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>2</b>, &z3p;0.352&ze;, &z3p;0.408&ze;, <b>R</b>, &z3p;0.652&ze;, &z3p;0.729&ze;, <b>r</b>, &z3p;3.405&ze;, &z3p;3.254&ze;
 <b>19</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>3</b>, &z3p;0.227&ze;, &z3p;0.262&ze;, <b>S</b>, &z3p;0.691&ze;, &z3p;0.758&ze;, <b>s</b>, &z3p;3.166&ze;, &z3p;2.961&ze;
 <b>20</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>4</b>, &z3p;0.177&ze;, &z3p;0.203&ze;, <b>T</b>, &z3p;0.686&ze;, &z3p;0.740&ze;, <b>t</b>, &z3p;4.566&ze;, &z3p;4.200&ze;
 <b>21</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>5</b>, &z3p;0.149&ze;, &z3p;0.171&ze;, <b>U</b>, &z3p;0.315&ze;, &z3p;0.349&ze;, <b>u</b>, &z3p;1.575&ze;, &z3p;1.510&ze;
 <b>22</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>6</b>, &z3p;0.176&ze;, &z3p;0.209&ze;, <b>V</b>, &z3p;0.128&ze;, &z3p;0.149&ze;, <b>v</b>, &z3p;0.662&ze;, &z3p;0.682&ze;
 <b>23</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>7</b>, &z3p;0.131&ze;, &z3p;0.144&ze;, <b>W</b>, &z3p;0.131&ze;, &z3p;0.135&ze;, <b>w</b>, &z3p;0.494&ze;, &z3p;0.385&ze;
 <b>24</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>8</b>, &z3p;0.184&ze;, &z3p;0.207&ze;, <b>X</b>, &z3p;0.213&ze;, &z3p;0.254&ze;, <b>x</b>, &z3p;0.870&ze;, &z3p;1.002&ze;
 <b>25</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>9</b>, &z3p;0.128&ze;, &z3p;0.122&ze;, <b>Y</b>, &z3p;0.091&ze;, &z3p;0.094&ze;, <b>y</b>, &z3p;0.515&ze;, &z3p;0.435&ze;
 <b>26</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>:</b>, &z3p;0.192&ze;, &z3p;0.176&ze;, <b>Z</b>, &z3p;0.027&ze;, &z3p;0.033&ze;, <b>z</b>, &z3p;0.125&ze;, &z3p;0.135&ze;
 <b>27</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>;</b>, &z3p;1.276&ze;, &z3p;1.670&ze;, <b>[</b>, &z3p;0.163&ze;, &z3p;0.210&ze;, <b>{</b>, &z3p;0.303&ze;, &z3p;0.401&ze;
 <b>28</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b><</b>, &z3p;0.118&ze;, &z3p;0.147&ze;, <b>\</b>, &z3p;0.097&ze;, &z3p;0.126&ze;, <b>|</b>, &z3p;0.098&ze;, &z3p;0.124&ze;
 <b>29</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>=</b>, &z3p;1.039&ze;, &z3p;1.042&ze;, <b>]</b>, &z3p;0.163&ze;, &z3p;0.210&ze;, <b>}</b>, &z3p;0.303&ze;, &z3p;0.401&ze;
 <b>30</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>></b>, &z3p;0.587&ze;, &z3p;0.762&ze;, <b>^</b>, &z3p;0.003&ze;, &z3p;0.002&ze;, <b>~</b>, &z3p;0.009&ze;, &z3p;0.012&ze;
 <b>31</b>, &z3p;0.000&ze;, &z3p;0.000&ze;, <b>?</b>, &z3p;0.022&ze;, &z3p;0.019&ze;, <b>_</b>, &z3p;2.550&ze;, &z3p;3.238&ze;, <b>127</b>, &z3p;0.000&ze;, &z3p;0.000&ze;
<caption>
Occurrence of characters as a percentage of all characters and as a
percentage of all noncomment characters (i.e., outside of comments).
Based on the visible form of the <file>.c</file> files.  For a
comparison of letter usage in English language and identifiers see
<figref href="ideng"/>.
</caption>
.E_TABLE


<A NAME="241">6</A>
C99 {ref multibyte character, state-dependent encoding} {ref shift state}

&emdash;&nbsp; A multibyte character set may have a <i>state-dependent
encoding</i>, wherein each sequence of multibyte characters begins in
an <i>initial shift state</i> and enters other locale-specific
<i>shift states</i> when specific multibyte characters are
encountered in the sequence.


.TABLE ISO2022
Name, Acronym, Code Value, Meaning
Escape, ESC, 0x1b, Escape
Shift-In, SI, 0x0f, Shift to the G0 set
Shift-Out, SO, 0x0e, Shift to the G1 set
Locking-Shift 2, LS2, ESC 0x6e, Shift to the G2 set
Locking-Shift 3, LS3, ESC 0x6f, Shift to the G3 set
Single-Shift 2, SS2, ESC 0x4e&comma; or 0x8e, Next character only is in G2
Single-Shift 3, SS3, ESC 0x4f&comma; or 0x8f, Next character only is in G3
<caption>
Commonly seen ISO 2022 Control Characters.  The alternative values for SS2
and SS3 are only available for 8-bit codes.
</caption>
.E_TABLE


.TABLE
Encoded values, 0x62, 0x63, 0x64, 0x0e, 0xe6, 0x1b, 0x6e, 0xe1, 0xe2, 0xe3, 0x0f
Control character,   ,   ,     ,   SO,       ,  LS2, ,        ,         ,          ,  SI
Graphic character,  a,  b,    c,     ,   &ae;,     , , &alpha;,   &beta;,   &gamma;
<caption>
An implementation where G1 is ISO 8859&endash;1, and G2 is ISO 8891&endash;7 (Greek).
</caption>
.E_TABLE


.TABLE JISESC
Character Set, Byte Encoding, Visible Ascii Representation
JIS C 6226&endash;1978,     1B 24 40,          <ESC> $ @
JIS X 0208&endash;1983,     1B 24 42,          <ESC> $ B
JIS X 0208&endash;1990,     1B 26 40 1B 24 42, <ESC> & @ <ESC> $ B
JIS X 0212&endash;1990,     1B 24 28 44,       <ESC> $ ( D
JIS-Roman,           1B 28 4A,          <ESC> ( J
Ascii,               1B 28 42,          <ESC> ( B
Half width Katakana, 1B 28 49,          <ESC> ( I
<caption>
ESC codes for some of the character sets used in Japanese.
</caption>
.E_TABLE


.TABLE
Encoded values, 0x1b, 0x24, 0x42, 0x242b, 0x244a, 0x3441, 0x3b7a, 0x1b , 0x28, 0x4a
Control character, <ESC> , $ , B ,      ,       ,       ,       , <ESC>, (   , J
Graphic character,       ,   ,   ,    beginCJK&JIS;242b endCJK ,  beginCJK&JIS;244a endCJK , beginCJK&JIS;3441 endCJK , beginCJK&JIS;3b7a endCJK ,  , , 
Ascii character  ,       ,   ,   ,  $+  ,   $J  ,  4A   ,   ;z  ,      ,     , 
<caption>
A JIS encoding of the character sequence 
beginCJK&JIS;242b endCJK beginCJK&JIS;244a endCJK beginCJK&JIS;3441 endCJK beginCJK&JIS;3b7a endCJK
(<quote>kana and kanji</quote>).
</caption>
.E_TABLE


<A NAME="275">2</A>
C99 {ref limit, block nesting}

&emdash;&nbsp; 127 nesting levels of blocks


.FIG
cmpdnest
<caption>
Maximum nesting of blocks and
<c_syntax>compound-statement</c_syntax>s within function definitions,
based on the visible form of the <file>.c</file> files.
</caption>
.E_FIG


<A NAME="276">3</A>
C99

&emdash;&nbsp; 63 nesting levels of conditional inclusion


.FIG
ppifnest
<caption>
Nesting of conditional inclusion directives (the maximum nesting of
any sequence of conditional inclusion directives, plus local maxima
within that sequence were counted).  Based on the visible form of the
<file>.c</file> and <file>.h</file> files.
</caption>
.E_FIG


<A NAME="277">4</A>
C99 {ref limit, type complexity}

&emdash;&nbsp; 12 pointer, array, and function declarators (in any
combinations) modifying an arithmetic, structure, union, or
incomplete type in a declaration


.FIG
nestdecl
<caption>
Number of full declarators containing a given number of modifiers,
based on the translated form of the books benchmark programs.
</caption>
.E_FIG


<A NAME="279">6</A>
C99 {ref parenthesized expression, nesting levels}

&emdash;&nbsp; 63 nesting levels of parenthesized expressions within a full
expression


.FIG
parennest
<caption>
Nesting of all occurrences of parentheses.  Based on the visible
form of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_FIG


<A NAME="281">8</A>
C99 {ref external identifier, significant characters}

&emdash;&nbsp; 31 significant initial characters in an external identifier
(each universal character name specifying a short identifier of
0000FFFF or less is considered 6 characters, each universal character
name specifying a short identifier of 00010000 or more is considered
10 characters, and each extended source character is considered the
same number of characters as the corresponding universal character
name, if any)<sup>14)</sup>


.FIG
exidlen
<caption>
Number of identifiers, with external linkage, having a given length,
based on the translated form of the books benchmark programs.
Information on the length of all identifiers in the visible source is
given elsewhere (see <figref href="idlen"/>).
</caption>
.E_FIG


<A NAME="283">9</A>
C99 {ref limit, external identifiers}

&emdash;&nbsp;  4095 external identifiers in one translation unit


.TABLE
: l c c l c c
Header, External Identifiers, Total Identifiers, Header, External Identifiers, Total Identifiers
<assert.h>,  &z2;1,  &z2;2, <signal.h>,   &z;2, 12
<complex.h>, &z;66,  &z;71, <stdarg.h>,   &z;3,  &z;5
<ctype.h>,   &z;15,  &z;15, <stdbool.h>,  &z;0,  &z;4
<errno.h>,   &z2;1,  &z2;4, <stddef.h>,   &z;0,  &z;5
<fenv.h>,    &z;11,  &z;24, <stdint.h>,   &z;0, 38
<float.h>,    &z2;0,  &z;31, <stdio.h>,     49, 65
<inttypes.h>, &z2;6,  &z;62, <stdlib.h>,    36, 37
<iso646.h>,   &z2;0,  &z;11, <string.h>,    22, 24
<limits.h>,   &z2;0,  &z;19, <tgmath.h>,   &z;0, 60
<locale.h>,   &z2;2,  &z;10, <time.h>,     &z;9, 15
<math.h>,     184, 203,     <wchar.h>,     59, 68
<setjmp.h>,   &z2;2,  &z2;3, <wctype.h>,    18, 22
<caption>
Number of identifiers with external linkage (total 487), and total
number of identifiers (total 810), implementations are required to
declare in the standard headers.
</caption>
.E_TABLE


<A NAME="284">10</A>
C99 {ref identifiers, number in block scope}

&emdash;&nbsp;  511 identifiers with block scope declared in one block


.FIG
loccount
<caption>
Number of declarations of identifiers as objects within all of the
blocks contained in a function definition.  Based on the translated
form of the books benchmark programs.
</caption>
.E_FIG


<A NAME="285">13</A>
C99 {ref limit, macro definitions}

&emdash;&nbsp; 4095 macro identifiers simultaneously defined in one
preprocessing translation unit


.FIG
numdefine
<caption>
Number of all identifiers, and unique identifiers, defined as macro
names in <keyword>#define</keyword> preprocessing directives.  Based
on the visible form of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_FIG


.FIG
macdefs
<caption>
Number of <keyword>#define</keyword> directives evaluated in each
translation unit, excluding the contents of system headers, during
translation of the books benchmark programs (there were a total of
1,432,735 macros defined, of which 313,620 were function-like macros).
</caption>
.E_FIG


<A NAME="286">14</A>
C99 {ref limit, parameters in definition}

&emdash;&nbsp;  127 parameters in one function definition


.FIG
paramcnt
<caption>
Percentage of function definitions appearing in the source of
embedded applications (5,597 function definitions), the SPECint95
benchmark (2,713 function definitions), and the translated form of
the books benchmark programs (53,719 function definitions) declared
to have a specified number of parameters.  The embedded and SPECint95
figures are from Engblom <book Engblom_99a>.
</caption>
.E_FIG


<A NAME="287">15</A>
C99 {ref function call, number of arguments}

&emdash;&nbsp;  127 arguments in one function call


.FIG
numargs
<caption>
Number of arguments passed in function calls.  Based on the
translated form of the books benchmark programs.
</caption>
.E_FIG


<A NAME="288">16</A>
C99 {ref limit, macro parameters}

&emdash;&nbsp;  127 parameters in one macro definition


.FIG
mdefparam
<caption>
Number of parameters declared in function-like macro definitions,
based on the visible form of the <file>.c</file> and <file>.h</file>
files.
</caption>
.E_FIG


<A NAME="289">17</A>
C99 {ref limit, arguments in macro invocation}

&emdash;&nbsp;  127 arguments in one macro invocation


.FIG
macexargs
<caption>
Number of arguments in expansions of function-like macros, excluding
expansions that occurred while processing system headers, during
translation of the books benchmark programs.
</caption>
.E_FIG


<A NAME="290">18</A>
C99 {ref limit, characters on line}

&emdash;&nbsp;  4095 characters in a logical source line


.FIG
logicline
<caption>
Number of characters on a physical line.  Based on the visible form of
the <file>.c</file> and <file>.h</file> files.
</caption>
.E_FIG


<A NAME="291">19</A>
C99 {ref limit, string literal}

&emdash;&nbsp; 4095 characters in a character string literal or wide
string literal (after concatenation)


.FIG
strlen
<caption>
Number of characters in character string literals (i.e., their
length).  Based on the visible form of the <file>.c</file> files
</caption>
.E_FIG


<A NAME="292">20</A>
C99 {ref limit, minimum object size}

&emdash;&nbsp;  65535 bytes in an object (in a hosted environment only)


.FIG
objsize
<caption>
Number of objects requiring the specified amount of storage.  Based
on the translated form of the <file>.c</file> files, using integer
types whose sizes were <c_code>sizeof(short) == 2</c_code>,
<c_code>sizeof(int) == 4</c_code>, and <c_code>sizeof(long) ==
4</c_code>; and alignment requirements that were a multiple of a
types size.
</caption>
.E_FIG


<A NAME="293">21</A>
C99 {ref limit, #include nesting}

&emdash;&nbsp; 15 nesting levels for <keyword>#include</keyword>d files


.FIG
incnest
<caption>
Nesting of <keyword>#include</keyword> preprocessor directives that
specify a header name using the quote-delimited form (occurrences of
the <keyword><</keyword> <keyword>></keyword> delimited form were not
counted).  Based on the translated form of the books benchmark
programs.
</caption>
.E_FIG


<A NAME="294">22</A>
C99 {ref limit, case labels}

&emdash;&nbsp; 1023 <keyword>case</keyword> labels for a
<keyword>switch</keyword> statement (excluding those for any nested
<keyword>switch</keyword> statements)


.FIG
caseuse
<caption>
Number of <keyword>case</keyword> labels on an individual statement
(cross) and per <keyword>switch</keyword> statement (bullet).  Based
on the visible form of the <file>.c</file> files.  Note that counts
do not include occurrences of the <keyword>default</keyword> label.
</caption>
.E_FIG


<A NAME="295">23</A>
C99 {ref limit, members in struct/union}

&emdash;&nbsp; 1023 members in a single structure or union


.FIG
sunummem
<caption>
Number of members in structure and union type definitions (members in
nested definitions are not included in the count of members of the
outer definition).  Based on the visible form of the <file>.c</file>
and <file>.h</file> files.
</caption>
.E_FIG


<A NAME="296">24</A>
C99 {ref limit, enumeration constants}

&emdash;&nbsp; 1023 enumeration constants in a single enumeration


.FIG
econst
<caption>
Number of enumeration constants defined in each definition of an
enumeration type.  Based on the visible form of the <file>.c</file>
and <file>.h</file> files.
</caption>
.E_FIG


<A NAME="297">25</A>
C99 {ref limit, struct/union nesting}

&emdash;&nbsp; 63 levels of nested structure or union definitions in a
single struct-declaration-list


.FIG
sunest
<caption>
Number of textually nested structure and union type definitions
(i.e., using <keyword>{</keyword> <keyword>}</keyword> not typedef
names).  Based on the visible form of the <file>.c</file> and
<file>.h</file> files.
</caption>
.E_FIG


<A NAME="301">1</A>
C99 {ref integer types, sizes}

The values given below shall be replaced by constant expressions
suitable for use in <keyword>#if</keyword> preprocessing directives.


.TABLE lim_std_id
: 2.5cm r r 2.5cm r r 2.5cm r r
Name, <file>.c</file> file, <file>.h</file> file, Name, <file>.c</file> file, <file>.h</file> file, Name, <file>.c</file> file, <file>.h</file> file
 LONG_MAX, &zs;47&ze;, &zs;28&ze;, CHAR_MAX, &zs;15&ze;, &zs;8&ze;, CHAR_BIT, &zs;36&ze;, &zs;3&ze;
 INT_MAX, &zs;106&ze;, &zs;17&ze;, INT_MIN, &zs;17&ze;, &zs;7&ze;, SCHAR_MIN, &zs;12&ze;, &zs;2&ze;
 UINT_MAX, &zs;30&ze;, &zs;14&ze;, UCHAR_MAX, &zs;16&ze;, &zs;5&ze;, LLONG_MAX, &zs;0&ze;, &zs;1&ze;
 SHRT_MAX, &zs;20&ze;, &zs;13&ze;, CHAR_MIN, &zs;9&ze;, &zs;5&ze;, ULLONG_MAX, &zs;0&ze;, &zs;0&ze;
 SHRT_MIN, &zs;19&ze;, &zs;12&ze;, SCHAR_MAX, &zs;13&ze;, &zs;4&ze;, LLONG_MIN, &zs;0&ze;, &zs;0&ze;
 USHRT_MAX, &zs;12&ze;, &zs;11&ze;, MB_LEN_MAX, &zs;15&ze;, &zs;4&ze;,  , , 
 ULONG_MAX, &zs;85&ze;, &zs;10&ze;, LONG_MIN, &zs;23&ze;, &zs;3&ze;,  , , 
<caption>
Number of identifiers defined as macros in
<keyword><limits.h></keyword> (see <tableref href="sptoksp"/> for
information on the number of identifiers appearing in the source)
appearing in the visible form of the <file>.c</file> and
<file>.h</file> files.
</caption>
.E_TABLE


<A NAME="328">1</A> FP
C99 {ref floating types, characteristics}

The characteristics of floating types are defined in terms of a model
that describes a representation of floating-point numbers and values
that provide information about an implementation's floating-point
arithmetic.<sup>16)</sup> 


.TABLE UCS
: l r c
Type, Bits, Decimal Range
<keyword>float</keyword>,    36,     1.4693680E39&z; &ellipsis; 1.7014118E+38&z;
<keyword>double</keyword>,    72,    2.7813423E309 &ellipsis; 8.9884657E+307
<keyword>long double</keyword>, 72 , 2.7813423E309 &ellipsis; 8.9884657E+307
<caption>
Range of representable floating-point values for the Unisys e-@ction
Application Development Solutions Compiling System.
</caption>
.E_TABLE


.TABLE rounding
: 2.5cm r r r
  , Correct, Rounding Down, Rounding Up
<equ>x</equ>,   100.01&z4;,   100.01&z2;,   100.01&z2;
<equ>y</equ>,    99.995&z3;,   99.995&z;,   99.995&z;
<equ>z</equ>,    0.025&z3;,   0.025&z;,   0.025&z;
<equ>(x + (y + z))/2</equ>,   100.015&z3;,   100.01&z2;,   100.02&z2;
Area,   1.000025,   0.0000,   1.5813
<caption>
Area of triangle, using Heron's formula, calculated using different
rounding directions.
</caption>
.E_TABLE


.TABLE flt_std_id
: 2.6cm r r 2.6cm r r 2.6cm r r
Name, <file>.c</file> file, <file>.h</file> file, Name, <file>.c</file> file, <file>.h</file> file, Name, <file>.c</file> file, <file>.h</file> file
 DBL_MIN, &zs;9&ze;, &zs;21&ze;, FLT_MAX, &zs;5&ze;, &zs;15&ze;, FLT_ROUNDS, &zs;18&ze;, &zs;14&ze;
 DBL_MAX, &zs;20&ze;, &zs;19&ze;, FLT_DIG, &zs;5&ze;, &zs;15&ze;, FLT_RADIX, &zs;20&ze;, &zs;14&ze;
 DBL_DIG, &zs;41&ze;, &zs;17&ze;, LDBL_MIN_EXP, &zs;4&ze;, &zs;14&ze;, FLT_MIN_EXP, &zs;4&ze;, &zs;14&ze;
 FLT_EPSILON, &zs;4&ze;, &zs;16&ze;, LDBL_MIN, &zs;4&ze;, &zs;14&ze;, FLT_MIN_10_EXP, &zs;4&ze;, &zs;14&ze;
 DBL_MIN_EXP, &zs;4&ze;, &zs;16&ze;, LDBL_MIN_10_EXP, &zs;4&ze;, &zs;14&ze;, FLT_MAX_EXP, &zs;4&ze;, &zs;14&ze;
 DBL_MIN_10_EXP, &zs;4&ze;, &zs;16&ze;, LDBL_MAX_EXP, &zs;4&ze;, &zs;14&ze;, FLT_MAX_10_EXP, &zs;4&ze;, &zs;14&ze;
 DBL_MAX_EXP, &zs;27&ze;, &zs;16&ze;, LDBL_MAX, &zs;4&ze;, &zs;14&ze;, FLT_MANT_DIG, &zs;8&ze;, &zs;14&ze;
 DBL_MAX_10_EXP, &zs;14&ze;, &zs;16&ze;, LDBL_MAX_10_EXP, &zs;4&ze;, &zs;14&ze;, FLT_EVAL_METHOD, &zs;0&ze;, &zs;0&ze;
 DBL_MANT_DIG, &zs;14&ze;, &zs;16&ze;, LDBL_MANT_DIG, &zs;4&ze;, &zs;14&ze;, DECIMAL_DIG, &zs;0&ze;, &zs;0&ze;
 DBL_EPSILON, &zs;4&ze;, &zs;16&ze;, LDBL_EPSILON, &zs;4&ze;, &zs;14&ze;,  , , 
 FLT_MIN, &zs;5&ze;, &zs;15&ze;, LDBL_DIG, &zs;4&ze;, &zs;14&ze;,  , , 
<caption>
Number of identifiers defined as macros in
<keyword><float.h></keyword> (see <tableref href="sptoksp"/> for
information on the number of identifiers appearing in the source)
appearing in the visible form of the <file>.c</file> and
<file>.h</file> files.
</caption>
.E_TABLE


<A NAME="332">3</A> FP
C99 {ref exponent}

<equ>e</equ> &quad; exponent (an integer between a minimum
<equ>e<sub>min</sub></equ> and a maximum <equ>e<sub>max</sub></equ>)


.TABLE connors97
: c r r r r c r r r r
Exponent, Compare, Add, Multiply, Divide, Exponent, Compare, Add, Multiply, Divide
0, 15.60, 11.4, 6.7, 3.0 ,     ,    ,    , 
-1, 2.5, 2.5, 1.9, 0.0, 1, 10.80, 9.3, 1.6, 1.0
-2, 0.7, 1.2, 0.6, 1.0, 2, 5.20, 2.6, 1.3, 3.0
-3, 0.1, 0.0, 0.7, 0.0, 3, 8.50, 4.3, 0.7, 0.0
-4, 0.0, 0.1, 0.2, 1.0, 4, 0.50, 0.0, 0.5, 0.0
-5, 0.0, 0.0, 0.5, 0.0   ,     ,    ,    , 
-6, 0.0, 0.6, 1.4, 0.0   ,     ,    ,    , 
<caption>
Dynamic distribution of decimal exponents, as a percentage, for
operands of various floating point operations.  Adapted from Connors,
Yamada, and Hwu <book Connors_97> (thanks to Connors for supplying
the raw data).
</caption>
.E_TABLE


.FIG
exprng
<caption>
Number of exponent values in floating constants
(that included an <c_syntax>exponent-part</c_syntax>).  Based on the
visible form of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_FIG


.FIG
oberman96
<caption>
Differences in the values of the exponents (in powers of 2) of the
operands of floating-point addition and subtraction operations while
executing the SPECfp92 benchmarks.  Adapted from Oberman <book
Oberman_96>.
</caption>
.E_FIG


<A NAME="336">1</A> FP
C99 {ref floating types, can represent}

In addition to normalized floating-point numbers
(<equ>f<sub>1</sub>&egt;0</equ> if <equ>x&neq;0</equ>), floating types
may be able to contain other kinds of floating-point numbers, such as
subnormal floating-point numbers (<equ>x&neq;0</equ>,
<equ>e=e<sub>min</sub></equ>, <equ>f<sub>1</sub>=0</equ>) and
unnormalized floating-point numbers (<equ>x&neq;0</equ>,
<equ>e&egt;e<sub>min</sub></equ>, <equ>f<sub>1</sub>=0</equ>), and values
that are not floating-point numbers, such as infinities and NaNs.


.FIG
subnormal
<caption>
Range of normalized numbers about zero, including subnormal numbers.
</caption>
.E_FIG


.FIG
ieeeformat
<caption>
Single-precision IEC 60559 format.
</caption>
.E_FIG


.TABLE
: 3cm r r r r r
Parameter, Single,  Single Extended, Double, Double Extended, Intel x86 Extended
Precision&comma; <equ>p</equ>&comma; (apparent mantissa width), 24, 32, 53, 64, 64
Actual mantissa width, 23, 31, 52, 63, 64
Mantissa's MS-Bit, hidden bit, unspecified, hidden bit, unspecified, explicit bit
Decimal digits of precision&comma; <equ>p/&log;<sub>2</sub>(10)</equ>, 7.22, 9.63, 15.95, 19.26, 19.26
E<sub>max</sub>, +127, +1023, +1023, +16383, +16383
E<sub>min</sub>, &minus;126, &minus;1022, &minus;1022, &minus;16382, &minus;16382
Exponent bias, +127, unspecified, +1023, unspecified, +16383
Exponent width, 8, 11, 11, 15, 15
Sign width, 1, 1, 1, 1, 1
Format width (9) + (8) + (4), 32, 43, 64, 79, 80
Maximum value&comma; 2<sup>E<sub>max</sub>+1</sup>, 3.4028E+38, 1.7976E+308, 1.7976E+308, 1.1897E+4932, 1.1897E+4932
Minimum value&comma; 2<sup>E<sub>min</sub></sup>, 1.1754E&minus;38, 2.2250E&minus;308, 2.2250E-308, 3.3621E&minus;4932, 3.3621E&minus;4932
Denormalized minimum value&comma; 2<sup>E<sub>min</sub>&minus;(4)</sup>, 1.4012E&minus;45, 1.0361E&minus;317, 4.9406E&minus;324, 3.6451E&minus;4951, 1.8225E&minus;4951
<caption>
Format Parameters of IEC 60559 representation.
All widths measured in bits.
Intel's <phrase>extended-precision</phrase>
format is a conforming IEC 60559 format derived from that standards
<phrase>extended double-precision</phrase> format.
</caption>
.E_TABLE


.TABLE x_inf_nan
: c c
<equ>Operation &Longrightarrow; Result</equ>, <equ>Operation &Longrightarrow; Result</equ>
<equ>x / (+&infty;) &Longrightarrow; +0</equ>, <equ>x / (+0) &Longrightarrow; +&infty;</equ>
<equ>x / (-&infty;) &Longrightarrow; -0</equ>, <equ>x / (-0) &Longrightarrow; -&infty;</equ>
<equ>(+&infty;) + x &Longrightarrow; +&infty;</equ>, <equ>x + NaN &Longrightarrow; NaN</equ>
<equ>(+&infty;) &times; x &Longrightarrow; +&infty;</equ>, <equ>&infty; &times; 0 &Longrightarrow; NaN</equ>
<equ>(+&infty;) / x &Longrightarrow; +&infty;</equ>, <equ>0 / 0 &Longrightarrow; NaN</equ>
<equ>(+&infty;) - (+&infty;) &Longrightarrow; NaN</equ>, <equ>NaN - NaN &Longrightarrow; NaN</equ>
<caption>
List of some results of operations on infinities and NaNs.  Also see:
<quote>Expression transformations</quote> in annex F.8.2 of the C
Standard.
</caption>
.E_TABLE


.TABLE
: 2.0cm l 1.3cm l
Variable or Operation, Value, Biased Exponent, Comment
A0         ,   1.100 1100 1100 1100 1100 1101 &times; 2<sup>-125</sup>, 2, 
A1 = A0 / 2,   1.100 1100 1100 1100 1100 1101 &times; 2<sup>-126</sup>, 1, 
A2 = A1 / 2,   0.110 0110 0110 0110 0110 0110 &times; 2<sup>-126</sup>, 0, Inexact*
A3 = A2 / 2,   0.011 0011 0011 0011 0011 0011 &times; 2<sup>-126</sup>, 0, Exact result
A4 = A3 / 2,   0.001 1001 1001 1001 1001 1010 &times; 2<sup>-126</sup>, 0, Inexact*
., , , 
., , , 
., , , 
A23 = A22 / 2, 0.000 0000 0000 0000 0000 0011 &times; 2<sup>-126</sup>, 0, Exact result
A24 = A23 / 2, 0.000 0000 0000 0000 0000 0010 &times; 2<sup>-126</sup>, 0, Inexact*
A25 = A24 / 2, 0.000 0000 0000 0000 0000 0001 &times; 2<sup>-126</sup>, 0, Exact result
A26 = A25 / 2, 0.0                                                    , 0, Inexact*
<caption>
Example of gradual underflow.
* Whenever division returns an inexact tiny value, the exception bit
for underflow is set to indicate that a low-order bit has been lost.
</caption>
.E_TABLE


<A NAME="342">1</A> FP
C99 {ref floating-point, operations accuracy}

The accuracy of the floating-point operations (<keyword>+</keyword>,
<keyword>-</keyword>, <keyword>*</keyword>, <keyword>/</keyword>) and
of the library functions in <keyword><math.h></keyword> and
<keyword><complex.h></keyword> that return floating-point results is
implementation-defined
<iso_new>, as is the accuracy of the conversion between
floating-point internal representations and string representations
performed by the library routine in <keyword><stdio.h></keyword>,
<keyword><stdlib.h></keyword> and
<keyword><wchar.h></keyword></iso_new>.


.FIG
tsao74
<caption>
Probability of a floating-point operation having a given error,
<equ>&eps;</equ>, for two kinds of rounding modes (truncated and
to-nearest); <equ>p</equ> is the number of digits in the significand.
Adapted from Tsao <book Tsao_74>.
</caption>
.E_FIG


<A NAME="348">1</A> FP
C99 {ref FLT_ROUNDS}

The rounding mode for floating-point addition is characterized by the
implementation-defined value of <fixedb>FLT_ROUNDS</fixedb>:<sup>18)</sup>

<fixedb>-1</fixedb> &quad; indeterminable 

<fixedb>&nbsp;0</fixedb> &quad; toward zero 

<fixedb>&nbsp;1</fixedb> &quad; to nearest

<fixedb>&nbsp;2</fixedb> &quad; toward positive infinity

<fixedb>&nbsp;3</fixedb> &quad; toward negative infinity

All other values for <fixedb>FLT_ROUNDS</fixedb> characterize
implementation-defined rounding behavior.


.TABLE
: r r l l l
           ,   0,     1,            2,            3
 1.00000007,   1.0,   1.00000012,   1.00000012,   1.0
 1.00000003,   1.0,   1.0,          1.00000012,   1.0
-1.00000003,  -1.0,  -1.0,         -1.0,         -1.00000012
-1.00000007,  -1.0,  -1.00000012,  -1.0,         -1.00000012
<caption>
Effect of rounding mode (<c_macro>FLT_ROUNDS</c_macro> taking on
values 0, 1, 2, or 3) on the result of a single precision value (left
column).
</caption>
.E_TABLE


<A NAME="364">4</A> FP
C99 {ref DECIMAL_DIG, macro}

&emdash;&nbsp; number of decimal digits, <i>n</i>, such that any
floating-point number in the widest supported floating type with
p<sub>max</sub> radix <i>b</i> digits can be rounded to a
floating-point number with $n$ decimal digits and back again without
change to the value,

<equ>&leftcurl;<array>p<sub>max</sub>&log;<sub>10</sub>b &qquad;&qquad;<text>if </text> b <text> is a power of 10</text> &linebreak;
&lceil;1+p<sub>max</sub>&log;<sub>10</sub>b&rceil; &qquad;<text>otherwise</text></array></equ>

.ASIS
<fixedb>DECIMAL_DIG                     10</fixedb>
.E_ASIS


.FIG
bindecrep
<caption>
Representable powers of 10 and powers of 2 on the real line.
</caption>
.E_FIG


<A NAME="385">1</A>
C99

A summary of the language syntax is given in annex A.


.FIG
ident
<caption>
Attributes a C language identifier can have.
</caption>
.E_FIG


<A NAME="393">8</A>
C99 {ref identifier, denote different entities}

The same identifier can denote different entities at different points
in the program.


.FIG
idlns
<caption>
All combinations of linkage, scope, and name space that all possible
kinds of identifiers, supported by C, can have.  <b>M</b> refers to
the members of a structure or union type.  There is a separate name
space for macro names and they have <phrase>no linkage</phrase>, but
their scope has no formally specified name.
</caption>
.E_FIG


.FIG
sameiddecl
<caption>
Number of declarations of an identifier with the same spelling in the
same translation unit.  Based on the translated form of the books
benchmark programs.  Note that members of the same type are likely to
be counted more than once (i.e., they are counted in every
translation unit that declares them), while parameters and objects
declared within function definitions are likely to be only counted
once.
</caption>
.E_FIG


<A NAME="403">2</A>
C99 {ref file scope}

If the declarator or type specifier that declares the identifier
appears outside of any block or list of parameters, the identifier
has <i>file scope</i>, which terminates at the end of the translation
unit.


.FIG
flowhier
<caption>
Some of the ways in which a function can be called&emdash; a single
call from one other function; called from two or more functions,
which in turn are all called by a single function; and called from
two or more functions whose nearest shared calling function is not
immediately above them.
</caption>
.E_FIG


<A NAME="404">3</A>
C99 {ref block scope, terminates}

If the declarator or type specifier that declares the identifier
appears inside a block or within the list of parameter declarations
in a function definition, the identifier has <i>block scope</i>,
which terminates at the end of the associated block.


.FIG
blkdeclnest
<caption>
Number of object declarations appearing at various block nesting
levels (level 1 is the outermost block).  Based on the translated
form of the books benchmark programs.
</caption>
.E_FIG


<A NAME="416">1</A>
C99 {ref linkage}

An identifier declared in different scopes or in the same scope more
than once can be made to refer to the same object or function by a
process called <i>linkage</i>.<sup>21)</sup>


.TABLE
Model, File 1, File 2
common, <c_code>extern int I; int main() {   I = 1;   second(); }</c_code>, <c_code>extern int I; void second() {    third( I ); }</c_code>
Relaxed Ref/Def, <c_code>int I; int main() {   I = 1;   second(); }</c_code>, <c_code>int I; void second() {    third( I ); }</c_code>
Strict Ref/Def, <c_code>int I; int main() {   I = 1;   second(); }</c_code>, <c_code>extern int I; void second() {    third( I ); }</c_code>
Initializer, <c_code>int I = 0; int main() {   I = 1;   second(); }</c_code>, <c_code>int I; void second() {    third( I ); }</c_code>
<caption>
Comparison of identifier linkage models
</caption>
.E_TABLE


<A NAME="417">2</A>
C99 {ref linkage, kinds of}

There are three kinds of linkage: external, internal, and none.


.FIG
linkage
<caption>
Number of objects and functions declared with internal and external
linkage (excluding declarations in system headers).  Based on the
translated form of the book benchmark programs.
</caption>
.E_FIG


<A NAME="433">1</A>
C99 {ref name space}

If more than one declaration of a particular identifier is visible at
any point in a translation unit, the syntactic context disambiguates
uses that refer to different entities.


.TABLE ns_tok_ident
: l r r l r r
Token, <file>.c</file> file, <file>.h</file> file, Token, <file>.c</file> file, <file>.h</file> file
<keyword>goto</keyword> identifier, &zp;99.9&ze;, &zp;100.0&ze;, <keyword>struct</keyword> identifier, &zp;99.0&ze;, &zp;88.4&ze;
<keyword>#define</keyword> identifier, &zp;99.9&ze;, &zp;100.0&ze;, <keyword>union</keyword> identifier, &zp;65.5&ze;, &zp;75.8&ze;
<keyword>.</keyword> identifier, &zp;100.0&ze;, &zp;99.8&ze;, <keyword>enum</keyword> identifier, &zp;86.6&ze;, &zp;53.6&ze;
<keyword>-></keyword> identifier, &zp;100.0&ze;, &zp;95.5&ze;, <keyword>case</keyword> identifier, &zp;71.3&ze;, &zp;47.2&ze;
<caption>
Identifiers occurring immediately to the right of the given token, as
a percentage of all identifiers appearing in the visible source.  An
identifier appearing to the left of a <keyword>:</keyword> could be a
label or a <keyword>case</keyword> label.  However, C syntax is
designed to be parsed from left to right and the presence, or absence,
of a <keyword>case</keyword> keyword indicates the entity denoted by
an identifier.
</caption>
.E_TABLE


<A NAME="434">2</A>
C99

Thus, there are separate <i>name spaces</i> for various categories of
identifiers, as follows:


.TABLE id_namespace
: l r l r
Declaration Context, %, Declaration Context, %
 block scope objects, &zp;23.7&ze;, file scope objects, &zp;4.4&ze;
 macro definitions, &zp;19.3&ze;, macro parameters, &zp;4.3&ze;
 function parameters, &zp;16.8&ze;, enumeration constants, &zp;2.1&ze;
struct/union members, &zp;9.6&ze;, <keyword>typedef</keyword> names, &zp;1.2&ze;
 function declarations, &zp;8.6&ze;, tag names, &zp;1.0&ze;
 function definitions, &zp;8.1&ze;, label names, &zp;0.9&ze;
<caption>
Occurrence of various kinds of declarations of identifiers as a
percentage of al identifiers declared in all the given contexts.
Based on the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="438">6</A>
C99 {ref member, namespace}

each structure or union has a separate name space for its members
(disambiguated by the type of the expression used to access the
member via the <keyword>.</keyword> or <keyword>-></keyword>
operator);


.TABLE record_name_1
: l r r r
 , Member Types the Same, Member Types Different, Total
Member names the same, 73 (94.8%), 4 (&z;5.2%), 77
Member names different, 52 (11&ptz;%), 421 (89&ptz;%), 473
<caption>
Number of matches found when comparing between pairs of members
contained in different records that were defined with the same type
name.  Adapted from Anquetil and Lethbridge <book Anquetil_98>.
</caption>
.E_TABLE


.TABLE record_name_2
: l r r r
 , Member Types the Same, Member Types Different, Total
Member names the same, 7&comma;709 (33.7%), 15&comma;174 (66.3%), 22&comma;883
Member names different, 158&comma;828 (&z;0.2%), 66&comma;652&comma;062 (99.8%), 66&comma;710&comma;890
<caption>
Number of matches found when comparing between pairs of members
contained in different records (that were defined with the any type
name).  Adapted from Anquetil and Lethbridge <book Anquetil_98>.
</caption>
.E_TABLE


<A NAME="444">2</A>
C99

There are three storage durations: static, automatic, and allocated.


.FIG
stackheap
<caption>
The location of the stack invariably depends on the effect of a
processors pop/push instructions (if they exist).  The heap usually
goes at the opposite end of available storage.  The program image
may, or may not, exist in the same address space.
</caption>
.E_FIG


.TABLE
: l r r r r r
Program, Total Objects, Total Bytes, Average Size, Maximum Objects, Maximum Bytes
sis,     63&comma;395, 15&comma;797&comma;173, 249.2,  48.5, 1&comma;932.2
perl,     1&comma;604,    34&comma;089,  21.3,   2.3,  116.4
xfig,       25,     1&comma;852,  72.7,  19.8, 1&comma;129.3
ghost,     924,    89&comma;782,  97.2,  26.5, 2&comma;129.0
make,       23,      539,  23.0,  10.4,  208.1
espresso, 1&comma;675,   107&comma;062,  63.9,   4.4,  280.1
ptc,       103,     2&comma;386,  23.2, 102.7, 2&comma;385.8
gawk,     1&comma;704,    67&comma;559,  39.6,   1.6,   41.0
cfrac,     522,     8001,  15.3,   1.5,   21.4
<caption>
Total number of objects allocated (in thousands), the total amount of
storage they occupy (in thousands of bytes), their average size (in
bytes) and the high water mark of these values (also in thousands).
Adapted from Detlefs, Dosser and Zorn <book Detlefs_93>.
</caption>
.E_TABLE


<A NAME="459">1</A>
C99 {ref VLA, lifetime starts/ends}

For such an object that does have a variable length array type, its
lifetime extends from the declaration of the object until execution
of the program leaves the scope of the declaration.<sup>27)</sup> 


.FIG
VLAstack
<caption>
Storage for objects not having VLA type is allocated on block entry,
plus storage for a descriptor for each object having VLA type.  By
the time <c_code>G</c_code> has been called, the declaration for
<c_code>a</c_code> has been reached and storage allocated for it.
After <c_code>G</c_code> returns, the declaration for
<c_code>d</c_code> is reached and is storage allocated for it.  The
descriptor for <c_code>d</c_code> needs to include a count of the
number of elements in one of the array dimensions.  This value is
needed for index calculations and is not known at translation time.
No such index calculations need to be made for <c_code>a</c_code>.
</caption>
.E_FIG


<A NAME="481">1</A>
C99 {ref signed integer, corresponding unsigned integer}

For each of the signed integer types, there is a corresponding (but
different) unsigned integer type (designated with the keyword
<keyword>unsigned</keyword>) that uses the same amount of storage
(including sign information) and has the same alignment requirements.


.TABLE signed_unsigned_width
: r r r r
 , 8 bits, 16 bits, 32 bits
unsigned, 70.8/1.3, 14.0/0.4, 2.1/44.9
signed, 2.7/0.0, 9.4/0.3, 1.0/53.1
<caption>
Occurrence of objects having different width integer types (as a
percentage of all integer types) for embedded source and the
SPECint95 benchmark (separated by a forward slash,
e.g.,embedded/SPECint95).  Adapted from Engblom <book Engblom_99a>.
</caption>
.E_TABLE


<A NAME="492">1</A> FP
C99 {ref floating types, three real}

There are three <i>real floating types</i>, designated as
<keyword>float</keyword>, <keyword>double</keyword>, and
<keyword>long double</keyword>.<sup>32)</sup> 


.TABLE float_t_usage
: l r r r r r r
Type, Block Scope, Parameter, File Scope, <keyword>typedef</keyword>, Member, Total
<keyword>float</keyword>, &zp;35.2&ze;, &zp;15.1&ze;, &zp;8.3&ze;, &zp;0.7&ze;, &zp;21.0&ze;, &zp;80.3&ze;
<keyword>double</keyword>, &zp;8.5&ze;, &zp;7.9&ze;, &zp;0.5&ze;, &zp;0.7&ze;, &zp;2.2&ze;, &zp;19.7&ze;
<keyword>long</keyword> <keyword>double</keyword>, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;
 Total, &zp;43.6&ze;, &zp;22.9&ze;, &zp;8.8&ze;, &zp;1.5&ze;, &zp;23.2&ze;
<caption>
Occurrence of floating types in various declaration contexts (as a
percentage of all floating types appearing in these contexts).  Based
on the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="510">1</A>
C99 {ref character types}

The three types <keyword>char</keyword>, <keyword>signed
char</keyword>, and <keyword>unsigned char</keyword> are collectively
called the <i>character types</i>.


.TABLE character_t_usage
: l r r r r r r
Type, Block Scope, Parameter, File Scope, <keyword>typedef</keyword>, Member, Total
<keyword>char</keyword>, &zp;16.4&ze;, &zp;3.6&ze;, &zp;1.2&ze;, &zp;0.1&ze;, &zp;6.6&ze;, &zp;28.0&ze;
<keyword>signed</keyword> <keyword>char</keyword>, &zp;0.2&ze;, &zp;0.3&ze;, &zp;0.0&ze;, &zp;0.1&ze;, &zp;0.3&ze;, &zp;1.0&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;18.1&ze;, &zp;10.6&ze;, &zp;0.4&ze;, &zp;0.8&ze;, &zp;41.2&ze;, &zp;71.1&ze;
 Total, &zp;34.7&ze;, &zp;14.6&ze;, &zp;1.5&ze;, &zp;1.0&ze;, &zp;48.2&ze;
<caption>
Occurrence of character types in various declaration contexts (as a
percentage of all character types appearing in these contexts).  Based
on the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="514">1</A>
C99 {ref integer types}

The type <keyword>char</keyword>, the signed and unsigned integer
types, and the enumerated types are collectively called <i>integer
types</i>.


.FIG
integertypes
<caption>
The integer types.
</caption>
.E_FIG


.TABLE integer_t_usage
: l r r r r r r
Type, Block Scope, Parameter, File Scope, <keyword>typedef</keyword>, Member, Total
<keyword>char</keyword>, &zp;1.8&ze;, &zp;0.4&ze;, &zp;0.1&ze;, &zp;0.0&ze;, &zp;0.7&ze;, &zp;3.1&ze;
<keyword>signed</keyword> <keyword>char</keyword>, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.0&ze;, &zp;1.2&ze;, &zp;0.0&ze;, &zp;0.1&ze;, &zp;4.6&ze;, &zp;7.9&ze;
<keyword>short</keyword>, &zp;0.7&ze;, &zp;0.3&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.4&ze;, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.3&ze;, &zp;0.8&ze;, &zp;0.1&ze;, &zp;0.1&ze;, &zp;3.2&ze;, &zp;6.5&ze;
<keyword>int</keyword>, &zp;28.4&ze;, &zp;10.6&ze;, &zp;4.2&ze;, &zp;0.1&ze;, &zp;6.4&ze;, &zp;49.7&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;5.6&ze;, &zp;3.6&ze;, &zp;0.3&ze;, &zp;0.1&ze;, &zp;4.2&ze;, &zp;13.8&ze;
<keyword>long</keyword>, &zp;3.0&ze;, &zp;1.2&ze;, &zp;0.1&ze;, &zp;0.1&ze;, &zp;0.8&ze;, &zp;5.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;4.8&ze;, &zp;1.9&ze;, &zp;0.2&ze;, &zp;0.1&ze;, &zp;2.1&ze;, &zp;9.1&ze;
<keyword>enum</keyword>, &zp;0.9&ze;, &zp;0.9&ze;, &zp;0.4&ze;, &zp;0.4&ze;, &zp;0.8&ze;, &zp;3.3&ze;
 Total, &zp;49.6&ze;, &zp;20.8&ze;, &zp;5.4&ze;, &zp;0.9&ze;, &zp;23.2&ze;
<caption>
Occurrence of integer types in various declaration contexts (as a
percentage of those all integer types appearing in these contexts),
based on the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="515">2</A>
C99 {ref real types}

The integer and real floating types are collectively called <i>real
types</i>.


.FIG
realtypes
<caption>
The real types.
</caption>
.E_FIG


<A NAME="516">1</A> FP
C99 {ref arithmetic type}

Integer and floating types are collectively called <i>arithmetic
types</i>.


.FIG
arithtypes
<caption>
The arithmetic types.
</caption>
.E_FIG


<A NAME="520">1</A>
C99 {ref derived type}

Any number of <i>derived types</i> can be constructed from the
object, function, and incomplete types, as follows:


.TABLE derived_t_usage
: l r r r r r r
Type, Block Scope, Parameter, File Scope, <keyword>typedef</keyword>, Member, Total
<keyword>*</keyword>, &zp;30.4&ze;, &zp;37.6&ze;, &zp;3.1&ze;, &zp;0.8&ze;, &zp;5.6&ze;, &zp;77.5&ze;
 array, &zp;3.3&ze;, &zp;0.0&ze;, &zp;4.4&ze;, &zp;0.0&ze;, &zp;3.0&ze;, &zp;10.8&ze;
<keyword>struct</keyword>, &zp;3.7&ze;, &zp;0.1&ze;, &zp;2.4&ze;, &zp;2.3&ze;, &zp;2.6&ze;, &zp;11.2&ze;
<keyword>union</keyword>, &zp;0.2&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.1&ze;, &zp;0.2&ze;, &zp;0.5&ze;
 Total, &zp;37.7&ze;, &zp;37.8&ze;, &zp;10.0&ze;, &zp;3.3&ze;, &zp;11.3&ze;
<caption>
Occurrence of derived types in various declaration contexts (as a
percentage of all derived types appearing in these contexts, e.g.,
<c_code>int **ap[2]</c_code> is counted as two pointer types and one
array type).  Based on the translated form of the books benchmark
programs.
</caption>
.E_TABLE


<A NAME="522">3</A>
C99

Array types are characterized by their element type and by the number
of elements in the array.


.FIG
elements
<caption>
Number of arrays defined to have the given number of elements.  Based
on the translated form of the books benchmark programs.
</caption>
.E_FIG


.TABLE elem_type
: l r l r
Element Type, %, Element Type, %
<keyword>char</keyword>, &zp;17.2&ze;, <keyword>struct</keyword> <keyword>*</keyword>, &zp;3.7&ze;
<keyword>struct</keyword>, &zp;16.6&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;2.7&ze;
<keyword>float</keyword>, &zp;14.6&ze;, <keyword>enum</keyword>, &zp;2.5&ze;
other-types, &zp;10.4&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.0&ze;
<keyword>int</keyword>, &zp;8.5&ze;, <keyword>float</keyword> [], &zp;1.9&ze;
<keyword>const</keyword> <keyword>char</keyword>, &zp;8.0&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>const</keyword>, &zp;1.3&ze;
<keyword>char</keyword> <keyword>*</keyword>, &zp;5.1&ze;, <keyword>short</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;4.4&ze;, , 
<caption>
Occurrence of arrays declared to have the given element type (as a
percentage of all objects declared to have an array type).  Based on
the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="525">6</A>
C99 {ref structure type, sequentially allocated objects}

&emdash;&nbsp; A <i>structure type</i> describes a sequentially allocated
nonempty set of member objects (and, in certain circumstances, an
incomplete array), each of which has an optionally specified name and
possibly distinct type.


.FIG
memcluster
<caption>
Possible member clusterings.  In (a) there are two independent
groupings, (b) shows a hierarchy of groupings, while in (c) it is not
possible to define two C structure types that share a subset of
common member (some other languages do support this functionality).
The member <c_code>c</c_code>, for instance, might be implemented as
a pointer to the value, or it may simply be duplicated in two
structure types.
</caption>
.E_FIG


<A NAME="534">12</A>
C99 {ref pointer type} {ref referenced type}

&emdash;&nbsp; A <i>pointer type</i> may be derived from a function type,
an object type, or an incomplete type, called the <i>referenced
type</i>.


.TABLE pointed_to_type
: l r l r
Pointed-to Type, %, Pointed-to Type, %
<keyword>struct</keyword>, &zp;66.5&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;2.2&ze;  
<keyword>char</keyword>, &zp;8.0&ze;, <keyword>struct</keyword> <keyword>*</keyword>, &zp;1.8&ze;
<keyword>union</keyword>, &zp;6.0&ze;, <keyword>int</keyword>, &zp;1.8&ze;
other-types, &zp;5.5&ze;, <keyword>const</keyword> <keyword>char</keyword>, &zp;1.3&ze;
<keyword>void</keyword>, &zp;3.3&ze;, <keyword>char</keyword> <keyword>*</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.6&ze;, , , 
<caption>
Occurrence of objects declared using a given pointer type (as a
percentage of all objects declared to have a pointer type).  Based on
the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="548">1</A>
C99 {ref unqualified type}

Any type so far mentioned is an <i>unqualified type</i>.


.TABLE qual_types
: l r l r
Type Combination, %, Type Combination, %
array of <keyword>const</keyword>, &zp;26.7&ze;, <keyword>const</keyword> <keyword>*</keyword>, &zp;0.4&ze;
<keyword>const</keyword> integer-type, &zp;4.8&ze;, <keyword>const</keyword> <keyword>union</keyword>, &zp;0.3&ze;
<keyword>const</keyword> real-type, &zp;2.7&ze;, <keyword>volatile</keyword> <keyword>struct</keyword>, &zp;0.1&ze;
<keyword>*</keyword> <keyword>const</keyword>, &zp;2.6&ze;, <keyword>volatile</keyword> integer-type, &zp;0.1&ze;
<keyword>const</keyword> <keyword>struct</keyword>, &zp;2.4&ze;, <keyword>*</keyword> <keyword>volatile</keyword>, &zp;0.1&ze;
<caption>
Occurrence of qualified types as a percentage of all (i.e., qualified
and unqualified) occurrences of that kind of type (e.g.,
<keyword>*</keyword> denotes any pointer type,
<keyword>struct</keyword> any structure type, and <phrase>array
of</phrase> an array of some type).  Based on the translated form of
the books benchmark programs.
</caption>
.E_TABLE


<A NAME="549">2</A>
C99 {ref qualified type, versions of}

Each unqualified type has several <i>qualified versions</i> of its
type,<sup>38)</sup> corresponding to the combinations of one, two, or
all three of the <keyword>const</keyword>,
<keyword>volatile</keyword>, and <keyword>restrict</keyword>
qualifiers.


.TABLE qual_context
: l r r r r r r
Type Qualifier, Local, Parameter, File Scope, <keyword>typedef</keyword>, Member, Total
<keyword>const</keyword>, &zp;18.5&ze;, &zp;4.3&ze;, &zp;50.8&ze;, &zp;0.0&ze;, &zp;1.2&ze;, &zp;74.8&ze;
<keyword>volatile</keyword>, &zp;1.6&ze;, &zp;0.1&ze;, &zp;3.0&ze;, &zp;0.1&ze;, &zp;20.4&ze;, &zp;25.2&ze;
<keyword>volatile</keyword> <keyword>const</keyword>, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;, &zp;0.0&ze;
 Total, &zp;20.1&ze;, &zp;4.4&ze;, &zp;53.8&ze;, &zp;0.1&ze;, &zp;21.6&ze;
<caption>
Occurrence of type qualifiers on the outermost type of declarations
occurring in various contexts (as a percentage of all type qualifiers
on the outermost type in these declarations).  Based on the translated
form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="553">2</A>
C99 {ref pointer, to qualified/unqualified types}

Similarly, pointers to qualified or unqualified versions of
compatible types shall have the same representation and alignment
requirements.


.FIG
picmem
<caption>
Data storage organization for the PIC18CXX2 devices <book PIC_18_99>
The 4,096 bytes of storage can be treated as a linear array
or as 16 banks of 256 bytes (different instructions and performance
penalties are involved).  Some storage locations hold
Special  Function Registers (SFR) or General Purpose Registers (GPR).
<phrase>Free</phrase> denotes storage that does not have a preassigned
usage and is available for general program use.
</caption>
.E_FIG


<A NAME="564">1</A>
C99 {ref object, contiguous sequence of bytes}

Except for bit-fields, objects are composed of contiguous sequences
of one or more bytes, the number, order, and encoding of which are
either explicitly specified or implementation-defined.


.FIG
endian
<caption>
Developers who use little-endian often represent increasing storage
locations going down the page.  Developers who use big-endian often
represent increasing storage locations going up the page.  The value
returned by an access to storage location <hlight>0</hlight>, using a
pointer type that causes 16 bits to be read, will depend on the
<phrase>endianness</phrase> of the processor.
</caption>
.E_FIG


.TABLE
: l l 2.9cm l l l
Vendor, 16-bit integer, 32-bit integer, 64-bit integer, 32-bit float, 64-bit float
AT&T 3B2,     , 4321 (data space)/ 1234 (program space), , , 
DEC PDP&endash;11, 12, 3412, , 3412 (F format), 78563412 (D format)
DEC VAX,    12, 1234, 12345678, 3412 (F format), 78563412 (D format)
NSC32016,     , 1234 (data space)/ 4321 (program space), , , 
<caption>
Byte order (indicated by the value of the digits) used by various
processors for some integer and floating types, in different processor
address spaces (all address spaces if none is specified).
</caption>
.E_TABLE


.FIG
unisysa
<caption>
The Unisys A Series <book Unisys_AS_94> uses the same representation
for integer and floating-point types.  For integer values bit 47 is
unused, bit 46 represents the sign of the significand, bits 45
through 39 are zero, and bits 38 through 0 denote the value (a sign
and magnitude representation).  For floating values bit 47 represents
the sign of the exponent and bits 46 through 39 represent the
exponent (the representation for double-precision uses an additional
word with bits 47 through 39 representing higher order-bits of the
exponent and bits 38 through 0 representing the fractional portion of
the significand).
</caption>
.E_FIG


<A NAME="588">2</A>
C99

If there are <equ>N</equ> value bits, each bit shall represent a
different power of 2 between 1 and 2<sup>N-1</sup>, so that objects
of that type shall be capable of representing values from 0 to
2<sup>N</sup>&minus;1 using a pure binary representation; 


.TABLE
Decimal, Binary, Gray code, 111 biased, 2&endash; out-of&endash;5
0,  0000, 0000, 0111, 00011
1,  0001, 0001, 1000, 00101
2,  0010, 0011, 1001, 00110
3,  0011, 0010, 1010, 01001
4,  0100, 0110, 1011, 01010
5,  0101, 0111, 1100, 01100
6,  0110, 0101, 1101, 10001
7,  0111, 0100, 1110, 10010
8,  1000, 1100, 1111, 10100
9,  1001, 1101,     , 11000
10, 1010, 1111,     , 
11, 1011, 1110,     , 
12, 1100, 1010,     , 
13, 1101, 1011,     , 
14, 1110, 1001,     , 
15, 1111, 1000,     , 
<caption>
Pattern of bits used to represent decimal numbers using various coding
schemes.
</caption>
.E_TABLE


<A NAME="604">6</A>
C99 {ref sign bit, representation}

If the sign bit is one, the value shall be modified in one of the
following ways:


.FIG
bincircle
<caption>
Decimal values obtained by interpreting a sequence of bits in various
ways.  From the inside out: unsigned, binary, two's complement, sign
and magnitude, and one's complement.
</caption>
.E_FIG


<A NAME="646">1</A>
C99 {ref operand, convert automatically}

Several operators convert operand values from one type to another
automatically.


.TABLE imp_conv
: l l r l l r
Converted to, Converted from, %, Converted to, Converted from, %
<keyword>(</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>)</keyword>, _<keyword>int</keyword>, &zp;33.0&ze;, <keyword>(</keyword> <keyword>int</keyword> <keyword>)</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.9&ze;
<keyword>(</keyword> <keyword>unsigned</keyword> <keyword>short</keyword> <keyword>)</keyword>, _<keyword>int</keyword>, &zp;17.7&ze;, <keyword>(</keyword> <keyword>unsigned</keyword> <keyword>long</keyword> <keyword>)</keyword>, _<keyword>int</keyword>, &zp;1.8&ze;
<keyword>(</keyword> other-types <keyword>)</keyword>, other-types, &zp;11.3&ze;, <keyword>(</keyword> <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;1.7&ze;
<keyword>(</keyword> <keyword>short</keyword> <keyword>)</keyword>, _<keyword>int</keyword>, &zp;7.6&ze;, <keyword>(</keyword> <keyword>short</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;1.7&ze;
<keyword>(</keyword> <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>)</keyword>, _<keyword>int</keyword>, &zp;5.1&ze;, <keyword>(</keyword> <keyword>enum</keyword> <keyword>)</keyword>, _<keyword>int</keyword>, &zp;1.3&ze;
<keyword>(</keyword> ptr-to <keyword>)</keyword>, ptr-to, &zp;4.7&ze;, <keyword>(</keyword> <keyword>unsigned</keyword> <keyword>long</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;1.2&ze;
<keyword>(</keyword> <keyword>char</keyword> <keyword>)</keyword>, _<keyword>int</keyword>, &zp;3.6&ze;, <keyword>(</keyword> <keyword>int</keyword> <keyword>)</keyword>, <keyword>char</keyword>, &zp;1.2&ze;
<keyword>(</keyword> ptr-to <keyword>)</keyword>, _ptr-to, &zp;2.9&ze;, <keyword>(</keyword> <keyword>int</keyword> <keyword>)</keyword>, <keyword>enum</keyword>, &zp;1.0&ze;
<keyword>(</keyword> <keyword>int</keyword> <keyword>)</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.3&ze;, , , 
<caption>
Occurrence of implicit conversions (as a percentage of all implicit
conversions; an <phrase>_</phrase> prefix indicates a literal
operand).  Based on the translated form of the books benchmark
programs.
</caption>
.E_TABLE


<A NAME="668">6</A>
C99 {ref integer promotions}

These are called the <i>integer promotions</i>.<sup>48)</sup>


.TABLE int_promote
: l c l c
Original Type, %, Original Type, %
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.3&ze;, <keyword>char</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.9&ze;, <keyword>short</keyword>, &zp;0.5&ze;
<caption>
Occurrence of integer promotions (as a percentage of all operands
appearing in all expressions).  Based on the translated form of the
books benchmark programs.
</caption>
.E_TABLE


<A NAME="680">2</A> FP
C99

If the value of the integral part cannot be represented by the
integer type, the behavior is undefined.<sup>50)</sup>


.FIG
twoballs2
<caption>
Illustration of the effect of integer addition wrapping rather than
saturating.  A value has been added to all of the pixels in the left
image to increase the brightness, creating the image on the right.
With permission from Jord&aup;n and Lotufo <book Jordan_00>.
</caption>
.E_FIG


<A NAME="718">1</A>
C99 {ref lvalue, converted to value}

Except when it is the operand of the <keyword>sizeof</keyword>
operator, the unary <keyword>&</keyword> operator, the
<keyword>++</keyword> operator, the <keyword>--</keyword> operator,
or the left operand of the <keyword>.</keyword> operator or an
assignment operator, an lvalue that does not have array type is
converted to the value stored in the designated object (and is no
longer an lvalue).


.FIG
var_rw
<caption>
Execution-time counts of the number of reads and writes of the same
object; items above the diagonal indicate more writes than reads.
Data kindly supplied by Caspi, based on his research <book Caspi_00>.
</caption>
.E_FIG


<A NAME="751">1</A>
C99 {ref pointer, converted to pointer to different object or type}

A pointer to an object or incomplete type may be converted to a
pointer to a different object or incomplete type.


.TABLE imp_ptr
: l l r l l r
To Type, From Type, %, To Type, From Type, %
<keyword>(</keyword> <keyword>struct</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;44.0&ze;, <keyword>(</keyword> <keyword>void</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;4.2&ze;
<keyword>(</keyword> function <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;18.4&ze;, <keyword>(</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;3.4&ze;
<keyword>(</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;7.9&ze;, <keyword>(</keyword> ptr-to <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;2.0&ze;
<keyword>(</keyword> <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;6.9&ze;, <keyword>(</keyword> <keyword>int</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;1.9&ze;
<keyword>(</keyword> <keyword>union</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;5.5&ze;, <keyword>(</keyword> <keyword>long</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;1.1&ze;
<keyword>(</keyword> other-types <keyword>*</keyword> <keyword>)</keyword>, other-types <keyword>*</keyword>, &zp;4.7&ze;, , , 
<caption>
Occurrence of implicit conversions that involve pointer types (as a
percentage of all implicit conversions that involve such types),
based on the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="763">7</A>
C99 {ref token, syntax} {ref preprocessing token, syntax} {ref lexical element}

.ASIS
<c_syntax>token:
                keyword
                identifier
                constant
                string-literal
                punctuator

preprocessing-token:
                header-name
                identifier
                pp-number
                character-constant
                string-literal
                punctuator</c_syntax>
                each non-white-space character that cannot be one of the above
.E_ASIS


.FIG
preatten
<caption>
Examples of features that may be preattentively processed (parallel
lines and the junction of two lines are the odd ones out).  Adapted
from Ware <book Ware_00>.
</caption>
.E_FIG


.FIG
proximity
<caption>
Proximity&emdash; the horizontal distance between the dots in the
upper left image is less than the vertical distance, causing them to
be perceptually grouped into lines (the relative distances are
reversed in the upper right image).
</caption>
.E_FIG


.FIG
similarity
<caption>
Similarity&emdash; a variety of dimensions along which visual items
can differ sufficiently to cause them to be perceived as being
distinct; rotating two line segments by 180&degree; does not create
as big a perceived difference as rotating them by 45&degree;.
</caption>
.E_FIG


.FIG
continu
<caption>
Continuity&emdash; upper image is perceived as two curved lines; the
lower-left image is perceived as a curved line overlapping a
rectangle rather than an angular line overlapping a rectangle having
a piece missing (lower-right image).
</caption>
.E_FIG


.FIG
closure
<caption>
Closure&emdash; when the two perceived lines in the upper image of
<figref href="continu"/> are joined at their end, the perception
changes to one of two cone-shaped objects.
</caption>
.E_FIG


.FIG
sympar
<caption>
Symmetry and parallelism&emdash; where the direction taken by one
line follows the same pattern of behavior as another line.
</caption>
.E_FIG


.FIG
quinlan98
<caption>
Conflict between proximity, color, and shape.  Based on
Quinlan <book Quinlan_98>.
</caption>
.E_FIG


.FIG
palmer94a
<caption>
A flowchart of  Palmer and Rock's <book Palmer_99> theory of perceptual
organization.
</caption>
.E_FIG


.FIG
kolers76
<caption>
Results for the same six subjects in two tests more than a year apart.
Based on Kolers <book Kolers_76>.
</caption>
.E_FIG


.FIG
treisman85
<caption>
Examples of unique items among visually similar items.  Those at the
top include an item that has a distinguishing feature (a vertical
line or a gap); those underneath them include an item that is missing
this distinguishing feature.  Graphs represent time taken to locate
unique items (positive if it is present, negative when it is not
present) when placed among different numbers of visibly similar
distractors.  Based on displays used in the study by Treisman and Sother
<book Treisman_85>.
</caption>
.E_FIG


.FIG
reichle98
<caption>
A passage of text with eye fixation position (dot under word),
fixation sequence number, and fixation duration (in milliseconds)
included.  Adapted from Reichle, Pollatsek, Fisher, and Rayner <book
Reichle_98> (timings on the third line are missing in the original).
</caption>
.E_FIG


.FIG
mrchips
<caption>
Mr. Chips schematic based on <book Legge_97>.  The shaded region in
the visual data is the parafoveal; in this region individual letters
(indicated by stars) can only be distinguished from spaces (indicated
by underscores).
</caption>
.E_FIG


.FIG
reichle98a
<caption>
How preview benefit is affected by word frequency.  The bottom line
denotes the time needed to complete the familiarity check, the middle
line the completion of lexical access, and the top line when the
execution of the eye movement triggered by the familiarity check
occurs.
Based on Reichle, Pollatsek, Fisher, and Rayner <book Reichle_98>.
</caption>
.E_FIG


.FIG
salvucci01
<caption>
Example case of EMMA's control flow.  Adapted from Salvucci <book Salvucci_01>.
</caption>
.E_FIG


.FIG
clawambig
<caption>
The ambiguity of patterns defined by the first and last letter and
an interior letter pair, as a function of the position of the first
letter of the pair.  Plots are for different word lengths using
the 65,000 words from CLAWS <book Leech_94> (as used by the
<tool>aspell</tool> tool).  The fixation position is taken to be
midway between the interior letter pair.
</caption>
.E_FIG


.FIG
idambig
<caption>
The ambiguity of source code identifiers, which can include digits as
well as alphabetic characters.  Plots are for different identifier
lengths.  A total of 344,000 identifiers from the visible form of the
<file>.c</file> files were used.
</caption>
.E_FIG


.TABLE epelboim
Filler type, Surround, Fill-1, Fill-2, Unspaced
Shaded boxes (aloud), &z;4 (&z;1&endash;12), &emdash;, &z;3 (&z;&minus;2&endash;9), 44 (25&endash;60)
Digits (aloud), 26 (15&endash;40), 26 (10&endash;42), &emdash;, 42 (19&endash;64)
Digits (silent), 40 (32&endash;55), 41 (32&endash;58), &emdash;, 52 (45&endash;63)
Greek letters (aloud), 33 (20&endash;47), 36 (23&endash;45), 46 (33&endash;57), 44 (32&endash;53)
Latin letters (aloud), 55 (44&endash;70), &emdash;, 74 (58&endash;84), 43 (13&endash;58)
Latin letters (silent), 66 (51&endash;75), 75 (68&endash;81), &emdash;, 45 (33&endash;60)
<caption>
Mean percentage differences, compared to normal, in reading times
(silent or aloud); the values in parenthesis are the range of
differences.  Adapted from Epelboim <book Epelboim_97>.
</caption>
.E_TABLE


.FIG
tokenonline
<caption>
Number of non-white-space characters and tokens on a physical line;
based on the visible form of the <file>.c</file> and <file>.h</file>
files.
</caption>
.E_FIG


.TABLE sptoksp
: l 1.7cm 1.7cm 1.6cm 1.5cm 1.7cm 1.7cm 1.8cm
Token, % of Tokens in <file>.c</file> files, % of Tokens in <file>.h</file> files, % Preceded by Space, % Followed by Space, % First Token on Line,  % Last Token on Line, Number of Occurrences
punctuator, &zp;53.5&ze; (&zp;11.4&ze;), &zp;48.1&ze; (&zp;7.5&ze;), &zp;27.5&ze;, &zp;29.7&ze;, &zp;3.7&ze;, &zp;25.3&ze;
identifier, &zp;29.8&ze; (&zp;43.4&ze;), &zp;20.8&ze; (&zp;30.6&ze;), &zp;54.9&ze;, &zp;27.6&ze;, &zp;1.4&ze;, &zp;1.2&ze;
constant, &zp;6.9&ze; (&zp;3.8&ze;), &zp;21.6&ze; (&zp;15.3&ze;), &zp;70.3&ze;, &zp;4.4&ze;, &zp;0.1&ze;, &zp;1.6&ze;
keyword, &zp;6.9&ze; (&zp;5.8&ze;), &zp;5.4&ze; (&zp;4.2&ze;), &zp;79.9&ze;, &zp;82.5&ze;, &zp;10.3&ze;, &zp;3.6&ze;
comment, &zp;1.9&ze; (&zp;31.0&ze;), &zp;3.4&ze; (&zp;40.3&ze;), &zp;53.4&ze;, &zp;2.2&ze;, &zp;41.2&ze;, &zp;97.4&ze;
<c_syntax>string-literal</c_syntax>, &zp;1.0&ze; (&zp;4.6&ze;), &zp;0.8&ze; (&zp;2.2&ze;), &zp;59.9&ze;, &zp;5.7&ze;, &zp;0.7&ze;, &zp;8.0&ze;
pp-directive, &zp;0.9&ze; (&zp;1.1&ze;), &zp;4.9&ze; (&zp;4.4&ze;), &zp;4.7&ze;, &zp;78.4&ze;, &zp;0.0&ze;, &zp;18.2&ze;
header-name, &zp;0.0&ze; (&zp;0.0&ze;), &zp;0.0&ze; (&zp;0.0&ze;), &endash;, &endash;, &endash;, &endash;
<caption>
Occurrence of kinds of tokens in the visible form of the
<file>.c</file> and <file>.h</file> files as a percentage of all
tokens (value in parenthesis is the percentage of all non-white-space
characters contained in those tokens), percentage occurrence (for
<file>.c</file> files only) of token kind where it was
preceded/followed by a space character, or starts/finishes a visible
line.  While comments are not tokens they are the only other
construct that can contain non-white-space characters.  While the
start of a preprocessing directive contains two tokens, these are
generally treated by developers as a single entity.

</caption>
.E_TABLE


<A NAME="770">7</A>
C99 {ref preprocessing tokens, white space separation}

Preprocessing tokens can be separated by <i>white space</i>;


.FIG
whitesp
<caption>
Number of white-space characters between preprocessing tokens (does
do not include white space at the start of a line&emdash; i.e.,
indentation white space, and end of line is not counted as a
white-space character).  Based on the visible form of the
<file>.c</file> and <file>.h</file> files.
</caption>
.E_FIG


<A NAME="780">3</A>
C99 {ref keywords, syntax}

.ASIS
      <c_syntax>keyword</c_syntax>: one of
        <keyword>auto        enum        restrict    unsigned
        break       extern      return      void
        case        float       short       volatile
        char        for         signed      while
        const       goto        sizeof      _Bool
        continue    if          static      _Complex
        default     inline      struct      _Imaginary
        do          int         switch
        double      long        typedef
        else        register    union</keyword>
.E_ASIS


.TABLE key_freq
: l r r 1cm 1cm l r r 1cm 1cm
Keyword, <file>.c</file> Files, <file>.h</file> Files, % Start of Line, % End of Line, Keyword, <file>.c</file> Files, <file>.h</file> Files, % Start of Line, % End of Line
<keyword>if</keyword>, &z2p;21.46&ze;, &z2p;15.63&ze;, &z2p;93.60&ze;, &z2p;0.00&ze;, <keyword>const</keyword>, &z2p;0.94&ze;, &z2p;0.80&ze;, &z2p;35.50&ze;, &z2p;0.30&ze;
<keyword>int</keyword>, &z2p;11.31&ze;, &z2p;13.40&ze;, &z2p;47.00&ze;, &z2p;5.30&ze;, <keyword>switch</keyword>, &z2p;0.75&ze;, &z2p;0.77&ze;, &z2p;99.40&ze;, &z2p;0.00&ze;
<keyword>return</keyword>, &z2p;10.18&ze;, &z2p;12.23&ze;, &z2p;94.50&ze;, &z2p;0.10&ze;, <keyword>extern</keyword>, &z2p;0.61&ze;, &z2p;0.71&ze;, &z2p;99.60&ze;, &z2p;0.40&ze;
<keyword>struct</keyword>, &z2p;8.10&ze;, &z2p;10.33&ze;, &z2p;38.90&ze;, &z2p;0.30&ze;, <keyword>register</keyword>, &z2p;0.59&ze;, &z2p;0.64&ze;, &z2p;95.00&ze;, &z2p;0.00&ze;
<keyword>void</keyword>, &z2p;6.24&ze;, &z2p;10.27&ze;, &z2p;28.70&ze;, &z2p;18.20&ze;, <keyword>default</keyword>, &z2p;0.54&ze;, &z2p;0.58&ze;, &z2p;99.90&ze;, &z2p;0.00&ze;
<keyword>static</keyword>, &z2p;6.04&ze;, &z2p;8.07&ze;, &z2p;99.80&ze;, &z2p;0.60&ze;, <keyword>continue</keyword>, &z2p;0.49&ze;, &z2p;0.33&ze;, &z2p;91.30&ze;, &z2p;0.00&ze;
<keyword>char</keyword>, &z2p;4.90&ze;, &z2p;5.08&ze;, &z2p;30.50&ze;, &z2p;0.20&ze;, <keyword>short</keyword>, &z2p;0.38&ze;, &z2p;0.28&ze;, &z2p;16.00&ze;, &z2p;1.00&ze;
<keyword>case</keyword>, &z2p;4.67&ze;, &z2p;4.81&ze;, &z2p;97.80&ze;, &z2p;0.00&ze;, <keyword>enum</keyword>, &z2p;0.20&ze;, &z2p;0.27&ze;, &z2p;73.70&ze;, &z2p;1.80&ze;
<keyword>else</keyword>, &z2p;4.62&ze;, &z2p;3.30&ze;, &z2p;70.20&ze;, &z2p;42.20&ze;, <keyword>do</keyword>, &z2p;0.20&ze;, &z2p;0.25&ze;, &z2p;87.30&ze;, &z2p;21.30&ze;
<keyword>unsigned</keyword>, &z2p;4.17&ze;, &z2p;2.58&ze;, &z2p;46.80&ze;, &z2p;0.10&ze;, <keyword>volatile</keyword>, &z2p;0.18&ze;, &z2p;0.17&ze;, &z2p;50.00&ze;, &z2p;0.00&ze;
<keyword>break</keyword>, &z2p;3.77&ze;, &z2p;2.44&ze;, &z2p;91.80&ze;, &z2p;0.00&ze;, <keyword>float</keyword>, &z2p;0.16&ze;, &z2p;0.17&ze;, &z2p;54.00&ze;, &z2p;0.70&ze;
<keyword>sizeof</keyword>, &z2p;2.23&ze;, &z2p;2.24&ze;, &z2p;11.30&ze;, &z2p;0.00&ze;, <keyword>typedef</keyword>, &z2p;0.15&ze;, &z2p;0.09&ze;, &z2p;99.80&ze;, &z2p;0.00&ze;
<keyword>long</keyword>, &z2p;2.23&ze;, &z2p;1.49&ze;, &z2p;10.10&ze;, &z2p;1.70&ze;, <keyword>double</keyword>, &z2p;0.14&ze;, &z2p;0.08&ze;, &z2p;53.60&ze;, &z2p;3.10&ze;
<keyword>for</keyword>, &z2p;2.22&ze;, &z2p;1.06&ze;, &z2p;99.70&ze;, &z2p;0.00&ze;, <keyword>union</keyword>, &z2p;0.04&ze;, &z2p;0.06&ze;, &z2p;63.30&ze;, &z2p;6.20&ze;
<keyword>while</keyword>, &z2p;1.23&ze;, &z2p;0.95&ze;, &z2p;85.20&ze;, &z2p;0.10&ze;, <keyword>signed</keyword>, &z2p;0.02&ze;, &z2p;0.01&ze;, &z2p;27.20&ze;, &z2p;0.00&ze;
<keyword>goto</keyword>, &z2p;1.23&ze;, &z2p;0.89&ze;, &z2p;94.10&ze;, &z2p;0.00&ze;, <keyword>auto</keyword>, &z2p;0.00&ze;, &z2p;0.00&ze;, &z2p;0.00&ze;, &z2p;0.00&ze;
<caption>
Occurrence of keywords (as a percentage of all keywords in the
respective kind of file) and occurrence of those keywords as the
first and last token on a line (as a percentage of occurrences of the
respective keyword; for <file>.c</file> files only).  Based on the
visible form of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


<A NAME="782">2</A>
C99 {ref identifier, syntax}

.ASIS
<c_syntax>identifier:
                identifier-nondigit
                identifier identifier-nondigit
                identifier digit

identifier-nondigit:
                nondigit
                universal-character-name</c_syntax>
                other implementation-defined characters

<c_syntax>nondigit:</c_syntax> one of
                <keyword>_  a  b  c  d  e  f  g  h  i  j  k  l  m
                   n  o  p  q  r  s  t  u  v  w  x  y  z
                   A  B  C  D  E  F  G  H  I  J  K  L  M
                   N  O  P  Q  R  S  T  U  V  W  X  Y  Z</keyword>

<c_syntax>digit:</c_syntax> one of
                <keyword>0  1  2  3  4  5  6  7  8  9</keyword>
.E_ASIS


.FIG
idexam1
<caption>
The same program visually presented in three different ways;
illustrating how a reader's existing knowledge of words can provide a
significant benefit in comprehending source code.  By comparison, all
the other tokens combined provide relatively little information.
Based on an example from Laitinen <book Laitinen_95>.
</caption>
.E_FIG


.TABLE bransford72
: l r r r r
 , No Topic Given, Topic Given After, Topic Given Before, Maximum Score
Comprehension, 2.29 (0.22), 2.12 (0.26), 4.50 (0.49), 7
Recall, 2.82 (0.60), 2.65 (0.53), 5.83 (0.49), 18
<caption>
Mean comprehension rating and mean number of ideas recalled from passage
(standard deviation is given in parentheses).
Adapted from Bransford and Johnson <book Bransford_72>.
</caption>
.E_TABLE


.TABLE mcu_vasm
: l 3cm 3cm 3cm 3cm
      ,        Visual, Acoustic, Semantic, Miscellaneous
Memory, Idetic memory, Working memory is sound based, Proper names&comma; LTM is semantic based, spelling&comma; cognitive studies&comma; Learning
Confusability, Letter and word shape, Sounds like, Categories&comma; metaphor, Sequence comparison
Usability, Careful reading&comma; visual search, Working memory limits&comma; pronounceability, interpersonal communication&comma; abbreviations, Cognitive resources&comma; typing
<caption>
Break down of issues considered applicable to selecting an identifier
spelling.
</caption>
.E_TABLE


.TABLE human_lang_speak
: r l r l l
Rank, Language,  Speakers (millions), Writing direction, Preferred word order
1, Mandarin Chinese, 1,075, left-to-right also top-down, SVO
2, Hindi/Urdu, 575, see note, see note
3, English, 514, left-to-right, SVO
4, Spanish, 425, left-to-right, SVO
5, Russian, 275, left-to-right, SVO
6, Arabic,  256, right-to-left, VSO
7, Bengali, 215, left-to-right, SOV
8, Portuguese, 194, left-to-right, SVO
9, Malay/Indonesian, 176, left-to-right, SVO
10, French, 129, left-to-right, SVO
11, German, 128, left-to-right, SOV
12, Japanese, 126, left-to-right, SOV
<caption>
Estimates of the number of speakers each language (figures include
both native and nonnative speakers of the language; adapted from
Ethnologue volume I, SIL International).

Note: Hindi and Urdu are essentially the same language, Hindustani.
As the official language of Pakistan, it is written right-to-left in
a modified Arabic script and called Urdu (106 million speakers). As
the official language of India, it is written left-to-right in the
Devanagari script and called Hindi (469 million speakers).
</caption>
.E_TABLE


.FIG
peereman97
<caption>
Example of the different kinds of lexical neighborhoods for the
English word <hlight>RACE</hlight>.  Adapted from Peereman and
Content <book Peereman_97>.
</caption>
.E_FIG


.FIG
harm98
<caption>
Triangle model of word recognition.  There are two routes to both
semantics and phonology, from orthography.  Adapted from Harm <book
Harm_98>.
</caption>
.E_FIG


.TABLE shared_id
: l r r r r r r r r
 ,  all_prog,  gcc,  idsoftware,  linux,  netscape,  openafs,  openMotif,  postgresql 
 all_prog ,  &emdash; ,    &zs;24271&ze; ,    &zs;11531&ze; ,   &zs;182910&ze; ,    &zs;15411&ze; ,    &zs;15856&ze; ,    &zs;12762&ze; ,     &zs;8196&ze; 
 gcc ,    &zs;24271&ze; ,  &emdash; ,     &zs;1164&ze; ,     &zs;2896&ze; ,     &zs;2141&ze; ,     &zs;1785&ze; ,     &zs;1241&ze; ,     &zs;1368&ze; 
 idsoftware ,    &zs;11531&ze; ,     &zs;1164&ze; ,  &emdash; ,     &zs;1895&ze; ,     &zs;1386&ze; ,     &zs;1173&ze; ,      &zs;948&ze; ,      &zs;847&ze; 
 linux ,   &zs;182910&ze; ,     &zs;2896&ze; ,     &zs;1895&ze; ,  &emdash; ,     &zs;3058&ze; ,     &zs;3037&ze; ,     &zs;1756&ze; ,     &zs;1719&ze; 
 netscape ,    &zs;15411&ze; ,     &zs;2141&ze; ,     &zs;1386&ze; ,     &zs;3058&ze; ,  &emdash; ,     &zs;2158&ze; ,     &zs;1818&ze; ,     &zs;1557&ze; 
 openafs ,    &zs;15856&ze; ,     &zs;1785&ze; ,     &zs;1173&ze; ,     &zs;3037&ze; ,     &zs;2158&ze; ,  &emdash; ,     &zs;1103&ze; ,     &zs;1459&ze; 
 openMotif ,    &zs;12762&ze; ,     &zs;1241&ze; ,      &zs;948&ze; ,     &zs;1756&ze; ,     &zs;1818&ze; ,     &zs;1103&ze; ,  &emdash; ,      &zs;905&ze; 
 postgresql ,     &zs;8196&ze; ,     &zs;1368&ze; ,      &zs;847&ze; ,     &zs;1719&ze; ,     &zs;1557&ze; ,     &zs;1459&ze; ,      &zs;905&ze; ,  &emdash; 
<caption>
Number of identifiers having the same spelling and occurring in pairs
of programs.  <phrase>all_prog</phrase> denotes the combined source
of all the programs.  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_TABLE


.FIG
labov73a
<caption>
Cup- and bowl-like objects of various widths (ratios 1.2, 1.5, 1.9,
and 2.5) and heights (ratios 1.2, 1.5, 1.9, and 2.4).  Adapted from Labov
<book Labov_73>.
</caption>
.E_FIG


.FIG
labov73b
<caption>
The percentage of subjects who selected the term <phrase>cup</phrase>
or <phrase>bowl</phrase> to describe the object they were shown (the
paper did not explain why the figures do not sum to 100%).  Adapted from Labov
<book Labov_73>.
</caption>
.E_FIG


.FIG
fillmore77
<caption>
A commercial event involving a buyer, seller, money, and goods; as
seen from the buy, sell, pay, or charge perspective.  Based on
Fillmore <book Fillmore_77>.
</caption>
.E_FIG


.TABLE id_kind_case
: l r r r r 2.4cm
, no lower-case, no upper-case, no underscore, no digits, only first character upper-case
file scope objects, &zp;0.8&ze; (&zp;1.0&ze;), &zp;80.3&ze; (&zp;79.1&ze;), &zp;29.6&ze; (&zp;25.4&ze;), &zp;87.3&ze; (&zp;85.7&ze;), &zp;5.2&ze; (&zp;5.7&ze;)
block scope objects, &zp;1.3&ze; (&zp;1.8&ze;), &zp;91.9&ze; (&zp;81.3&ze;), &zp;79.9&ze; (&zp;58.9&ze;), &zp;96.3&ze; (&zp;93.0&ze;), &zp;1.3&ze; (&zp;3.1&ze;)
function parameters, &zp;0.1&ze; (&zp;0.4&ze;), &zp;94.2&ze; (&zp;82.9&ze;), &zp;88.6&ze; (&zp;67.4&ze;), &zp;96.8&ze; (&zp;94.8&ze;), &zp;1.4&ze; (&zp;2.9&ze;)
function definitions, &zp;0.2&ze; (&zp;0.2&ze;), &zp;59.0&ze; (&zp;62.1&ze;), &zp;27.1&ze; (&zp;24.1&ze;), &zp;87.1&ze; (&zp;86.4&ze;), &zp;29.9&ze; (&zp;27.3&ze;)
struct/union members, &zp;0.5&ze; (&zp;0.8&ze;), &zp;78.5&ze; (&zp;71.8&ze;), &zp;65.7&ze; (&zp;51.3&ze;), &zp;93.2&ze; (&zp;91.4&ze;), &zp;12.0&ze; (&zp;14.2&ze;)
function declarations, &zp;0.7&ze; (&zp;0.5&ze;), &zp;55.5&ze; (&zp;57.1&ze;), &zp;27.3&ze; (&zp;26.5&ze;), &zp;88.7&ze; (&zp;87.5&ze;), &zp;32.4&ze; (&zp;30.1&ze;)
tag names, &zp;5.7&ze; (&zp;6.6&ze;), &zp;60.7&ze; (&zp;63.8&ze;), &zp;25.6&ze; (&zp;21.6&ze;), &zp;88.1&ze; (&zp;85.9&ze;), &zp;18.4&ze; (&zp;14.5&ze;)
<keyword>typedef</keyword> names, &zp;14.0&ze; (&zp;17.0&ze;), &zp;37.0&ze; (&zp;33.5&ze;), &zp;45.0&ze; (&zp;40.4&ze;), &zp;89.7&ze; (&zp;89.3&ze;), &zp;39.8&ze; (&zp;37.4&ze;)
enumeration constants, &zp;55.8&ze; (&zp;56.0&ze;), &zp;10.8&ze; (&zp;10.6&ze;), &zp;16.0&ze; (&zp;15.0&ze;), &zp;79.9&ze; (&zp;77.9&ze;), &zp;32.1&ze; (&zp;32.0&ze;)
label names, &zp;27.2&ze; (&zp;48.1&ze;), &zp;69.2&ze; (&zp;47.4&ze;), &zp;70.8&ze; (&zp;65.6&ze;), &zp;67.4&ze; (&zp;46.3&ze;), &zp;2.2&ze; (&zp;2.3&ze;)
macro definitions, &zp;78.4&ze; (&zp;79.9&ze;), &zp;4.9&ze; (&zp;5.0&ze;), &zp;15.5&ze; (&zp;13.0&ze;), &zp;70.9&ze; (&zp;69.3&ze;), &zp;13.1&ze; (&zp;11.1&ze;)
macro parameters, &zp;19.8&ze; (&zp;20.4&ze;), &zp;77.6&ze; (&zp;68.7&ze;), &zp;96.0&ze; (&zp;83.6&ze;), &zp;94.2&ze; (&zp;90.7&ze;), &zp;1.4&ze; (&zp;5.0&ze;)
<caption>

Occurrence of declared identifiers (as a percentage of all
identifiers in the visible form of the <file>.c</file> files;
weighted by number of occurrences; unique identifiers are in
parentheses) containing particular character sequences (the phrase
<phrase>spelled using upper-case letters</phrase> is usually taken to
mean that no lower-case letters are used, i.e., digits and underscore
are included in the possible set of characters; for simplicity and
accuracy the set of characters omitted are listed).

</caption>
.E_TABLE


.FIG
idlen
<caption>
Number of identifiers (unique and all) of different length in the
visible form of the <file>.c</file> files.  Any identifier whose
spelling appeared in the <tool>aspell</tool> 65,000 word dictionary
was considered to be a word.
</caption>
.E_FIG


.TABLE human_lang_write
: 5.4cm r 3.4cm
Total languages out of 50, Speakers (millions), Readers (millions&comma; based on illiteracy rates)
Character-based systems&emdash; 8 (all Chinese) + Japanese, 1&comma;088, &ptz;930
Syllabic systems&emdash; 13 (mostly in India) + Japanese&comma; Korean, 561, &ptz;329
Consonantal systems&emdash; 4 (two Arabic) + Urdu&comma; Persian, 148, no figures available
Alphabetic systems&emdash; 21 (worldwide), 1&comma;572, 1&comma;232
<caption>
Number of people using particular types of writing system for the top
50 world languages in terms of number of speakers.  Literacy rates
from UNESCO based on typical countries for each language (e.g.,
China, Egypt, India, Spain).  Adapted from Cook <book Cook_97b>.
</caption>
.E_TABLE


.FIG
muter85
<caption>
Improvement in word-recognition performance with number of
sessions (most sessions consisted of 16 blocks of 16 trials).
Adapted from Muter and Johns <book Muter_85>.
</caption>
.E_FIG


.TABLE word_order
: l r l
Common order, Languages, Example
None, no figures, Sanscrit
SOV, 180, Turkish <quote>Hansan &odots;k&odots;z-&udots; ald&iota;</quote> &Rightarrow; <quote>Hassan ox bought</quote>
SVO, 168, English <quote>The farmer killed the duckling</quote>
VSO, 37, Welsh <quote>Lladdodd y ddraig y dyn</quote> &Rightarrow; <quote>killed the dragon the man</quote>
VOS, 12, Malagasy <quote>Nahita ny mpianatra ny vehivavy</quote> &Rightarrow; <quote>saw the student the woman</quote>
OVS, 5, Hixkaryana <quote>Toto yahosi-ye kamara</quote> &Rightarrow; <quote>man it-grabbed-him jaguar</quote>
OSV, 2, Apurin&atilde; none available
<caption>
Known number of languages commonly using a particular word order.
Based on Comrie <book Comrie_89>.
</caption>
.E_TABLE


.FIG
berlin69
<caption>
The original Berlin and Kay <book Berlin_69> language color
hierarchy.  The presence of any color term in a language, implies the
existence, in that language, of all terms to its left.  Papuan Dani
has two terms (black and white), while Russian has eleven.  (Russian
may also be an exception in that it has two terms for blue.)
</caption>
.E_FIG


.FIG
wordsinid
<caption>
Number of <phrase>components</phrase> of an identifier (where a
component is defined as a character sequence delimited by one or more
underscore characters, <phrase>_</phrase>, the start of the
identifier, or its ending, e.g., the identifier
<c_code>big_blk_proboscis</c_code> is considered to contain three
components, one of which is a word).  A word is defined by the
contents of the <tool>ispell</tool> 65,000 word list (this means, for
instance, that the character sequence proboscis is not considered to
be a word).  Based on the visible form of the <file>.c</file> files.
</caption>
.E_FIG


.TABLE english_tense
, Simple, Perfect, Progressive, Perfect progressive
Present, write/writes, has/have written, am/is/are writing, has/have been writing
       , walk/walks, has/have walked, am-is/are walking, has/have been walking

Past, wrote, had written, was/were writing, had been writing
    , walked, had walked, was/were walking, had been walking

Future, will write, will have written, will be writing, will have been writing
      , will walk, will have walked, will be walking, will have been walking
<caption>

The 12 <phrase>tenses</phrase> of English (actually three tenses and
four aspects).  Adapted from Celce-Murcia <book Celce-Murcia_99>.
</caption>
.E_TABLE


.TABLE Svatko_79
determiner, option, size, shape, condition, age, color, origin, noun
  , 0.80, 0.97, 0.66, 0.79, 0.85, 0.77, 1.0, 
an, ugly, big, round, chipped, old, blue, French, vase
<caption>
Probability of an adjective occurring at a particular position relative
to other adjectives.  Adapted from Celce-Murcia <book Celce-Murcia_99>.
</caption>
.E_TABLE


.TABLE
: 4.1cm 4.3cm 5.3cm
Predeterminers,            Core determiners,          Post determiners
qualifiers: <i>all&comma; both&comma; half</i>&comma; etc.,  articles: <i>a&comma; an&comma; the</i>&comma; etc.,    cardinal numbers: <i>one&comma; two</i>&comma; &etc;
fractions: <i>such a&comma; what a</i>&comma; etc., possessives: <i>my&comma; our</i>&comma; etc.,  ordinal numbers: <i>first&comma; second</i>&comma; &etc;
multipliers: <i>double&comma; twice&comma; three times</i>&comma; etc., demonstratives: <i>this&comma; that</i>&comma; etc.,   general ordinals: <i>next&comma; last&comma; another</i>&comma; &etc;
         , quantifiers: <i>some&comma; any&comma; no&comma; each&comma; every&comma; either&comma; neither&comma; enough</i>&comma; etc., quantifiers: <i>many&comma; much&comma; (a) few (a) little&comma; several&comma; more&comma; less most&comma; least</i>&comma; &etc;
         ,            ,   phrasal quantifiers: <i>a great deal&comma; of&comma; a lot of&comma; a good number of</i>&comma; &etc;
<caption>
Subcategories of determiners.  Adapted from Celce-Murcia <book Celce-Murcia_99>.
</caption>
.E_TABLE


.FIG
dirven93
<caption>
Examples, using <quote><b>at</b></quote> and <quote><b>in</b></quote>
of extensions of prepositions from physical to mental space.  Adapted from
Dirven <book Dirven_93>.
</caption>
.E_FIG


.FIG
interlang
<caption>
A learners independent language&emdash;
<phrase>interlanguage</phrase>.  This language changes as learners go
through the various stages of learning a new language.  It represents
the rules and structures invented by learners, which are influenced
by what they already know, as they acquire knowledge and proficiency
in a new language.
</caption>
.E_FIG


.TABLE sloboda80
: 1.5cm 2.1cm 1.4cm 2.2cm 1.4cm
Spelling pattern, similar phonologically, mistakes made, dissimilar phonologically, mistakes made
-ent, clement, 46, convert, 1
-ant, clemant, , convart, 

-ce, promice, &z;9, polich, 1
-se, promise, , polish, 

w-, weight, &z;3, sapely, 1
wh-, wheight, , shapely

-er, paster, &z;7, parret, 6
-or, pastor, , parrot, 

-le, hostle, 11, assits, 1
-el, hostel, , assist, 

-ayed, sprayed, 18, slayer, 0
-aid, spraid, , slair

-ea-, deamed, 24, dearth, 3
-ee-, deemed, , deerth, 

-CC-, deppress, 33, preessed, 0
-C-, depress, , pressed, 

-ancy, currancy, 27, corractly, 0
-ency, currency, , correctly, 

-al, rival, 13, livas, 2
-el, rivel, , lives, 
<caption>
Example words and total number of all mistakes for particular
spelling patterns (<hlight>&endash;C&endash;</hlight> denotes any
consonant).  Adapted from Sloboda <book Sloboda_80>.
</caption>
.E_TABLE


.FIG
horowitz61a
<caption>
Mean correct recall scores and mean number of responses (correct and
incorrect) for 10 trials.  Adapted from Horowitz <book Horowitz_61>.
</caption>
.E_FIG


.FIG
horowitz61b
<caption>
Percentage of correct orderings as a function of the trigram position
within the list learned for three different trials.  Adapted from Horowitz
<book Horowitz_61>.
</caption>
.E_FIG


.TABLE cohen90
, Name, Occupation, Possession
Nonword, 18.6, 37.1, 16.5
Word, 23.6, 37.0, 30.4
<caption>
Mean number of each kind of information recalled in each condition
(maximum score: 48).  Adapted from Cohen <book Cohen_90>.
</caption>
.E_TABLE


.TABLE pollock83
Kind of Mistake, Percentage Mistakes
omission, 34
insertion, 27
substitution, 19
transposition, 12.5
more than one, &z;7.5
<caption>
Breakdown of 52,963 spelling mistakes in 25 million typed words.
Adapted from Pollock and Zamora <book Pollock_83>.
</caption>
.E_TABLE


.TABLE natsec_spel
: l 2.2cm 2.2cm 2.3cm 2.3cm
     , High Frequency Regular Spelling, Low Frequency Regular Spelling, High Frequency Irregular Spelling, Low Frequency Irregular Spelling
Native speaker, 0.106, 4.213, 0.596, 7.319
Second language, 0.766, 7.383, 2.426, 9.255
Example, cat&comma; paper, fen&comma; yak, of&comma; one, tsetse&comma; ghoul
<caption>
Mean number of spelling mistakes for high/low frequency words with
regular/irregular spellings.  Adapted from Brown <book Brown_70a>.
</caption>
.E_TABLE


.FIG
idlev
<caption>
Number of identifiers having a given Levenstein distance from all
other identifiers occurring in the visible form of the
<file>.c</file> files of individual programs (i.e., identifiers in
gcc were only compared against other identifier in gcc).  The
<phrase>keyboard-levenstein</phrase> distance was calculated using a
weight of 1 when comparing characters on immediately adjacent
keyboard keys and a weight of 2 for all other cases (the result was
normalized to allow comparison against unweighted Levenstein distance
values).
</caption>
.E_FIG


.FIG
ideng
<caption>
Occurrence of alphabetic letters in English text <book Solso_76> and
identifier names (based on the visible form of the <file>.c</file>
files; all letters mapped to lowercase).  Left graph plots the letter
percentage occurrence as (<equ>x</equ>, <equ>y</equ>) coordinates and
right graph plots the ratio of dividing the English by the identifier
letter frequency (i.e., letters above the line are more common in
English text than in identifiers; two letters outside the range
plotted are <equ>v=0.0588</equ> and <equ>x=0.165</equ>).
</caption>
.E_FIG


.FIG
glyphs
<caption>
The same glyphs rendered in different fonts.
</caption>
.E_FIG


.FIG
letfont
<caption>
Similarity hierarchy for English letters.
Adapted from ### <book letfont_??>.
</caption>
.E_FIG


.FIG
chambers75
<caption>
Response time to match two letter sequences as being identical.
Adapted from Chambers and Foster <book Chambers_75>.
</caption>
.E_FIG


.TABLE chambers75_t
: l r r r r r
, All Letters, First Letter, Third Letter, Fifth Letter, Same Response
Words, 677, 748, 815, 851, 747
Pronounceable nonwords, 673, 727, 844, 886, 873
Unpronounceable nonwords, 686, 791, 1&comma;007, 1&comma;041, 1&comma;007
<caption>
Response time (in milliseconds) to fail to match two letter
sequences.  Right column is average response time to match identical
letter sequences.  Columns are ordered by which letter differed
between letter sequences.  Adapted from Chambers and Foster <book
Chambers_75>.
</caption>
.E_TABLE


.FIG
eichelman70
<caption>
Time taken (in milliseconds) to match a pair of letter sequences as
being identical&emdash; for different number of letters in the
sequence and number of positions in the sequence containing a
nonmatching letter.  Adapted from Eichelman <book Eichelman_70>.
</caption>
.E_FIG


.TABLE monk_83
: l 2.4cm 2.7cm 2.5cm 2.5cm
 , Same Lowercase Word Shape, Different Lowercase Word Shape, Same Mixedcase Word Shape, Different Mixedcase Word Shape
Letter deleted, 0.554, 0.615, 0.529, 0.517
Letter substituted, 0.759, 0.818, 0.678, 0.680
<caption>
Proportion of spelling errors detected (after arcsin transform was
applied to the results).  Adapted from Monk and Hulme <book Monk_83>.
</caption>
.E_TABLE


.FIG
paap84
<caption>
Percentage of misspellings not detected for various kinds of word.
Adapted from Paap, Newsome, and Noel <book Paap_84>.
</caption>
.E_FIG


.TABLE conrad_65
: 2cm 1.5cm 2.2cm 0.9cm 1.5cm 2.2cm 0.9cm r
Number Intervening Letters, Transpose (AS), Semi-transpose (AS), Other (AS), Transpose (AD), Semi-transpose (AD), Other (AD), Total
0, 797, 446, 130, 157, 252, 207, 1&comma;989
1, 140, 112,  &z;34,  &z;13,  &z;33,  &z;76,  408
2,  &z;31,  &z;23,  &z;16,   &z2;2,  &z;18,  &z;56,  146
3,  &z;12,  &z;20,  &z;12,   &z2;1,  &z2;5,  &z;23,   73
4,  &z2;0,  &z2;4,  &z2;1,   &z2;0,  &z2;2,  &z2;7,   14
Total, 890, 605, 193, 173, 310, 369, 2&comma;630
<caption>
Classification of recall errors for acoustically similar (AS),
acoustically dissimilar (AD) pairs of letters.  Semi-transpose refers
to the case where, for instance, <hlight>PB</hlight> is presented and
<hlight>BV</hlight> is recalled (where <hlight>V</hlight> does not
appear in the list).  Other refers to the case where pairs are both
replaced by completely different letters.  Adapted from Conrad <book
Conrad_65>.
</caption>
.E_TABLE


.FIG
baddeley68
<caption>
Left graph is the rate of forgetting of visually presented lists of
four words containing the same (solid line) or different (dashed
line) vowels.  Right graph is the rate for two lists, one containing
three acoustically similar words and the other five acoustically
dissimilar words.  Adapted from Baddeley <book Baddeley_68>.
</caption>
.E_FIG


.FIG
lambert02a
<caption>
Error rate at low and high neighborhood frequency.  Stimulus (drug
name) frequency (SF), neighborhood density (ND).  Adapted from
Lambert, Chang, and Gupta <book Lambert_03>.
</caption>
.E_FIG


.FIG
lambert02b
<caption>
Number of substitution errors having a given edit distance from the
correct response.  Lighter bars denote non-drug-name responses, while
darker bars denote responses for known drug names.  Based on Lambert,
Chang, and Gupta <book Lambert_03>.
</caption>
.E_FIG


.FIG
idperfunc
<caption>
Number of identifiers referenced within individual function
definitions.  Based on the translated form of the books benchmark
programs.
</caption>
.E_FIG


.FIG
idzipf
<caption>
Frequency of identifiers having a particular spelling plotted against
the number of occurrences (the content of comments has been
excluded) in the visible form of (b) Mozilla, and (c) Linux 2.4
kernel; (a) is a distribution following Zipf's law with the most
common item occurring 10,000 times.  A dot is appears for each
identifier rank.
</caption>
.E_FIG


.TABLE nonwords
: 2.2cm 2.2cm 2.2cm 2.2cm
0-order, 1-order, 2-order, 4-order
YRULPZOC, STANUGOP, WALLYLOF, RICANING
OZHGPMTJ, VTYEHULO, RGERARES, VERNALIT
DLEGQMNW, EINOAASE, CHEVADNE, MOSSIANT
GFUJXZAQ, IYDEWAKN, NERMBLIM, POKERSON
WXPAUJVB, RPITCQET, ONESTEVA, ONETICUL
VQWVBIFX, OMNTOHCH, ACOSUNST, ATEDITOL
CVGJCDHM, DNEHHSNO, SERRRTHE, APHYSTER
MFRSIWZE, RSEMPOIN, ROCEDERT, TERVALLE
<caption>
Examples of nonwords.  The 0-order words were created by randomly
selecting a sequence of equally probable letters, the 1-order words
by weighting the random selection according to the probability of
letters found in English words, the 2-order words by weighting the
random selection according to the probability of a particular letter
following the previous letter in the nonword (for English words), and
so on.  Adapted from Miller <book Miller_54>).
</caption>
.E_TABLE


.FIG
miller54
<caption>
Number of correct letters regardless of position (A), and number of
correct letters placed in the correct position (C).  Normalizing for
information content, the corresponding results are (B) and (D),
respectively.  Plotted lines denote 0-, 1-, 2-, and 4-order
approximations to English words (see <tableref href="nonwords"/>).
Adapted from Miller, Bruner, and Postman <book Miller_54>.
</caption>
.E_FIG


.FIG
green87
<caption>
Mean response time (in milliseconds) for correct target detection as
a function of the position of the match within the character
sequence.  Adapted from Green and Meara <book Green_87>.
</caption>
.E_FIG


.FIG
idexam2
<caption>
Example of identifier spellings containing lots of characters.
Based on an example from Laitinen <book Laitinen_95>.
</caption>
.E_FIG


.FIG
frost87
<caption>
Error (as a percentage of responses) for naming and lexical decision
tasks in Hebrew, English, and Serbo-Croatian using high/low frequency
words and nonwords.  Adapted from Frost, Katz, and Bentin <book
Frost_87>.
</caption>
.E_FIG


.TABLE
 Concept Denoted, Example Words
Reflected or indirect light, glare&comma; gleam&comma; glim&comma; glimmer&comma; glint&comma; glisten&comma; glister&comma; glitter&comma; gloaming&comma; glow
Indirect use of the eyes, glance&comma; glaze(d)&comma; glimpse&comma; glint
Reflecting surfaces, glac&eup;&comma; glacier&comma; glair&comma; glare&comma; glass&comma; glaze&comma; gloss
<caption>
Words that make up 19 of the 46 words beginning with the English
<hlight>/gl/</hlight> of the monomorphemic vocabulary (Note: The
others are: globe, glower, glean, glib, glimmer, glimpse, gloss,
glyph, glib, glide, glitter, gloss, glide, glissade, glob, globe,
glut, glean, glimmer, glue, gluten, glutton, glance, gland, glove,
glad, glee, gloat, glory, glow, gloom, glower, glum, glade, and
glen).  Adapted from Magnus <book Magnus_01>.
</caption>
.E_TABLE


.TABLE wordnet
: l r r r
Part of Speech, Unique Strings, Synsets, Total Word-sense Pairs
Noun,     114&comma;648,   79&comma;689,  141&comma;690
Verb,      11&comma;306,   13&comma;508,   24&comma;632
Adjective, 21&comma;436,   18&comma;563,   31&comma;015
Adverb,     4&comma;669,    3&comma;664,    5&comma;808
Total,    152&comma;059,  115&comma;424,  203&comma;145
<caption>
WordNet 2.0 database statistics.
</caption>
.E_TABLE


.FIG
duty
<caption>
Similarity tree for <phrase>duty</phrase>.  The first value is the
computed similarity of the word to its parent (in the tree), the
second value its similarity to <phrase>duty</phrase>.  Adapted from Lin <book
Lin_98>.
</caption>
.E_FIG


.FIG
dimarco93
<caption>
The relationship between words for tracts of trees in various
languages.  The interpretation given to words (boundary indicated by
the zigzags) in one language may overlap that given in other
languages.  Adapted from DiMarco, Hirst, and Stede <book DiMarco_93>.
</caption>
.E_FIG


.FIG
streeter83
<caption>
Percentage of abbreviations generated using each algorithm.  The
<phrase>rule</phrase> case was a set of syllable-based rules created
by Streeter et al.; the <phrase>popular</phrase> case was the
percentage occurrence of the most popular abbreviation.  Based on
Streeter, Ackroff, and Taylor <book Streeter_83>.
</caption>
.E_FIG


.TABLE Carter_00
: 3.4cm 1.5cm 1.1cm 0.7cm 0.7cm
Syllables in Word and Primary Stress Position, Syllable(s) 1, Omitted 2, Most 3, Often 4
2syl&endash;1pri, , &times;, &endash;, &endash;
2syl&endash;2pri, &times;, , &endash;, &endash;
3syl&endash;1pri, , &times;, &times;, &endash;
3syl&endash;2pri, &times;, , , &endash;
3syl&endash;3pri, , &times;, &times;, &endash;
4syl&endash;1pri, , &times;, , 
4syl&endash;2pri, , , &times;, &times;
4syl&endash;3pri, &times;, &times;, , &times;
<caption>
The syllable most likely to be omitted in a word (indicated by the
&times; symbol) based on the number of syllables
(<phrase>syl</phrase>) and the position of the primary,
(<phrase>pri</phrase>) stressed syllable.  Adapted from Carter and Clopper
<book Carter_00>.
</caption>
.E_TABLE


.TABLE Laitinen97
: l r r r r r
Application, A, B, C, D, E
Source lines, 12&comma;075&ptz;, 6&comma;114&ptz;, 3&comma;874&ptz;, 6&comma;420&ptz;, 3&comma;331&ptz;
Total names, 1&comma;410&ptz;, 927&ptz;, 439&ptz;, 740&ptz;, 272&ptz;
Already acceptable,    5.6,  3.1,  8.7,  9.3, 11.0
Tool suggestion used, 42.6, 44.7, 35.3, 46.8, 41.5
User suggestion used, 39.6, 29.3, 15.0, 30.7, 43.8
Skipped or unknown names, 12.2, 22.9, 41.0, 13.2, 3.7
User time (hours), 11&ptz;, 5&ptz;, 4&ptz;, 4&ptz;, 3&ptz;
<caption>
Five different applications (A&endash; E) unabbreviated using
<tool>InName</tool>, by five different people.  Application C had
many short names of the form <c_code>i</c_code>, <c_code>m</c_code>,
<c_code>k</c_code>, and <c_code>r2</c_code>.  Adapted from Laitinen <book
Laitinen_97>.
</caption>
.E_TABLE


.TABLE shaffer68a
: l r r r r r r
Kind of mistake, Prose, Word, Syllable, First Order, Zero Order, Total
Omission, 19 (21), 11 (23), 24 (&z;36), 15 (46), 34 (&z;82), 103 (208)
Response, 19 (25), 31 (38), 27 (&z;53), 32 (43), 108 (113), 217 (272)
Reading, 3 (&z;2), 2 (&z;0),  8 (&z;15), 14 (20), 20 (&z;41), 47 (&z;78)
Context, 19 (27), 19 (17), 34 (&z;30), 56 (51), 46 (&z;40), 174 (165)
Random, 3 (&z;5), 2 (&z;6), 4 (&z;11), 13 (15), 22 (&z;41), 44 (&z;78)
Total, 63 (80), 65 (84), 97 (145), 130 (175), 230 (317), 585 (801)
<caption>
Distribution of mistakes for each kind of text.  Unparenthesized
values are for subjects making fewer than 2.5% mistakes, and
parenthesized values for subjects making 2.5% or more mistakes.
Omission&emdash; failing to type a letter; response&emdash; hitting
a key adjacent to the correct one; reading&emdash; mistakes were
those letters that are confusable visually or acoustically; context
&emdash; transpositions of adjacent letters and displacements of
letters appearing within a range of three letters left or right of
the mistake position; random&emdash; everything else.  When a
mistake could be assigned to more than one category, the category
appearing nearer the top of the table was chosen.  Adapted from Shaffer <book
Shaffer_68>.
</caption>
.E_TABLE


.TABLE shaffer68b
: l r r 0.5cm l r r
 , Syllable, Random, , , First Order, Zero Order
5-letter, 246, 326, , Fixed, 236, 344
15-letter, 292, 373, , Random, 242, 343
<caption>
Mean response time per letter (in milliseconds).  Right half of the
table shows mean response times for the same subjects with comparable
passages in the first experiment.  Adapted from Shaffer <book
Shaffer_68>.
</caption>
.E_TABLE


.FIG
idonline
<caption>
Number of physical lines containing the given number of identifiers,
based on the visible form of the <file>.c</file> files.
</caption>
.E_FIG


<A NAME="787">2</A>
C99

The initial character shall not be a universal character name
designating a digit.


.TABLE
: l l l l
Encoding Range, Language, Encoding Range, Language
0030&endash;0039, ISO Latin-1,                 0BE7&endash;0BEF, Tamil (has no zero)
0660&endash;0669, Arabic&endash; Indic,         0C66&endash;0C6F, Telugu
06F0&endash;06F9, Eastern Arabic&endash; Indic, 0CE6&endash;0CEF, Kannada
0966&endash;096F, Devanagari,                  0D66&endash;0D6F, Malayalam
09E6&endash;09EF, Bengali,                     0E50&endash;0E59, Thai
0A66&endash;0A6F, Gurmukhi,                    0ED0&endash;0ED9, Lao
0AE6&endash;0AEF, Gujarati,                    FF10&endash; FF19, Fullwidth
0B66&endash;0B6F, Oriya digits, , 
<caption>
The Unicode digit encodings.
</caption>
.E_TABLE


<A NAME="796">3</A>
C99

The number of significant characters in an identifier is
implementation-defined.


.FIG
idsignif
<caption>
Occurrence of unique identifiers whose significant characters match
those of a different identifier (as a percentage of all unique
identifiers in a program), for various numbers of significant
characters.  Based on the visible form of the <file>.c</file> files.
</caption>
.E_FIG


<A NAME="812">7</A>
C99 {ref constant, syntax}

.ASIS
<c_syntax>constant:
                integer-constant
                floating-constant
                enumeration-constant
                character-constant</c_syntax>
.E_ASIS


.TABLE constant
: l r r
Kind of Constant, <file>.c</file> files, <file>.h</file> files
<c_syntax>character-constant</c_syntax>, &z2p;0.16&ze;, &z2p;0.06&ze;
<c_syntax>integer-constant</c_syntax>, &z2p;6.70&ze;, &z2p;20.79&ze;
<c_syntax>floating-constant</c_syntax>, &z2p;0.02&ze;, &z2p;0.20&ze;
<c_syntax>string-literal</c_syntax>, &z2p;1.02&ze;, &z2p;0.74&ze;
<caption>
Occurrence of different kinds of constants (as a percentage of all
tokens).  Based on the visible form of the <file>.c</file> and
<file>.h</file> files.
</caption>
.E_TABLE


<A NAME="815">2</A>
C99 {ref integer constant, syntax}

.ASIS
<c_syntax>integer-constant:
                decimal-constant integer-suffix<sub>opt</sub>
                octal-constant integer-suffix<sub>opt</sub>
                hexadecimal-constant integer-suffix<sub>opt</sub>

decimal-constant:
                nonzero-digit
                decimal-constant digit

octal-constant:
                <keyword>0</keyword>
                octal-constant octal-digit

hexadecimal-constant:
                hexadecimal-prefix hexadecimal-digit
                hexadecimal-constant hexadecimal-digit

hexadecimal-prefix:</c_syntax> one of
                <keyword>0x  0X</keyword>

<c_syntax>nonzero-digit:</c_syntax> one of
                <keyword>1  2  3  4  5  6  7  8  9</keyword>

<c_syntax>octal-digit:</c_syntax> one of
                <keyword>0  1  2  3  4  5  6  7</keyword>

<c_syntax>hexadecimal-digit:</c_syntax> one of
                <keyword>0  1  2  3  4  5  6  7  8  9
                a  b  c  d  e  f
                A  B  C  D  E  F</keyword>

<c_syntax>integer-suffix:
                unsigned-suffix long-suffix<sub>opt</sub>
                unsigned-suffix long-long-suffix
                long-suffix unsigned-suffix<sub>opt</sub>
                long-long-suffix unsigned-suffix<sub>opt</sub></c_syntax>

<c_syntax>unsigned-suffix:</c_syntax> one of
                <keyword>u  U</keyword>

<c_syntax>long-suffix:</c_syntax> one of
                <keyword>l  L</keyword>

<c_syntax>long-long-suffix:</c_syntax> one of
                <keyword>ll  LL</keyword>
.E_ASIS


.FIG
freqcons
<caption>
Number of integer constants, having the lexical form of a
<c_syntax>decimal-constant</c_syntax> (zero is also included in this
set) or <c_syntax>hexadecimal-constant</c_syntax>, with different
values.  Based on the visible form of the <file>.c</file> and
<file>.h</file> files.
</caption>
.E_FIG


.FIG
benfordint
<caption>
Probability of a <c_syntax>decimal-constant</c_syntax> or
<c_syntax>hexadecimal-constant</c_syntax> starting with a particular
digit; based on <file>.c</file> files.  Dotted lines are the
probabilities predicted by Benford's law (for values expressed in
base 10 and base 16)&emdash; <equ>&log;(1+d<sup>-1</sup>)</equ>,
where <equ>d</equ> is the numeric value of the digit.
</caption>
.E_FIG


.TABLE int_cons_kind
: l r r
Kind of <c_syntax>integer-constant</c_syntax>, <file>.c</file> files, h. files
<c_syntax>decimal-constant</c_syntax>, &zp;64.1&ze;, &zp;17.8&ze;
<c_syntax>hexadecimal-constant</c_syntax>, &zp;35.8&ze;, &zp;82.1&ze;
<c_syntax>octal-constant</c_syntax>, &zp;0.1&ze;, &zp;0.2&ze;
<caption>
Occurrence of various kinds of <c_syntax>integer-constant</c_syntax>s
(as a percentage of all integer constants).  Based on the visible form
of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


.TABLE int_suffix
: l r r l r r
Suffix Character Sequence, <file>.c</file> files, h. files, Suffix Character Sequence, <file>.c</file> files, h. files
 none, 99.6850, 99.5997, Lu/lU, 0.0005, 0.0001
 U/u, 0.0298, 0.0198, LL/lL/ll, 0.0072, 0.0022
 L/l, 0.1378, 0.2096, ULL/uLl/ulL/Ull, 0.0128, 0.0061
 U/uL/ul, 0.1269, 0.1625, LLU/lLu/LlU/llu, 0.0000, 0.0000
<caption>
Occurrence of various <c_syntax>integer-suffix</c_syntax> sequences
(as a percentage of all <c_syntax>integer-constants</c_syntax>),
based on the visible form of the <file>.c</file> and <file>.h</file>
files.
</caption>
.E_TABLE


.TABLE int_cons_bigram
: l 2.0cm 2.1cm l 2.0cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
&comma; <c_syntax>integer-constant</c_syntax>, &zp;42.9&ze;, &zp;56.5&ze;, <keyword>(</keyword> <c_syntax>integer-constant</c_syntax>, &zp;2.8&ze;, &zp;3.4&ze;
<c_syntax>integer-constant</c_syntax> <keyword>]</keyword>, &zp;6.4&ze;, &zp;44.4&ze;, <keyword>==</keyword> <c_syntax>integer-constant</c_syntax>, &zp;25.5&ze;, &zp;2.0&ze;
<c_syntax>integer-constant</c_syntax> &comma;, &zp;58.2&ze;, &zp;44.2&ze;, <keyword>return</keyword> <c_syntax>integer-constant</c_syntax>, &zp;18.6&ze;, &zp;1.9&ze;
<c_syntax>integer-constant</c_syntax> <keyword>;</keyword>, &zp;14.1&ze;, &zp;12.1&ze;, <keyword>+</keyword> <c_syntax>integer-constant</c_syntax>, &zp;33.7&ze;, &zp;1.9&ze;
<c_syntax>integer-constant</c_syntax> <keyword>)</keyword>, &zp;14.2&ze;, &zp;11.7&ze;, <keyword>&</keyword> <c_syntax>integer-constant</c_syntax>, &zp;30.6&ze;, &zp;1.5&ze;
<c_syntax>integer-constant</c_syntax> <keyword>#</keyword>, &zp;1.4&ze;, &zp;9.1&ze;, identifier <c_syntax>integer-constant</c_syntax>, &zp;0.3&ze;, &zp;1.5&ze;
<keyword>=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;19.6&ze;, &zp;9.0&ze;, <keyword>-</keyword> <c_syntax>integer-constant</c_syntax>, &zp;44.0&ze;, &zp;1.3&ze;
<keyword>[</keyword> <c_syntax>integer-constant</c_syntax>, &zp;39.3&ze;, &zp;5.6&ze;, <keyword><</keyword> <c_syntax>integer-constant</c_syntax>, &zp;40.0&ze;, &zp;1.3&ze;
<c_syntax>integer-constant</c_syntax> <keyword>}</keyword>, &zp;1.2&ze;, &zp;4.4&ze;, <keyword>{</keyword> <c_syntax>integer-constant</c_syntax>, &zp;4.2&ze;, &zp;1.2&ze;
<keyword>-v</keyword> <c_syntax>integer-constant</c_syntax>, &zp;69.0&ze;, &zp;4.1&ze;, , , 
<caption>
Common token pairs involving <c_syntax>integer-constant</c_syntax>s,
based on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="820">3</A>
C99 {ref hexadecimal constant}

A hexadecimal constant consists of the prefix <fixedb>0x</fixedb> or
<fixedb>0X</fixedb> followed by a sequence of the decimal digits and
the letters <fixedb>a</fixedb> (or <fixedb>A</fixedb>) through
<fixedb>f</fixedb> (or <fixedb>F</fixedb>) with values 10 through 15
respectively.


.TABLE hex_num_dig
: r r r r r r r r
Digits, Occurrences, Digits, Occurrences, Digits, Occurrences, Digits, Occurrences
 &zs;0&ze;, &zs;20&ze;, &zs;5&ze;, &zs;3469&ze;, &zs;10&ze;, &zs;36&ze;, &zs;15&ze;, &zs;1&ze;
 &zs;1&ze;, &zs;8107&ze;, &zs;6&ze;, &zs;1677&ze;, &zs;11&ze;, &zs;10&ze;, &zs;16&ze;, &zs;1553&ze;
 &zs;2&ze;, &zs;441166&ze;, &zs;7&ze;, &zs;453&ze;, &zs;12&ze;, &zs;10&ze;,  , 
 &zs;3&ze;, &zs;8592&ze;, &zs;8&ze;, &zs;21627&ze;, &zs;13&ze;, &zs;2&ze;,  , 
 &zs;4&ze;, &zs;255832&ze;, &zs;9&ze;, &zs;76&ze;, &zs;14&ze;, &zs;1&ze;,  , 
<caption>
Occurrence of <c_syntax>hexadecimal-constant</c_syntax>s (as a
percentage of all such constants) containing a given number of
digits.  Based on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="825">1</A>
C99 {ref integer constant, type first in list}

The type of an integer constant is the first of the corresponding
list in which its value can be represented.


.TABLE cons_int_type
: l r r
Type, 16-bit <keyword>int</keyword>, 32-bit <keyword>int</keyword>
<keyword>int</keyword>, &z3p;94.117&ze;, &z3p;99.271&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &z3p;3.493&ze;, &z3p;0.414&ze;
<keyword>long</keyword>, &z3p;1.805&ze;, &z3p;0.118&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, &z3p;0.557&ze;, &z3p;0.138&ze;
other-types, &z3p;0.029&ze;, &z3p;0.059&ze;
<caption>
Occurrence of <c_syntax>integer-constant</c_syntax>s having a
particular type (as a percentage of all such constants; with the type
denoted by any suffix taken into account) when using two possible
representations of the type <keyword>int</keyword> (i.e., 16- and
32-bit).  Based on the visible form of the <file>.c</file> and
<file>.h</file> files.
</caption>
.E_TABLE


<A NAME="826">2</A>
C99 {ref integer constant, possible types}


.TABLE
: l l l
Suffix       ,   Decimal Constant    , Octal or Hexadecimal Constant


none         , <keyword>int</keyword>            , <keyword>int</keyword>
             , <keyword>long int</keyword>       , <keyword>unsigned int</keyword>
             , <keyword>long long int</keyword>  , <keyword>long int</keyword>
             ,                                   , <keyword>unsigned long int</keyword>
             ,                                   , <keyword>long long int</keyword>
             ,                                   , <keyword>unsigned long long int</keyword>

<keyword>u</keyword> or <keyword>U</keyword>  , <keyword>unsigned int</keyword>           , <keyword>unsigned int</keyword>
                                              , <keyword>unsigned long int</keyword>      , <keyword>unsigned long int</keyword>
                                              , <keyword>unsigned long long int</keyword> , <keyword>unsigned long long int</keyword>

<keyword>l</keyword> or <keyword>L</keyword>  , <keyword>long int</keyword>               , <keyword>long int</keyword>
                                              , <keyword>long long int</keyword>          , <keyword>unsigned long int</keyword>
                                              ,                                           , <keyword>long long int</keyword>
                                              ,                                           , <keyword>unsigned long long int</keyword>

Both <keyword>u</keyword> or <keyword>U</keyword> , <keyword>unsigned long int</keyword>      , <keyword>unsigned long int</keyword>
and <keyword>l</keyword> or <keyword>L</keyword>  , <keyword>unsigned long long int</keyword> , <keyword>unsigned long long int</keyword>

<keyword>ll</keyword> or <keyword>LL</keyword>    , <keyword>long long int</keyword>          , <keyword>long long int</keyword>
                                                  ,                                           , <keyword>unsigned long long int</keyword>

Both <keyword>u</keyword> or <keyword>U</keyword>  , <keyword>unsigned long long int</keyword> , <keyword>unsigned long long int</keyword>
and <keyword>ll</keyword> or <keyword>LL</keyword> ,                                           , 
.E_TABLE


.TABLE
: l l l
Suffix   ,   Decimal Constant

none     , <keyword>int</keyword>
         , <keyword>long int</keyword>
         , <keyword>unsigned long int</keyword>

<keyword>l</keyword> or <keyword>L</keyword>   , <keyword>long int</keyword>
         , <keyword>unsigned long int</keyword>
.E_TABLE


<A NAME="831">12</A> FP
C99 {ref floating constant, syntax}

.ASIS
<c_syntax>floating-constant:
                decimal-floating-constant
                hexadecimal-floating-constant

decimal-floating-constant:
                fractional-constant exponent-part<sub>opt</sub> floating-suffix<sub>opt</sub>
                digit-sequence exponent-part floating-suffix<sub>opt</sub>

hexadecimal-floating-constant:
                hexadecimal-prefix hexadecimal-fractional-constant
                                binary-exponent-part floating-suffix<sub>opt</sub>
                hexadecimal-prefix hexadecimal-digit-sequence
                                binary-exponent-part floating-suffix<sub>opt</sub>

fractional-constant:
                digit-sequence<sub>opt</sub></c_syntax> <keyword>.</keyword> <c_syntax>digit-sequence
                digit-sequence</c_syntax> <keyword>.</keyword>

<c_syntax>exponent-part:</c_syntax>
                <keyword>e</keyword> <c_syntax>sign<sub>opt</sub> digit-sequence</c_syntax>
                <keyword>E</keyword> <c_syntax>sign<sub>opt</sub> digit-sequence</c_syntax>

<c_syntax>sign:</c_syntax> one of
                <keyword>+  -</keyword>

<c_syntax>digit-sequence:
                digit
                digit-sequence digit</c_syntax>

<c_syntax>hexadecimal-fractional-constant:
                hexadecimal-digit-sequence<sub>opt</sub></c_syntax> <keyword>.</keyword>
                                <c_syntax>hexadecimal-digit-sequence
                hexadecimal-digit-sequence</c_syntax> <keyword>.</keyword>

<c_syntax>binary-exponent-part:</c_syntax>
                <keyword>p</keyword> <c_syntax>sign<sub>opt</sub> digit-sequence</c_syntax>
                <keyword>P</keyword> <c_syntax>sign<sub>opt</sub> digit-sequence</c_syntax>

<c_syntax>hexadecimal-digit-sequence:
                hexadecimal-digit
                hexadecimal-digit-sequence hexadecimal-digit</c_syntax>

<c_syntax>floating-suffix:</c_syntax> one of
                <keyword>f  l  F  L</keyword>
.E_ASIS


.FIG
benfordflt
<caption>
Probability of a <c_syntax>decimal-floating-constant</c_syntax>
(i.e., not hexadecimal) starting with a particular digit.  Based on
the visible form of the <file>.c</file> files.  Dotted line is the
probability predicted by Benford's law&emdash;
<equ>&log;(1+d<sup>-1</sup>)</equ>, where <equ>d</equ> is the numeric
value of the digit.
</caption>
.E_FIG


.TABLE flt_suffix
: l r r
Suffix Character Sequence, <file>.c</file> files, h. files
none, 98.3963, 99.7554
F/f, 1.4033, 0.1896
L/l, 0.2005, 0.0550
<caption>
Occurrence of various <c_syntax>floating-suffix</c_syntax>es (as a
percentage of all such constants).  Based on the visible form of the
<file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


.TABLE flt_cons_bigram
: l 2.0cm 2.1cm l 2.0cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
&comma; <c_syntax>floating-constant</c_syntax>, &zp;0.0&ze;, &zp;20.4&ze;, <c_syntax>floating-constant</c_syntax> <keyword>/</keyword>, &zp;5.8&ze;, &zp;1.8&ze;
<keyword>=</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.1&ze;, &zp;15.7&ze;, <keyword>*=</keyword> <c_syntax>floating-constant</c_syntax>, &zp;6.3&ze;, &zp;1.6&ze;
<keyword>*</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.2&ze;, &zp;12.5&ze;, <c_syntax>floating-constant</c_syntax> <keyword>*</keyword>, &zp;6.8&ze;, &zp;0.1&ze;
<keyword>(</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.0&ze;, &zp;8.8&ze;, <c_syntax>floating-constant</c_syntax> <keyword>;</keyword>, &zp;26.5&ze;, &zp;0.1&ze;
<keyword>+</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.4&ze;, &zp;7.7&ze;, <c_syntax>floating-constant</c_syntax> <keyword>)</keyword>, &zp;25.9&ze;, &zp;0.1&ze;
<keyword>-v</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.3&ze;, &zp;6.7&ze;, <c_syntax>floating-constant</c_syntax> &comma;, &zp;25.8&ze;, &zp;0.1&ze;
<keyword>/</keyword> <c_syntax>floating-constant</c_syntax>, &zp;2.0&ze;, &zp;6.4&ze;, , , 
<caption>
Common token pairs involving floating constants.  Based on the visible
form of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="833">2</A> FP
C99 {ref whole-number part} {ref fraction part}

The components of the significand part may include a digit sequence
representing the whole-number part, followed by a period
(<keyword>.</keyword>), followed by a digit sequence representing the
fraction part.


.FIG
fltconst
<caption>
Number of digit sequences before and after the decimal point (dp) in
<c_syntax>floating-constant</c_syntax>s that do not contain an
exponent part, and the total number of digit in a
<c_syntax>floating-constant</c_syntax>.  Based on the visible form of
the <file>.c</file> and <file>.h</file> files.
</caption>
.E_FIG


<A NAME="841">5</A> FP
C99 {ref floating constant, representable value chosen}

For decimal floating constants, and also for hexadecimal floating
constants when <fixedb>FLT_RADIX</fixedb> is not a power of 2, the
result is either the nearest representable value, or the larger or
smaller representable value immediately adjacent to the nearest
representable value, chosen in an implementation-defined manner.


.FIG
repvalu
<caption>
The nearest representable value to <equ>X</equ> is <equ>b</equ>,
however, its value may also be rounded to <equ>a</equ> or
<equ>c</equ>.  In the case of <equ>Y</equ>, while <equ>d</equ> is the
nearest representable value the result may be rounded to <equ>c</equ>
or <equ>e</equ>.
</caption>
.E_FIG


<A NAME="855">3</A>
C99 {ref character constant, syntax} {ref escape sequence, syntax}

.ASIS
<c_syntax>character-constant:</c_syntax>
                <keyword>'</keyword> <c_syntax>c-char-sequence</c_syntax> <keyword>'</keyword>
                <keyword>L'</keyword> <c_syntax>c-char-sequence</c_syntax> <keyword>'</keyword>

<c_syntax>c-char-sequence:
                c-char
                c-char-sequence c-char</c_syntax>

<c_syntax>c-char:</c_syntax>
                any member of the source character set except
                       the single-quote <keyword>'</keyword>, backslash <keyword>\</keyword>, or new-line character
                <c_syntax>escape-sequence</c_syntax>

<c_syntax>escape-sequence:
                simple-escape-sequence
                octal-escape-sequence
                hexadecimal-escape-sequence
                universal-character-name</c_syntax>

<c_syntax>simple-escape-sequence:</c_syntax> one of
                <keyword>\'  \"  \?  \\
                \a  \b  \f  \n  \r  \t  \v</keyword>

<c_syntax>octal-escape-sequence:</c_syntax>
                <keyword>\</keyword> <c_syntax>octal-digit</c_syntax>
                <keyword>\</keyword> <c_syntax>octal-digit octal-digit</c_syntax>
                <keyword>\</keyword> <c_syntax>octal-digit octal-digit octal-digit</c_syntax>

<c_syntax>hexadecimal-escape-sequence:</c_syntax>
                <keyword>\x</keyword> <c_syntax>hexadecimal-digit
                hexadecimal-escape-sequence hexadecimal-digit</c_syntax>
.E_ASIS


.TABLE char_cons_kind
: l r
Kind of <c_syntax>character-constant</c_syntax>, % of all <c_syntax>character-constant</c_syntax>s
not an escape sequence, &zp;76.1&ze;
<c_syntax>simple-escape-sequence</c_syntax>, &zp;8.8&ze;
<c_syntax>octal-escape-sequence</c_syntax>, &zp;15.1&ze;
<c_syntax>hexadecimal-escape-sequence</c_syntax>, &zp;0.0&ze;
<c_syntax>universal-character-name</c_syntax>, &zp;0.0&ze;
<caption>
Occurrence of various kinds of <c_syntax>character-constant</c_syntax>
(as a percentage of all such constants).  Based on the visible form
of the <file>.c</file> files.
</caption>
.E_TABLE


.TABLE escape_seq
: 1.3cm 2.6cm 2.5cm 1.3cm 2.6cm 2.5cm
Escape Sequence, % of <c_syntax>character-constant</c_syntax> Escape Sequences, % of <c_syntax>string-literal</c_syntax> escape sequences, Escape sequence, % of <c_syntax>character-constant</c_syntax> Escape Sequences, % of <c_syntax>string-literal</c_syntax> Escape Sequences
 \n, &z2p;18.10&ze;, &z2p;79.15&ze;, \b, &z2p;0.66&ze;, &z2p;0.04&ze;
 \t, &z2p;3.90&ze;, &z2p;11.62&ze;, \', &z2p;3.24&ze;, &z2p;0.02&ze;
 \", &z2p;1.29&ze;, &z2p;3.08&ze;, \%, &z2p;0.00&ze;, &z2p;0.02&ze;
 \0, &z2p;52.70&ze;, &z2p;2.06&ze;, \v, &z2p;0.31&ze;, &z2p;0.01&ze;
 \x, &z2p;0.12&ze;, &z2p;1.10&ze;, \p, &z2p;0.00&ze;, &z2p;0.01&ze;
 \2, &z2p;2.73&ze;, &z2p;1.01&ze;, \f, &z2p;0.44&ze;, &z2p;0.01&ze;
 \\, &z2p;5.70&ze;, &z2p;0.61&ze;, \?, &z2p;0.01&ze;, &z2p;0.01&ze;
 \r, &z2p;3.01&ze;, &z2p;0.46&ze;, \e, &z2p;0.00&ze;, &z2p;0.00&ze;
 \3, &z2p;4.95&ze;, &z2p;0.42&ze;, \a, &z2p;0.11&ze;, &z2p;0.00&ze;
 \1, &z2p;2.72&ze;, &z2p;0.35&ze;,  , , 
<caption>
Occurrence of <c_syntax>escape-sequence</c_syntax>s within
<c_syntax>character-constant</c_syntax>s and
<c_syntax>string-literal</c_syntax>s (as a percentage of
<c_syntax>escape-sequence</c_syntax>s for that kind of token).  Based
on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


.TABLE cchar_bigram
: l 2.0cm 2.1cm l 2.0cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
<keyword>==</keyword> <c_syntax>character-constant</c_syntax>, &zp;7.1&ze;, &zp;22.8&ze;, <c_syntax>character-constant</c_syntax> <keyword>||</keyword>, &zp;4.2&ze;, &zp;4.2&ze;
&comma; <c_syntax>character-constant</c_syntax>, &zp;0.3&ze;, &zp;18.1&ze;, <c_syntax>character-constant</c_syntax> <keyword>&&</keyword>, &zp;5.3&ze;, &zp;3.3&ze;
<keyword>case</keyword> <c_syntax>character-constant</c_syntax>, &zp;8.5&ze;, &zp;16.7&ze;, <keyword><=</keyword> <c_syntax>character-constant</c_syntax>, &zp;7.1&ze;, &zp;1.7&ze;
<keyword>=</keyword> <c_syntax>character-constant</c_syntax>, &zp;0.8&ze;, &zp;14.2&ze;, <keyword>>=</keyword> <c_syntax>character-constant</c_syntax>, &zp;3.6&ze;, &zp;1.5&ze;
<keyword>!=</keyword> <c_syntax>character-constant</c_syntax>, &zp;5.3&ze;, &zp;8.4&ze;, <c_syntax>character-constant</c_syntax> <keyword>)</keyword>, &zp;33.0&ze;, &zp;0.7&ze;
<keyword>(</keyword> <c_syntax>character-constant</c_syntax>, &zp;0.1&ze;, &zp;6.1&ze;, <c_syntax>character-constant</c_syntax> &comma;, &zp;17.6&ze;, &zp;0.3&ze;
<c_syntax>character-constant</c_syntax> <keyword>:</keyword>, &zp;16.7&ze;, &zp;6.0&ze;, <c_syntax>character-constant</c_syntax> <keyword>;</keyword>, &zp;16.6&ze;, &zp;0.3&ze;
<caption>
Common token pairs involving
<c_syntax>character-constant</c_syntax>s.  Based on the visible form
of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="873">2</A>
C99 {ref character constant, value}

The value of an integer character constant containing a single
character that maps to a single-byte execution character is the
numerical value of the representation of the mapped character
interpreted as an integer.


.FIG
ccharc
<caption>
Occurrence of characters in an integer
<c_syntax>character-constant</c_syntax> (as a fraction of the most
common character, the null character).  Based on the visible form of
the <file>.c</file> files.
</caption>
.E_FIG


.TABLE cchar_op
: l r
Operator, %
Arithmetic operators, &zp;4.5&ze;
Bit operators, &zp;0.5&ze;
Equality operators, &zp;31.3&ze;
Relational operators, &zp;4.1&ze;
<caption>
Occurrence of a <c_syntax>character-constant</c_syntax> appearing as
one of the operands of binary operators (as a percentage of all such
constants).  Based on the visible form of the <file>.c</file> files.
See <tableref href="cchar_bigram"/> for more detailed information.
</caption>
.E_TABLE


<A NAME="874">3</A>
C99 {ref character constant, more than one character}

The value of an integer character constant containing more than one
character (e.g., <fixedb>'ab'</fixedb>), or containing a character or
escape sequence that does not map to a single-byte execution
character, is implementation-defined.


.TABLE cchar_len
: c r c r
Number of Characters, Occurrences, Number of Characters, Occurrences
 &zs;0&ze;, &zs;27&ze;, &zs;4&ze;, &zs;21&ze;
 &zs;1&ze;, &zs;50590&ze;, &zs;5&ze;, &zs;4&ze;
 &zs;2&ze;, &zs;0&ze;, &zs;6&ze;, &zs;4&ze;
 &zs;3&ze;, &zs;8&ze;, &zs;7&ze;, &zs;0&ze;
<caption>
Number of <c_syntax>character-constant</c_syntax>s containing a
given number of characters.  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_TABLE


<A NAME="897">1</A>
C99 {ref string literal, distinct array}

It is unspecified whether these arrays are distinct provided their
elements have the appropriate values.


.TABLE str_lit_info
: l r r r r r r r r
String Literals, gcc, idsoftware, linux, netscape, openafs, openMotif, postgresql, Total
Number of strings, &zs;38063&ze;, &zs;21811&ze;, &zs;177224&ze;, &zs;30358&ze;, &zs;30574&ze;, &zs;11285&ze;, &zs;16387&ze;, &zs;325702&ze;
Bytes in strings, &zs;656366&ze;, &zs;324667&ze;, &zs;4050258&ze;, &zs;512766&ze;, &zs;737015&ze;, &zs;288018&ze;, &zs;298888&ze;, &zs;6867978&ze;
Number of unique strings, &zs;18602&ze;, &zs;9148&ze;, &zs;114170&ze;, &zs;17192&ze;, &zs;18483&ze;, &zs;7401&ze;, &zs;7930&ze;, &zs;187549&ze;
Bytes in unique strings, &zs;434028&ze;, &zs;170170&ze;, &zs;3189466&ze;, &zs;378917&ze;, &zs;562555&ze;, &zs;240811&ze;, &zs;219690&ze;, &zs;5159385&ze;
<caption>
Number of <c_syntax>string-literal</c_syntax>s (the empty
<c_syntax>string-literal</c_syntax>, i.e., <c_code>""</c_code>, was
not counted).  Based on the visible form of the <file>.c</file> and
<file>.h</file> files.  Although many of the program source trees
contain more than one program, they were treated as a single entity.
A consequence of this is that the number of unique matches represents
a lower bound; having a smaller number of string literals is likely
to reduce the probability of matches occurring.
</caption>
.E_TABLE


<A NAME="901">3</A>
C99 {ref punctuator, syntax}

.ASIS
<c_syntax>punctuator:</c_syntax> one of
                <keyword>[  ]  (  )  {  }  .  ->
                ++  --  &  *  +  -  ~  !
                /  %  <<  >>  <  >  <=  >=  ==  !=  ^  | &&  ||
                ?  :  ;  ...
                =  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=
                ,  #  ##
                <:  :>  <%  %>  %:  %:%:</keyword>
.E_ASIS


.TABLE punct_terms
: 1.2cm 4.5cm 1.2cm 4.5cm
Punctuator/ Operator, Term, Punctuator/ Operator, Term
<keyword>[</keyword> <keyword>]</keyword>, left square bracket or opening square bracket or bracket, <keyword>^</keyword>, circumflex or xor or exclusive <phrase>or</phrase>
<keyword>(</keyword> <keyword>)</keyword>, left round bracket or opening round bracket or bracket or parenthesis, <keyword>|</keyword>, vertical bar or bitwise <phrase>or</phrase> or <phrase>or</phrase>
<keyword>{</keyword> <keyword>}</keyword>, left curly bracket or opening curly bracket or bracket or brace, <keyword>&&</keyword>, and and or logical and
<keyword>.</keyword>, dot or period or full stop or dot selection, <keyword>||</keyword>,  logical <phrase>or</phrase> or <phrase>or</phrase>
<keyword>-></keyword>, indirect or indirect selection, <keyword>?</keyword>, question mark
<keyword>*</keyword>, times or star or dereference or asterisk, <keyword>:</keyword>, colon
<keyword>+</keyword>, plus, <keyword>;</keyword>, semicolon
<keyword>-</keyword>, minus or subtract, <keyword>...</keyword>, dot dot dot or ellipsis
<keyword>~</keyword>, tilde or bitwise not, <keyword>=</keyword>, equal or assign
<keyword>!</keyword>, exclamation or shriek, <keyword>*=</keyword>, times equal
<keyword>++</keyword>, plus plus, <keyword>/=</keyword>, divide equal
<keyword>--</keyword>, minus minus, <keyword>%=</keyword>, percent equal or remainder equal
<keyword>&</keyword>, and or address of or ampersand or bitwise-and, <keyword>+=</keyword>, plus equal
<keyword>/</keyword>, slash or divide or solidus, <keyword>-=</keyword>, minus equal
<keyword>%</keyword>, remainder or percent, <keyword><<=</keyword>, left-shift equal
<keyword><<</keyword>, left-shift, <keyword>>>=</keyword>, right-shift equal
<keyword>>></keyword>, right-shift, <keyword>&=</keyword>, and equal
<keyword><</keyword>, less than, <keyword>^=</keyword>, xor equal or exclusive or equal
<keyword>></keyword>, greater than, <keyword>|=</keyword>, or equal
<keyword><=</keyword>, less than or equal, <keyword>&comma;</keyword>, comma
<keyword>>=</keyword>, greater than or equal, <keyword>#</keyword>, hash or sharp or pound
<keyword>==</keyword>, equal, <keyword>##</keyword>, hash hash or sharp sharp or pound pound
<keyword>!=</keyword>, not equal, <keyword><:</keyword>  <keyword>:></keyword>  <keyword><%</keyword>  <keyword>%></keyword>  <keyword>%:</keyword>  <keyword>%:%:</keyword>, no commonly used terms
<caption>
Commonly used terms for punctuators and operators.
</caption>
.E_TABLE


.TABLE punct_freq
Punctuator, % of Tokens, Punctuator, % of Tokens, Punctuator, % of Tokens, Punctuator, % of Tokens
&comma;, &z2p;8.82&ze;, <keyword>:</keyword>, &z2p;0.46&ze;, <keyword>></keyword>, &z2p;0.11&ze;, <keyword>--v</keyword>, &z2p;0.01&ze;
<keyword>)</keyword>, &z2p;8.09&ze;, <keyword>-v</keyword>, &z2p;0.40&ze;, <keyword><<</keyword>, &z2p;0.09&ze;, <keyword>...</keyword>, &z2p;0.01&ze;
<keyword>(</keyword>, &z2p;8.09&ze;, <keyword>*p</keyword>, &z2p;0.40&ze;, <keyword>?:</keyword>, &z2p;0.08&ze;, <keyword>>>=</keyword>, &z2p;0.01&ze;
<keyword>;</keyword>, &z2p;7.80&ze;, <keyword>+</keyword>, &z2p;0.38&ze;, <keyword>?</keyword>, &z2p;0.08&ze;, <keyword>^</keyword>, &z2p;0.01&ze;
<keyword>=</keyword>, &z2p;3.08&ze;, <keyword>*v</keyword>, &z2p;0.34&ze;, <keyword>|=</keyword>, &z2p;0.08&ze;, <keyword>+v</keyword>, &z2p;0.00&ze;
<keyword>-></keyword>, &z2p;3.00&ze;, <keyword>&</keyword>, &z2p;0.32&ze;, <keyword>>=</keyword>, &z2p;0.07&ze;, <keyword>:b</keyword>, &z2p;0.00&ze;
<keyword>}</keyword>, &z2p;1.87&ze;, <keyword>!</keyword>, &z2p;0.31&ze;, <keyword>/</keyword>, &z2p;0.06&ze;, <keyword>%=</keyword>, &z2p;0.00&ze;
<keyword>{</keyword>, &z2p;1.87&ze;, <keyword>v++</keyword>, &z2p;0.27&ze;, <keyword>>></keyword>, &z2p;0.06&ze;, <keyword>##</keyword>, &z2p;0.00&ze;
<keyword>.</keyword>, &z2p;1.26&ze;, <keyword>&&</keyword>, &z2p;0.26&ze;, <keyword>~</keyword>, &z2p;0.05&ze;, <keyword>*=</keyword>, &z2p;0.00&ze;
<keyword>*</keyword>, &z2p;1.10&ze;, <keyword>!=</keyword>, &z2p;0.26&ze;, <keyword>v--</keyword>, &z2p;0.04&ze;, <keyword>/=</keyword>, &z2p;0.00&ze;
<keyword>#</keyword>, &z2p;1.00&ze;, <keyword><</keyword>, &z2p;0.22&ze;, <keyword>&=</keyword>, &z2p;0.04&ze;, <keyword><<=</keyword>, &z2p;0.00&ze;
<keyword>]</keyword>, &z2p;0.96&ze;, <keyword>-</keyword>, &z2p;0.19&ze;, <keyword><=</keyword>, &z2p;0.04&ze;, <keyword>^=</keyword>, &z2p;0.00&ze;
<keyword>[</keyword>, &z2p;0.96&ze;, <keyword>|</keyword>, &z2p;0.17&ze;, <keyword>-=</keyword>, &z2p;0.03&ze;, , 
<keyword>&v</keyword>, &z2p;0.58&ze;, <keyword>||</keyword>, &z2p;0.16&ze;, <keyword>++v</keyword>, &z2p;0.02&ze;, , 
<keyword>==</keyword>, &z2p;0.53&ze;, <keyword>+=</keyword>, &z2p;0.11&ze;, <keyword>%</keyword>, &z2p;0.02&ze;, , 
<caption>
Occurrence of <c_syntax>punctuator</c_syntax> tokens (as a percentage
of all tokens; multiply by 1.88 to express occurrence as a percentage
of all punctuator tokens).  Based on the visible form of the
<file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


<A NAME="921">3</A>
C99 {ref footnote, 68}

68) Thus, sequences of characters that resemble escape sequences
cause undefined behavior.


.TABLE
Style of Comment, Example
Item name&emdash; Definition, MaxLength&emdash; Maximum CFG Depth.
Definition, Maximum CFG Depth.
Unattached prepositional phrase, To support scrolling text.
Value definitions, 0 = not selected&comma; 1 = is selected.
Mathematical formulas,  Can be Boolean expressions...
<caption>
Common formats of nonsentence style comments.
Adapted from Etzkorn, Bowen, and Davis <book Etzkorn_99>.
</caption>
.E_TABLE


.TABLE
: r l l
Percentage, Style of Sentence, Example
51, Operational description, This routine reads the data.  Then it opens the file.
44, Definition, General Matrix&emdash; rectangular matrix class.
2, Description of definition, This defines a NIL value for a list.
3, Instructions to reader, See the header at the top of the file.
<caption>
Breakdown of comments containing parsable sentences.
Adapted from Etzkorn, Bowen, and Davis <book Etzkorn_99>.
</caption>
.E_TABLE


.TABLE
: 4cm 2cm l
Part of Speech, Percentage, Example
Present Tense, 75, 
Indicative mood&comma; active voice, , This routine reads the data.
Indicative mood&comma; active voice&comma; missing subject, , Reads the data.
Imperative mood&comma; active voice, , Read the data.
Indicative mood&comma; passive voice, , This is done by reading the data.
Indicative mood&comma; passive voice&comma; missing subject, , Is done by reading the data.

Past Tense, 4, 
Indicative mood&comma; either active or passive voice&comma; occasional missing subject, , This routine opened the file. or Opened the file.

Future Tense, 4, 
Indicative mood&comma; either active or passive voice&comma; occasional missing subject, , This routine will open the file. or Will open the file.

Other, 15, 
<caption>
Common formats of sentence-style comments.
Adapted from Etzkorn, Bowen, and Davis <book Etzkorn_99>.
</caption>
.E_TABLE


<A NAME="922">1</A>
C99 {ref comment, /*}

Except within a character constant, a string literal, or a comment,
the characters <fixedb>/*</fixedb> introduce a comment.


.TABLE starplus_sent
Statement Relative to Fact, Example
true-affirmative (TA), star is above plus: &soverp;
false-affirmative (FA), plus is above star: &povers;
false-negative (FN), star isn't above plus: &soverp;
true-negative (TN), plus isn't above star: &soverp;
<caption>
Four types of questions.
</caption>
.E_TABLE


.TABLE comment_info
: l r r
Kind of Comment, <file>.c</file> files, <file>.h</file> files
/* comment */, &zp;91.0&ze;, &zp;90.1&ze;
// comment, &zp;9.0&ze;, &zp;9.9&ze;
/* on one line */, &zp;70.3&ze;, &zp;79.1&ze;
new-lines in /* comments, &zp;12.3&ze;, &zp;17.5&ze;
<caption>
Occurrence of kinds of comments (as a percentage of all comments; last
row as a percentage of all new-line characters).  Based on the visible
form of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


<A NAME="928">1</A>
C99 {ref expressions}

An <c_syntax>expression</c_syntax> is a sequence of operators and operands that
specifies computation of a value, or that designates an object or a
function, or that generates side effects, or that performs a
combination thereof.


.FIG
shufps
<caption>
The <c_code>SHUFPS</c_code> (shuffle packed single-precision
floating-point values) instruction, supported by the Intel Pentium
processor <book Intel_IA32_00>, places any two of the four packed
floating-point values from the destination operand into the two
low-order doublewords of the destination operand, and places any two
of the four packed floating-point values from the source operand into
the two high-order doublewords of the destination operand.  By using
the same register for the source and destination operands, the
<c_code>SHUFPS</c_code> instruction can shuffle four single-precision
floating-point values into any order. 
</caption>
.E_FIG


.FIG
miller64
<caption>
Parse tree of a sentence with no embedding (S 1) and a sentence with
four degrees of embedding (S 2).
Adapted from Miller and Isard <book Miller_64>.
</caption>
.E_FIG


.TABLE token_eol
: l 1.9cm 1.8cm l 1.9cm 1.8cm
Token, % Occurrence of Token, % Last Token on Line, Token, % Occurrence of Token, % Last Token on Line
<keyword>;</keyword>, &zp;92.2&ze;, &zp;36.0&ze;, <keyword>#else</keyword>, &zp;89.1&ze;, &zp;0.2&ze;
\* <keyword>...</keyword> *\, &zp;97.9&ze;, &zp;8.4&ze;, <keyword>int</keyword>, &zp;5.3&ze;, &zp;0.2&ze;
<keyword>)</keyword>, &zp;20.6&ze;, &zp;8.3&ze;, <keyword>||</keyword>, &zp;23.7&ze;, &zp;0.2&ze;
<keyword>{</keyword>, &zp;86.7&ze;, &zp;8.1&ze;, <keyword>|</keyword>, &zp;12.3&ze;, &zp;0.1&ze;
<keyword>}</keyword>, &zp;78.9&ze;, &zp;7.4&ze;, <keyword>+</keyword>, &zp;3.8&ze;, &zp;0.1&ze;
&comma;, &zp;13.9&ze;, &zp;6.1&ze;, <keyword>?:</keyword>, &zp;7.3&ze;, &zp;0.0&ze;
<keyword>:</keyword>, &zp;74.3&ze;, &zp;1.7&ze;, <keyword>?</keyword>, &zp;7.1&ze;, &zp;0.0&ze;
header-name, &zp;97.7&ze;, &zp;1.5&ze;, <keyword>do</keyword>, &zp;21.3&ze;, &zp;0.0&ze;
\\, &zp;100.0&ze;, &zp;0.9&ze;, <keyword>#error</keyword>, &zp;25.1&ze;, &zp;0.0&ze;
<keyword>#endif</keyword>, &zp;81.9&ze;, &zp;0.8&ze;, <keyword>:b</keyword>, &zp;7.2&ze;, &zp;0.0&ze;
<keyword>else</keyword>, &zp;42.2&ze;, &zp;0.7&ze;, <keyword>double</keyword>, &zp;3.1&ze;, &zp;0.0&ze;
<c_syntax>string-literal</c_syntax>, &zp;8.0&ze;, &zp;0.4&ze;, <keyword>^</keyword>, &zp;3.1&ze;, &zp;0.0&ze;
<keyword>void</keyword>, &zp;18.2&ze;, &zp;0.4&ze;, <keyword>union</keyword>, &zp;6.2&ze;, &zp;0.0&ze;
<keyword>&&</keyword>, &zp;17.8&ze;, &zp;0.2&ze;, , , 
<caption>
Occurrence of a token as the last token on a line (as a percentage of
that kind of token and as a percentage of all lines).  Based on the
visible form of the <file>.c</file> files.
</caption>
.E_TABLE


.TABLE sol_token
: l 1.8cm 1.9cm l 1.8cm 1.9cm
Token, % First Token on Line, % Occurrence of Token, Token, % First Token on Line, % Occurrence of Token
<keyword>default</keyword>, &zp;0.2&ze;, &zp;99.9&ze;, <keyword>volatile</keyword>, &zp;0.0&ze;, &zp;50.0&ze;
<keyword>#</keyword>, &zp;5.0&ze;, &zp;99.9&ze;, <keyword>int</keyword>, &zp;1.8&ze;, &zp;47.0&ze;
<keyword>typedef</keyword>, &zp;0.1&ze;, &zp;99.8&ze;, <keyword>unsigned</keyword>, &zp;0.7&ze;, &zp;46.8&ze;
<keyword>static</keyword>, &zp;2.1&ze;, &zp;99.8&ze;, <keyword>struct</keyword>, &zp;1.1&ze;, &zp;38.9&ze;
<keyword>for</keyword>, &zp;0.8&ze;, &zp;99.7&ze;, <keyword>const</keyword>, &zp;0.1&ze;, &zp;35.5&ze;
<keyword>extern</keyword>, &zp;0.2&ze;, &zp;99.6&ze;, <keyword>char</keyword>, &zp;0.5&ze;, &zp;30.5&ze;
<keyword>switch</keyword>, &zp;0.3&ze;, &zp;99.4&ze;, <keyword>void</keyword>, &zp;0.6&ze;, &zp;28.7&ze;
<keyword>case</keyword>, &zp;1.6&ze;, &zp;97.8&ze;, <keyword>*v</keyword>, &zp;0.5&ze;, &zp;28.7&ze;
\* new-line *\, &zp;13.7&ze;, &zp;97.7&ze;, <keyword>++v</keyword>, &zp;0.0&ze;, &zp;27.8&ze;
<keyword>register</keyword>, &zp;0.2&ze;, &zp;95.0&ze;, <keyword>signed</keyword>, &zp;0.0&ze;, &zp;27.2&ze;
<keyword>return</keyword>, &zp;3.3&ze;, &zp;94.5&ze;, <keyword>&&</keyword>, &zp;0.3&ze;, &zp;21.2&ze;
<keyword>goto</keyword>, &zp;0.4&ze;, &zp;94.1&ze;, identifier, &zp;31.1&ze;, &zp;20.8&ze;
<keyword>if</keyword>, &zp;6.9&ze;, &zp;93.6&ze;, <keyword>||</keyword>, &zp;0.2&ze;, &zp;18.4&ze;
<keyword>break</keyword>, &zp;1.2&ze;, &zp;91.8&ze;, <keyword>--v</keyword>, &zp;0.0&ze;, &zp;17.9&ze;
<keyword>continue</keyword>, &zp;0.2&ze;, &zp;91.3&ze;, <keyword>short</keyword>, &zp;0.0&ze;, &zp;16.0&ze;
<keyword>}</keyword>, &zp;8.3&ze;, &zp;88.3&ze;, <keyword>#error</keyword>, &zp;0.0&ze;, &zp;15.6&ze;
<keyword>do</keyword>, &zp;0.1&ze;, &zp;87.3&ze;, <c_syntax>string-literal</c_syntax>, &zp;0.6&ze;, &zp;12.4&ze;
<keyword>while</keyword>, &zp;0.4&ze;, &zp;85.2&ze;, <keyword>sizeof</keyword>, &zp;0.1&ze;, &zp;11.3&ze;
<keyword>enum</keyword>, &zp;0.1&ze;, &zp;73.7&ze;, <keyword>long</keyword>, &zp;0.1&ze;, &zp;10.1&ze;
\\, &zp;0.6&ze;, &zp;70.8&ze;, <c_syntax>integer-constant</c_syntax>, &zp;2.2&ze;, &zp;6.6&ze;
<keyword>else</keyword>, &zp;1.1&ze;, &zp;70.2&ze;, <keyword>?</keyword>, &zp;0.0&ze;, &zp;5.6&ze;
<keyword>union</keyword>, &zp;0.0&ze;, &zp;63.3&ze;, <keyword>&v</keyword>, &zp;0.1&ze;, &zp;5.2&ze;
\* <keyword>...</keyword> *\, &zp;5.4&ze;, &zp;62.6&ze;, <keyword>-v</keyword>, &zp;0.1&ze;, &zp;5.0&ze;
<keyword>{</keyword>, &zp;5.1&ze;, &zp;54.9&ze;, <keyword>?:</keyword>, &zp;0.0&ze;, &zp;5.0&ze;
<keyword>float</keyword>, &zp;0.0&ze;, &zp;54.0&ze;, <keyword>|</keyword>, &zp;0.0&ze;, &zp;4.2&ze;
<keyword>double</keyword>, &zp;0.0&ze;, &zp;53.6&ze;, <c_syntax>floating-constant</c_syntax>, &zp;0.0&ze;, &zp;4.1&ze;
<caption>
Occurrence of a token as the first token on a physical line (as a
percentage of all occurrences of that token and as a percentage of
all lines).  Based on the visible form of the <file>.c</file> files.
<phrase>/* new-line */</phrase> denotes a comment containing one or
more new-line characters, while <phrase>/* ... */</phrase> denotes
that form of comment on a single line.
</caption>
.E_TABLE


.TABLE obj_val_bits
: r r c
Bits, Objects Defined, Objects Requiring Specified Bits
1,    0, 203
8,    7, 134
16,  27, 108
32, 686, 275
<caption>
Number of objects defined (in a variety of small multimedia and
scientific programs) to have types represented using the given number
of bits (i.e., mostly 32-bit <keyword>int</keyword>) and number of
objects having a maximum bit-width usage (i.e., number of bits
required to represent any of the values stored in the object; rounded
up to the nearest byte boundary).  Adapted from Stephenson <book
Stephenson_00>, whose analysis was performed by static analysis of
the source.
</caption>
.E_TABLE


.TABLE
: l r r r r r r r r r r r r r
Program,     ILd,     FLd,    LdA,     St,   IMul,    FMul,   FDiv,  IArth,   FArth,    Cmp,   Shft,  CMov,   FOps
compress, 44(27),   0(0), 88(&z;2), 16(&z;9), 15(0),   0(0),  0(0), 11(36),   0(0), 92(2), 14( 9),  0(0),   0(0)
gcc,      46(24),  83(0), 59(&z;9), 48(11), 40(0),  30(0), 31(0), 46(28),   0(0), 87(3), 54(&z;7), 51(1),  95(0)
go,       36(30), 100(0), 71(13), 35(&z;8), 18(0), 100(0),  0(0), 29(31),   0(0), 73(4), 42(&z;0), 52(1), 100(0)
ijpeg,    19(18),  73(0),  9(11), 20(&z;5), 10(1),  68(0),  0(0), 15(37),   0(0), 96(2), 17(21), 15(0),  98(0)
li,       40(30), 100(0), 27(&z;8), 42(15), 30(0),  13(0),  0(0), 56(22),   0(0), 93(2), 79(&z;3), 60(0), 100(0)
perl,     70(24),  54(3), 81(&z;7), 59(15),  2(0),  50(0), 19(0), 65(22),  34(0), 87(4), 69(&z;6), 28(1),  51(1)
m88ksim,  76(22),  59(0), 68(&z;8), 79(11), 33(0),  53(0), 66(0), 64(28), 100(0), 91(5), 66(&z;6), 65(0), 100(0)
vortex,   61(29),  99(0), 46(&z;6), 65(14),  9(0),   4(0),  0(0), 70(31),   0(0), 98(2), 40(&z;3), 20(0), 100(0)
<caption>
Breakdown of invariance by instruction types. These categories
include integer loads (ILd), floating-point loads (FLd), load address
calculations (LdA), stores (St), integer multiplication (IMul),
floating-point multiplication (FMul), floating-point division (FDiv),
all other integer arithmetic (IArth), all other floating-point
arithmetic (FArith), compare (Cmp), shift (Shft), conditional moves
(CMov), and all other floating-point operations (FOps). The first
number shown is the percent invariance of the topmost value for a
class type, while the number in parenthesis is the dynamic execution
frequency of that type.  Results are not shown for instruction types
that do not write a register (e.g., branches).  Adapted from Calder,
Feller, and Eustace <book Calder_97>.
</caption>
.E_TABLE


<A NAME="931">1</A>
C99 {ref expression, grouping}

The grouping of operators and operands is indicated by the
syntax.<sup>71)</sup> 


.FIG
baker01
<caption>
English (<quote>Chris is talking with Pat</quote>) and Japanese
(<quote>John-ga Mary to renaisite irue</quote>) language phrase
structure for sentences of similar complexity and structure.  While
the Japanese structure may seem back-to-front to English speakers, it
appears perfectly natural to native speakers of Japanese.
Adapted from Baker <book Baker_01>.
</caption>
.E_FIG


<A NAME="932">2</A>
C99 {ref expression, order of evaluation}

Except as specified later (for the function-call
<keyword>()</keyword>, <keyword>&&</keyword>, <keyword>||</keyword>,
<keyword>?:</keyword>, and comma operators), the order of evaluation
of subexpressions and the order in which side effects take place are
both unspecified.


.FIG
exprtree
<caption>
A simplified form of the kind of tree structure that is likely to be
built by a translator for the expression <c_code>a[i]=x*(y+z)</c_code>.
</caption>
.E_FIG


<A NAME="963">1</A>
C99 {ref identifier, is primary expression if}

An identifier is a primary expression, provided it has been declared
as designating an object (in which case it is an lvalue) or a
function (in which case it is a function designator).<sup>76)</sup>


.TABLE calder_load
: l r r r l r r r
Program,  Mean,    Leaf,   NonLeaf, Program,  Mean,    Leaf,   Non-Leaf
burg,     21.7,    12.9,   26.7,     eqntott,  12.8,    11.8,   20.2
ditroff,  30.3,    18.6,   32.9,     espresso, 21.6,    20.1,   22.9
tex,      30.7,    19.6,   31.3,     gcc,      23.9,    16.7,   24.6
xfig,     23.5,    15.6,   25.8,     li,       28.1,    44.1,   26.3
xtex,     23.2,    16.1,   28.2,     sc,       21.2,    15.3,   22.8
compress, 26.4,     0.1,   26.5,     Mean,     23.9,    17.3,   26.2
<caption>

Occurrence of load instructions (as a percentage of all instructions
executed on &HP; Alpha).  The column headed <phrase>Leaf</phrase>
lists percentage of calls to leaf functions, <phrase>NonLeaf</phrase>
is for nonleaf functions.  Adapted from Calder, Grunwald, and Zorn
<book Calder_95b>.

</caption>
.E_TABLE


.TABLE calder_mips_alpha
Program,   MIPS,   Alpha, Program,   MIPS,   Alpha
compress,   17.3,   26.4, li,   21.8,   28.1
eqntott,   14.6,   12.8, sc,   19.2,   21.2
espresso,   17.9,   21.6, Program mean,   18.2,   22.3
gcc,   18.7,   23.9, , , 
<caption>
Comparison of dynamic load percentages on Alpha and MIPS.
Adapted from Calder, Grunwald, and Zorn <book Calder_95b>.
</caption>
.E_TABLE


.TABLE
: l r r r r r r r r r r r r
Class, compress, gcc, go, ijpeg,     li, m88ksim,  perl, vortex,   bzip,  gzip,   mcf,   Mean
SSN,   &endash;,  1.28,     3.50,    0.42,   4.40,  12.10,   6.23,   7.26,   0.12,  0.15,   0.15,  2.97
SAN,   &endash;,  0.63,     1.01,   16.61,  &endash;,   0.45,   2.58,      &endash;,  12.73,  0.01,   &endash;   ,  2.84
SMN,   &endash;,  0.67, &endash;,    3.62,  &endash;,   0.30,      &endash;,   2.60,      &endash;,     &endash;,   &endash;   ,  0.60
SSP,   &endash;,  0.37, &endash;,    0.17,   1.40,    &endash;,      &endash;,   0.33,      &endash;,  0.02,   &endash;   ,  0.19
SAP,   &endash;,  0.25, &endash;,    0.17,  &endash;, &endash;,      &endash;,      &endash;,      &endash;,     &endash;,   &endash;   ,  0.04
SMP,   &endash;,  0.29, &endash;,    0.25,   0.01,   0.24,   2.15,   0.05,      &endash;,     &endash;,   &endash;   ,  0.25
HSN,   &endash;,  0.88, &endash;,   14.75,   3.51,    &endash;,   8.07,   7.32,   0.27,  0.01,   0.20,  2.92
HAN,   &endash;,  7.39, &endash;,   48.55,  &endash;, &endash;,   4.30,   5.39,  31.83,     &endash;,   2.75,  8.35
HMN,   &endash;, 16.37, &endash;,    0.76,   8.80,   6.11,   8.42,   0.85,      &endash;,  3.54,  27.35,  6.02
HSP,   &endash;,  0.33, &endash;, &endash;,  1.82,    &endash;,  20.01,   7.64,      &endash;,     &endash;,   &endash; ,    2.48
HAP,   &endash;,  9.42, &endash;,    1.33,   0.56,    &endash;,   3.02,   4.97,      &endash;,     &endash;,   0.88,  1.68
HMP,   &endash;,  1.82, &endash;,    0.11,  24.44,   0.57,   6.29,   0.16,      &endash;,  0.01,  17.47,  4.24
GSN,      43.46, 11.10,    14.23,    0.45,  12.76,  17.49,  16.81,  27.79,  43.71, 43.75,   3.12, 19.56
GAN,      19.27,  6.51,    52.03,    3.00,  &endash;,  21.86,      &endash;,   0.03,   3.63, 26.24,   &endash;   , 11.05
GMN,   &endash;,  0.81, &endash;,    0.41,  &endash;,  10.96,      &endash;,   0.16,      &endash;,     &endash;,   2.79,  1.26
GSP,   &endash;,  0.68, &endash;,    0.04,  &endash;, &endash;,      &endash;,      &endash;,      &endash;,     &endash;,   0.48,  0.10
GAP,   &endash;,  2.17, &endash;, &endash;, &endash;,   0.86,   &endash;,   0.60,   0.41,     &endash;,   4.72,  0.73
GMP,   &endash;,  0.77, &endash;,    0.20,  &endash;,   0.07,      &endash;,      &endash;,      &endash;,     &endash;,   0.26,  0.11
RA,        7.65,  5.16,     3.68,    0.91,   8.84,   4.58,   4.11,   4.60,   0.76,  2.52,   7.29,  4.17
CS,       29.62, 33.10,    25.55,    8.27,  33.46,  24.40,  18.01,  30.24,   6.54, 23.75,  32.55, 22.12
<caption>
Dynamic percentage of load instructions from different
<phrase>classes</phrase>.  The <phrase>Class</phrase> column is a
three-letter acronym: the first letter represents the region of
storage (Stack, Heap, or Global), the second denotes the kind of
reference (Array, Member, or Scalar), and the third indicates the
type of the reference (Pointer or Nonpointer).  For instance,
<phrase>HFP</phrase> is a load of pointer-typed member from a
heap-allocated object.  There are two kinds of loads generated as a
result of internal translator housekeeping: <phrase>RA</phrase> is a
load of the return address from a function-call, and any register
values saved to memory prior to the call also need to be reloaded
when the call returns, <phrase>CS</phrase> callee-saved registers

The figures were obtained by instrumenting the source prior to
translation.  As such they provide a count of loads that would be
made by the abstract machine (apart from <phrase>RA</phrase> and
<phrase>CS</phrase>).  The number of loads performed by the machine
code generated by translators is likely to be optimized (evaluation
of constructs moved out of loops and register contents reused) and
resulting in fewer loads.  Whether these optimizations will change
the distribution of loads in different classes is not known.

Adapted from Burtscher, Diwan and Hauswirth <book Burtscher_02>.
</caption>
.E_TABLE


<A NAME="972">9</A>
C99 {ref postfix-expression, syntax}

.ASIS
<c_syntax>postfix-expression:
                primary-expression
                postfix-expression</c_syntax> <keyword>[</keyword> <c_syntax>expression</c_syntax> <keyword>]</keyword>
                <c_syntax>postfix-expression</c_syntax> <keyword>(</keyword> <c_syntax>argument-expression-list<sub>opt</sub></c_syntax> <keyword>)</keyword>
                <c_syntax>postfix-expression</c_syntax> <keyword>.</keyword>  <c_syntax>identifier
                postfix-expression</c_syntax> <keyword>-></keyword> <c_syntax>identifier
                postfix-expression</c_syntax> <keyword>++</keyword>
                <c_syntax>postfix-expression</c_syntax> <keyword>--</keyword>
                <keyword>(</keyword> <c_syntax>type-name</c_syntax> <keyword>) {</keyword> <c_syntax>initializer-list</c_syntax> <keyword>}</keyword>
                <keyword>(</keyword> <c_syntax>type-name</c_syntax> <keyword>) {</keyword> <c_syntax>initializer-list</c_syntax> <keyword>, }</keyword>

<c_syntax>argument-expression-list:
                assignment-expression
                argument-expression-list</c_syntax> <keyword>,</keyword> <c_syntax>assignment-expression</c_syntax>
.E_ASIS


.TABLE postfix_op_tok
: l 1.8cm 2.1cm l 1.8cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword>-></keyword>, &zp;9.8&ze;, &zp;97.5&ze;, <keyword>v++</keyword> <keyword>)</keyword>, &zp;41.4&ze;, &zp;1.4&ze;
identifier <keyword>v++</keyword>, &zp;0.9&ze;, &zp;96.9&ze;, <keyword>v++</keyword> <keyword>;</keyword>, &zp;39.9&ze;, &zp;1.4&ze;
identifier <keyword>v--</keyword>, &zp;0.1&ze;, &zp;96.1&ze;, <keyword>v++</keyword> <keyword>]</keyword>, &zp;4.6&ze;, &zp;1.3&ze;
identifier <keyword>.</keyword>, &zp;3.6&ze;, &zp;83.8&ze;, <keyword>v++</keyword> <keyword>=</keyword>, &zp;7.6&ze;, &zp;0.7&ze;
<keyword>]</keyword> <keyword>.</keyword>, &zp;20.3&ze;, &zp;15.4&ze;, <keyword>v--</keyword> <keyword>;</keyword>, &zp;58.4&ze;, &zp;0.3&ze;
<keyword>-></keyword> identifier, &zp;100.0&ze;, &zp;10.1&ze;, <keyword>v--</keyword> <keyword>)</keyword>, &zp;29.1&ze;, &zp;0.1&ze;
<keyword>.</keyword> identifier, &zp;100.0&ze;, &zp;4.2&ze;, , , 
<caption>
Common token pairs involving <keyword>.</keyword>,
<keyword>-></keyword>, <keyword>++</keyword>, or
<keyword>--</keyword> (as a percentage of all occurrences of each
token).  Based on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


.TABLE postfix_oprnd
: c l r c l r
Operator, Type, %, Operator, Type, %
<keyword>v++</keyword>, <keyword>int</keyword>, &zp;54.0&ze;, <keyword>[</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;5.1&ze;
<keyword>v--</keyword>, <keyword>int</keyword>, &zp;52.5&ze;, <keyword>[</keyword>, other-types, &zp;4.7&ze;
<keyword>[</keyword>, <keyword>*</keyword>, &zp;38.0&ze;, <keyword>[</keyword>, <keyword>int</keyword>, &zp;4.1&ze;
<keyword>v++</keyword>, <keyword>*</keyword>, &zp;25.7&ze;, <keyword>v++</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;3.1&ze;
<keyword>v--</keyword>, <keyword>long</keyword>, &zp;15.9&ze;, <keyword>v--</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.7&ze;
<keyword>[</keyword>, <keyword>struct</keyword>, &zp;14.5&ze;, <keyword>v--</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.6&ze;
<keyword>v++</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;13.3&ze;, <keyword>[</keyword>, <keyword>const</keyword> <keyword>char</keyword>, &zp;2.4&ze;
<keyword>[</keyword>, <keyword>float</keyword>, &zp;12.0&ze;, <keyword>[</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.2&ze;
<keyword>v--</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;11.5&ze;, <keyword>v++</keyword>, <keyword>long</keyword>, &zp;1.1&ze;
<keyword>[</keyword>, <keyword>union</keyword>, &zp;10.2&ze;, <keyword>[</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.1&ze;
<keyword>v--</keyword>, <keyword>*</keyword>, &zp;7.1&ze;, <keyword>v++</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.0&ze;
<keyword>[</keyword>, <keyword>char</keyword>, &zp;6.8&ze;, <keyword>v++</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.0&ze;
<keyword>v--</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;6.1&ze;, <keyword>v--</keyword>, <keyword>short</keyword>, &zp;1.0&ze;
<caption>
Occurrence postfix operators having particular operand types (as a
percentage of all occurrences of each operator, with
<keyword>[</keyword> denoting array subscripting).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="975">1</A>
C99

A postfix expression followed by an expression in square brackets
<keyword>[]</keyword> is a subscripted designation of an element of
an array object.


.TABLE
: L c c
Time step, Operation
t=1,   A[0] = B[1]
t=2,   C[1] = A[1]
t=3,   A[1] = B[2]
t=4,   C[2] = A[2]
.E_TABLE


.TABLE
: L c c
Time step, Thread 1, Thread 2
t=1,   A[0] = B[1],  A[1] = B[2]
t=2,   C[1] = A[1],  C[2] = A[2]
.E_TABLE


.TABLE
: L c c
Time step, Operation
t=1,   B[1] = A[0]
t=2,   A[1] = C[1]
t=3,   B[2] = A[1]
t=4,   A[2] = C[2]
.E_TABLE


.TABLE
: L c c
Time step, Thread 1, Thread 2
t=1,   B[1] = A[0],  B[2] = A[1]
t=2,   A[1] = C[1],  A[2] = C[2]
.E_TABLE


.TABLE
: L c c
Time step, Operation
t=1,   A[0] = B[1]
t=2,   A[1] = C[1]
t=3,   A[1] = B[2]
t=4,   A[2] = C[2]
.E_TABLE


.TABLE
: L c c
Time step, Thread 1, Thread 2
t=1,   A[0] = B[1],  A[1] = B[2]
t=2,   A[1] = C[1],  A[2] = C[2]
.E_TABLE


<A NAME="978">1</A>
C99

Successive subscript operators designate an element of a
multidimensional array object.


.TABLE array_dims
: c r r r
Dimensions, Parameters, Block Scope, File Scope
 1 , 100.0 , 97.9 , 91.9
 2 , 0.0 , 2.0 , 7.5
 3 , 0.0 , 0.1 , 0.6
<caption>
Occurrence of object declarations having an array type with the given
number of dimensions (as a percentage of all array types in the given
scope; with local scope separated into parameters and everything
else).  Based on the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="981">4</A>
C99 {ref array, row-major storage order}

It follows from this that arrays are stored in row-major order (last
subscript varies fastest).


.FIG
rowmajor
<caption>
Row (left) and column (right) major order.  The dotted line indicates
successively increasing addresses for the two kinds of storage layouts,
with the gray boxes denoting the same sequence of index values.
</caption>
.E_FIG


.FIG
arrarrchar
<caption>
Difference in storage layout between an array of array of characters
(left) and array of pointer to characters (right; not all pointers
shown and the relative storage locations of the strings is only one
of many that are possible).
</caption>
.E_FIG


<A NAME="987">1</A>
C99 {ref operator, ()}

A postfix expression followed by parentheses <keyword>()</keyword>
containing a possibly empty, comma-separated list of expressions is a
function call.


.FIG
stack
<caption>
Common storage organization of a function call stack.
</caption>
.E_FIG


.TABLE
Name, Within File, Not in File, Via Pointer
cccp,     191 (&z2;&zcz;1&comma;414),   &z2;4 (&z2;&zcz;&zcz;3),  &z;1 (&z;&zcz;140)
compress, &z;27 (&z2;&zcz;4&comma;283), &z2;0 (&z2;&zcz;&zcz;0),  &z;0 (&z3;&zcz;0)
eqn,    &z;81 (&z2;&zcz;6&comma;959), 144 (&zcz;33&comma;534),  &z;0 (&z3;&zcz;0)
espresso, 167 (&z;&zcz;55&comma;696), 982 (&zc;925&comma;710),   11 (&z;60&comma;965)
lex,      110 (&z;&zcz;63&comma;240), 234 (&z;&zcz;4&comma;675),  &z;0 (&z3;&zcz;0)
tbl,    &z;91 (&z2;&zcz;9&comma;616), 364 (&zcz;37&comma;809),  &z;0 (&z3;&zcz;0)
xlist,    331 (10&comma;308&comma;201), 834 (8&comma;453&comma;735),  &z;4 (479&comma;473)
yacc,     118 (&z;&zcz;34&comma;146), &z;81 (&z;&zcz;3&comma;323),  &z;0 (&z3;&zcz;0)
<caption>

Static count of number of calls: to functions defined within the same
source file as the call, not defined in the file containing the call,
and made via pointers-to functions.  Parenthesized numbers are the
corresponding dynamic count.  Adapted from Chang, Mahlke, Chen, and Hwu
<book Chang_92>.

</caption>
.E_TABLE


.TABLE
: l r r r r l r r r r
Program,   Leaf, Non-Leaf, Indirect, Direct, Program,   Leaf, NonLeaf, Indirect, Direct
burg,      72.3,   27.7,  0.1,   99.9, eqntott,   85.3,   14.7, 68.7,   31.3
ditroff,   14.7,   85.3,  1.0,   99.0, espresso,  75.0,   25.0,  4.0,   96.0
tex,       20.0,   80.0,  0.0,  100.0, gcc,       28.9,   71.1,  5.4,   94.6
xfig,      35.5,   64.5,  6.2,   93.8, li,        13.4,   86.6,  2.9,   97.1
xtex,      50.6,   49.4,  3.0,   97.0, sc,        29.1,   70.9,  0.1,   99.9
compress,   0.1,   99.9,  0.0,  100.0, Mean,      38.6,   61.4,  8.3,   91.7
<caption>
Percentage of function invocations during execution of various
programs in SPECint92 execution.  The column headed
<phrase>Leaf</phrase> lists percentage of calls to leaf functions,
<phrase>NonLeaf</phrase> is for nonleaf functions (the issues
surrounding this distinction are discussed elsewhere).  The column
headed <phrase>Direct</phrase> lists percentages of calls where a
function name appeared in the expression, <phrase>Indirect</phrase>
is where the function address was obtained via expression evaluation.
Adapted from Calder, Grunwald, and Zorn <book Calder_95b>.
</caption>
.E_TABLE


.TABLE
: l r r l r r
Program,   Mean,   Std. Dev., Program,   Mean,   Std. Dev.
burg,     10.5,   30.84, eqntott,   6.5,    1.39
ditroff,   7.1,    2.45, espresso, 11.5,    4.67
tex,       7.9,    2.71, gcc,       9.9,    2.44
xfig,     11.6,    4.47, li,       42.0,   14.50
xtex,     14.2,    4.27, sc,        6.8,    1.41
compress,  4.0,    0.07, Mean,     12.0,    6.29
<caption>
Mean and standard deviation of call stack depth for various programs in
SPECint92.  Adapted from Calder, Grunwald, and Zorn <book Calder_95b>.
</caption>
.E_TABLE


.TABLE Calder95b1
: l r r r r r
Program Name, Instructions Executed, Function Calls Invoked, Instructions/Call, Total I-calls, Instructions/I-call
burg,       390&comma;772&comma;349,       6&comma;342&comma;378,    61.6,      8&comma;753,  44&comma;644.4
ditroff,     38&comma;893&comma;571,     663&comma;454,    58.6,      6&comma;920,   5&comma;620.5
tex,        147&comma;811&comma;789,     853&comma;193,   173.2,          0,       &endash;
xfig,        33&comma;203&comma;506,     536&comma;004,    61.9,     33&comma;312,    996.7
xtex,        23&comma;797&comma;633,     207&comma;047,   114.9,      6&comma;227,   3&comma;821.7
compress,    92&comma;629&comma;716,     251&comma;423,   368.4,          0,       &endash;
eqntott,  1&comma;810&comma;540&comma;472,   4&comma;680&comma;514,   386.8,  3&comma;215&comma;048,    563.1
espresso,   513&comma;008&comma;232,   2&comma;094&comma;635,   244.9,     84&comma;751,   6&comma;053.1
gcc,        143&comma;737&comma;904,   1&comma;490&comma;292,    96.4,     80&comma;809,   1&comma;778.7
li,       1&comma;354&comma;926&comma;022,  31&comma;857&comma;867,    42.5,    919&comma;965,   1&comma;472.8
sc,         917&comma;754&comma;841,  12&comma;903&comma;351,    71.1,     13&comma;785,  66&comma;576.3
dhrystone,  608&comma;057&comma;060,  18&comma;000&comma;726,    33.8,          0,      &endash;
Program mean, 497&comma;006&comma;912,   5&comma;625&comma;468,   152.8,    397&comma;233,  14&comma;614.1
<caption>
Count of instructions executed and function calls made during
execution of various SPECint92 programs on an Alpha AXP21064
processor.  <phrase>Function calls invoked</phrase> includes indirect
function calls; <phrase>Instructions/Call</phrase> is the number of
instructions executed per call; <phrase>Total I-calls</phrase> is the
number of indirect function calls made; and
<phrase>Instructions/I-call</phrase> is the number of instructions
executed per indirect call.
Adapted from Calder, Grunwald, and Zorn <book Calder_95b>.
</caption>
.E_TABLE


<A NAME="988">2</A>
C99

The postfix expression denotes the called function.


.TABLE cheng_calls
: l r r r r r r
Benchmark, Lines Code, Functions Defined, Library Functions, Direct Calls, Indirect Calls, &amp; Function
008.espresso, 14&comma;838,  361,  24,  2&comma;674,  15,  12
023.eqntott,  12&comma;053,   62,  21,   358,  11,   5
072.sc,        8&comma;639,  179,  53,  1&comma;459,   2,  20
085.cc1,      90&comma;857, 1&comma;452,  44,  8&comma;332,  67, 588
124.m88ksim,  19&comma;092,  252,  36,  1&comma;496,   3,  57
126.gcc,     205&comma;583, 2&comma;019,  45, 19&comma;731, 132, 229
130.li,        7&comma;597,  357,  27,  1&comma;267,   4, 190
132.ijpeg,    29&comma;290,  477,  18,  1&comma;016, 641, 188
134.perl,     26&comma;874,  276,  72,  4&comma;367,   3,   3
147.vortex,   67&comma;205,  923,  33,  8&comma;521,  15,  44
<caption>
Static count of functions defined, library functions called, direct
and indirect calls to them and number of functions that had their
addresses taken in SPECint95.  Adapted from Cheng <book Cheng_00>.
</caption>
.E_TABLE


<A NAME="990">1</A>
C99

An argument may be an expression of any object type.


.TABLE arg_type
: l r l r
Type, %, Type, %
<keyword>struct</keyword> <keyword>*</keyword>, &zp;26.8&ze;, <keyword>void</keyword> <keyword>*</keyword>, &zp;4.0&ze;
<keyword>int</keyword>, &zp;16.5&ze;, <keyword>union</keyword> <keyword>*</keyword>, &zp;3.4&ze;
<keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;9.7&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.5&ze;
<keyword>char</keyword> <keyword>*</keyword>, &zp;8.4&ze;, <keyword>enum</keyword>, &zp;2.1&ze;
other-types, &zp;8.0&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.9&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;7.1&ze;, <keyword>const</keyword> <keyword>void</keyword> <keyword>*</keyword>, &zp;1.8&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;6.3&ze;, <keyword>long</keyword>, &zp;1.4&ze;
<caption>
Occurrence of various argument types in calls to functions (as a
percentage of the argument types in all calls).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="991">2</A>
C99 {ref function call, preparing for}

In preparing for the call to a function, the arguments are evaluated,
and each parameter is assigned the value of the corresponding
argument.<sup>78)</sup>


.FIG
regwin
<caption>
A processors register file (on the left) and the register windows, of
registers accessible to a program, after 0, 1, 2, and 3
<hlight>call</hlight> instructions have been executed.  The mapping
of the first eight registers is not affected by the
<hlight>call</hlight> instruction.
</caption>
.E_FIG


<A NAME="992">1</A>
C99

If the expression that denotes the called function has type pointer
to function returning an object type, the function call expression
has the same type as that object type, and has the value determined
as specified in 6.8.6.4.


.TABLE ret_type
: l r l r
Type, %, Type, %
<keyword>void</keyword>, &zp;35.8&ze;, <keyword>union</keyword> <keyword>*</keyword>, &zp;3.2&ze;
<keyword>int</keyword>, &zp;30.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;3.1&ze;
<keyword>struct</keyword> <keyword>*</keyword>, &zp;9.1&ze;, <keyword>char</keyword> <keyword>*</keyword>, &zp;3.1&ze;
<keyword>void</keyword> <keyword>*</keyword>, &zp;6.3&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;2.1&ze;
other-types, &zp;5.2&ze;, <keyword>char</keyword>, &zp;1.6&ze;
<caption>
Occurrence of various return types in calls to functions (as a
percentage of the return type of all calls).  Based on the translated
form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="998">4</A>
C99 {ref function definition, ends with ellipsis}

If the function is defined with a type that includes a prototype, and
either the prototype ends with an ellipsis (<fixedb>, ...</fixedb>)
or the types of the arguments after promotion are not compatible with
the types of the parameters, the behavior is undefined.


.FIG
wrongtype
<caption>
An example of the impact, on relative stack addresses, of passing an
argument having a type that occupies more storage than the declared
parameter type.  For instance, the offset of <c_code>z</c_code>,
relative to the frame pointer, <hlight>fp</hlight> might be changed by
passing an argument having a type different from the declared type of
the parameter <c_code>y</c_code> (when there is no visible prototype,
at the point of call, to cause the type of the argument to be
converted).
</caption>
.E_FIG


<A NAME="1018">1</A>
C99 {ref member, selection}

A postfix expression followed by the <keyword>.</keyword> operator
and an identifier designates a member of a structure or union object.


.TABLE selnest
: l r r r r r r
<keyword>.</keyword> \ <keyword>-></keyword> , 0, 1, 2, 3, 4, 5
0, &zs;0&ze; , &zs;165745&ze; , &zs;10396&ze; , &zs;522&ze; , &zs;36&ze; , &zs;4&ze; 
1, &zs;28160&ze; , &zs;34065&ze; , &zs;3437&ze; , &zs;230&ze; , &zs;7&ze; , &zs;0&ze; 
2, &zs;3252&ze; , &zs;6643&ze; , &zs;579&ze; , &zs;26&ze; , &zs;0&ze; , &zs;0&ze; 
3, &zs;363&ze; , &zs;309&ze; , &zs;35&ze; , &zs;5&ze; , &zs;0&ze; , &zs;0&ze; 
4, &zs;16&ze; , &zs;33&ze; , &zs;2&ze; , &zs;0&ze; , &zs;0&ze; , &zs;0&ze; 
5, &zs;0&ze; , &zs;15&ze; , &zs;0&ze; , &zs;0&ze; , &zs;0&ze; , &zs;0&ze; 
<caption>
Number of member selection operators of the same
object (number of dot selections is indicated down the left, and the
number of indirect selections across the top).  For instance,
<c_code>x.m1->m2</c_code> is counted as one occurrence of the dot
selection operator with one instance of the indirect selection
operator.  Based on the translated form of the books benchmark
programs.
</caption>
.E_TABLE


<A NAME="1065">3</A>
C99 {ref unary-expression, syntax}

.ASIS
<c_syntax>unary-expression:
                postfix-expression
                </c_syntax><keyword>++</keyword> <c_syntax>unary-expression
                </c_syntax><keyword>--</keyword> <c_syntax>unary-expression
                unary-operator cast-expression
                </c_syntax><keyword>sizeof</keyword> <c_syntax>unary-expression
                </c_syntax><keyword>sizeof (</keyword> <c_syntax>type-name</c_syntax> <keyword>)</keyword>

<c_syntax>unary-operator:</c_syntax> one of
                <keyword>&  *  +  -  ~  !</keyword>
.E_ASIS


.TABLE unary_op_tok
: l 1.8cm 2.1cm l 1.8cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
<keyword>!</keyword> defined, &zp;2.0&ze;, &zp;16.7&ze;, <keyword>!</keyword> <keyword>(</keyword>, &zp;14.5&ze;, &zp;0.5&ze;
<keyword>*v</keyword> <keyword>--v</keyword>, &zp;0.3&ze;, &zp;7.8&ze;, <keyword>-v</keyword> identifier, &zp;30.2&ze;, &zp;0.4&ze;
<keyword>-v</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.3&ze;, &zp;6.7&ze;, <keyword>*v</keyword> <keyword>(</keyword>, &zp;9.0&ze;, &zp;0.4&ze;
<keyword>*v</keyword> <keyword>++v</keyword>, &zp;0.5&ze;, &zp;6.3&ze;, <keyword>~</keyword> <c_syntax>integer-constant</c_syntax>, &zp;20.1&ze;, &zp;0.2&ze;
<keyword>!</keyword> <keyword>--v</keyword>, &zp;0.2&ze;, &zp;4.8&ze;, <keyword>++v</keyword> identifier, &zp;97.3&ze;, &zp;0.1&ze;
<keyword>-v</keyword> <c_syntax>integer-constant</c_syntax>, &zp;69.0&ze;, &zp;4.1&ze;, <keyword>~</keyword> identifier, &zp;56.3&ze;, &zp;0.1&ze;
<keyword>&v</keyword> identifier, &zp;96.1&ze;, &zp;1.9&ze;, <keyword>~</keyword> <keyword>(</keyword>, &zp;23.4&ze;, &zp;0.1&ze;
<keyword>sizeof</keyword> <keyword>(</keyword>, &zp;97.5&ze;, &zp;1.8&ze;, <keyword>+v</keyword> <c_syntax>integer-constant</c_syntax>, &zp;49.0&ze;, &zp;0.0&ze;
<keyword>*v</keyword> identifier, &zp;86.8&ze;, &zp;1.0&ze;, <keyword>--v</keyword> identifier, &zp;97.1&ze;, &zp;0.0&ze;
<keyword>!</keyword> identifier, &zp;81.9&ze;, &zp;0.8&ze;, , , 
<caption>
Common token pairs involving <keyword>sizeof</keyword>,
<c_syntax>unary-operator</c_syntax>, prefix <keyword>++</keyword>, or
prefix <keyword>--</keyword> (as a percentage of all occurrences of
each token).  Based on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


.FIG
unarycons
<caption>
Integer constant values appearing as the operand of the unary minus
and unary <keyword>~</keyword> operators.  Based on the visible form
of the <file>.c</file> files.
</caption>
.E_FIG


.TABLE unary_oprnd
: c l r c l r c l r
Operator, Type, %, Operator, Type, %, Operator, Type, %
<keyword>-v</keyword>, _<keyword>int</keyword>, &zp;96.0&ze;, <keyword>~</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;6.8&ze;, <keyword>!</keyword>, _<keyword>long</keyword>, &zp;2.7&ze;
<keyword>*v</keyword>, ptr-to, &zp;95.3&ze;, <keyword>&v</keyword>, <keyword>int</keyword>, &zp;6.2&ze;, <keyword>~</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.5&ze;
<keyword>+v</keyword>, _<keyword>int</keyword>, &zp;72.2&ze;, <keyword>~</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;6.0&ze;, <keyword>&v</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.4&ze;
<keyword>--v</keyword>, <keyword>int</keyword>, &zp;54.7&ze;, <keyword>+v</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;5.6&ze;, <keyword>!</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.1&ze;
<keyword>!</keyword>, <keyword>int</keyword>, &zp;50.0&ze;, <keyword>+v</keyword>, <keyword>long</keyword>, &zp;5.6&ze;, <keyword>~</keyword>, <keyword>long</keyword>, &zp;2.0&ze;
<keyword>~</keyword>, _<keyword>int</keyword>, &zp;49.3&ze;, <keyword>+v</keyword>, <keyword>float</keyword>, &zp;5.6&ze;, <keyword>++v</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.9&ze;
<keyword>&v</keyword>, other-types, &zp;45.1&ze;, <keyword>!</keyword>, other-types, &zp;5.6&ze;, <keyword>~</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.7&ze;
<keyword>++v</keyword>, <keyword>int</keyword>, &zp;43.8&ze;, <keyword>++v</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;5.2&ze;, <keyword>~</keyword>, _<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.7&ze;
<keyword>++v</keyword>, ptr-to, &zp;33.3&ze;, <keyword>&v</keyword>, <keyword>struct</keyword> <keyword>*</keyword>, &zp;4.9&ze;, <keyword>!</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.6&ze;
<keyword>~</keyword>, <keyword>int</keyword>, &zp;28.5&ze;, <keyword>--v</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;4.7&ze;, <keyword>~</keyword>, other-types, &zp;1.6&ze;
<keyword>--v</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;22.1&ze;, <keyword>!</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;4.7&ze;, <keyword>-v</keyword>, _<keyword>double</keyword>, &zp;1.4&ze;
<keyword>!</keyword>, ptr-to, &zp;20.1&ze;, <keyword>*v</keyword>, fnptr-to, &zp;4.1&ze;, <keyword>-v</keyword>, other-types, &zp;1.3&ze;
<keyword>--v</keyword>, ptr-to, &zp;14.6&ze;, <keyword>&v</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;4.0&ze;, <keyword>++v</keyword>, <keyword>long</keyword>, &zp;1.2&ze;
<keyword>&v</keyword>, <keyword>struct</keyword>, &zp;13.9&ze;, <keyword>--v</keyword>, other-types, &zp;4.0&ze;, <keyword>-v</keyword>, <keyword>int</keyword>, &zp;1.2&ze;
<keyword>&v</keyword>, <keyword>char</keyword>, &zp;13.1&ze;, <keyword>&v</keyword>, <keyword>long</keyword>, &zp;3.4&ze;, <keyword>!</keyword>, _<keyword>int</keyword>, &zp;1.2&ze;
<keyword>++v</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;12.6&ze;, <keyword>&v</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.0&ze;, <keyword>++v</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.1&ze;
<keyword>+v</keyword>, <keyword>int</keyword>, &zp;11.1&ze;, <keyword>&v</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.9&ze;, <keyword>&v</keyword>, <keyword>char</keyword> <keyword>*</keyword>, &zp;1.1&ze;
<keyword>!</keyword>, <keyword>char</keyword>, &zp;9.2&ze;, <keyword>!</keyword>, <keyword>enum</keyword>, &zp;2.9&ze;, , , 
<caption>
Occurrence of the <c_syntax>unary-operator</c_syntax>s, prefix
<keyword>++</keyword>, and prefix <keyword>--</keyword> having
particular operand types (as a percentage of all occurrences of the
particular operator; an <phrase>_</phrase> prefix indicates a literal
operand).  Based on the translated form of the books benchmark
programs.
</caption>
.E_TABLE


<A NAME="1088">3</A>
C99 {ref !, operand type}

of the <keyword>!</keyword> operator, scalar type.


.TABLE log_not_context
: l r r
Context, % of <keyword>!</keyword>, % of Contexts
<keyword>if</keyword> control-expression, &zp;91.0&ze;, &zp;17.4&ze;
<keyword>while</keyword> control-expression, &zp;2.3&ze;, &zp;8.2&ze;
<keyword>for</keyword> control-expression, &zp;0.3&ze;, &zp;0.7&ze;
<keyword>switch</keyword> control-expression, &zp;0.0&ze;, &zp;0.0&ze;
other contexts, &zp;6.4&ze;, &emdash;
<caption>
Occurrence of the unary <keyword>!</keyword> operator in various
contexts (as a percentage of all occurrences of this operator and the
percentage of all occurrences of the given context that contains this
operator).  Based on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="1103">1</A>
C99 {ref sizeof, constraints}

The <keyword>sizeof</keyword> operator shall not be applied to an
expression that has function type or an incomplete type, to the
parenthesized name of such a type, or to an expression that
designates a bit-field member.


.TABLE sizeof_oprnd
: l r l r
Type, %, Type, %
<keyword>struct</keyword>, &zp;48.2&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.7&ze;
<keyword>[</keyword> <keyword>]</keyword>, &zp;12.2&ze;, <keyword>struct</keyword> <keyword>*</keyword>, &zp;2.6&ze;
<keyword>int</keyword>, &zp;11.6&ze;, <keyword>char</keyword>, &zp;2.0&ze;
other-types, &zp;4.7&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.5&ze;
<keyword>long</keyword>, &zp;3.8&ze;, <keyword>char</keyword> <keyword>*</keyword>, &zp;1.5&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.6&ze;, <keyword>signed</keyword> <keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;3.4&ze;, <keyword>union</keyword>, &zp;1.1&ze;
<caption>
Occurrence of the <keyword>sizeof</keyword> operator having
particular operand types (as a percentage of all occurrences of this
operator).  Based on the translated form of the books benchmark
programs.
</caption>
.E_TABLE


<A NAME="1119">1</A>
C99 {ref cast, scalar or void type}

Unless the type name specifies a void type, the type name shall
specify qualified or unqualified scalar type and the operand shall
have scalar type.


.TABLE cast_oprnd
: l l r l l r
To Type, From Type, %, To Type, From Type, %
<keyword>(</keyword> other-types <keyword>)</keyword>, other-types, &zp;40.1&ze;, <keyword>(</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;1.6&ze;
<keyword>(</keyword> <keyword>void</keyword> <keyword>*</keyword> <keyword>)</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;18.9&ze;, <keyword>(</keyword> <keyword>union</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;1.5&ze;
<keyword>(</keyword> <keyword>struct</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>struct</keyword> <keyword>*</keyword>, &zp;11.2&ze;, <keyword>(</keyword> <keyword>void</keyword> <keyword>)</keyword>, <keyword>long</keyword>, &zp;1.3&ze;
<keyword>(</keyword> <keyword>struct</keyword> <keyword>*</keyword> <keyword>)</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;4.2&ze;, <keyword>(</keyword> <keyword>unsigned</keyword> <keyword>long</keyword> <keyword>)</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.3&ze;
<keyword>(</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>char</keyword> <keyword>*</keyword>, &zp;4.0&ze;, <keyword>(</keyword> <keyword>int</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;1.3&ze;
<keyword>(</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>struct</keyword> <keyword>*</keyword>, &zp;3.9&ze;, <keyword>(</keyword> <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;1.2&ze;
<keyword>(</keyword> <keyword>struct</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;2.8&ze;, <keyword>(</keyword> <keyword>enum</keyword> <keyword>)</keyword>, int:8 &zs;24&ze;, &zp;1.2&ze;
<keyword>(</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>)</keyword>, <keyword>int</keyword>, &zp;1.7&ze;, <keyword>(</keyword> <keyword>char</keyword> <keyword>)</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.2&ze;
<keyword>(</keyword> <keyword>struct</keyword> <keyword>*</keyword> <keyword>)</keyword>, <keyword>char</keyword> <keyword>*</keyword>, &zp;1.7&ze;, <keyword>(</keyword> <keyword>unsigned</keyword> <keyword>long</keyword> <keyword>)</keyword>, ptr-to <keyword>*</keyword>, &zp;1.0&ze;
<caption>
Occurrence of the cast operator having particular operand types (as a
percentage of all occurrences of this operator).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1128">8</A>
C99 {ref multiplicative-expression, syntax}

.ASIS
<c_syntax>multiplicative-expression:
                cast-expression
                multiplicative-expression</c_syntax> <keyword>*</keyword> <c_syntax>cast-expression
                multiplicative-expression</c_syntax> <keyword>/</keyword> <c_syntax>cast-expression
                multiplicative-expression</c_syntax> <keyword>%</keyword> <c_syntax>cast-expression</c_syntax> 
.E_ASIS


.FIG
campbell97
<caption>
Mean percentage of errors in simple multiplication (e.g.,
<equ>3&times;7</equ>) and division (e.g., <equ>81/9</equ>) problems
as a function of the operand value (see paper for a discussion of the
effect of the relative position of the minimum/maximum operand
values).  Adapted from Campbell <book Campbell_97>.
</caption>
.E_FIG


.TABLE
: l r r
      ,   Campbell and Graham,     Harley
Operand errors,          79.1&z;,  86.2&z;
Close operand errors,    76.8&z;,  76.74
Frequent product errors, 24.2&z;,  23.26
Table errors,            13.5&z;,  13.8&z;
Operation error,          1.7&z;,  13.72
Error frequency,          7.65,  6.3&z;
<caption>
Percentage breakdown of errors.  Figures are mean values for 60
adults tested on <equ>2&times;2</equ> to <equ>9&times;9</equ> from
Campbell and Graham <book Campbell_85>, and 42 adults tested on
<equ>0&times;0</equ> to <equ>9&times;9</equ> from Harley <book
Harley_91>.  For the Campbell and Graham data, the operand error and
operation error percentages are an approximation due to incomplete
data.
</caption>
.E_TABLE


.TABLE mult_op_tok
: l 1.8cm 2.1cm l 1.8cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword>*</keyword>, &zp;3.4&ze;, &zp;92.1&ze;, <keyword>/</keyword> <keyword>sizeof</keyword>, &zp;9.0&ze;, &zp;3.6&ze;
identifier <keyword>%</keyword>, &zp;0.0&ze;, &zp;57.7&ze;, <keyword>*</keyword> identifier, &zp;76.5&ze;, &zp;2.8&ze;
identifier <keyword>/</keyword>, &zp;0.1&ze;, &zp;54.3&ze;, <keyword>*</keyword> <keyword>)</keyword>, &zp;14.4&ze;, &zp;2.0&ze;
<keyword>)</keyword> <keyword>/</keyword>, &zp;0.3&ze;, &zp;33.9&ze;, <c_syntax>floating-constant</c_syntax> <keyword>/</keyword>, &zp;5.8&ze;, &zp;1.8&ze;
<keyword>)</keyword> <keyword>%</keyword>, &zp;0.1&ze;, &zp;31.8&ze;, <keyword>/</keyword> <c_syntax>integer-constant</c_syntax>, &zp;53.5&ze;, &zp;0.5&ze;
<keyword>*</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.2&ze;, &zp;12.5&ze;, <keyword>%</keyword> <c_syntax>integer-constant</c_syntax>, &zp;44.8&ze;, &zp;0.1&ze;
<keyword>*</keyword> <keyword>sizeof</keyword>, &zp;1.6&ze;, &zp;11.2&ze;, <keyword>/</keyword> identifier, &zp;27.5&ze;, &zp;0.1&ze;
<c_syntax>integer-constant</c_syntax> <keyword>/</keyword>, &zp;0.1&ze;, &zp;8.5&ze;, <c_syntax>floating-constant</c_syntax> <keyword>*</keyword>, &zp;6.8&ze;, &zp;0.1&ze;
&comma; <keyword>%</keyword>, &zp;0.0&ze;, &zp;6.5&ze;, <keyword>/</keyword> <keyword>(</keyword>, &zp;7.9&ze;, &zp;0.1&ze;
<keyword>/</keyword> <c_syntax>floating-constant</c_syntax>, &zp;2.0&ze;, &zp;6.4&ze;, <keyword>%</keyword> identifier, &zp;47.6&ze;, &zp;0.0&ze;
<keyword>*</keyword> <keyword>*v</keyword>, &zp;1.4&ze;, &zp;4.4&ze;, , , 
<caption>
Common token pairs involving multiplicative operators (as a
percentage of all occurrences of each token).  Based on the
visible form of the <file>.c</file> files.  Note: a consequence of
the method used to perform the counts is that occurrences of the
sequence <phrase>identifier <keyword>*</keyword></phrase> are over
estimated (e.g., occurrences of a typedef name followed by a
<keyword>*</keyword> are included in the counts).
</caption>
.E_TABLE


.FIG
multcons
<caption>
Number of integer constants appearing as the right operand of the
multiplicative operators.  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_FIG


<A NAME="1129">1</A>
C99 {ref multiplicative, operand type}

Each of the operands shall have arithmetic type.


.TABLE mult_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>int</keyword>, <keyword>%</keyword>, _<keyword>int</keyword>, &zp;40.6&ze;, _<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>*</keyword>, _<keyword>int</keyword>, &zp;2.8&ze;
<keyword>int</keyword>, <keyword>/</keyword>, _<keyword>int</keyword>, &zp;25.6&ze;, <keyword>int</keyword>, <keyword>/</keyword>, <keyword>float</keyword>, &zp;2.7&ze;
other-types, <keyword>*</keyword>, other-types, &zp;18.1&ze;, <keyword>long</keyword>, <keyword>/</keyword>, _<keyword>int</keyword>, &zp;2.5&ze;
other-types, <keyword>/</keyword>, other-types, &zp;16.2&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>%</keyword>, <keyword>int</keyword>, &zp;2.3&ze;
_<keyword>int</keyword>, <keyword>*</keyword>, _<keyword>int</keyword>, &zp;13.4&ze;, _<keyword>int</keyword>, <keyword>*</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.2&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>%</keyword>, _<keyword>int</keyword>, &zp;12.6&ze;, _<keyword>int</keyword>, <keyword>*</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.2&ze;
<keyword>int</keyword>, <keyword>%</keyword>, <keyword>int</keyword>, &zp;12.2&ze;, _<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>*</keyword>, <keyword>int</keyword>, &zp;2.1&ze;
<keyword>int</keyword>, <keyword>*</keyword>, _<keyword>int</keyword>, &zp;12.1&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>*</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.9&ze;
_<keyword>int</keyword>, <keyword>/</keyword>, _<keyword>int</keyword>, &zp;11.0&ze;, <keyword>int</keyword>, <keyword>%</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.8&ze;
_<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>/</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;9.9&ze;, <keyword>float</keyword>, <keyword>/</keyword>, <keyword>float</keyword>, &zp;1.8&ze;
_<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>*</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;9.5&ze;, _<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>/</keyword>, _<keyword>int</keyword>, &zp;1.6&ze;
<keyword>int</keyword>, <keyword>*</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;8.8&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>%</keyword>, <keyword>int</keyword>, &zp;1.6&ze;
<keyword>float</keyword>, <keyword>*</keyword>, <keyword>float</keyword>, &zp;8.8&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>%</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.5&ze;
other-types, <keyword>%</keyword>, other-types, &zp;7.3&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>/</keyword>, _<keyword>int</keyword>, &zp;1.3&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>/</keyword>, _<keyword>int</keyword>, &zp;6.6&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>/</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.3&ze;
_<keyword>int</keyword>, <keyword>*</keyword>, <keyword>int</keyword>, &zp;6.5&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>*</keyword>, _<keyword>int</keyword>, &zp;1.3&ze;
<keyword>int</keyword>, <keyword>*</keyword>, <keyword>int</keyword>, &zp;5.9&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>*</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>/</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;5.8&ze;, <keyword>int</keyword>, <keyword>/</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>/</keyword>, _<keyword>int</keyword>, &zp;5.3&ze;, _<keyword>double</keyword>, <keyword>/</keyword>, _<keyword>double</keyword>, &zp;1.2&ze;
<keyword>int</keyword>, <keyword>/</keyword>, <keyword>int</keyword>, &zp;5.0&ze;, <keyword>float</keyword>, <keyword>*</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>%</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;4.2&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>*</keyword>, _<keyword>int</keyword>, &zp;1.0&ze;
<keyword>int</keyword>, <keyword>%</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;4.2&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>%</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.0&ze;
<keyword>int</keyword>, <keyword>%</keyword>, _<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;3.9&ze;, <keyword>int</keyword>, <keyword>/</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.0&ze;
<keyword>long</keyword>, <keyword>%</keyword>, _<keyword>int</keyword>, &zp;3.7&ze;, _<keyword>int</keyword>, <keyword>*</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.0&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>%</keyword>, _<keyword>int</keyword>, &zp;3.1&ze;, , , , 
<caption>
Occurrence of multiplicative operators having particular (left and
right) operand types (as a percentage of all occurrences of the
particular operator; an <phrase>_</phrase> prefix indicates a literal
operand).  Based on the translated form of the books benchmark
programs.
</caption>
.E_TABLE


<A NAME="1138">3</A>
C99 {ref additive-expression, syntax} {ref additive operators}

.ASIS
<c_syntax>additive-expression:
                multiplicative-expression
                additive-expression</c_syntax> <keyword>+</keyword> <c_syntax>multiplicative-expression
                additive-expression</c_syntax> <keyword>-</keyword> <c_syntax>multiplicative-expression</c_syntax>
.E_ASIS


.TABLE add_op_tok
: l 1.8cm 2.1cm l 1.8cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword>+</keyword>, &zp;1.0&ze;, &zp;77.5&ze;, <keyword>+</keyword> <keyword>sizeof</keyword>, &zp;1.5&ze;, &zp;3.8&ze;
identifier <keyword>-</keyword>, &zp;0.5&ze;, &zp;75.7&ze;, <keyword>+</keyword> <c_syntax>integer-constant</c_syntax>, &zp;33.7&ze;, &zp;1.9&ze;
<keyword>)</keyword> <keyword>-</keyword>, &zp;0.3&ze;, &zp;14.7&ze;, <keyword>-</keyword> <c_syntax>integer-constant</c_syntax>, &zp;44.0&ze;, &zp;1.3&ze;
<keyword>)</keyword> <keyword>+</keyword>, &zp;0.6&ze;, &zp;12.9&ze;, <keyword>+</keyword> identifier, &zp;55.4&ze;, &zp;0.7&ze;
<keyword>+</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.4&ze;, &zp;7.7&ze;, <keyword>+</keyword> <keyword>(</keyword>, &zp;8.3&ze;, &zp;0.4&ze;
<c_syntax>integer-constant</c_syntax> <keyword>+</keyword>, &zp;0.4&ze;, &zp;6.3&ze;, <keyword>-</keyword> identifier, &zp;46.1&ze;, &zp;0.3&ze;
<c_syntax>integer-constant</c_syntax> <keyword>-</keyword>, &zp;0.2&ze;, &zp;5.8&ze;, <keyword>-</keyword> <keyword>(</keyword>, &zp;6.2&ze;, &zp;0.1&ze;
<caption>
Common token pairs involving the additive operators (as a percentage
of all occurrences of each token).  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_TABLE


.FIG
addcons
<caption>
Number of integer constants appearing as the right operand of
additive operators; based on the visible form of the <file>.c</file>
files.
</caption>
.E_FIG


<A NAME="1139">1</A>
C99 {ref addition, operand types}

For addition, either both operands shall have arithmetic type, or one
operand shall be a pointer to an object type and the other shall have
integer type.


.TABLE add_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>int</keyword>, <keyword>+</keyword>, _<keyword>int</keyword>, &zp;37.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>+</keyword>, _<keyword>int</keyword>, &zp;2.6&ze;
<keyword>int</keyword>, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;19.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>-</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.4&ze;
other-types, <keyword>+</keyword>, other-types, &zp;16.2&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>-</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;2.2&ze;
other-types, <keyword>-</keyword>, other-types, &zp;16.0&ze;, <keyword>long</keyword>, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;2.2&ze;
_<keyword>int</keyword>, <keyword>+</keyword>, _<keyword>int</keyword>, &zp;11.8&ze;, _<keyword>int</keyword>, <keyword>-</keyword>, <keyword>int</keyword>, &zp;2.1&ze;
<keyword>int</keyword>, <keyword>-</keyword>, <keyword>int</keyword>, &zp;10.8&ze;, ptr-to, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;2.0&ze;
_<keyword>int</keyword>, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;8.8&ze;, <keyword>long</keyword>, <keyword>-</keyword>, <keyword>long</keyword>, &zp;2.0&ze;
ptr-to, <keyword>-</keyword>, ptr-to, &zp;6.4&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>+</keyword>, _<keyword>int</keyword>, &zp;1.7&ze;
ptr-to, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;6.2&ze;, <keyword>float</keyword>, <keyword>+</keyword>, <keyword>float</keyword>, &zp;1.7&ze;
ptr-to, <keyword>+</keyword>, <keyword>long</keyword>, &zp;5.8&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>-</keyword>, <keyword>int</keyword>, &zp;1.5&ze;
<keyword>float</keyword>, <keyword>-</keyword>, <keyword>float</keyword>, &zp;5.0&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;4.9&ze;, <keyword>int</keyword>, <keyword>-</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.4&ze;
<keyword>int</keyword>, <keyword>+</keyword>, <keyword>int</keyword>, &zp;4.7&ze;, _<keyword>int</keyword>, <keyword>+</keyword>, <keyword>int</keyword>, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;4.2&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>+</keyword>, _<keyword>int</keyword>, &zp;1.2&ze;
ptr-to, <keyword>+</keyword>, <keyword>int</keyword>, &zp;3.7&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
_<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;3.1&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>-</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
ptr-to, <keyword>-</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;3.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.0&ze;
ptr-to, <keyword>+</keyword>, _<keyword>int</keyword>, &zp;3.0&ze;, , , , 
<caption>
Occurrence of additive operators having particular operand types (as
a percentage of all occurrences of each operator; an
<phrase>_</phrase> prefix indicates a literal operand).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1144">3</A>
C99 {ref subtraction, pointer operands}

&emdash;&nbsp; both operands are pointers to qualified or unqualified
versions of compatible object types; or


.TABLE sub_ptr_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>char</keyword> <keyword>*</keyword>, &zp;48.9&ze;, <keyword>void</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;26.2&ze;, <keyword>int</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>int</keyword> <keyword>*</keyword>, &zp;1.4&ze;
<keyword>struct</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>struct</keyword> <keyword>*</keyword>, &zp;13.7&ze;, <keyword>unsigned</keyword> <keyword>short</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword> <keyword>*</keyword>, &zp;1.2&ze;
<keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;4.6&ze;, other-types, <keyword>-</keyword>, other-types, &zp;0.0&ze;
<caption>
Occurrence of operands of the subtraction operator having a pointer
type (as a percentage of all occurrences of this operator with
operands having a pointer type).  Based on the translated form of the
books benchmark programs.
</caption>
.E_TABLE


<A NAME="1145">5</A>
C99

&emdash;&nbsp; the left operand is a pointer to an object type and the
right operand has integer type.


.TABLE addsub_ptr_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;46.0&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>int</keyword>, &zp;1.7&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;27.3&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.7&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>long</keyword>, &zp;26.8&ze;, <keyword>short</keyword> <keyword>*</keyword>, <keyword>-</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.6&ze;
other-types, <keyword>+</keyword>, other-types, &zp;10.6&ze;, <keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.6&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;9.5&ze;, <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, <keyword>int</keyword>, &zp;1.6&ze;
<keyword>struct</keyword> <keyword>*</keyword>, <keyword>-</keyword>, array-index, &zp;9.1&ze;, <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, array-index, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;8.8&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.3&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;7.4&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, array-index, &zp;1.3&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>int</keyword>, &zp;6.6&ze;, <keyword>void</keyword> <keyword>*</keyword>, <keyword>-</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>int</keyword>, &zp;5.7&ze;, <keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>signed</keyword> <keyword>int</keyword>, &zp;1.2&ze;
<keyword>struct</keyword> <keyword>*</keyword>, <keyword>-</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;4.7&ze;, <keyword>unsigned</keyword> <keyword>long</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>int</keyword>, &zp;1.1&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;3.6&ze;, <keyword>struct</keyword> <keyword>*</keyword>, <keyword>+</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>-</keyword>, _<keyword></keyword> <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.1&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.0&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.9&ze;, <keyword>char</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.0&ze;
<keyword>struct</keyword> <keyword>*</keyword>, <keyword>+</keyword>, <keyword>int</keyword>, &zp;1.8&ze;, other-types, <keyword>-</keyword>, other-types, &zp;0.0&ze;
<caption>
Occurrence of additive operators one of whose operands has a pointer
type (as a percentage of all occurrences of each operator having one
operand with a pointer type).  Based on the translated form of the
books benchmark programs.  Note: in the translator used the result of
the <keyword>sizeof</keyword> operator had type <keyword>unsigned
long</keyword>.
</caption>
.E_TABLE


<A NAME="1148">1</A> FP
C99

The result of the binary <keyword>+</keyword> operator is the sum of
the operands.


.TABLE add_ird
Distribution, Increasing Order, Random Order, Decreasing Order, Insertion, Adjacency
Uniform (0&comma; 2&mu;), <equ>0.2&mu;<sup>2</sup>N<sup>3</sup>&sigma;<sup>2</sup></equ>, <equ>0.33&mu;<sup>2</sup>N<sup>3</sup>&sigma;<sup>2</sup></equ>, <equ>0.53&mu;<sup>2</sup>N<sup>3</sup>&sigma;<sup>2</sup></equ>, <equ>2.6&mu;<sup>2</sup>N<sup>2</sup>&sigma;<sup>2</sup></equ>, <equ>2.7&mu;<sup>2</sup>N<sup>2</sup>&sigma;<sup>2</sup></equ>
Exponential (&mu;), <equ>0.13&mu;<sup>2</sup>N<sup>3</sup>&sigma;<sup>2</sup></equ>, <equ>0.33&mu;<sup>2</sup>N<sup>3</sup>&sigma;<sup>2</sup></equ>, <equ>0.63&mu;<sup>2</sup>N<sup>3</sup>&sigma;<sup>2</sup></equ>, <equ>2.63&mu;<sup>2</sup>N<sup>2</sup>&sigma;<sup>2</sup></equ>, <equ>4.0&mu;<sup>2</sup>N<sup>2</sup>&sigma;<sup>2</sup></equ>
<caption>
Mean square error in the result of summing, using five different
algorithms, <equ>N</equ> values having a uniform or exponential
distribution.
</caption>
.E_TABLE


<A NAME="1166">7</A>
C99 {ref shift-expression, syntax}

.ASIS
<c_syntax>shift-expression:
                additive-expression
                shift-expression</c_syntax> <keyword><<</keyword> <c_syntax>additive-expression
                shift-expression</c_syntax> <keyword>>></keyword> <c_syntax>additive-expression</c_syntax>
.E_ASIS


.TABLE shift_op_tok
: l 1.8cm 2.1cm l 1.8cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword>>></keyword>, &zp;0.1&ze;, &zp;63.9&ze;, <keyword>]</keyword> <keyword><<</keyword>, &zp;0.5&ze;, &zp;5.3&ze;
identifier <keyword><<</keyword>, &zp;0.1&ze;, &zp;37.3&ze;, <keyword><<</keyword> <c_syntax>integer-constant</c_syntax>, &zp;63.4&ze;, &zp;0.8&ze;
<c_syntax>integer-constant</c_syntax> <keyword><<</keyword>, &zp;0.5&ze;, &zp;36.1&ze;, <keyword>>></keyword> <c_syntax>integer-constant</c_syntax>, &zp;79.8&ze;, &zp;0.7&ze;
<keyword>)</keyword> <keyword>>></keyword>, &zp;0.2&ze;, &zp;28.0&ze;, <keyword><<</keyword> identifier, &zp;28.4&ze;, &zp;0.1&ze;
<keyword>)</keyword> <keyword><<</keyword>, &zp;0.2&ze;, &zp;20.3&ze;, <keyword><<</keyword> <keyword>(</keyword>, &zp;8.1&ze;, &zp;0.1&ze;
<keyword>]</keyword> <keyword>>></keyword>, &zp;0.4&ze;, &zp;6.2&ze;, <keyword>>></keyword> identifier, &zp;15.9&ze;, &zp;0.0&ze;
<caption>
Common token pairs involving the shift operators (as a percentage of
all occurrences of each token).  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_TABLE


.FIG
shiftcons
<caption>
Number of integer constants appearing as the right operand of the
shift operators.  Based on the visible form of the <file>.c</file>
files.
</caption>
.E_FIG


<A NAME="1167">1</A>
C99

Each of the operands shall have integer type.


.TABLE shift_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>int</keyword>, <keyword>>></keyword>, _<keyword>int</keyword>, &zp;29.4&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;2.8&ze;
_<keyword>int</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;27.1&ze;, _<keyword>long</keyword>, <keyword><<</keyword>, _<keyword>long</keyword>, &zp;2.8&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>>></keyword>, _<keyword>int</keyword>, &zp;26.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>>></keyword>, <keyword>int</keyword>, &zp;2.6&ze;
_<keyword>long</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;11.9&ze;, _<keyword>int</keyword>, <keyword>>></keyword>, _<keyword>int</keyword>, &zp;2.5&ze;
<keyword>int</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;11.8&ze;, <keyword>int</keyword>, <keyword>>></keyword>, <keyword>int</keyword>, &zp;2.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>>></keyword>, _<keyword>int</keyword>, &zp;11.3&ze;, <keyword>long</keyword>, <keyword>>></keyword>, _<keyword>int</keyword>, &zp;2.0&ze;
_<keyword>int</keyword>, <keyword><<</keyword>, <keyword>int</keyword>, &zp;7.3&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>>></keyword>, <keyword>int</keyword>, &zp;1.8&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>>></keyword>, _<keyword>int</keyword>, &zp;7.0&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;1.8&ze;
other-types, <keyword>>></keyword>, other-types, &zp;6.9&ze;, <keyword>long</keyword>, <keyword>>></keyword>, <keyword>int</keyword>, &zp;1.7&ze;
<keyword>int</keyword>, <keyword><<</keyword>, <keyword>int</keyword>, &zp;6.0&ze;, _<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><<</keyword>, <keyword>int</keyword>, &zp;1.3&ze;
other-types, <keyword><<</keyword>, other-types, &zp;5.8&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>>></keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword><<</keyword>, <keyword>int</keyword>, &zp;5.3&ze;, <keyword>signed</keyword> <keyword>long</keyword>, <keyword>>></keyword>, _<keyword>int</keyword>, &zp;1.2&ze;
_<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;4.9&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;4.2&ze;, <keyword>long</keyword>, <keyword><<</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>>></keyword>, _<keyword>int</keyword>, &zp;4.0&ze;, <keyword>int</keyword>, <keyword><<</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><<</keyword>, <keyword>int</keyword>, &zp;3.8&ze;, , , , 
<caption>
Occurrence of shift operators having particular operand types (as a
percentage of all occurrences of each operator; an <phrase>_</phrase>
prefix indicates a literal operand).  Based on the translated form of
the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1182">4</A>
C99 {ref relational-expression, syntax} {ref relational operators, syntax}

.ASIS
<c_syntax>relational-expression:
                shift-expression
                relational-expression</c_syntax> <keyword><</keyword>  <c_syntax>shift-expression
                relational-expression</c_syntax> <keyword>></keyword>  <c_syntax>shift-expression
                relational-expression</c_syntax> <keyword><=</keyword> <c_syntax>shift-expression
                relational-expression</c_syntax> <keyword>>=</keyword> <c_syntax>shift-expression</c_syntax>
.E_ASIS


.TABLE rel_op_tok
: l 1.9cm 2.1cm l 1.9cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword><</keyword>, &zp;0.7&ze;, &zp;87.9&ze;, <keyword>>=</keyword> <c_syntax>character-constant</c_syntax>, &zp;3.6&ze;, &zp;1.5&ze;
identifier <keyword>>=</keyword>, &zp;0.2&ze;, &zp;85.9&ze;, <keyword><</keyword> <c_syntax>integer-constant</c_syntax>, &zp;40.0&ze;, &zp;1.3&ze;
identifier <keyword>></keyword>, &zp;0.3&ze;, &zp;85.0&ze;, <keyword>></keyword> <c_syntax>integer-constant</c_syntax>, &zp;53.2&ze;, &zp;0.9&ze;
identifier <keyword><=</keyword>, &zp;0.1&ze;, &zp;84.8&ze;, <keyword>>=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;41.2&ze;, &zp;0.4&ze;
<keyword>)</keyword> <keyword><=</keyword>, &zp;0.1&ze;, &zp;10.4&ze;, <keyword><</keyword> identifier, &zp;53.9&ze;, &zp;0.4&ze;
<keyword>)</keyword> <keyword>>=</keyword>, &zp;0.1&ze;, &zp;10.1&ze;, <keyword><=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;41.0&ze;, &zp;0.2&ze;
<keyword>)</keyword> <keyword><</keyword>, &zp;0.3&ze;, &zp;9.9&ze;, <keyword>></keyword> identifier, &zp;40.1&ze;, &zp;0.2&ze;
<keyword>)</keyword> <keyword>></keyword>, &zp;0.1&ze;, &zp;9.6&ze;, <keyword>>=</keyword> identifier, &zp;50.0&ze;, &zp;0.1&ze;
<keyword><=</keyword> <c_syntax>character-constant</c_syntax>, &zp;7.1&ze;, &zp;1.7&ze;, <keyword><=</keyword> identifier, &zp;45.7&ze;, &zp;0.1&ze;
<caption>
Common token pairs involving relational operators (as a percentage of
all occurrences of each token).  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_TABLE


.FIG
relatcons
<caption>
Number of integer constants appearing as the right operand of
relational operators.  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_FIG


.TABLE
: l 2.2cm l 2.2cm
Word, Occurrences per Million Words, Word, Occurrences per Million Words
great, 464, less, 344
greater, 154, lesser, &z;18
greatest, &z;51, least, &z;45
greatly, &z;33, &endash;, &endash;
&endash;, &endash;, less than, &z;40
<caption>
Occurrences (per million words) of English words that may
be used in natural language sentences expressing some relative state
of affairs.
Based on data from the British National Corpus <book Leech_01>.
</caption>
.E_TABLE


.TABLE rel_context
: l r r r r
Context, % of <keyword><</keyword>, % of <keyword><=</keyword>, % of <keyword>></keyword>, % of <keyword>>=</keyword>
other contexts, &zp;11.5&ze; (&emdash;), (&emdash;), (&emdash;), (&emdash;)
<keyword>if</keyword> control-expression, &zp;76.7&ze; (&zp;3.4&ze;), (&zp;6.7&ze;), (&zp;1.8&ze;), (&zp;6.0&ze;)
<keyword>for</keyword> control-expression, &zp;7.1&ze; (&zp;3.1&ze;), (&zp;65.9&ze;), (&zp;4.5&ze;), (&zp;2.6&ze;)
<keyword>while</keyword> control-expression, &zp;4.8&ze; (&zp;3.9&ze;), (&zp;12.0&ze;), (&zp;2.2&ze;), (&zp;10.4&ze;)
<keyword>switch</keyword> control-expression, &zp;0.0&ze; (&zp;0.0&ze;), (&zp;0.0&ze;), (&zp;0.0&ze;), (&zp;0.0&ze;)
<caption>
Occurrence of relational operators (as a percentage of all
occurrences of the given operator; the parenthesized value is the
percentage of all occurrences of the context that contains the
operator).  Based on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="1184">2</A>
C99 {ref relational operators, real operands}

&emdash;&nbsp; both operands have real type;


.TABLE rel_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>int</keyword>, <keyword>>=</keyword>, _<keyword>int</keyword>, &zp;35.3&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>></keyword>, _<keyword>int</keyword>, &zp;2.3&ze;
<keyword>int</keyword>, <keyword>></keyword>, _<keyword>int</keyword>, &zp;35.2&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>>=</keyword>, _<keyword>int</keyword>, &zp;2.3&ze;
<keyword>int</keyword>, <keyword><</keyword>, _<keyword>int</keyword>, &zp;34.8&ze;, ptr-to, <keyword><=</keyword>, ptr-to, &zp;2.3&ze;
<keyword>int</keyword>, <keyword><=</keyword>, _<keyword>int</keyword>, &zp;28.2&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>>=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;2.1&ze;
<keyword>int</keyword>, <keyword><</keyword>, <keyword>int</keyword>, &zp;25.5&ze;, <keyword>long</keyword>, <keyword><=</keyword>, <keyword>long</keyword>, &zp;2.1&ze;
<keyword>int</keyword>, <keyword><=</keyword>, <keyword>int</keyword>, &zp;17.5&ze;, <keyword>long</keyword>, <keyword>>=</keyword>, _<keyword>int</keyword>, &zp;2.0&ze;
other-types, <keyword>></keyword>, other-types, &zp;15.8&ze;, <keyword>float</keyword>, <keyword>></keyword>, _<keyword>int</keyword>, &zp;2.0&ze;
other-types, <keyword><</keyword>, other-types, &zp;15.4&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>></keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.9&ze;
<keyword>int</keyword>, <keyword>></keyword>, <keyword>int</keyword>, &zp;15.0&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>></keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.8&ze;
other-types, <keyword><=</keyword>, other-types, &zp;14.5&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>></keyword>, _<keyword>int</keyword>, &zp;1.8&ze;
other-types, <keyword>>=</keyword>, other-types, &zp;13.2&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword><=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.7&ze;
<keyword>enum</keyword>, <keyword><=</keyword>, _<keyword>int</keyword>, &zp;12.6&ze;, ptr-to, <keyword>>=</keyword>, ptr-to, &zp;1.7&ze;
<keyword>int</keyword>, <keyword>>=</keyword>, <keyword>int</keyword>, &zp;10.8&ze;, <keyword>int</keyword>, <keyword><=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.7&ze;
<keyword>enum</keyword>, <keyword>>=</keyword>, <keyword>enum</keyword>, &zp;7.5&ze;, <keyword>float</keyword>, <keyword>></keyword>, <keyword>float</keyword>, &zp;1.7&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>>=</keyword>, <keyword>int</keyword>, &zp;7.3&ze;, <keyword>char</keyword>, <keyword>>=</keyword>, _<keyword>int</keyword>, &zp;1.7&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>></keyword>, _<keyword>int</keyword>, &zp;6.0&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>>=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.6&ze;
<keyword>long</keyword>, <keyword><</keyword>, _<keyword>int</keyword>, &zp;5.3&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>></keyword>, _<keyword>int</keyword>, &zp;1.5&ze;
ptr-to, <keyword>></keyword>, ptr-to, &zp;4.1&ze;, <keyword>double</keyword>, <keyword><=</keyword>, _<keyword>double</keyword>, &zp;1.5&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword><=</keyword>, _<keyword>int</keyword>, &zp;4.0&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword><</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.7&ze;, <keyword>long</keyword>, <keyword>>=</keyword>, <keyword>long</keyword>, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>>=</keyword>, _<keyword>int</keyword>, &zp;3.5&ze;, <keyword>int</keyword>, <keyword><</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.4&ze;
<keyword>char</keyword>, <keyword><=</keyword>, _<keyword>int</keyword>, &zp;3.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.3&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>></keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.3&ze;, <keyword>long</keyword>, <keyword><</keyword>, <keyword>long</keyword>, &zp;1.3&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword><=</keyword>, _<keyword>int</keyword>, &zp;3.1&ze;, _<keyword>long</keyword>, <keyword>>=</keyword>, _<keyword>long</keyword>, &zp;1.3&ze;
<keyword>long</keyword>, <keyword>></keyword>, <keyword>long</keyword>, &zp;2.9&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword><=</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.2&ze;
ptr-to, <keyword><</keyword>, ptr-to, &zp;2.8&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>></keyword>, <keyword>int</keyword>, &zp;1.2&ze;
<keyword>int</keyword>, <keyword><</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;2.7&ze;, <keyword>float</keyword>, <keyword><</keyword>, _<keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><=</keyword>, _<keyword>int</keyword>, &zp;2.6&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword><=</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword><</keyword>, _<keyword>int</keyword>, &zp;2.5&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword><</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
_<keyword>long</keyword>, <keyword>>=</keyword>, <keyword>long</keyword>, &zp;2.5&ze;, <keyword>float</keyword>, <keyword><</keyword>, <keyword>float</keyword>, &zp;1.1&ze;
<keyword>long</keyword>, <keyword>></keyword>, _<keyword>int</keyword>, &zp;2.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>></keyword>, <keyword>int</keyword>, &zp;1.0&ze;
<keyword>enum</keyword>, <keyword>>=</keyword>, _<keyword>int</keyword>, &zp;2.5&ze;, <keyword>long</keyword>, <keyword>>=</keyword>, <keyword>int</keyword>, &zp;1.0&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>>=</keyword>, <keyword>int</keyword>, &zp;2.4&ze;, <keyword>float</keyword>, <keyword><=</keyword>, _<keyword>int</keyword>, &zp;1.0&ze;
<caption>
Occurrence of relational operators having particular operand types
(as a percentage of all occurrences of each operator; an
<phrase>_</phrase> prefix indicates a literal operand).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1185">3</A>
C99 {ref relational operators, pointer operands}

&emdash;&nbsp; both operands are pointers to qualified or unqualified
versions of compatible object types; or


.TABLE rel_ptr_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>char</keyword> <keyword>*</keyword>, <keyword>></keyword>, <keyword>char</keyword> <keyword>*</keyword>, &zp;67.5&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>></keyword>, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;4.0&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>char</keyword> <keyword>*</keyword>, &zp;39.6&ze;, other-types, <keyword>></keyword>, other-types, &zp;3.8&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>char</keyword> <keyword>*</keyword>, &zp;26.9&ze;, <keyword>int</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>int</keyword> <keyword>*</keyword>, &zp;3.6&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>char</keyword> <keyword>*</keyword>, &zp;25.8&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;3.6&ze;
<keyword>struct</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>struct</keyword> <keyword>*</keyword>, &zp;23.2&ze;, <keyword>struct</keyword> <keyword>*</keyword>, <keyword>></keyword>, <keyword>struct</keyword> <keyword>*</keyword>, &zp;3.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;22.8&ze;, <keyword>short</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>short</keyword> <keyword>*</keyword>, &zp;3.0&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;21.0&ze;, other-types, <keyword><</keyword>, other-types, &zp;2.8&ze;
<keyword>short</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>short</keyword> <keyword>*</keyword>, &zp;16.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>*</keyword>, &zp;2.6&ze;
<keyword>struct</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>struct</keyword> <keyword>*</keyword>, &zp;14.9&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;2.6&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;13.4&ze;, <keyword>const</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>const</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;2.0&ze;
<keyword>signed</keyword> <keyword>int</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>signed</keyword> <keyword>int</keyword> <keyword>*</keyword>, &zp;13.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>*</keyword>, <keyword>></keyword>, <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>*</keyword>, &zp;1.9&ze;
<keyword>struct</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>struct</keyword> <keyword>*</keyword>, &zp;13.0&ze;, <keyword>unsigned</keyword> <keyword>long</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword> <keyword>*</keyword>, &zp;1.8&ze;
<keyword>void</keyword> <keyword>*</keyword>, <keyword>></keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;11.0&ze;, other-types, <keyword><=</keyword>, other-types, &zp;1.8&ze;
<keyword>void</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;9.4&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;1.8&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>></keyword>, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;8.7&ze;, <keyword>void</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;1.6&ze;
<keyword>unsigned</keyword> <keyword>short</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword> <keyword>*</keyword>, &zp;7.9&ze;, <keyword>unsigned</keyword> <keyword>short</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword> <keyword>*</keyword>, &zp;1.2&ze;
<keyword>const</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>const</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;4.9&ze;, <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>*</keyword>, &zp;1.2&ze;
ptr-to <keyword>*</keyword>, <keyword><</keyword>, ptr-to <keyword>*</keyword>, &zp;4.8&ze;, <keyword>union</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>union</keyword> <keyword>*</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>short</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword> <keyword>*</keyword>, &zp;4.7&ze;, <keyword>int</keyword> <keyword>*</keyword>, <keyword><</keyword>, <keyword>int</keyword> <keyword>*</keyword>, &zp;1.2&ze;
<keyword>const</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>>=</keyword>, <keyword>const</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;4.7&ze;, <keyword>int</keyword> <keyword>*</keyword>, <keyword><=</keyword>, <keyword>int</keyword> <keyword>*</keyword>, &zp;1.2&ze;
<caption>
Occurrence of relational operators (as a percentage of all
occurrences of each operator with operands having a pointer type)
having particular operand pointer types.  Based on the translated
form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1197">3</A>
C99 {ref equality operators, syntax}

.ASIS
<c_syntax>equality-expression:
                relational-expression
                equality-expression</c_syntax> <keyword>==</keyword> <c_syntax>relational-expression
                equality-expression</c_syntax> <keyword>!=</keyword> <c_syntax>relational-expression</c_syntax>
.E_ASIS


.FIG
dehaene95
<caption>
Reaction time (in milliseconds) and error rates for same/different
judgment for values between one and nine, expressed in Arabic or Word
form.  Adapted from Dehaene and Akhavein <book Dehaene_95>.
</caption>
.E_FIG


.TABLE equal_op_tok
: l 1.9cm 2.1cm l 1.9cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword>!=</keyword>, &zp;0.6&ze;, &zp;69.2&ze;, <keyword>]</keyword> <keyword>!=</keyword>, &zp;1.4&ze;, &zp;5.1&ze;
identifier <keyword>==</keyword>, &zp;1.2&ze;, &zp;67.9&ze;, <keyword>==</keyword> <keyword>-v</keyword>, &zp;2.6&ze;, &zp;3.5&ze;
<keyword>)</keyword> <keyword>==</keyword>, &zp;1.6&ze;, &zp;25.1&ze;, <keyword>==</keyword> <c_syntax>integer-constant</c_syntax>, &zp;25.5&ze;, &zp;2.0&ze;
<keyword>)</keyword> <keyword>!=</keyword>, &zp;0.8&ze;, &zp;24.7&ze;, <keyword>==</keyword> identifier, &zp;62.1&ze;, &zp;1.1&ze;
<keyword>==</keyword> <c_syntax>character-constant</c_syntax>, &zp;7.1&ze;, &zp;22.8&ze;, <keyword>!=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;22.7&ze;, &zp;0.9&ze;
<keyword>!=</keyword> <c_syntax>character-constant</c_syntax>, &zp;5.3&ze;, &zp;8.4&ze;, <keyword>!=</keyword> identifier, &zp;65.0&ze;, &zp;0.6&ze;
<keyword>]</keyword> <keyword>==</keyword>, &zp;3.1&ze;, &zp;5.6&ze;, , , 
<caption>
Common token pairs involving the equality operators (as a percentage
of all occurrences of each token).  Based on the visible form of the
<file>.c</file> files.  Note: entries do not always sum to 100%
because several token sequences that have very low percentages are
not listed.
</caption>
.E_TABLE


.FIG
equalcons
<caption>
Number of integer constants appearing as the right operand of
equality operators.  Based on the visible form of the <file>.c</file>
files.
</caption>
.E_FIG


<A NAME="1199">2</A>
C99 {ref equality operators, arithmetic operands}

&emdash;&nbsp; both operands have arithmetic type;


.TABLE equal_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
ptr-to, <keyword>!=</keyword>, ptr-to, &zp;28.5&ze;, <keyword>char</keyword>, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;3.9&ze;
<keyword>int</keyword>, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;21.1&ze;, ptr-to, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;3.5&ze;
<keyword>int</keyword>, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;15.8&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>!=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.5&ze;
ptr-to, <keyword>==</keyword>, ptr-to, &zp;15.3&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;2.2&ze;
other-types, <keyword>==</keyword>, other-types, &zp;12.7&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;2.0&ze;
other-types, <keyword>!=</keyword>, other-types, &zp;12.6&ze;, int:16 &zs;16&ze;, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;2.0&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;9.5&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>!=</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.9&ze;
<keyword>enum</keyword>, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;9.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>!=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.9&ze;
int:16 &zs;16&ze;, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;8.2&ze;, ptr-to, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;1.8&ze;
<keyword>int</keyword>, <keyword>!=</keyword>, <keyword>int</keyword>, &zp;6.5&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;1.7&ze;
<keyword>int</keyword>, <keyword>==</keyword>, <keyword>int</keyword>, &zp;6.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>==</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.7&ze;
<keyword>char</keyword>, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;5.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;1.6&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;4.8&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>!=</keyword>, _<keyword>long</keyword>, &zp;1.3&ze;
<keyword>enum</keyword>, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;4.8&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>!=</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.3&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>!=</keyword>, _<keyword>int</keyword>, &zp;4.4&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>==</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>==</keyword>, _<keyword>int</keyword>, &zp;4.0&ze;, , , , 
<caption>
Occurrence of equality operators having particular operand types (as
a percentage of all occurrences of each operator).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1200">3</A>
C99 {ref equality operators, pointer to compatible types}

&emdash;&nbsp; both operands are pointers to qualified or unqualified
versions of compatible types;


.TABLE equal_ptr_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>struct</keyword> <keyword>*</keyword>, <keyword>==</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;59.9&ze;, <keyword>int</keyword> <keyword>*</keyword>, <keyword>!=</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;3.0&ze;
<keyword>struct</keyword> <keyword>*</keyword>, <keyword>!=</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;52.2&ze;, <keyword>void</keyword> <keyword>*</keyword>, <keyword>==</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;2.2&ze;
<keyword>union</keyword> <keyword>*</keyword>, <keyword>!=</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;18.3&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>==</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.8&ze;
<keyword>union</keyword> <keyword>*</keyword>, <keyword>==</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;18.1&ze;, <keyword>int</keyword>, <keyword>==</keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;1.4&ze;
other-types, <keyword>==</keyword>, other-types, &zp;8.1&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>!=</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.4&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>!=</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;8.1&ze;, <keyword>int</keyword>, <keyword>!=</keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;1.3&ze;
<keyword>char</keyword> <keyword>*</keyword>, <keyword>==</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;7.3&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, <keyword>==</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.1&ze;
array-index, <keyword>!=</keyword>, <keyword>void</keyword> <keyword>*</keyword>, &zp;6.9&ze;, ptr-to <keyword>*</keyword>, <keyword>!=</keyword>, _<keyword></keyword> <keyword>int</keyword>, &zp;1.1&ze;
other-types, <keyword>!=</keyword>, other-types, &zp;6.4&ze;, <keyword>char</keyword> <keyword>*</keyword>, <keyword>!=</keyword>, array-index, &zp;1.1&ze;
<caption>
Occurrence of equality operators having particular operand pointer
types (as a percentage of all occurrences of each operator with
operands having a pointer type; <phrase>_int</phrase> is probably the
<c_code>0</c_code> representation of the null-pointer constant).
Based on the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1219">2</A>
C99 {ref AND-expression, syntax} {ref bitwise, &}

.ASIS
<c_syntax>AND-expression:
                equality-expression
                AND-expression</c_syntax> <keyword>&</keyword> <c_syntax>equality-expression</c_syntax>
.E_ASIS


.TABLE bitwise_op_tok
: l 1.9cm 2.1cm l 1.9cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword>|</keyword>, &zp;0.4&ze;, &zp;74.0&ze;, <keyword>&</keyword> identifier, &zp;57.1&ze;, &zp;0.6&ze;
identifier <keyword>&</keyword>, &zp;0.7&ze;, &zp;67.5&ze;, <keyword>|</keyword> identifier, &zp;79.8&ze;, &zp;0.4&ze;
identifier <keyword>^</keyword>, &zp;0.0&ze;, &zp;51.1&ze;, <keyword>&</keyword> <keyword>(</keyword>, &zp;7.4&ze;, &zp;0.3&ze;
<keyword>)</keyword> <keyword>^</keyword>, &zp;0.0&ze;, &zp;38.7&ze;, <keyword>|</keyword> <keyword>(</keyword>, &zp;14.4&ze;, &zp;0.3&ze;
<keyword>&</keyword> <keyword>~</keyword>, &zp;4.6&ze;, &zp;30.1&ze;, <keyword>^</keyword> <keyword>*v</keyword>, &zp;5.5&ze;, &zp;0.1&ze;
<keyword>)</keyword> <keyword>&</keyword>, &zp;1.1&ze;, &zp;27.7&ze;, <keyword>|</keyword> <c_syntax>integer-constant</c_syntax>, &zp;5.5&ze;, &zp;0.1&ze;
<keyword>)</keyword> <keyword>|</keyword>, &zp;0.4&ze;, &zp;20.8&ze;, <keyword>^</keyword> <c_syntax>integer-constant</c_syntax>, &zp;20.8&ze;, &zp;0.0&ze;
<keyword>]</keyword> <keyword>^</keyword>, &zp;0.0&ze;, &zp;5.1&ze;, <keyword>^</keyword> identifier, &zp;55.5&ze;, &zp;0.0&ze;
<keyword>]</keyword> <keyword>&</keyword>, &zp;1.4&ze;, &zp;4.2&ze;, <keyword>^</keyword> <keyword>(</keyword>, &zp;16.1&ze;, &zp;0.0&ze;
<keyword>&</keyword> <c_syntax>integer-constant</c_syntax>, &zp;30.6&ze;, &zp;1.5&ze;, , , 
<caption>
Common token pairs involving one of the operators
<keyword>&</keyword>, <keyword>|</keyword>, or <keyword>^</keyword>
(as a percentage of all occurrences of each token).  Based on the
visible form of the <file>.c</file> files.  Note: entries do not
always sum to 100% because several token sequences that have very low
percentages are not listed.
</caption>
.E_TABLE


.TABLE and_context
: l r r
Context, Binary <keyword>&</keyword>, <keyword>&&</keyword>
other contexts, &zp;45.3&ze; (&emdash;), (&emdash;)
<keyword>for</keyword> control-expression, &zp;0.3&ze; (&zp;0.6&ze;), (&zp;4.7&ze;)
<keyword>while</keyword> control-expression, &zp;2.1&ze; (&zp;8.1&ze;), (&zp;18.4&ze;)
<keyword>if</keyword> control-expression, &zp;51.4&ze; (&zp;10.5&ze;), (&zp;10.4&ze;)
<keyword>switch</keyword> control-expression, &zp;0.8&ze; (&zp;5.2&ze;), (&zp;0.0&ze;)
<caption>
Occurrence of the <keyword>&</keyword> and <keyword>&&</keyword>
operator (as a percentage of all occurrences of each operator; the
parenthesized value is the percentage of all occurrences of the
context that contains the operator).  Based on the visible form of
the <file>.c</file> files.
</caption>
.E_TABLE


.FIG
bandcons
<caption>
Number of integer constants appearing as the right operand of the
binary <keyword>&</keyword> operator.  Based on the visible form of
the <file>.c</file> files.
</caption>
.E_FIG


<A NAME="1220">1</A>
C99 {ref & binary, operand type}

Each of the operands shall have integer type.


.TABLE bitwise_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>int</keyword>, <keyword>|</keyword>, _<keyword>int</keyword>, &zp;27.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>|</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;4.0&ze;
<keyword>int</keyword>, <keyword>&</keyword>, _<keyword>int</keyword>, &zp;24.3&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>&</keyword>, _<keyword>int</keyword>, &zp;3.8&ze;
_<keyword>int</keyword>, <keyword>|</keyword>, _<keyword>int</keyword>, &zp;23.0&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>|</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;3.4&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>^</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;17.7&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>^</keyword>, _<keyword>int</keyword>, &zp;3.3&ze;
other-types, <keyword>&</keyword>, other-types, &zp;13.9&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>^</keyword>, <keyword>int</keyword>, &zp;3.1&ze;
<keyword>int</keyword>, <keyword>|</keyword>, <keyword>int</keyword>, &zp;13.6&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>&</keyword>, <keyword>int</keyword>, &zp;2.6&ze;
_<keyword>int</keyword>, <keyword>^</keyword>, _<keyword>int</keyword>, &zp;13.5&ze;, <keyword>long</keyword>, <keyword>^</keyword>, <keyword>long</keyword>, &zp;2.6&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>^</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;12.2&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>&</keyword>, <keyword>int</keyword>, &zp;2.5&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>&</keyword>, _<keyword>int</keyword>, &zp;11.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>|</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.4&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>&</keyword>, _<keyword>int</keyword>, &zp;10.3&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>&</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.0&ze;
<keyword>int</keyword>, <keyword>^</keyword>, _<keyword>int</keyword>, &zp;10.3&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>^</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.8&ze;
other-types, <keyword>^</keyword>, other-types, &zp;9.9&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>^</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.7&ze;
<keyword>int</keyword>, <keyword>^</keyword>, <keyword>int</keyword>, &zp;9.8&ze;, <keyword>int</keyword>, <keyword>^</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.7&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>|</keyword>, <keyword>int</keyword>, &zp;9.6&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>&</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.5&ze;
other-types, <keyword>|</keyword>, other-types, &zp;8.9&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>^</keyword>, _<keyword>int</keyword>, &zp;1.5&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>&</keyword>, _<keyword>int</keyword>, &zp;7.1&ze;, <keyword>long</keyword>, <keyword>&</keyword>, <keyword>int</keyword>, &zp;1.4&ze;
<keyword>int</keyword>, <keyword>&</keyword>, <keyword>int</keyword>, &zp;6.3&ze;, <keyword>int</keyword>, <keyword>|</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>&</keyword>, <keyword>int</keyword>, &zp;5.7&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>&</keyword>, <keyword>int</keyword>, &zp;1.3&ze;
<keyword>long</keyword>, <keyword>|</keyword>, <keyword>long</keyword>, &zp;5.5&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>^</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.3&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>&</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;4.6&ze;, <keyword>long</keyword>, <keyword>&</keyword>, _<keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>^</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;4.6&ze;, _<keyword>int</keyword>, <keyword>|</keyword>, <keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>^</keyword>, _<keyword>int</keyword>, &zp;4.2&ze;, <keyword>int</keyword>, <keyword>^</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.1&ze;
<caption>
Occurrence of bitwise operators having particular operand types (as a
percentage of all occurrences of each operator).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1222">1</A>
C99 {ref bitwise AND, result}

The result of the binary <keyword>&</keyword> operator is the bitwise
AND of the operands (that is, each bit in the result is set if and
only if each of the corresponding bits in the converted operands is
set).


.TABLE
: L c c
 , 0, 1
0, 0, 0
1, 0, 1
.E_TABLE


<A NAME="1228">1</A>
C99

The result of the <keyword>^</keyword> operator is the bitwise
exclusive OR of the operands (that is, each bit in the result is set
if and only if exactly one of the corresponding bits in the converted
operands is set).


.TABLE
: L c c
 , 0, 1
0, 0, 1
1, 1, 0
.E_TABLE


<A NAME="1229">2</A>
C99 {ref inclusive-OR-expression, syntax}

.ASIS
<c_syntax>inclusive-OR-expression:
                exclusive-OR-expression
                inclusive-OR-expression</c_syntax> <keyword>|</keyword> <c_syntax>exclusive-OR-expression</c_syntax>
.E_ASIS


.TABLE or_context
: l r r
Context, <keyword>|</keyword>, <keyword>||</keyword>
other contexts, &zp;90.7&ze; (&emdash;), (&emdash;)
<keyword>if</keyword> control-expression, &zp;8.8&ze; (&zp;0.7&ze;), (&zp;6.9&ze;)
<keyword>while</keyword> control-expression, &zp;0.3&ze; (&zp;0.5&ze;), (&zp;2.7&ze;)
<keyword>for</keyword> control-expression, &zp;0.0&ze; (&zp;0.0&ze;), (&zp;0.2&ze;)
<keyword>switch</keyword> control-expression, &zp;0.1&ze; (&zp;0.3&ze;), (&zp;0.0&ze;)
<caption>
Occurrence of the <keyword>|</keyword> and <keyword>||</keyword>
operator (as a percentage of all occurrences of each operator; the
parenthesized value is the percentage of all occurrences of the
context that contains the operator).  Based on the visible form of
the <file>.c</file> files.
</caption>
.E_TABLE


.FIG
borcons
<caption>
Number of integer constants appearing as the right operand of the
bitwise-OR operator.  Based on the visible form of the <file>.c</file>
files.
</caption>
.E_FIG


<A NAME="1232">1</A>
C99

The result of the <keyword>|</keyword> operator is the bitwise
inclusive OR of the operands (that is, each bit in the result is set
if and only if at least one of the corresponding bits in the
converted operands is set).


.TABLE
: L c c
 , 0, 1
0, 0, 1
1, 1, 1
.E_TABLE


<A NAME="1233">2</A>
C99 {ref logical-AND-expression, syntax}

.ASIS
<c_syntax>logical-AND-expression:
                inclusive-OR-expression
                logical-AND-expression</c_syntax> <keyword>&&</keyword> <c_syntax>inclusive-OR-expression</c_syntax>
.E_ASIS


.TABLE bool_algebra
: c c
Relative Order Preserved, Expression &Rightarrow; Alternative Representation
 , Distributive laws
no, <c_code>(A && B) || (A && C)</c_code> &Rightarrow; <c_code>A && (B || C)</c_code>
no, <c_code>(A || B) && (A || C)</c_code> &Rightarrow;  <c_code>A || (B && C)</c_code>

 , DeMorgan's theorem
yes, <c_code>!(A || B)</c_code> &Rightarrow; <c_code>(!A) && (!B)</c_code>
yes, <c_code>!(A && B)</c_code> &Rightarrow; <c_code>(!A) || (!B)</c_code>

 , Other identities
yes, <c_code>A && ((!A) || B)</c_code> &Rightarrow; <c_code>A && B</c_code>
yes, <c_code>A || ((!A) && B)</c_code> &Rightarrow; <c_code>A || B</c_code>

 , The consensus identities
no, <c_code>(A && B) || ((!A) && C) || (B && C)</c_code> &Rightarrow; <c_code>(A && B) || ((!A) && C))</c_code>
yes, <c_code>(A && B) || (A && (!B) && C)</c_code> &Rightarrow; <c_code>(A && B) || (A && C)</c_code>
yes, <c_code>(A && B) || ((!A) && C)</c_code> &Rightarrow; <c_code>((!A) || B) && (A || C)</c_code>
<caption>
Various identities in boolean algebra expressed using the
<keyword>||</keyword> and <keyword>&&</keyword> operators.  Use of
these identities may change the number of times a particular
expression is evaluated (which is sometimes the rationale for the
writing it).  The relative order in which expressions are evaluated
may also change (e.g., in <c_code>A==1</c_code> and
<c_code>B==0</c_code> the order of evaluation is A&Rightarrow;
B&Rightarrow; A&Rightarrow; C but after use of the distributive law
the order becomes A&Rightarrow; B&Rightarrow; C.
</caption>
.E_TABLE


.TABLE logical_op_tok
: l 1.9cm 2.1cm l 1.9cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword>&&</keyword>, &zp;0.4&ze;, &zp;48.5&ze;, <keyword>&&</keyword> defined, &zp;0.9&ze;, &zp;6.2&ze;
<keyword>)</keyword> <keyword>||</keyword>, &zp;0.9&ze;, &zp;42.7&ze;, <keyword>||</keyword> <keyword>!</keyword>, &zp;11.3&ze;, &zp;6.0&ze;
identifier <keyword>||</keyword>, &zp;0.2&ze;, &zp;39.3&ze;, <c_syntax>character-constant</c_syntax> <keyword>||</keyword>, &zp;4.2&ze;, &zp;4.2&ze;
<keyword>)</keyword> <keyword>&&</keyword>, &zp;1.1&ze;, &zp;34.9&ze;, <c_syntax>character-constant</c_syntax> <keyword>&&</keyword>, &zp;5.3&ze;, &zp;3.3&ze;
<keyword>||</keyword> defined, &zp;4.8&ze;, &zp;21.0&ze;, <keyword>&&</keyword> <keyword>(</keyword>, &zp;28.7&ze;, &zp;0.9&ze;
<c_syntax>integer-constant</c_syntax> <keyword>||</keyword>, &zp;0.3&ze;, &zp;12.4&ze;, <keyword>||</keyword> <keyword>(</keyword>, &zp;29.7&ze;, &zp;0.6&ze;
<c_syntax>integer-constant</c_syntax> <keyword>&&</keyword>, &zp;0.4&ze;, &zp;11.5&ze;, <keyword>&&</keyword> identifier, &zp;53.9&ze;, &zp;0.5&ze;
<keyword>&&</keyword> <keyword>!</keyword>, &zp;13.5&ze;, &zp;11.3&ze;, <keyword>||</keyword> identifier, &zp;51.8&ze;, &zp;0.3&ze;
<caption>
Common token pairs involving <keyword>&&</keyword>, or
<keyword>||</keyword> (as a percentage of all occurrences of each
token).  Based on the visible form of the <file>.c</file> files.
Note: entries do not always sum to 100% because several token
sequences that have very low percentages are not listed.
</caption>
.E_TABLE


<A NAME="1234">1</A>
C99 {ref &&, operand type}

Each of the operands shall have scalar type.


.TABLE logical_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>int</keyword>, <keyword>||</keyword>, <keyword>int</keyword>, &zp;87.7&ze;, _<keyword>long</keyword>, <keyword>||</keyword>, _<keyword>long</keyword>, &zp;2.2&ze;
<keyword>int</keyword>, <keyword>&&</keyword>, <keyword>int</keyword>, &zp;73.9&ze;, <keyword>int</keyword>, <keyword>&&</keyword>, ptr-to, &zp;2.2&ze;
other-types, <keyword>&&</keyword>, other-types, &zp;12.8&ze;, <keyword>int</keyword>, <keyword>&&</keyword>, <keyword>char</keyword>, &zp;1.8&ze;
other-types, <keyword>||</keyword>, other-types, &zp;8.4&ze;, <keyword>int</keyword>, <keyword>||</keyword>, _<keyword>long</keyword>, &zp;1.7&ze;
ptr-to, <keyword>&&</keyword>, <keyword>int</keyword>, &zp;4.5&ze;, <keyword>int</keyword>, <keyword>&&</keyword>, _<keyword>int</keyword>, &zp;1.3&ze;
<keyword>char</keyword>, <keyword>&&</keyword>, <keyword>int</keyword>, &zp;2.3&ze;, ptr-to, <keyword>&&</keyword>, ptr-to, &zp;1.1&ze;
<caption>
Occurrence of logical operators having particular operand types (as a
percentage of all occurrences of each operator).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1240">3</A>
C99 {ref &&, second operand}

If the first operand compares equal to 0, the second operand is not
evaluated.


.TABLE A_or_B_and_C
: c c c c c
Case,   A,       B,       C,       Result
 1,   FALSE,   FALSE,   TRUE,       FALSE
 2,   TRUE,    FALSE,   TRUE,       TRUE
 3,   FALSE,   TRUE,    TRUE,       TRUE
 4,   FALSE,   TRUE,    FALSE,      FALSE
<caption>
Truth table showing how each operand of <c_code>(A || (B &&
C))</c_code> can affect its result.  Case 1 and 2 show that
<c_code>A</c_code> affects the outcome; in Case 2 and 3 that
<c_code>B</c_code> affects the outcome; Case 3 and 4 that
<c_code>C</c_code> affects the outcome.
</caption>
.E_TABLE


<A NAME="1249">4</A>
C99 {ref conditional-expression, syntax}

.ASIS
<c_syntax>conditional-expression:
                logical-OR-expression
                logical-OR-expression</c_syntax> <keyword>?</keyword> <c_syntax>expression</c_syntax> <keyword>:</keyword> <c_syntax>conditional-expression</c_syntax>
.E_ASIS


.TABLE ternary_op_tok
: l 1.9cm 2.1cm l 1.9cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
<keyword>)</keyword> <keyword>?</keyword>, &zp;0.4&ze;, &zp;44.7&ze;, <keyword>?</keyword> <c_syntax>string-literal</c_syntax>, &zp;20.1&ze;, &zp;1.5&ze;
identifier <keyword>?</keyword>, &zp;0.1&ze;, &zp;44.0&ze;, <keyword>?:</keyword> <c_syntax>integer-constant</c_syntax>, &zp;28.7&ze;, &zp;0.3&ze;
identifier <keyword>?:</keyword>, &zp;0.1&ze;, &zp;40.3&ze;, <keyword>?</keyword> <c_syntax>integer-constant</c_syntax>, &zp;20.2&ze;, &zp;0.2&ze;
<c_syntax>integer-constant</c_syntax> <keyword>?:</keyword>, &zp;0.3&ze;, &zp;23.1&ze;, <keyword>?</keyword> identifier, &zp;43.9&ze;, &zp;0.1&ze;
<c_syntax>string-literal</c_syntax> <keyword>?:</keyword>, &zp;1.5&ze;, &zp;20.2&ze;, <keyword>?:</keyword> identifier, &zp;35.9&ze;, &zp;0.1&ze;
<keyword>)</keyword> <keyword>?:</keyword>, &zp;0.1&ze;, &zp;11.6&ze;, <keyword>?:</keyword> <keyword>(</keyword>, &zp;7.2&ze;, &zp;0.1&ze;
<c_syntax>integer-constant</c_syntax> <keyword>?</keyword>, &zp;0.1&ze;, &zp;9.6&ze;, <keyword>?</keyword> <keyword>(</keyword>, &zp;6.2&ze;, &zp;0.1&ze;
<keyword>?:</keyword> <c_syntax>string-literal</c_syntax>, &zp;21.0&ze;, &zp;1.6&ze;, , , 
<caption>
Common token pairs involving <keyword>?</keyword> or
<keyword>:</keyword> (denoted by the character sequence
<keyword>?:</keyword>) (as a percentage of all occurrences of each
token).  Based on the visible form of the <file>.c</file> files.
Note: entries do not always sum to 100% because several token
sequences that have very low percentages are not listed.
</caption>
.E_TABLE


<A NAME="1251">1</A>
C99 {ref conditional operator, second and third operands}

One of the following shall hold for the second and third operands:


.TABLE ternary_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
ptr-to, <keyword>?:</keyword>, ptr-to, &zp;29.5&ze;, <keyword>int</keyword>, <keyword>?:</keyword>, _<keyword>int</keyword>, &zp;5.7&ze;
other-types, <keyword>?:</keyword>, other-types, &zp;12.1&ze;, _<keyword>char</keyword>, <keyword>?:</keyword>, _<keyword>char</keyword>, &zp;3.4&ze;
_<keyword>int</keyword>, <keyword>?:</keyword>, _<keyword>int</keyword>, &zp;10.4&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>?:</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;2.2&ze;
<keyword>int</keyword>, <keyword>?:</keyword>, <keyword>int</keyword>, &zp;10.0&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>?:</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.2&ze;
<keyword>void</keyword>, <keyword>?:</keyword>, <keyword>void</keyword>, &zp;9.4&ze;, <keyword>signed</keyword> <keyword>int</keyword>, <keyword>?:</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>?:</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;7.9&ze;, <keyword>char</keyword>, <keyword>?:</keyword>, <keyword>void</keyword>, &zp;1.1&ze;
_<keyword>int</keyword>, <keyword>?:</keyword>, <keyword>int</keyword>, &zp;6.0&ze;, , , , 
<caption>
Occurrence of the ternary operator having particular operand types
(as a percentage of all occurrences of each operator).  Based on the
translated form of the books benchmark programs.  <file>.c</file>
files.
</caption>
.E_TABLE


<A NAME="1273">8</A>
C99 {ref assignment-expression, syntax}

.ASIS
<c_syntax>assignment-expression:
                conditional-expression
                unary-expression assignment-operator assignment-expression</c_syntax>

<c_syntax>assignment-operator:</c_syntax> one of
                <keyword>=  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=</keyword>
.E_ASIS


.TABLE
: l r r l r r
Program,  Leaf,   Non-Leaf, Program,  Leaf,   Non-Leaf
burg,     34.3,    7.7, eqntott,   0.0,   11.4
ditroff,   8.3,    8.3, espresso,  6.5,    3.9
tex,      15.1,    9.8, gcc,       9.6,   12.0
xfig,      8.0,   11.7, li,        0.0,   16.3
xtex,      8.3,   11.2, sc,        1.2,   11.1
compress, 83.5,    9.2, Mean,     15.9,   10.2
<caption>
Occurrence of executed store instructions (as a percentage of all
instructions executed for various program) in two different kinds of
functions (<phrase>Leaf</phrase> functions do not call any other
functions, while <phrase>Non-Leaf</phrase> do).
Adapted from Calder, Grunwald, and Zorn <book Calder_95b>.
</caption>
.E_TABLE


.TABLE assign_op_tok
: l 1.9cm 2.1cm l 1.9cm 2.1cm
Token Sequence, % Occurrence of First Token, % Occurrence of Second Token, Token Sequence, % Occurrence of First Token, % Occurrence of Second Token
identifier <keyword>%=</keyword>, &zp;0.0&ze;, &zp;100.0&ze;, <keyword>v++</keyword> <keyword>=</keyword>, &zp;7.6&ze;, &zp;0.7&ze;
identifier <keyword>/=</keyword>, &zp;0.0&ze;, &zp;99.3&ze;, <keyword>+=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;21.7&ze;, &zp;0.3&ze;
identifier <keyword>>>=</keyword>, &zp;0.0&ze;, &zp;99.3&ze;, <keyword>|=</keyword> identifier, &zp;77.0&ze;, &zp;0.2&ze;
identifier <keyword><<=</keyword>, &zp;0.0&ze;, &zp;97.5&ze;, <keyword>+=</keyword> identifier, &zp;68.0&ze;, &zp;0.2&ze;
identifier <keyword>+=</keyword>, &zp;0.3&ze;, &zp;96.3&ze;, <keyword>>>=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;87.1&ze;, &zp;0.1&ze;
identifier <keyword>*=</keyword>, &zp;0.0&ze;, &zp;96.0&ze;, <keyword>-=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;24.2&ze;, &zp;0.1&ze;
identifier <keyword>-=</keyword>, &zp;0.1&ze;, &zp;95.2&ze;, <keyword>&=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;12.4&ze;, &zp;0.1&ze;
identifier <keyword>|=</keyword>, &zp;0.3&ze;, &zp;93.9&ze;, <keyword>|=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;10.7&ze;, &zp;0.1&ze;
identifier <keyword>&=</keyword>, &zp;0.1&ze;, &zp;93.1&ze;, <keyword>-=</keyword> identifier, &zp;65.1&ze;, &zp;0.1&ze;
identifier <keyword>=</keyword>, &zp;9.4&ze;, &zp;90.9&ze;, <keyword>+=</keyword> <keyword>(</keyword>, &zp;6.5&ze;, &zp;0.1&ze;
identifier <keyword>^=</keyword>, &zp;0.0&ze;, &zp;85.9&ze;, <keyword>|=</keyword> <keyword>(</keyword>, &zp;12.0&ze;, &zp;0.1&ze;
<keyword>&=</keyword> <keyword>~</keyword>, &zp;75.0&ze;, &zp;52.5&ze;, <keyword><<=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;85.1&ze;, &zp;0.0&ze;
<keyword>=</keyword> <keyword>+v</keyword>, &zp;0.0&ze;, &zp;45.1&ze;, <keyword>/=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;52.1&ze;, &zp;0.0&ze;
<keyword>=</keyword> <c_syntax>floating-constant</c_syntax>, &zp;0.1&ze;, &zp;15.7&ze;, <keyword>*=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;39.8&ze;, &zp;0.0&ze;
<keyword>=</keyword> <c_syntax>character-constant</c_syntax>, &zp;0.8&ze;, &zp;14.2&ze;, <keyword>^=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;34.5&ze;, &zp;0.0&ze;
<keyword>=</keyword> <keyword>-v</keyword>, &zp;1.6&ze;, &zp;12.0&ze;, <keyword>%=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;31.5&ze;, &zp;0.0&ze;
<keyword>]</keyword> <keyword>^=</keyword>, &zp;0.0&ze;, &zp;11.1&ze;, <keyword>&=</keyword> identifier, &zp;8.6&ze;, &zp;0.0&ze;
<keyword>=</keyword> <keyword>&v</keyword>, &zp;1.9&ze;, &zp;10.2&ze;, <keyword>%=</keyword> identifier, &zp;68.1&ze;, &zp;0.0&ze;
<keyword>=</keyword> <keyword>*v</keyword>, &zp;1.1&ze;, &zp;9.9&ze;, <keyword>^=</keyword> identifier, &zp;46.4&ze;, &zp;0.0&ze;
<keyword>=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;19.6&ze;, &zp;9.0&ze;, <keyword>*=</keyword> identifier, &zp;44.2&ze;, &zp;0.0&ze;
<keyword>]</keyword> <keyword>=</keyword>, &zp;21.8&ze;, &zp;6.8&ze;, <keyword>/=</keyword> identifier, &zp;34.6&ze;, &zp;0.0&ze;
<keyword>=</keyword> identifier, &zp;62.5&ze;, &zp;6.5&ze;, <keyword><<=</keyword> identifier, &zp;13.4&ze;, &zp;0.0&ze;
<keyword>=</keyword> <keyword>sizeof</keyword>, &zp;0.3&ze;, &zp;5.9&ze;, <keyword>>>=</keyword> identifier, &zp;10.5&ze;, &zp;0.0&ze;
<keyword>]</keyword> <keyword>&=</keyword>, &zp;0.2&ze;, &zp;5.7&ze;, <keyword>#error</keyword> <keyword>=</keyword>, &zp;16.9&ze;, &zp;0.0&ze;
<keyword>]</keyword> <keyword>|=</keyword>, &zp;0.4&ze;, &zp;4.6&ze;, <keyword>-=</keyword> <keyword>(</keyword>, &zp;7.0&ze;, &zp;0.0&ze;
<keyword>=</keyword> <keyword>(</keyword>, &zp;9.1&ze;, &zp;3.5&ze;, <keyword>/=</keyword> <keyword>(</keyword>, &zp;5.8&ze;, &zp;0.0&ze;
<keyword>*=</keyword> <c_syntax>floating-constant</c_syntax>, &zp;6.3&ze;, &zp;1.6&ze;, <keyword>^=</keyword> <keyword>(</keyword>, &zp;13.9&ze;, &zp;0.0&ze;
<caption>
Common token pairs involving the assignment operators (as a
percentage of all occurrences of each token).  Based on the visible
form of the <file>.c</file> files.  Bottom row gives operator
occurrences as percentage of all assignment operators.  Note: entries
do not always sum to 100% because several token sequences that have
very low percentages are not listed.
</caption>
.E_TABLE


<A NAME="1275">1</A>
C99

An assignment operator stores a value in the object designated by the
left operand.


.TABLE silent_store
: l 1.7cm 1.1cm 1.1cm l 1.7cm 1.1cm 1.1cm
Program, Silent stores (PPC/SS), PSSVL (PPC), MPSVL (PPC), Program, Silent stores (PPC/SS), PSSVL (PPC), MPSVL (PPC)
go,       38/27, 30, 36, tomcatv,  47/33, 40, 45
m88ksim,  68/62, 56, 65, swim,     34/26, 20, 19
gcc,      53/46, 37, 49, mgrid,    23/&z;7,  24, 17
compress, 42/39, 35, 16, applu,    37/35, 35, 28
li,       34/20, 32, 34, apsi,     21/25, 22, 20
ijpeg,    43/33, 52, 46, fpppp,    15/15, 15, 14
perl,     49/36, 39, 42, wave5,    25/22, 30, 20
vortex,   64/55, 71, 57, , , , 
<caption>
Percentage of stores that are <phrase>silent</phrase>.  The results
from two instruction sets, the PowerPC (PPC) and SimpleScalar (SS),
are given for silent stores.  The measurements for Program Structure
Store Value Locality (PSSVL) and Message-Passing Store Value Locality
(MPSVL) are for the PowerPC only.  Adapted from Lepak, Bell, and Lipasti
<book Lepak_01>.
</caption>
.E_TABLE


<A NAME="1295">1</A>
C99 {ref compound assignment, constraints}

For the operators <keyword>+=</keyword> and <keyword>-=</keyword>
only, either the left operand shall be a pointer to an object type
and the right shall have integer type, or the left operand shall have
qualified or unqualified arithmetic type and the right shall have
arithmetic type.


.TABLE assign_oprnd
: l c l r l c l r
Left Operand, Operator, Right Operand, %, Left Operand, Operator, Right Operand, %
<keyword>int</keyword>, <keyword>%=</keyword>, _<keyword>int</keyword>, &zp;31.0&ze;, <keyword>double</keyword>, <keyword>*=</keyword>, <keyword>double</keyword>, &zp;3.1&ze;
ptr-to, <keyword>=</keyword>, ptr-to, &zp;29.7&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>/=</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;3.0&ze;
<keyword>int</keyword>, <keyword>*=</keyword>, _<keyword>int</keyword>, &zp;29.5&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>|=</keyword>, <keyword>int</keyword>, &zp;3.0&ze;
<keyword>long</keyword>, <keyword>-=</keyword>, <keyword>long</keyword>, &zp;28.9&ze;, <keyword>int</keyword>, <keyword>/=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.0&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword><<=</keyword>, _<keyword>int</keyword>, &zp;28.3&ze;, <keyword>float</keyword>, <keyword>/=</keyword>, <keyword>int</keyword>, &zp;3.0&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>>>=</keyword>, _<keyword>int</keyword>, &zp;28.2&ze;, <keyword>double</keyword>, <keyword>/=</keyword>, <keyword>double</keyword>, &zp;3.0&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>^=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;26.7&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>+=</keyword>, _<keyword>int</keyword>, &zp;2.9&ze;
<keyword>int</keyword>, <keyword>>>=</keyword>, _<keyword>int</keyword>, &zp;26.2&ze;, <keyword>float</keyword>, <keyword>*=</keyword>, _<keyword>int</keyword>, &zp;2.9&ze;
<keyword>int</keyword>, <keyword><<=</keyword>, _<keyword>int</keyword>, &zp;25.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>+=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.8&ze;
<keyword>int</keyword>, <keyword>/=</keyword>, _<keyword>int</keyword>, &zp;23.8&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>|=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.8&ze;
<keyword>int</keyword>, <keyword>+=</keyword>, <keyword>int</keyword>, &zp;22.1&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>|=</keyword>, <keyword>long</keyword>, &zp;2.8&ze;
other-types, <keyword>=</keyword>, other-types, &zp;20.1&ze;, <keyword>long</keyword>, <keyword>=</keyword>, <keyword>long</keyword>, &zp;2.8&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>&=</keyword>, <keyword>int</keyword>, &zp;19.7&ze;, <keyword>int</keyword>, <keyword>&=</keyword>, _<keyword>int</keyword>, &zp;2.8&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>&=</keyword>, <keyword>int</keyword>, &zp;19.4&ze;, <keyword>float</keyword>, <keyword>=</keyword>, <keyword>float</keyword>, &zp;2.8&ze;
other-types, <keyword>-=</keyword>, other-types, &zp;17.6&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>-=</keyword>, <keyword>int</keyword>, &zp;2.7&ze;
<keyword>int</keyword>, <keyword>-=</keyword>, <keyword>int</keyword>, &zp;17.4&ze;, <keyword>int</keyword>, <keyword>>>=</keyword>, <keyword>int</keyword>, &zp;2.7&ze;
<keyword>long</keyword>, <keyword>^=</keyword>, <keyword>long</keyword>, &zp;16.9&ze;, <keyword>int</keyword>, <keyword>^=</keyword>, <keyword>int</keyword>, &zp;2.7&ze;
<keyword>int</keyword>, <keyword>&=</keyword>, <keyword>int</keyword>, &zp;16.2&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>=</keyword>, _<keyword>int</keyword>, &zp;2.6&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><<=</keyword>, _<keyword>int</keyword>, &zp;15.9&ze;, <keyword>float</keyword>, <keyword>-=</keyword>, <keyword>float</keyword>, &zp;2.6&ze;
other-types, <keyword>+=</keyword>, other-types, &zp;14.9&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.5&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>/=</keyword>, _<keyword>int</keyword>, &zp;12.9&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword><<=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;2.5&ze;
ptr-to, <keyword>+=</keyword>, <keyword>int</keyword>, &zp;12.8&ze;, <keyword>int</keyword>, <keyword><<=</keyword>, <keyword>int</keyword>, &zp;2.5&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>%=</keyword>, _<keyword>int</keyword>, &zp;12.6&ze;, <keyword>float</keyword>, <keyword>/=</keyword>, _<keyword>double</keyword>, &zp;2.5&ze;
<keyword>int</keyword>, <keyword>%=</keyword>, <keyword>int</keyword>, &zp;12.6&ze;, <keyword>int</keyword>, <keyword>*=</keyword>, <keyword>float</keyword>, &zp;2.4&ze;
other-types, <keyword>|=</keyword>, other-types, &zp;12.5&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>|=</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.3&ze;
<keyword>int</keyword>, <keyword>=</keyword>, <keyword>int</keyword>, &zp;12.3&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>&=</keyword>, _<keyword>int</keyword>, &zp;2.2&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>|=</keyword>, _<keyword>int</keyword>, &zp;12.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>-=</keyword>, _<keyword>int</keyword>, &zp;2.2&ze;
<keyword>float</keyword>, <keyword>*=</keyword>, <keyword>float</keyword>, &zp;12.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>^=</keyword>, <keyword>int</keyword>, &zp;2.2&ze;
<keyword>int</keyword>, <keyword>|=</keyword>, _<keyword>int</keyword>, &zp;12.0&ze;, <keyword>char</keyword>, <keyword>=</keyword>, _<keyword>int</keyword>, &zp;2.2&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>|=</keyword>, _<keyword>int</keyword>, &zp;11.7&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>-=</keyword>, <keyword>int</keyword>, &zp;2.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>%=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;11.5&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>+=</keyword>, <keyword>int</keyword>, &zp;2.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>%=</keyword>, _<keyword>int</keyword>, &zp;11.5&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>=</keyword>, _<keyword>int</keyword>, &zp;2.1&ze;
<keyword>int</keyword>, <keyword>/=</keyword>, <keyword>int</keyword>, &zp;11.4&ze;, <keyword>long</keyword>, <keyword>-=</keyword>, _<keyword>int</keyword>, &zp;2.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>^=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;11.3&ze;, <keyword>float</keyword>, <keyword>-=</keyword>, _<keyword>int</keyword>, &zp;2.1&ze;
<keyword>int</keyword>, <keyword>^=</keyword>, _<keyword>int</keyword>, &zp;11.1&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>+=</keyword>, <keyword>int</keyword>, &zp;2.0&ze;
<keyword>int</keyword>, <keyword>=</keyword>, _<keyword>int</keyword>, &zp;11.0&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>/=</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.0&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>>>=</keyword>, _<keyword>int</keyword>, &zp;10.3&ze;, <keyword>long</keyword>, <keyword>+=</keyword>, <keyword>long</keyword>, &zp;2.0&ze;
other-types, <keyword>*=</keyword>, other-types, &zp;10.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword><<=</keyword>, <keyword>int</keyword>, &zp;1.9&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>>>=</keyword>, _<keyword>int</keyword>, &zp;9.5&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>^=</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.8&ze;
<keyword>int</keyword>, <keyword>*=</keyword>, <keyword>int</keyword>, &zp;9.3&ze;, ptr-to, <keyword>+=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.8&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, <keyword><<=</keyword>, _<keyword>int</keyword>, &zp;8.9&ze;, <keyword>int</keyword>, <keyword>-=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.8&ze;
other-types, <keyword>&=</keyword>, other-types, &zp;8.7&ze;, <keyword>float</keyword>, <keyword>*=</keyword>, <keyword>int</keyword>, &zp;1.8&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>*=</keyword>, _<keyword>int</keyword>, &zp;8.4&ze;, <keyword>float</keyword>, <keyword>+=</keyword>, <keyword>float</keyword>, &zp;1.8&ze;
<keyword>int</keyword>, <keyword>-=</keyword>, _<keyword>int</keyword>, &zp;8.0&ze;, <keyword>double</keyword>, <keyword>*=</keyword>, _<keyword>double</keyword>, &zp;1.8&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>&=</keyword>, <keyword>int</keyword>, &zp;7.9&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>&=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.7&ze;
other-types, <keyword>/=</keyword>, other-types, &zp;7.9&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>=</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.7&ze;
<keyword>long</keyword>, <keyword>>>=</keyword>, _<keyword>int</keyword>, &zp;7.7&ze;, <keyword>int</keyword>, <keyword>&=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.7&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>|=</keyword>, <keyword>int</keyword>, &zp;7.5&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>=</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.6&ze;
<keyword>long</keyword>, <keyword>/=</keyword>, _<keyword>int</keyword>, &zp;7.4&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>*=</keyword>, _<keyword>int</keyword>, &zp;1.6&ze;
<keyword>int</keyword>, <keyword>+=</keyword>, _<keyword>int</keyword>, &zp;7.4&ze;, <keyword>int</keyword>, <keyword>-=</keyword>, <keyword>long</keyword>, &zp;1.6&ze;
<keyword>int</keyword>, <keyword>|=</keyword>, <keyword>int</keyword>, &zp;7.4&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>-=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.5&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>%=</keyword>, _<keyword>int</keyword>, &zp;6.9&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>+=</keyword>, <keyword>int</keyword>, &zp;1.5&ze;
other-types, <keyword>^=</keyword>, other-types, &zp;6.7&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>>>=</keyword>, <keyword>int</keyword>, &zp;1.5&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>^=</keyword>, _<keyword>int</keyword>, &zp;6.4&ze;, <keyword>short</keyword>, <keyword>/=</keyword>, _<keyword>int</keyword>, &zp;1.5&ze;
<keyword>float</keyword>, <keyword>/=</keyword>, <keyword>float</keyword>, &zp;6.4&ze;, <keyword>int</keyword>, <keyword>+=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.5&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>|=</keyword>, _<keyword>int</keyword>, &zp;6.2&ze;, <keyword>int</keyword>, <keyword>*=</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.5&ze;
ptr-to, <keyword>+=</keyword>, _<keyword>int</keyword>, &zp;6.2&ze;, <keyword>float</keyword>, <keyword>/=</keyword>, _<keyword>int</keyword>, &zp;1.5&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>|=</keyword>, <keyword>int</keyword>, &zp;6.1&ze;, <keyword>double</keyword>, <keyword>/=</keyword>, <keyword>signed</keyword> <keyword>int</keyword>, &zp;1.5&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>-=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;5.9&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>=</keyword>, <keyword>int</keyword>, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>>>=</keyword>, _<keyword>int</keyword>, &zp;5.8&ze;, <keyword>enum</keyword>, <keyword>=</keyword>, _<keyword>int</keyword>, &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword><<=</keyword>, _<keyword>int</keyword>, &zp;5.7&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>^=</keyword>, _<keyword>int</keyword>, &zp;1.3&ze;
<keyword>long</keyword>, <keyword>+=</keyword>, _<keyword>int</keyword>, &zp;5.6&ze;, <keyword>long</keyword>, <keyword>+=</keyword>, <keyword>int</keyword>, &zp;1.3&ze;
<keyword>long</keyword>, <keyword>*=</keyword>, _<keyword>int</keyword>, &zp;5.3&ze;, <keyword>long</keyword>, <keyword><<=</keyword>, <keyword>int</keyword>, &zp;1.3&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>&=</keyword>, <keyword>int</keyword>, &zp;5.1&ze;, <keyword>char</keyword>, <keyword>&=</keyword>, <keyword>int</keyword>, &zp;1.3&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>/=</keyword>, _<keyword>int</keyword>, &zp;5.0&ze;, <keyword>char</keyword>, <keyword>=</keyword>, <keyword>char</keyword>, &zp;1.3&ze;
other-types, <keyword>>>=</keyword>, other-types, &zp;4.7&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>>>=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>&=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;4.6&ze;, ptr-to, <keyword>-=</keyword>, <keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>|=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;4.6&ze;, <keyword>int</keyword>, <keyword>-=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.2&ze;
<keyword>long</keyword>, <keyword>%=</keyword>, _<keyword>int</keyword>, &zp;4.6&ze;, <keyword>float</keyword>, <keyword>+=</keyword>, _<keyword>int</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>/=</keyword>, _<keyword>int</keyword>, &zp;4.5&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>^=</keyword>, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>&=</keyword>, _<keyword>int</keyword>, &zp;4.3&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>+=</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>|=</keyword>, _<keyword>int</keyword>, &zp;4.1&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>=</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>|=</keyword>, <keyword>int</keyword>, &zp;3.9&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>%=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.1&ze;
<keyword>long</keyword>, <keyword><<=</keyword>, _<keyword>int</keyword>, &zp;3.8&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>^=</keyword>, <keyword>long</keyword>, &zp;1.1&ze;
<keyword>float</keyword>, <keyword>*=</keyword>, _<keyword>double</keyword>, &zp;3.7&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>%=</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>+=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.5&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>>>=</keyword>, <keyword>int</keyword>, &zp;1.1&ze;
other-types, <keyword><<=</keyword>, other-types, &zp;3.5&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>%=</keyword>, <keyword>short</keyword>, &zp;1.1&ze;
<keyword>long</keyword>, <keyword>&=</keyword>, <keyword>int</keyword>, &zp;3.5&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>%=</keyword>, <keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.4&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, <keyword>^=</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>int</keyword>, <keyword>%=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.4&ze;, <keyword>short</keyword>, <keyword>+=</keyword>, <keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>^=</keyword>, <keyword>int</keyword>, &zp;3.3&ze;, <keyword>short</keyword>, <keyword>>>=</keyword>, _<keyword>int</keyword>, &zp;1.1&ze;
<keyword>float</keyword>, <keyword>*=</keyword>, <keyword>double</keyword>, &zp;3.3&ze;, <keyword>long</keyword>, <keyword>%=</keyword>, <keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, <keyword>*=</keyword>, _<keyword>int</keyword>, &zp;3.1&ze;, <keyword>long</keyword>, <keyword>-=</keyword>, <keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>^=</keyword>, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;3.1&ze;, <keyword>int</keyword>, <keyword>+=</keyword>, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, <keyword>^=</keyword>, <keyword>int</keyword>, &zp;3.1&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, <keyword>&=</keyword>, _<keyword>int</keyword>, &zp;1.0&ze;
ptr-to, <keyword>+=</keyword>, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;3.1&ze;, <keyword>enum</keyword>, <keyword>|=</keyword>, _<keyword>int</keyword>, &zp;1.0&ze;
<caption>
Occurrence of assignment operators having particular operand types
(as a percentage of all occurrences of each operator).  Based
on the translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1333">5</A>
C99 {ref declaration, syntax}

.ASIS
<c_syntax>declaration:
                declaration-specifiers init-declarator-list<sub>opt</sub></c_syntax> <keyword>;</keyword>

<c_syntax>declaration-specifiers:
                storage-class-specifier declaration-specifiers<sub>opt</sub>
                type-specifier declaration-specifiers<sub>opt</sub>
                type-qualifier declaration-specifiers<sub>opt</sub>
                function-specifier declaration-specifiers<sub>opt</sub></c_syntax>

<c_syntax>init-declarator-list:
                init-declarator
                init-declarator-list</c_syntax> <keyword>,</keyword> <c_syntax>init-declarator</c_syntax>

<c_syntax>init-declarator:
                declarator
                declarator</c_syntax> <keyword>=</keyword> <c_syntax>initializer</c_syntax>
.E_ASIS


.FIG
howard02
<caption>
The <phrase>lag recency effect</phrase>.  The plot on the left shows
the probability of a subject recalling an item having a given lag,
while the plot on the right gives the time interval between recalling
an item having a given lag (error bars give 95% confidence interval).
If a subject, when asked to remember the list <quote>ABSENCE HOLLOW
PUPIL</quote>, recalled <quote>HOLLOW</quote> then
<quote>PUPIL</quote>, the recall of <quote>PUPIL</quote> would have a
lag of one (<quote>ABSENCE</quote> followed by <quote>PUPIL</quote>
would be a lag of 2).  Had the subject recalled <quote>HOLLOW</quote>
then <quote>ABSENCE</quote>, the recall of <quote>ABSENCE</quote>
would be a lag of minus one.
Adapted from Howard and Kahana <book Howard_02>.
</caption>
.E_FIG


.TABLE obj_decl_type
Type, Embedded, Books' benchmarks
integer, 55.97, 37.5
float, &z;0.05, &z;1.6
pointer, 22.08 (data)/0.23 (code), 48.2
struct/union, &z;9.88, &z;6.1
array, 11.80, &z;6.6
<caption>
Occurrence of types used in declarations of objects (as a percentage
of all types).  Adapted from Engblom <book Engblom_98> and the books
benchmark programs.
</caption>
.E_TABLE


.TABLE loc_obj_type
: l r l r
Type, %, Type, %
<keyword>int</keyword>, &zp;28.1&ze;, <keyword>long</keyword>, &zp;3.0&ze;
<keyword>struct</keyword> <keyword>*</keyword>, &zp;27.7&ze;, <keyword>union</keyword> <keyword>*</keyword>, &zp;2.9&ze;
other-types, &zp;10.8&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.3&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;5.5&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;2.0&ze;
<keyword>struct</keyword>, &zp;4.9&ze;, <keyword>char</keyword>, &zp;1.8&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;4.8&ze;, <keyword>char</keyword> [], &zp;1.5&ze;
<keyword>char</keyword> <keyword>*</keyword>, &zp;3.5&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;1.3&ze;
<caption>
Occurrence of types used to declare objects in block scope (as a
percentage of all such declarations).  Based on the translated form
of the books benchmark programs.
</caption>
.E_TABLE


.TABLE int_obj_type
: l r l r
Type, %, Type, %
<keyword>int</keyword>, &zp;20.9&ze;, <keyword>const</keyword> <keyword>char</keyword> [], &zp;2.4&ze;
other-types, &zp;14.4&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.8&ze;
<keyword>struct</keyword>, &zp;13.0&ze;, <keyword>const</keyword> <keyword>struct</keyword>, &zp;1.8&ze;
<keyword>struct</keyword> <keyword>*</keyword>, &zp;8.2&ze;, <keyword>void</keyword> *(), &zp;1.7&ze;
<keyword>struct</keyword> [], &zp;7.4&ze;, <keyword>const</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> [], &zp;1.6&ze;
<keyword>(</keyword> <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>const</keyword> <keyword>)</keyword> [], &zp;4.0&ze;, <keyword>unsigned</keyword> <keyword>int</keyword> [], &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>char</keyword> [], &zp;3.4&ze;, <keyword>int</keyword> *(), &zp;1.4&ze;
<keyword>unsigned</keyword> <keyword>short</keyword> [], &zp;3.3&ze;, <keyword>(</keyword> <keyword>struct</keyword> <keyword>*</keyword> <keyword>)</keyword> [], &zp;1.3&ze;
<keyword>int</keyword> [], &zp;2.9&ze;, <keyword>(</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>)</keyword> [], &zp;1.3&ze;
<keyword>char</keyword> <keyword>*</keyword>, &zp;2.8&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;1.2&ze;
<keyword>char</keyword> [], &zp;2.7&ze;, <keyword>const</keyword> <keyword>short</keyword> [], &zp;1.2&ze;
<caption>
Occurrence of types used to declare objects with internal linkage (as
a percentage of all such declarations).  Based on the translated form
of the books benchmark programs.
</caption>
.E_TABLE


.TABLE ext_obj_type
: l r l r
Type, %, Type, %
<keyword>int</keyword>, &zp;22.8&ze;, <keyword>char</keyword> <keyword>*</keyword>, &zp;3.2&ze;
<keyword>const</keyword> <keyword>char</keyword> [], &zp;15.4&ze;, <keyword>union</keyword> <keyword>*</keyword>, &zp;3.0&ze;
other-types, &zp;10.6&ze;, <keyword>enum</keyword>, &zp;2.4&ze;
<keyword>struct</keyword> <keyword>*</keyword>, &zp;10.3&ze;, <keyword>float</keyword>, &zp;1.4&ze;
<keyword>const</keyword> <keyword>struct</keyword>, &zp;10.2&ze;, <keyword>char</keyword> [], &zp;1.4&ze;
<keyword>struct</keyword>, &zp;8.2&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;1.2&ze;
<keyword>void</keyword> *(), &zp;4.6&ze;, <keyword>int</keyword> [], &zp;1.2&ze;
<keyword>struct</keyword> [], &zp;4.1&ze;, , 
<caption>
Occurrence of types used to declare objects with external linkage (as
a percentage of all such declarations).  Based on the translated form
of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1349">4</A>
C99 {ref storage-class specifier, syntax}

.ASIS
<c_syntax>storage-class-specifier:</c_syntax>
                <keyword>typedef
                extern
                static
                auto
                register</keyword>
.E_ASIS


.TABLE storclass_bigram
: l 1.8cm 2.1cm l 1.8cm 2.1cm
Token Sequence, % Occurrence First Token, % Occurrence of Second Token, Token Sequence, % Occurrence First Token, % Occurrence of Second Token
<keyword>static</keyword> <keyword>void</keyword>, &zp;33.7&ze;, &zp;32.7&ze;, <keyword>extern</keyword> <keyword>int</keyword>, &zp;32.1&ze;, &zp;1.7&ze;
<keyword>static</keyword> <keyword>int</keyword>, &zp;28.2&ze;, &zp;15.1&ze;, <keyword>register</keyword> <keyword>struct</keyword>, &zp;19.1&ze;, &zp;1.4&ze;
<keyword>typedef</keyword> <keyword>union</keyword>, &zp;3.2&ze;, &zp;11.0&ze;, <keyword>typedef</keyword> <keyword>struct</keyword>, &zp;62.4&ze;, &zp;1.2&ze;
<keyword>static</keyword> <keyword>const</keyword>, &zp;1.5&ze;, &zp;10.0&ze;, <keyword>register</keyword> <keyword>int</keyword>, &zp;23.0&ze;, &zp;1.2&ze;
<keyword>static</keyword> <keyword>volatile</keyword>, &zp;0.3&ze;, &zp;8.6&ze;, <keyword>register</keyword> <keyword>char</keyword>, &zp;10.2&ze;, &zp;1.2&ze;
<keyword>typedef</keyword> <keyword>enum</keyword>, &zp;10.8&ze;, &zp;8.2&ze;, <keyword>register</keyword> <keyword>unsigned</keyword>, &zp;6.1&ze;, &zp;0.9&ze;
<keyword>static</keyword> <keyword>signed</keyword>, &zp;0.0&ze;, &zp;6.5&ze;, <keyword>extern</keyword> <keyword>char</keyword>, &zp;7.4&ze;, &zp;0.9&ze;
<keyword>static</keyword> <keyword>unsigned</keyword>, &zp;3.8&ze;, &zp;5.5&ze;, <keyword>extern</keyword> <keyword>struct</keyword>, &zp;6.9&ze;, &zp;0.5&ze;
<keyword>extern</keyword> <keyword>double</keyword>, &zp;1.3&ze;, &zp;5.5&ze;, <keyword>static</keyword> identifier, &zp;21.0&ze;, &zp;0.3&ze;
<keyword>static</keyword> <keyword>char</keyword>, &zp;4.1&ze;, &zp;5.1&ze;, <keyword>typedef</keyword> <keyword>unsigned</keyword>, &zp;6.2&ze;, &zp;0.2&ze;
<keyword>static</keyword> <keyword>struct</keyword>, &zp;6.4&ze;, &zp;4.8&ze;, <keyword>typedef</keyword> identifier, &zp;7.9&ze;, &zp;0.0&ze;
<keyword>register</keyword> <keyword>enum</keyword>, &zp;1.6&ze;, &zp;4.6&ze;, <keyword>register</keyword> identifier, &zp;35.9&ze;, &zp;0.0&ze;
<keyword>extern</keyword> <keyword>void</keyword>, &zp;21.5&ze;, &zp;2.1&ze;, <keyword>extern</keyword> identifier, &zp;23.7&ze;, &zp;0.0&ze;
<caption>
Common token pairs involving a <c_syntax>storage-class</c_syntax>.
Based on the visible form of the <file>.c</file> files (the keyword
<keyword>auto</keyword> occurred 14 times).
</caption>
.E_TABLE


.TABLE storclass_bigram_h
: l 1.8cm 2.1cm l 1.8cm 2.1cm
Token Sequence, % Occurrence First Token, % Occurrence of Second Token, Token Sequence, % Occurrence First Token, % Occurrence of Second Token
<keyword>typedef</keyword> <keyword>union</keyword>, &zp;12.4&ze;, &zp;67.1&ze;, <keyword>typedef</keyword> <keyword>unsigned</keyword>, &zp;6.6&ze;, &zp;3.1&ze;
<keyword>typedef</keyword> <keyword>enum</keyword>, &zp;6.2&ze;, &zp;37.2&ze;, <keyword>extern</keyword> <keyword>unsigned</keyword>, &zp;2.9&ze;, &zp;2.8&ze;
<keyword>typedef</keyword> <keyword>signed</keyword>, &zp;0.5&ze;, &zp;28.6&ze;, <keyword>static</keyword> <keyword>void</keyword>, &zp;10.3&ze;, &zp;2.2&ze;
<keyword>extern</keyword> <keyword>void</keyword>, &zp;28.6&ze;, &zp;24.0&ze;, <keyword>typedef</keyword> <keyword>void</keyword>, &zp;4.0&ze;, &zp;1.6&ze;
<keyword>extern</keyword> <keyword>double</keyword>, &zp;0.3&ze;, &zp;17.9&ze;, <keyword>static</keyword> <keyword>int</keyword>, &zp;7.0&ze;, &zp;1.2&ze;
<keyword>typedef</keyword> <keyword>struct</keyword>, &zp;46.3&ze;, &zp;16.6&ze;, <keyword>extern</keyword> identifier, &zp;32.2&ze;, &zp;0.9&ze;
<keyword>extern</keyword> <keyword>int</keyword>, &zp;23.2&ze;, &zp;15.2&ze;, <keyword>register</keyword> <keyword>long</keyword>, &zp;16.0&ze;, &zp;0.8&ze;
<keyword>extern</keyword> <keyword>float</keyword>, &zp;0.3&ze;, &zp;9.8&ze;, <keyword>register</keyword> <keyword>unsigned</keyword>, &zp;24.8&ze;, &zp;0.6&ze;
<keyword>register</keyword> <keyword>signed</keyword>, &zp;2.6&ze;, &zp;8.2&ze;, <keyword>static</keyword> identifier, &zp;70.3&ze;, &zp;0.5&ze;
<keyword>static</keyword> <keyword>const</keyword>, &zp;6.4&ze;, &zp;5.0&ze;, <keyword>register</keyword> <keyword>int</keyword>, &zp;18.4&ze;, &zp;0.3&ze;
<keyword>extern</keyword> <keyword>char</keyword>, &zp;3.8&ze;, &zp;4.8&ze;, <keyword>typedef</keyword> identifier, &zp;16.7&ze;, &zp;0.2&ze;
<keyword>extern</keyword> <keyword>struct</keyword>, &zp;4.3&ze;, &zp;3.3&ze;, <keyword>register</keyword> identifier, &zp;18.4&ze;, &zp;0.0&ze;
<caption>
Common token pairs involving a <c_syntax>storage-class</c_syntax>.
Based on the visible form of the <file>.h</file> files (the keyword
<keyword>auto</keyword> occurred 6 times).
</caption>
.E_TABLE


<A NAME="1354">1</A>
C99 {ref register, storage-class}

A declaration of an identifier for an object with storage-class
specifier <keyword>register</keyword> suggests that access to the
object be as fast as possible.


.TABLE franklin92
: l r r r r r r r r r r r r
Usage,        0,     1,     2,    3, &tgeq;4, Average,    0,     1,     2,     3, &tgeq;4, Average
eqntott,       ,      ,      ,     ,     ,        ,   0.89, 71.34, 17.54,  9.47,  0.76,  1.86 
espresso,      ,      ,      ,     ,     ,        ,   3.67, 72.30, 17.66,  3.74,  2.63,  1.48
gcc,           ,      ,      ,     ,     ,        ,   6.26, 67.37, 15.51,  4.45,  6.41,  1.69
xlisp,         ,      ,      ,     ,     ,        ,   4.27, 66.14, 12.42, 10.20,  6.97,  1.84
dnasa7,    0.00, 99.83,  0.02, 0.03, 0.12,    1.31,   0.67,  2.36, 16.29, 64.36, 16.33,  3.28
doduc,     1.46, 84.00,  9.51, 1.94, 3.09,    1.36,  10.31, 44.35, 26.52, 10.13,  8.69,  2.93
fpppp,     0.16, 91.09,  6.15, 1.14, 1.46,    1.16,   1.34, 10.12, 83.45,  0.46,  4.63,  3.09
matrix300, 0.00, 99.92,  0.00, 0.00, 0.08,    1.25,  15.29, 61.54,  7.71,  0.12, 15.35,  1.92
spice2g6,  0.21, 79.85, 19.22, 0.16, 0.56,    1.22,   4.04, 73.38, 12.08,  3.56,  6.94,  1.68
tomcatv,   0.00, 86.43,  8.30, 1.49, 3.77,    1.26,   0.12, 24.99, 37.54, 27.40,  9.96,  3.22
<caption>
Degree of use of floating-point and integer register instances (a
particular value loaded into a register).  Values denote the
percentage of register instances with a particular degree of use
(listed across the top), for the program listed down the left.  For
instance, 15.51% of the integer values loaded into a register, in
<tool>gcc</tool>, are used twice.  Left half of table refers to
floating-point register instances, right half of table to integer
register instances.  Zero uses of a value loaded into a register
occur for situations such as arguments passed to functions that are
never accessed.  Adapted from Franklin and Sohi <book Franklin_92>.
</caption>
.E_TABLE


<A NAME="1363">3</A>
C99 {ref type specifier, syntax}

.ASIS
<c_syntax>type-specifier:</c_syntax>
                <keyword>void
                char
                short
                int
                long
                float
                double
                signed
                unsigned
                _Bool
                _Complex
                _Imaginary</keyword>
                <c_syntax>struct-or-union-specifier
                enum-specifier
                typedef-name</c_syntax>
.E_ASIS


.FIG
fltsimd
<caption>
Behavior of packed single-precision floating-point operations
supported by the Intel Pentium processor <book Intel_IA32_00>.
</caption>
.E_FIG


.TABLE typespec_bigram
: l 1.8cm 2.2cm l 1.8cm 2.2cm
Token Sequence, % Occurrence First Token, % Occurrence of Second Token, Token Sequence, % Occurrence First Token, % Occurrence of Second Token
<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;38.7&ze;, &zp;72.2&ze;, <keyword>;</keyword> <keyword>long</keyword>, &zp;0.1&ze;, &zp;6.2&ze;
<keyword>unsigned</keyword> <keyword>short</keyword>, &zp;5.8&ze;, &zp;63.8&ze;, &comma; <keyword>void</keyword>, &zp;0.3&ze;, &zp;5.8&ze;
<keyword>char</keyword> <keyword>*p</keyword>, &zp;74.5&ze;, &zp;63.3&ze;, <keyword>static</keyword> <keyword>unsigned</keyword>, &zp;3.8&ze;, &zp;5.5&ze;
<keyword>(</keyword> <keyword>signed</keyword>, &zp;0.0&ze;, &zp;60.5&ze;, <keyword>extern</keyword> <keyword>double</keyword>, &zp;1.3&ze;, &zp;5.5&ze;
<keyword>;</keyword> <keyword>enum</keyword>, &zp;0.1&ze;, &zp;45.5&ze;, <keyword>}</keyword> <keyword>int</keyword>, &zp;2.2&ze;, &zp;5.3&ze;
<keyword>(</keyword> <keyword>struct</keyword>, &zp;2.9&ze;, &zp;41.8&ze;, <keyword>{</keyword> <keyword>signed</keyword>, &zp;0.0&ze;, &zp;5.2&ze;
<keyword>;</keyword> <keyword>float</keyword>, &zp;0.1&ze;, &zp;40.0&ze;, <keyword>static</keyword> <keyword>char</keyword>, &zp;4.1&ze;, &zp;5.1&ze;
<keyword>;</keyword> <keyword>union</keyword>, &zp;0.0&ze;, &zp;33.7&ze;, header-name <keyword>double</keyword>, &zp;0.2&ze;, &zp;5.1&ze;
<keyword>static</keyword> <keyword>void</keyword>, &zp;33.7&ze;, &zp;32.7&ze;, <keyword>static</keyword> <keyword>struct</keyword>, &zp;6.4&ze;, &zp;4.8&ze;
<keyword>(</keyword> <keyword>float</keyword>, &zp;0.0&ze;, &zp;32.0&ze;, <keyword>register</keyword> <keyword>enum</keyword>, &zp;1.6&ze;, &zp;4.6&ze;
<keyword>(</keyword> <keyword>unsigned</keyword>, &zp;1.0&ze;, &zp;29.0&ze;, <keyword>long</keyword> <keyword>*p</keyword>, &zp;7.1&ze;, &zp;2.8&ze;
<keyword>(</keyword> <keyword>void</keyword>, &zp;1.4&ze;, &zp;26.6&ze;, <keyword>int</keyword> identifier, &zp;87.6&ze;, &zp;2.3&ze;
<keyword>;</keyword> <keyword>unsigned</keyword>, &zp;1.0&ze;, &zp;26.4&ze;, <keyword>extern</keyword> <keyword>void</keyword>, &zp;21.5&ze;, &zp;2.1&ze;
<keyword>;</keyword> <keyword>int</keyword>, &zp;2.5&ze;, &zp;24.8&ze;, <keyword>struct</keyword> identifier, &zp;99.0&ze;, &zp;1.9&ze;
<keyword>(</keyword> <keyword>char</keyword>, &zp;1.0&ze;, &zp;23.9&ze;, <keyword>extern</keyword> <keyword>int</keyword>, &zp;32.1&ze;, &zp;1.7&ze;
<keyword>{</keyword> <keyword>union</keyword>, &zp;0.0&ze;, &zp;23.4&ze;, <keyword>short</keyword> <keyword>*p</keyword>, &zp;21.8&ze;, &zp;1.4&ze;
<keyword>(</keyword> <keyword>double</keyword>, &zp;0.0&ze;, &zp;22.9&ze;, <keyword>register</keyword> <keyword>struct</keyword>, &zp;19.1&ze;, &zp;1.4&ze;
<keyword>;</keyword> <keyword>double</keyword>, &zp;0.0&ze;, &zp;19.8&ze;, <keyword>const</keyword> <keyword>unsigned</keyword>, &zp;6.2&ze;, &zp;1.4&ze;
<keyword>void</keyword> <keyword>*p</keyword>, &zp;17.5&ze;, &zp;19.0&ze;, <keyword>const</keyword> <keyword>struct</keyword>, &zp;11.1&ze;, &zp;1.3&ze;
&comma; <keyword>unsigned</keyword>, &zp;0.6&ze;, &zp;18.9&ze;, <keyword>typedef</keyword> <keyword>struct</keyword>, &zp;62.4&ze;, &zp;1.2&ze;
<keyword>}</keyword> <keyword>void</keyword>, &zp;4.1&ze;, &zp;18.0&ze;, <keyword>register</keyword> <keyword>int</keyword>, &zp;23.0&ze;, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;21.2&ze;, &zp;18.0&ze;, <keyword>register</keyword> <keyword>char</keyword>, &zp;10.2&ze;, &zp;1.2&ze;
<keyword>;</keyword> <keyword>struct</keyword>, &zp;1.3&ze;, &zp;17.6&ze;, <keyword>volatile</keyword> <keyword>unsigned</keyword>, &zp;25.6&ze;, &zp;1.1&ze;
<keyword>;</keyword> <keyword>char</keyword>, &zp;0.8&ze;, &zp;17.5&ze;, <keyword>void</keyword> identifier, &zp;61.7&ze;, &zp;0.9&ze;
&comma; <keyword>int</keyword>, &zp;1.4&ze;, &zp;15.9&ze;, <keyword>void</keyword> <keyword>)</keyword>, &zp;17.5&ze;, &zp;0.9&ze;
<keyword>static</keyword> <keyword>int</keyword>, &zp;28.2&ze;, &zp;15.1&ze;, <keyword>register</keyword> <keyword>unsigned</keyword>, &zp;6.1&ze;, &zp;0.9&ze;
<keyword>;</keyword> <keyword>signed</keyword>, &zp;0.0&ze;, &zp;14.7&ze;, <keyword>extern</keyword> <keyword>char</keyword>, &zp;7.4&ze;, &zp;0.9&ze;
<keyword>{</keyword> <keyword>struct</keyword>, &zp;4.3&ze;, &zp;14.5&ze;, <keyword>const</keyword> <keyword>void</keyword>, &zp;5.3&ze;, &zp;0.8&ze;
identifier <keyword>double</keyword>, &zp;0.0&ze;, &zp;13.1&ze;, <keyword>signed</keyword> <keyword>short</keyword>, &zp;11.3&ze;, &zp;0.7&ze;
<keyword>{</keyword> <keyword>unsigned</keyword>, &zp;1.9&ze;, &zp;12.5&ze;, <keyword>int</keyword> <keyword>)</keyword>, &zp;6.6&ze;, &zp;0.6&ze;
&comma; <keyword>struct</keyword>, &zp;0.8&ze;, &zp;12.2&ze;, <keyword>extern</keyword> <keyword>struct</keyword>, &zp;6.9&ze;, &zp;0.5&ze;
<keyword>{</keyword> <keyword>int</keyword>, &zp;4.8&ze;, &zp;11.5&ze;, <keyword>volatile</keyword> <keyword>struct</keyword>, &zp;15.5&ze;, &zp;0.4&ze;
<keyword>{</keyword> <keyword>enum</keyword>, &zp;0.1&ze;, &zp;11.1&ze;, <keyword>long</keyword> identifier, &zp;68.3&ze;, &zp;0.4&ze;
<keyword>typedef</keyword> <keyword>union</keyword>, &zp;3.2&ze;, &zp;11.0&ze;, <keyword>long</keyword> <keyword>)</keyword>, &zp;21.7&ze;, &zp;0.4&ze;
<keyword>(</keyword> <keyword>short</keyword>, &zp;0.0&ze;, &zp;11.0&ze;, <keyword>float</keyword> <keyword>*p</keyword>, &zp;9.2&ze;, &zp;0.3&ze;
<keyword>;</keyword> <keyword>short</keyword>, &zp;0.0&ze;, &zp;10.6&ze;, <keyword>char</keyword> identifier, &zp;22.6&ze;, &zp;0.3&ze;
<keyword>(</keyword> <keyword>int</keyword>, &zp;1.0&ze;, &zp;10.6&ze;, <keyword>typedef</keyword> <keyword>unsigned</keyword>, &zp;6.2&ze;, &zp;0.2&ze;
&comma; <keyword>float</keyword>, &zp;0.0&ze;, &zp;10.6&ze;, <keyword>signed</keyword> <keyword>long</keyword>, &zp;20.8&ze;, &zp;0.2&ze;
<keyword>const</keyword> <keyword>char</keyword>, &zp;54.1&ze;, &zp;10.4&ze;, <keyword>double</keyword> <keyword>*p</keyword>, &zp;7.9&ze;, &zp;0.2&ze;
<keyword>{</keyword> <keyword>float</keyword>, &zp;0.1&ze;, &zp;10.2&ze;, <keyword>volatile</keyword> <keyword>int</keyword>, &zp;7.4&ze;, &zp;0.1&ze;
<keyword>(</keyword> <keyword>union</keyword>, &zp;0.0&ze;, &zp;9.9&ze;, <keyword>unsigned</keyword> identifier, &zp;7.0&ze;, &zp;0.1&ze;
&comma; <keyword>char</keyword>, &zp;0.4&ze;, &zp;9.9&ze;, <keyword>union</keyword> <keyword>{</keyword>, &zp;34.5&ze;, &zp;0.1&ze;
<keyword>(</keyword> <keyword>long</keyword>, &zp;0.2&ze;, &zp;9.2&ze;, <keyword>signed</keyword> <keyword>char</keyword>, &zp;22.6&ze;, &zp;0.1&ze;
&comma; <keyword>enum</keyword>, &zp;0.0&ze;, &zp;9.2&ze;, <keyword>short</keyword> identifier, &zp;60.9&ze;, &zp;0.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;24.6&ze;, &zp;9.1&ze;, <keyword>enum</keyword> <keyword>{</keyword>, &zp;13.4&ze;, &zp;0.1&ze;
<keyword>{</keyword> <keyword>double</keyword>, &zp;0.0&ze;, &zp;8.6&ze;, <keyword>union</keyword> identifier, &zp;65.5&ze;, &zp;0.0&ze;
<keyword>typedef</keyword> <keyword>enum</keyword>, &zp;10.8&ze;, &zp;8.2&ze;, <keyword>signed</keyword> <keyword>int</keyword>, &zp;7.5&ze;, &zp;0.0&ze;
&comma; <keyword>double</keyword>, &zp;0.0&ze;, &zp;8.2&ze;, <keyword>signed</keyword> <keyword>)</keyword>, &zp;37.9&ze;, &zp;0.0&ze;
<keyword>int</keyword> <keyword>*p</keyword>, &zp;4.1&ze;, &zp;8.1&ze;, <keyword>short</keyword> <keyword>)</keyword>, &zp;14.0&ze;, &zp;0.0&ze;
&comma; <keyword>union</keyword>, &zp;0.0&ze;, &zp;8.0&ze;, <keyword>float</keyword> identifier, &zp;64.3&ze;, &zp;0.0&ze;
&comma; <keyword>signed</keyword>, &zp;0.0&ze;, &zp;7.9&ze;, <keyword>float</keyword> <keyword>)</keyword>, &zp;26.1&ze;, &zp;0.0&ze;
<keyword>)</keyword> <keyword>enum</keyword>, &zp;0.0&ze;, &zp;7.1&ze;, <keyword>enum</keyword> identifier, &zp;86.6&ze;, &zp;0.0&ze;
<keyword>{</keyword> <keyword>char</keyword>, &zp;1.3&ze;, &zp;7.1&ze;, <keyword>double</keyword> identifier, &zp;70.7&ze;, &zp;0.0&ze;
<keyword>static</keyword> <keyword>signed</keyword>, &zp;0.0&ze;, &zp;6.5&ze;, <keyword>double</keyword> <keyword>)</keyword>, &zp;19.1&ze;, &zp;0.0&ze;
<keyword>;</keyword> <keyword>void</keyword>, &zp;0.3&ze;, &zp;6.3&ze;, , , 
<caption>
Common token pairs involving a
<c_syntax>type-specifier</c_syntax>.  Based on the visible form of the
<file>.c</file> files.  The type specifiers <keyword>_Bool</keyword>,
<keyword>_Complex</keyword>, and <keyword>_Imaginary</keyword> did
not appear in the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="1367">9</A>
C99 {ref type specifiers, possible sets of}

.ASIS
&emdash;&nbsp;  <keyword>void</keyword>
&emdash;&nbsp;  <keyword>char</keyword>
&emdash;&nbsp;  <keyword>signed char</keyword>
&emdash;&nbsp;  <keyword>unsigned char</keyword>
&emdash;&nbsp;  <keyword>short</keyword>, <keyword>signed short</keyword>, <keyword>short int</keyword>, or <keyword>signed short int</keyword>
&emdash;&nbsp;  <keyword>unsigned short</keyword>, or <keyword>unsigned short int</keyword>
&emdash;&nbsp;  <keyword>int</keyword>, <keyword>signed</keyword>, or <keyword>signed int</keyword>
&emdash;&nbsp;  <keyword>unsigned</keyword>, or <keyword>unsigned int</keyword>
&emdash;&nbsp;  <keyword>long</keyword>, <keyword>signed long</keyword>, <keyword>long int</keyword>, or <keyword>signed long int</keyword>
&emdash;&nbsp;  <keyword>unsigned long</keyword>, or <keyword>unsigned long int</keyword>
&emdash;&nbsp;  <keyword>long long</keyword>, <keyword>signed long long</keyword>, <keyword>long long int</keyword>, or <keyword>signed long long int</keyword>
&emdash;&nbsp;  <keyword>unsigned long long</keyword>, or <keyword>unsigned long long int</keyword>
&emdash;&nbsp;  <keyword>float</keyword>
&emdash;&nbsp;  <keyword>double</keyword>
&emdash;&nbsp;  <keyword>long double</keyword>
&emdash;&nbsp;  <keyword>_Bool</keyword>
&emdash;&nbsp;  <keyword>float _Complex</keyword>
&emdash;&nbsp;  <keyword>double _Complex</keyword>
&emdash;&nbsp;  <keyword>long double _Complex</keyword>
<iso_deleted>&emdash;&nbsp; <keyword>float _Imaginary</keyword></iso_deleted>
<iso_deleted>&emdash;&nbsp; <keyword>double _Imaginary</keyword></iso_deleted>
<iso_deleted>&emdash;&nbsp; <keyword>long double _Imaginary</keyword></iso_deleted>
&emdash;&nbsp;  struct or union specifier
&emdash;&nbsp;  enum specifier
&emdash;&nbsp;  typedef name
.E_ASIS


.TABLE typespec_seq
: l r l r
Type Specifier Sequence, %, Type Specifier Sequence, %
<keyword>int</keyword>, &zp;39.9&ze;, <keyword>long</keyword>, &zp;2.2&ze;
<keyword>void</keyword>, &zp;24.3&ze;, <keyword>unsigned</keyword>, &zp;1.6&ze;
<keyword>char</keyword>, &zp;15.6&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;0.9&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;6.2&ze;, <keyword>float</keyword>, &zp;0.6&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;4.0&ze;, <keyword>short</keyword>, &zp;0.5&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;3.4&ze;, <keyword>double</keyword>, &zp;0.5&ze;
<caption>
Occurrence of <c_syntax>type-specifier</c_syntax> sequences (as a
percentage of all type specifier sequences; cut-off below 0.1%),
based on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="1375">3</A>
C99 {ref struct/union, syntax}

.ASIS
<c_syntax>struct-or-union-specifier:
                struct-or-union identifier<sub>opt</sub></c_syntax> <keyword>{</keyword> <c_syntax>struct-declaration-list</c_syntax> <keyword>}</keyword>
                <c_syntax>struct-or-union identifier</c_syntax>

<c_syntax>struct-or-union:</c_syntax>
                <keyword>struct
                union</keyword>

<c_syntax>struct-declaration-list:
                struct-declaration
                struct-declaration-list struct-declaration</c_syntax>

<c_syntax>struct-declaration:
                specifier-qualifier-list struct-declarator-list</c_syntax> <keyword>;</keyword>

<c_syntax>specifier-qualifier-list:
                type-specifier specifier-qualifier-list<sub>opt</sub>
                type-qualifier specifier-qualifier-list<sub>opt</sub></c_syntax>

<c_syntax>struct-declarator-list:
                struct-declarator
                struct-declarator-list</c_syntax> <keyword>,</keyword> <c_syntax>struct-declarator</c_syntax>

<c_syntax>struct-declarator:
                declarator
                declarator<sub>opt</sub></c_syntax> <keyword>:</keyword> <c_syntax>constant-expression</c_syntax>
.E_ASIS


.TABLE esu_tok_tok
: l r l r
Token Sequence, Occurrences, Token Sequence, Occurrences
<keyword>enum</keyword> <keyword>{</keyword>, &zs;456&ze; (&zs;1591&ze;), <keyword>struct</keyword> id <keyword>;</keyword>, &zs;76&ze; (&zs;13384&ze;)
<keyword>enum</keyword> id <keyword>;</keyword>, &zs;0&ze; (&zs;0&ze;), <keyword>struct</keyword> id id, &zs;122974&ze; (&zs;27589&ze;)
<keyword>enum</keyword> id <keyword>{</keyword>, &zs;474&ze; (&zs;1059&ze;), <keyword>union</keyword> <keyword>{</keyword>, &zs;297&ze; (&zs;725&ze;)
<keyword>enum</keyword> id id, &zs;2922&ze; (&zs;633&ze;), <keyword>union</keyword> id <keyword>;</keyword>, &zs;0&ze; (&zs;11&ze;)
<keyword>struct</keyword> <keyword>{</keyword>, &zs;1567&ze; (&zs;6503&ze;), <keyword>union</keyword> id <keyword>{</keyword>, &zs;105&ze; (&zs;2624&ze;)
<keyword>struct</keyword> id <keyword>{</keyword>, &zs;4407&ze; (&zs;1311&ze;), <keyword>union</keyword> id id, &zs;330&ze; (&zs;231&ze;)
<caption>
Number of occurrences of the given token sequence.  Based on the
visible source of the <file>.c</file> files (<file>.h</file> files in
parentheses).
</caption>
.E_TABLE


<A NAME="1378">1</A>
C99 {ref bit-field, maximum width}

The expression that specifies the width of a bit-field shall be an
integer constant expression that has nonnegative value that shall not
exceed the <iso_deleted>number</iso_deleted><iso_new>width</iso_new> of
<iso_deleted>bits in</iso_deleted> an object of the type that is
specified if the colon and expression are omitted.


.FIG
bitwidth
<caption>
Number of bit-field declarations specifying the given number of
bits.  Based on the translated form of the books benchmark programs.
(Declarations encountered in any source or header file were only
counted once, the contents of system headers were ignored.)
</caption>
.E_FIG


<A NAME="1387">1</A>
C99 {ref struct member, type}

A member of a structure or union may have any object type other than
a variably modified type.<sup>102)</sup> 


.TABLE st_member_type
: l r l r l r l r
Type, %, Type, %, Type, %, Type, %
<keyword>int</keyword>, &zp;15.8&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;7.7&ze;, <keyword>char</keyword> <keyword>*</keyword>, &zp;2.3&ze;, <keyword>void</keyword> *(), &zp;1.3&ze;
other-types, &zp;12.7&ze;, <keyword>struct</keyword>, &zp;7.2&ze;, <keyword>enum</keyword>, &zp;1.9&ze;, <keyword>float</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;11.1&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;5.2&ze;, <keyword>long</keyword>, &zp;1.8&ze;, <keyword>short</keyword>, &zp;1.0&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;10.4&ze;, <keyword>unsigned</keyword>, &zp;4.0&ze;, <keyword>char</keyword>, &zp;1.8&ze;, <keyword>int</keyword> *(), &zp;1.0&ze;
<keyword>struct</keyword> <keyword>*</keyword>, &zp;8.8&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> [], &zp;3.1&ze;, <keyword>char</keyword> [], &zp;1.5&ze;, , 
<caption>
Occurrence of structure member types (as a percentage of the types of
all such members).  Based on the translated form of the books
benchmark programs.
</caption>
.E_TABLE


.TABLE un_member_type
: l r l r l r l r
Type, %, Type, %, Type, %, Type, %
<keyword>struct</keyword>, &zp;46.9&ze;, <keyword>unsigned</keyword> <keyword>int</keyword>, &zp;3.8&ze;, <keyword>double</keyword>, &zp;1.9&ze;, <keyword>char</keyword> [], &zp;1.3&ze;
other-types, &zp;11.3&ze;, <keyword>char</keyword> <keyword>*</keyword>, &zp;2.8&ze;, <keyword>enum</keyword>, &zp;1.7&ze;, <keyword>union</keyword> <keyword>*</keyword>, &zp;1.1&ze;
<keyword>struct</keyword> <keyword>*</keyword>, &zp;8.3&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.4&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.5&ze;, , 
<keyword>int</keyword>, &zp;6.0&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.1&ze;, <keyword>struct</keyword> [], &zp;1.3&ze;, , 
<keyword>unsigned</keyword> <keyword>char</keyword> [], &zp;4.3&ze;, <keyword>long</keyword>, &zp;2.1&ze;, <keyword>(</keyword> <keyword>struct</keyword> <keyword>*</keyword> <keyword>)</keyword> [], &zp;1.3&ze;, , 
<caption>
Occurrence of union member types (as a percentage of the types of all
such members).  Based on the translated form of the books benchmark
programs.
</caption>
.E_TABLE


<A NAME="1424">1</A>
C99 {ref enumeration constant, representable in int}

The expression that defines the value of an enumeration constant
shall be an integer constant expression that has a value
representable as an <keyword>int</keyword>.


.FIG
ecvals
<caption>
Number of enumeration constants in an enumeration type and number
whose value is explicitly or implicitly specified.  Based on the
translated form of the books benchmark programs (also see <figref
href="econst"/>).
</caption>
.E_FIG


.TABLE enum_const_role
: 7cm r
Property, %
All value assigned implicitly, &zp;79.1&ze;
All values are bitwise distinct and zero is not used, &zp;1.7&ze;
One or more constants share the same value, &zp;1.8&ze;
All values are continuous &comma; i.e.&comma; number of enumeration constants equals maximum value minus minimum value plus &zs;1&ze;, &zp;94.9&ze;
<caption>
Some properties of the set of values (the phrase <phrase>all
values</phrase> refers to all the values in a particular enumeration
definition) assigned to the enumeration constants in enumeration
definitions.  Based on the translated form of the books benchmark
programs.
</caption>
.E_TABLE


<A NAME="1446">3</A>
C99 {ref tag, declare}

If an identifier is provided,<sup>110)</sup> the type specifier also
declares the identifier to be the tag of that type.


.TABLE esu_ident_cnt
 , <file>.c</file> files, <file>.h</file> files
<keyword>union</keyword> identifier, &zp;65.5&ze;, &zp;75.8&ze;
<keyword>struct</keyword> identifier, &zp;99.0&ze;, &zp;88.4&ze;
<keyword>enum</keyword> identifier, &zp;86.6&ze;, &zp;53.6&ze;
<caption>
Occurrence of types (as a percentage of all occurrences of the each
keyword) declared with tag names.  Based on the visible form of the
<file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


<A NAME="1455">1</A>
C99 {ref struct-or-union identifier, visible}

If a type specifier of the form

.ASIS
        <c_syntax>struct-or-union identifier</c_syntax>
.E_ASIS

or

.ASIS
        <keyword>enum</keyword> <c_syntax>identifier</c_syntax>
.E_ASIS

occurs other than as part of one of the above forms, and a
declaration of the identifier as a tag is visible, then it specifies
the same type as that other declaration, and does not redeclare the
tag.


.FIG
esutag
<caption>

Number of references
to each tag previously defined in the visible source (times, bullet,
square; the definition itself is not included in the count), tags
with no definition visible in the <file>.c</file> file (i.e., it is
defined in a header) and anonymous structure/union/enumeration
definitions.  Based on the visible form of the <file>.c</file> files.

</caption>
.E_FIG


<A NAME="1459">3</A>
C99 {ref type qualifier, syntax}

.ASIS
<c_syntax>type-qualifier:</c_syntax>
                <keyword>const
                restrict
                volatile</keyword>
.E_ASIS


.TABLE typequal_bigram
: l 1.8cm 2.1cm l 1.8cm 2.1cm
Token Sequence, % Occurrence First Token, % Occurrence of Second Token, Token Sequence, % Occurrence First Token, % Occurrence of Second Token
<keyword>;</keyword> <keyword>volatile</keyword>, &zp;0.1&ze;, &zp;36.1&ze;, <keyword>{</keyword> <keyword>const</keyword>, &zp;0.2&ze;, &zp;5.6&ze;
&comma; <keyword>const</keyword>, &zp;0.2&ze;, &zp;32.8&ze;, <keyword>const</keyword> <keyword>unsigned</keyword>, &zp;6.2&ze;, &zp;1.4&ze;
<keyword>(</keyword> <keyword>const</keyword>, &zp;0.2&ze;, &zp;28.1&ze;, <keyword>const</keyword> <keyword>struct</keyword>, &zp;11.1&ze;, &zp;1.3&ze;
<keyword>(</keyword> <keyword>volatile</keyword>, &zp;0.0&ze;, &zp;26.2&ze;, <keyword>volatile</keyword> <keyword>unsigned</keyword>, &zp;25.6&ze;, &zp;1.1&ze;
<keyword>;</keyword> <keyword>const</keyword>, &zp;0.1&ze;, &zp;14.1&ze;, <keyword>const</keyword> <keyword>void</keyword>, &zp;5.3&ze;, &zp;0.8&ze;
identifier <keyword>volatile</keyword>, &zp;0.0&ze;, &zp;11.4&ze;, <keyword>volatile</keyword> <keyword>struct</keyword>, &zp;15.5&ze;, &zp;0.4&ze;
<keyword>{</keyword> <keyword>volatile</keyword>, &zp;0.1&ze;, &zp;11.0&ze;, <keyword>volatile</keyword> <keyword>int</keyword>, &zp;7.4&ze;, &zp;0.1&ze;
<keyword>const</keyword> <keyword>char</keyword>, &zp;54.1&ze;, &zp;10.4&ze;, <keyword>volatile</keyword> identifier, &zp;36.2&ze;, &zp;0.0&ze;
<keyword>static</keyword> <keyword>const</keyword>, &zp;1.5&ze;, &zp;10.0&ze;, <keyword>volatile</keyword> <keyword>(</keyword>, &zp;8.9&ze;, &zp;0.0&ze;
<keyword>static</keyword> <keyword>volatile</keyword>, &zp;0.3&ze;, &zp;8.6&ze;, <keyword>const</keyword> identifier, &zp;17.6&ze;, &zp;0.0&ze;
<caption>
Common token sequences containing
<c_syntax>type-qualifier</c_syntax>s (as a percentage of each
<c_syntax>type-qualifier</c_syntax>).  Based on the visible form of
the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="1512">4</A>
C99 {ref inline, suggests fast calls}

Making a function an inline function suggests that calls to the
function be as fast as possible.<sup>118)</sup> 


.TABLE Ratliff_97
: l 0.6cm 1.3cm 1.3cm 1.6cm l 0.6cm 1.3cm 1.3cm 1.6cm
Program, Stack Size, Bytes Saved (%), Inlined Stack Size, Inlined Bytes Saved (%), Program, Stack Size, Bytes Saved (%), Inlined Stack Size, Inlined Bytes Saved (%)
ackerman, &ptz;312,  8 (2.56),   &zcz;232, &z;8 (3.45), linpack,   1&comma;504, 48 (3.19), 3&comma;312,  112 (&z;3.38)
bubblesort, &ptz;568,  8 (1.41), &zcz;136, &z;8 (5.88), mincost,   1&comma;216, &z;0 (&emdash;),    &ptz;192, &z2;8 (&z;4.17)
cal,       &ptz;384,  0 (&emdash;),     &z;&zcz;96,  &z;0 (&emdash;), prof,      1&comma;584,  &z;0 (&emdash;),   &ptz;400, &z;40 (10.00)
cmp,       &ptz;768,  0 (&emdash;),     &zcz;192, &z;0 (&emdash;), sdiff,     2&comma;536, &z;0 (&emdash;),     5&comma;784, &z;16 (&z;0.28)
csplit,    1&comma;488,  0 (&emdash;), &zcz;728, &z;0 (&emdash;), spline,    &ptz;560,     &z;8 (1.43),  &ptz;200, &z2;8 (&z;4.00)
ctags,     8&comma;144,  0 (&emdash;), 24&comma;544, 88 (0.36), tr,  &ptz;192,  &z;0 (&emdash;),       &zcz;96, &z2;0 (&emdash;)
dhrystone, &ptz;664,  0 (&emdash;),     &zcz;200, &z;8 (4.00), tsp,       3&comma;008, &z;8 (0.27), 2&comma;216, &z;56 (&z;2.53)
grep,      &ptz;592,  0 (&emdash;),     &zcz;304, &z;0 (&emdash;), whetstone,  &ptz;568,    &z;0 (&emdash;),     &ptz;488, 296 (60.66)
join,      &ptz;480,  0 (&emdash;),     &z;&zcz;96,  &z;0 (&emdash;), yacc,    4&comma;232,  &z;0 (&emdash;), 1&comma;360, &z2;8 (&z;0.59)
lex,       9&comma;472,  0 (&emdash;),  &z;7&comma;208, &z;8 (0.11), average,   1&comma;989,  &z;4 (0.47), 2&comma;510, &z;34 (&z;5.23)
<caption>
Number of bytes of stack space needed by various programs before and
after inlining (automatically performed by <tool>VPCC</tool>).
<phrase>Bytes saved</phrase> refers to the amount of storage saved by
optimizing the allocation of locally defined objects.  Adapted from
Ratliff <book Ratliff_97>.
</caption>
.E_TABLE


<A NAME="1611">4</A>
C99 {ref typedef name, syntax}

.ASIS
<c_syntax>typedef-name:
                identifier</c_syntax>
.E_ASIS


.TABLE typedef_type
: l r l r
Type, Occurrences, Type, Occurrences
<keyword>struct</keyword>, &z2p;58.00&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, &z2p;1.47&ze;
<keyword>enum</keyword>, &z2p;9.50&ze;, <keyword>int</keyword> *(), &z2p;1.46&ze;
other-types, &z2p;8.86&ze;, <keyword>enum</keyword> *(), &z2p;1.46&ze;
<keyword>struct</keyword> <keyword>*</keyword>, &z2p;6.97&ze;, <keyword>union</keyword>, &z2p;1.38&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &z2p;2.68&ze;, <keyword>long</keyword>, &z2p;1.29&ze;
<keyword>int</keyword>, &z2p;2.46&ze;, <keyword>void</keyword> *(), &z2p;1.18&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &z2p;2.21&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &z2p;1.07&ze;
<caption>
Occurrences of types defined in a <keyword>typedef</keyword>
definition (as a percentage of all types appearing in
<keyword>typedef</keyword> definition).  Based on the translated form
of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1623">2</A>
C99 {ref initialization, syntax}

.ASIS
<c_syntax>initializer:
                assignment-expression</c_syntax>
                <keyword>{</keyword> <c_syntax>initializer-list</c_syntax> <keyword>}</keyword>
                <keyword>{</keyword> <c_syntax>initializer-list</c_syntax> <keyword>, }</keyword>

<c_syntax>initializer-list:
                designation<sub>opt</sub> initializer
                initializer-list</c_syntax> <keyword>,</keyword> <c_syntax>designation<sub>opt</sub> initializer

designation:
                designator-list</c_syntax> <keyword>=</keyword>

<c_syntax>designator-list:
                designator
                designator-list designator

designator:</c_syntax>
                <keyword>[</keyword> <c_syntax>constant-expression</c_syntax> <keyword>]</keyword>
                <keyword>.</keyword> <c_syntax>identifier</c_syntax>
.E_ASIS


.FIG
trick93
<caption>
Average time (in milliseconds) taken for subjects to enumerate O's in
a background of X or Q distractors.  Based on Trick and Pylyshyn
<book Trick_93>.
</caption>
.E_FIG


.TABLE loc_init_type
: l r l r
Type, %, Type, %
<keyword>struct</keyword> <keyword>*</keyword>, &zp;39.5&ze;, <keyword>long</keyword>, &zp;2.6&ze;
<keyword>int</keyword>, &zp;22.6&ze;, <keyword>char</keyword>, &zp;2.5&ze;
other-types, &zp;9.1&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.4&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;4.5&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.5&ze;
<keyword>union</keyword> <keyword>*</keyword>, &zp;4.3&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;1.4&ze;
<keyword>char</keyword> <keyword>*</keyword>, &zp;4.0&ze;, <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>*</keyword>, &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;3.4&ze;, <keyword>enum</keyword>, &zp;1.1&ze;
<caption>
Occurrence of object types, in block scope, whose declarations
include an initializer (as a percentage of the type of all such
declarations with initializers).  Based on the translated form of the
books benchmark programs.  Usage information on the types of all
objects declared at file scope is given elsewhere (see <tableref
href="loc_obj_type"/>).
</caption>
.E_TABLE


.TABLE glob_init_type
: l r l r
Type, %, Type, %
<keyword>const</keyword> <keyword>char</keyword> [], &zp;22.5&ze;, <keyword>char</keyword> <keyword>*</keyword>, &zp;2.2&ze;
<keyword>const</keyword> <keyword>struct</keyword>, &zp;14.7&ze;, <keyword>int</keyword> [], &zp;2.1&ze;
<keyword>int</keyword>, &zp;11.1&ze;, <keyword>char</keyword> [], &zp;2.0&ze;
<keyword>struct</keyword>, &zp;10.4&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> [], &zp;1.7&ze;
other-types, &zp;10.4&ze;, <keyword>void</keyword> *(), &zp;1.3&ze;
<keyword>struct</keyword> [], &zp;8.3&ze;, <keyword>(</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>)</keyword> [], &zp;1.3&ze;
<keyword>struct</keyword> <keyword>*</keyword>, &zp;2.9&ze;, <keyword>int</keyword> *(), &zp;1.2&ze;
<keyword>(</keyword> <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword> <keyword>const</keyword> <keyword>)</keyword> [], &zp;2.9&ze;, <keyword>const</keyword> <keyword>unsigned</keyword> <keyword>char</keyword> [], &zp;1.2&ze;
<keyword>unsigned</keyword> <keyword>short</keyword> [], &zp;2.5&ze;, <keyword>const</keyword> <keyword>short</keyword> [], &zp;1.2&ze;
<caption>
Occurrence of object types with internal linkage, at file scope,
whose declarations include an initializer (as a percentage of the
type of all such declarations with initializers).  Based on the
translated form of the books benchmark programs.  Usage information
on the types of all objects declared at file scope is given elsewhere
(see <tableref href="ext_obj_type"/>).
</caption>
.E_TABLE


<A NAME="1634">1</A>
C99 {ref object, value indeterminate}

If an object that has automatic storage duration is not initialized
explicitly, its value is indeterminate.


.FIG
obj_init
<caption>
Number of object declarations that include an initializer (as a
percentage of all corresponding object declarations), either within
function definitions (functions that did not contain any object
definitions were not included), or within translation units having
internal linkage (while there are a number of ways of counting
objects with external linkage, none seemed appropriate and no usage
information is given).  Based on the translated form of the books
benchmark programs.
</caption>
.E_FIG


<A NAME="1688">3</A>
C99 {ref statement, syntax}

.ASIS
<c_syntax>statement:
                labeled-statement
                compound-statement
                expression-statement
                selection-statement
                iteration-statement
                jump-statement</c_syntax>
.E_ASIS


.FIG
bransford71
<caption>
Subject confidence level of having previously seen a sentence
containing different numbers of idea units.  Based on Bransford and
Franks <book Bransford_71>.
</caption>
.E_FIG


.FIG
kintsch73
<caption>
Two sentences containing four and eight propositions, and their
propositional analyses.  Based on Kintsch and Keenan <book
Kintsch_73>.
</caption>
.E_FIG


.FIG
kintsch73b
<caption>
Reading time (in seconds) and recall time for sentences containing
different numbers of propositions (straight lines represent a least
squares fit; for presentation <equ>t=6.37+.94P<sub>pres</sub></equ>,
and for recall <equ>t=5.53+1.48P<sub>rec</sub></equ>).  Adapted from
Kintsch and Keenan <book Kintsch_73>.
</caption>
.E_FIG


.FIG
daneman80
<caption>
Percentage of correct subject responses to the pronoun reference
questions as a function of the number of sentences between the
pronoun and the referent noun.  Plotted lines are subject reading
spans.  Adapted from Daneman and Carpenter <book Daneman_80>.
</caption>
.E_FIG


.FIG
daneman83
<caption>
Percentage of correct answers to questions as a function of subjects
reading span and the presence or absence of a sentence boundary.
Adapted from Daneman and Carpenter <book Daneman_83>.
</caption>
.E_FIG


.FIG
mcnamara89
<caption>
Example of one of the object layouts and the corresponding ordered
tree for one of the subjects.
Based on McNamara, Hardy, and Hirtle <book McNamara_89>.
</caption>
.E_FIG


.FIG
stmtlendiff
<caption>
Visible difference in offset of right margin between successive
lines, in the visible form of the <file>.c</file> files (horizontal
tab characters were mapped to 8 space characters), for lines of
various lengths, i.e., those whose previous line contained 60 or more
characters, and those whose previous line contains less than 20
characters.  There are ten times fewer lines sharing the same right
offset as sharing the same left offset (<figref href="indentdiff"/>).
</caption>
.E_FIG


.FIG
indentdiff
<caption>
Visible difference in offset of indentation of left margin between
successive lines in the visible form of the <file>.c</file> files
(horizontal tab characters were mapped to 8 space characters).  The
smaller peaks around zero are indentation differences of two
characters.  The wider spaced peaks have a separation of eight
characters.  Individual files had more pronounced peaks; this plot is
for all the source.
</caption>
.E_FIG


.FIG
stmtperfunc
<caption>
Number of each kind of statement in function definitions.  Based on
the translated form of the books benchmark programs.
</caption>
.E_FIG


<A NAME="1691">1</A>
C99 {ref block}

A <i>block</i> allows a set of declarations and statements to be
grouped into one syntactic unit.


.TABLE bb_end_reason
Basic Block Type, Static Count (thousand), Dynamic Count (billion)
Branch,          54.026 (42.4%),  4.0 (50.2%)
Fall-through,    31.120 (24.4%),  1.8 (22.4%)
Function return, 32.052 (25.2%),  1.1 (13.7%)
Function call,   10.228 (&z;8&ptz;%),  1.1 (13.7%)
<caption>
Occurrence of constructs that terminated execution of a basic block
during execution of PostgreSQL running the TPC-D benchmark.  Adapted
from Ramirez, Larriba-Pey, Navarro, Serrano, Torrellas, and Valero
<book Ramirez_99>.
</caption>
.E_TABLE


.TABLE bb_length
: l r r l r r
Program,  Leaf,   Non-Leaf, Program,  Leaf,   Non-Leaf
burg,      6.8,   4.9,      eqntott,   9.1,   5.4
ditroff,   6.8,   4.7,      espresso,  5.0,   5.1
tex,      10.4,   8.5,      gcc,       5.2,   5.7
xfig,      4.8,   5.3,      li,        2.9,   5.7
xtex,      7.3,   5.8,      sc,        3.5,   4.2
compress, 18.4,   5.7,      Mean,      7.3,   5.5
<caption>
Mean number of machine instructions executed per basic block (i.e.,
total number of instructions executed in a function divided by the
total number of basic blocks executed in that function) for a variety
of SPEC benchmark programs.  <phrase>Leaf</phrase> refers to
functions that do not call any other functions, while
<phrase>Non-Leaf</phrase> refers to functions that contain calls to
other functions.  Based on Calder, Grunwald, and Zorn <book
Calder_95b>.
</caption>
.E_TABLE


.FIG
cmpdperfunc
<caption>
Number of <c_syntax>compound-statement</c_syntax>s in function
definitions.  Based on the translated form of the books benchmark
programs.
</caption>
.E_FIG


<A NAME="1694">2</A>
C99

Each of the following is a full expression:


.TABLE full_expr_per_func
Context of Full Expression, Occurrence, Context of Full Expression, Occurrence
expression statement, &zp;65.9&ze;, <keyword>for</keyword> expr-1, &zp;1.6&ze;
<keyword>if</keyword> controlling expression, &zp;16.4&ze;, <keyword>for</keyword> controlling expression, &zp;1.5&ze;
<keyword>return</keyword> expression, &zp;6.2&ze;, <keyword>for</keyword> clause-1, &zp;1.5&ze;
object declaration initializer, &zp;4.2&ze;, <keyword>switch</keyword> controlling expression, &zp;0.6&ze;
<keyword>while</keyword> controlling expression, &zp;2.1&ze;, , 
<caption>
Occurrence of full expressions in various contexts (as a percentage
of all full expressions).  Based on the translated form of the books
benchmark programs.
</caption>
.E_TABLE


<A NAME="1703">10</A>
C99 {ref labeled statements, syntax}

.ASIS
<c_syntax>labeled-statement:
                identifier</c_syntax> <keyword>:</keyword> <c_syntax>statement</c_syntax>
                <keyword>case</keyword> <c_syntax>constant-expression</c_syntax> <keyword>:</keyword> <c_syntax>statement</c_syntax>
                <keyword>default :</keyword> <c_syntax>statement</c_syntax>
.E_ASIS


.TABLE numlabels
Labels, % Functions, Labels, % Functions
 &zs;1&ze;, &zp;3.5&ze;, &zs;3&ze;, &zp;0.3&ze;
 &zs;2&ze;, &zp;0.9&ze;, &zs;4&ze;, &zp;0.1&ze;
<caption>
Percentage of function definitions containing the given number of
labeled statements (other than a <keyword>case</keyword> or
<keyword>default</keyword> label).  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_TABLE


<A NAME="1708">2</A>
C99 {ref case, fall through}

Labels in themselves do not alter the flow of control, which
continues unimpeded across them.


.TABLE case_bigram
: l r r
Token Sequence, % Occurrence First Token, % Occurrence of Second Token
<keyword>;</keyword> <keyword>default</keyword>, &zp;0.4&ze;, &zp;81.4&ze;
<keyword>;</keyword> <keyword>case</keyword>, &zp;2.1&ze;, &zp;52.1&ze;
<keyword>:</keyword> <keyword>case</keyword>, &zp;15.5&ze;, &zp;22.1&ze;
<keyword>{</keyword> <keyword>case</keyword>, &zp;2.6&ze;, &zp;15.0&ze;
<keyword>}</keyword> <keyword>case</keyword>, &zp;1.3&ze;, &zp;7.3&ze;
<keyword>:</keyword> <keyword>default</keyword>, &zp;0.5&ze;, &zp;5.7&ze;
<keyword>#endif</keyword> <keyword>default</keyword>, &zp;0.8&ze;, &zp;4.4&ze;
<caption>
Common token pairs involving a <keyword>case</keyword> or
<keyword>default</keyword> label.  Based on the visible form of the
<file>.c</file> files.  Almost all of the sequences <c_code>{
case</c_code> occur immediately after the controlling expression of
the <keyword>switch</keyword> statement.
</caption>
.E_TABLE


<A NAME="1710">4</A>
C99 {ref compound statement, syntax}

.ASIS
<c_syntax>compound-statement:</c_syntax>
                <keyword>{</keyword> <c_syntax>block-item-list<sub>opt</sub></c_syntax> <keyword>}</keyword>

<c_syntax>block-item-list:
                block-item
                block-item-list block-item</c_syntax>

<c_syntax>block-item:
                declaration
                statement</c_syntax>
.E_ASIS


.FIG
scopelines
<caption>
Number of physical lines occurring within a
<c_syntax>compound-statement</c_syntax> (including the opening and
closing braces and any nested
<c_syntax>compound-statement</c_syntax>s, but excluding the lines
between the braces denoting the start/end of the function
definition).  Based on the translated form of the books benchmark
programs.
</caption>
.E_FIG


<A NAME="1712">2</A>
C99 {ref null statement, syntax} {ref expression statement, syntax}

.ASIS
<c_syntax>expression-statement:
                expression<sub>opt</sub></c_syntax> <keyword>;</keyword>
.E_ASIS


.TABLE exprstmt
: l r l r
Form of <c_syntax>expression-statement</c_syntax>, %, Form of <c_syntax>expression-statement</c_syntax>, %
function-call, &zs;37&ze;, identifier <keyword>=</keyword> expression, &zs;4&ze;
identifier <keyword>=</keyword> identifier, &zs;16&ze;, identifier <keyword>v++</keyword>, &zs;2&ze;
identifier <keyword>=</keyword> function-call, &zs;10&ze;, expression, &zs;1&ze;
identifier <keyword>=</keyword> constant, &zs;7&ze;, other-expr-stmt, &zs;22&ze;
<caption>
Occurrence of the most common forms of expression statement (as a
percentage of all expression statements).  Based on the translated
form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1720">4</A>
C99 {ref selection statement, syntax}

.ASIS
<c_syntax>selection-statement:</c_syntax>
                <keyword>if (</keyword> <c_syntax>expression</c_syntax> <keyword>)</keyword> <c_syntax>statement</c_syntax>
                <keyword>if (</keyword> <c_syntax>expression</c_syntax> <keyword>)</keyword> <c_syntax>statement</c_syntax> <keyword>else</keyword> <c_syntax>statement</c_syntax>
                <keyword>switch (</keyword> <c_syntax>expression</c_syntax> <keyword>)</keyword> <c_syntax>statement</c_syntax>
.E_ASIS


.TABLE ball93
: l 1.0cm 1.1cm 0.6cm 0.8cm 0.8cm l 1.0cm 1.1cm 0.6cm 0.8cm 0.8cm
Program, % of All Branches, Heuristics, Perfect, Random, Big (%), Program, % of All Branches, Heuristics, Perfect, Random, Big (%)
gcc,       73,   37, 11,   50,  0 (&z;0), poly,      20,   40,  &z;3,   31,  3 (54)
lcc,       71,   32, 12,   52,  1 (13), fpppp,     86,   42, &z;9,   41,  0 (&z;0)
qpt,       70,   26, &z;9, 52,  0 (&z;0), costScale, 71,   29,   21,   49,  6 (52)
compress,  66,   40, 18,   66,  6 (69), doduc,     52,   33, &z;3,   49,  0 (&z;0)
xlisp,     62,   28, &z;7, 50,  0 (&z;0), tomcatv,   38, &z;2, &z;0,   50,  2 (98)
addalg,    52,   43, 30,   43,  7 (67), dcg,       21,   15, &z;4,   46,  4 (51)
ghostview, 52,   16, &z;4, 47,  4 (53), spice2g6,  21,   36, &z;8,   52,  2 (27)
eqntott,   49,   50, 25,   50,  2 (92), sgefat,    18,   26, &z;8,   61,  8 (73)
rn,        48,   34, &z;1, 51,  3 (25), dnasa7,    10,   32, &z;4,   55,  4 (58)
grep,      44, &z;1, &z;0, &z;3, 3 (96), matrix300, &z;4, 33, &z;0,   66,  3 (99)
congress,  40,   28, &z;3, 57,  2 (10), Mean,        ,   29, 10,   49, 
espresso,  37,   26, 13,   42,  3 (24), Std.Dev.,    ,   12, &z;8,   13, 
awk,       29,   14, &z;3, 57,  4 (29), , , , , 
<caption>
Dynamic breakdown of non-loop branches for programs in SPEC89.
<phrase>% of all branches</phrase> is the percentage of all branches
that are non-loop branches.  <phrase>Heuristics</phrase> are the
results of using the heuristics for predicting the target successor
of each non-loop branch, <phrase>Perfect</phrase> the results for the
perfect predictor, <phrase>Random</phrase> the results for predicting
each non-loop branch randomly.  <phrase>Big</phrase> is the number of
non-loop branches in the program contributing more than 5% of all
dynamic non-loop branches (and as a percentage of non-loop branches).
Based on Ball and Larus <book Ball_93>.
</caption>
.E_TABLE


.TABLE Bell_JL_98
: l c c
Kind of Question , Correct 'yes' Response, Correct 'no' Response
is possible, 91%, 65%
is necessary, 71%, 81%
<caption>
Percentage of correct responses given to the four kinds of questions.
Adapted from Bell and Johnson-Laird <book Bell_98>.
</caption>
.E_TABLE


.TABLE evans_bp_83
: l l c
Status-context, Example, Conclusion Accepted
Valid-believable
 , No Police dogs are vicious
 , Some highly trained dogs are vicious
 , Therefore&comma; some highly trained dogs are not police dogs, 88%
Valid-unbelievable
 , No nutritional things are inexpensive
 , Some vitamin tablets are inexpensive
 , Therefore&comma; some vitamin tablets are not nutritional things, 56%
Invalid-believable
 , No addictive things are inexpensive
 , Some cigarettes are inexpensive
 , Therefore&comma; some addictive things are not cigarettes, 72%
Invalid-unbelievable
 , No millionaires are hard workers
 , Some rich people are hard workers
 , Therefore&comma; some millionaires are not rich people, 13%
<caption>
Percentage of subjects accepting that the stated conclusion could be
logically deduced from the given premises.
Based on Evans, Barston, and Pollard <book Evans_83>.
</caption>
.E_TABLE


.TABLE stanovich_99
: 5.3cm 5.3cm
System 1, System 2
Unconscious, Conscious
Automatic, Controlled
Associative, Rule-based
Heuristic processing, Analytic processing
Undemanding of cognitive capacity, Demanding of cognitive capacity
Relatively fast, Relatively slow
Acquisition by biology&comma; exposure&comma; and personal experience, Acquisition by cultural and formal training
Highly contextualized, Decontextualized
Conversational and socialized, Asocial
Independent of general intelligence, Correlated with general intelligence
<caption>
Properties of the two systems of thinking.  Based on Stanovich <book
Stanovich_99>.
</caption>
.E_TABLE


.TABLE De_Soto_65
: l c 2.5cm l c 2.5cm
 , Premises, Percentage Correct Response, , Premises, Percentage Correct Response
1, A is better than B,        , 5, A is better than B, 
 , B is better than C, 60.5   ,  , C is worse than B, 61.8

2, B is better than C,        , 6, C is worse than B, 
 , A is better than B, 52.8   ,  , A is better than B, 57.0

3, B is worse than A,         , 7, B is worse than A, 
 , C is worse than B, 50.0    ,  , B is better than C, 41.5

4, C is worse than B,         , 8, B is better than C, 
 , B is worse than A, 42.5    ,  , B is worse than A, 38.3
<caption>
Eight sets of premises describing the same relative ordering between
A, B, and C (peoples names were used in the study) in different ways,
followed by the percentage of subjects giving the correct answer.
Adapted from De Soto, London, and Handel <book De_Soto_65>.
</caption>
.E_TABLE


.TABLE sloman02b
Question, Causal, Conditional
D holds?, 80%, 57%
A holds?, 79%, 36%
<caption>
Percentage <hlight>yes</hlight> responses to questions (based on 238
responses).  Based on Sloman, and Lagnado <book Sloman_02b>.
</caption>
.E_TABLE


.TABLE
: l r r
Structure, Speech, Writing
If + present&comma; present,                        19.2, 16.5
If + present&comma; (will/be going to),             10.9, 12.5
If + past&comma; (would/might/could),               10.2, 10.0
If + present&comma; (should/must/can/may),           9.0, 12.1
If + (were/were to)&comma; (would/could/might),      8.6,  6.0
If + (had/have +en)&comma; (would/could/might) have, 3.8,  3.3
If + present&comma; (would/could/might),             2.6,  6.1
<caption>
Occurrence of the most common conditional sentence types in speech
(266 conditionals from a 63,746 word corpus) and writing (948
conditionals from 357,249 word corpus).  In the notation <phrase>if +
x, y</phrase>: <hlight>x</hlight> is the condition (which might, for
instance, be in the past tense) and <hlight>y</hlight> can be thought
of as the <phrase>then part</phrase> (which might, for instance, use
one of the words would/could/might, or be in the present tense).
Adapted from Celce-Murcia <book Celce-Murcia_99>.
</caption>
.E_TABLE


.TABLE if_cntrl
: c r c r
Abstract Form of Control Expression, %, Abstract Form of Control Expression, %
object, &zp;15.5&ze;, object <keyword><</keyword> <c_syntax>integer-constant</c_syntax>, &zp;2.2&ze;
object <keyword>==</keyword> object, &zp;8.9&ze;, object <keyword>></keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.8&ze;
function-call, &zp;7.4&ze;, function-call <keyword>==</keyword> object, &zp;1.6&ze;
<keyword>!</keyword> object, &zp;7.4&ze;, object <keyword>></keyword> object, &zp;1.4&ze;
expression, &zp;5.7&ze;, object <keyword>!=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.3&ze;
object <keyword>!=</keyword> object, &zp;4.2&ze;, function-call <keyword>==</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.2&ze;
object <keyword>==</keyword> <c_syntax>integer-constant</c_syntax>, &zp;4.0&ze;, object <keyword><</keyword> object, &zp;1.1&ze;
<keyword>!</keyword> function-call, &zp;3.8&ze;, others, &zp;32.4&ze;
<caption>
Occurrence of various kinds of <keyword>if</keyword> statement
controlling expressions (as a percentage of all <keyword>if</keyword>
statements).  Based on the visible form of the <file>.c</file> files.
Where <phrase>object</phrase> is a reference to a single object,
which may be an identifier, a member (e.g., <c_code>s.m</c_code>,
<c_code>s->m->n</c_code>, or <c_code>a[expr]</c_code>),
<phrase>func</phrase> is a function call,
<c_syntax>integer-constant</c_syntax> is an integer constant
expression, and <phrase>expression</phrase> represents all other
expressions.
</caption>
.E_TABLE


.TABLE switch_cntrl
: c r
Abstract Form of Control Expression, %
 object, &zp;75.3&ze;
 function-call, &zp;14.2&ze;
 expression, &zp;5.2&ze;
<keyword>*v</keyword> object, &zp;2.0&ze;
others, &zp;3.3&ze;
<caption>
Occurrence of <keyword>switch</keyword> statement controlling
expressions (as a percentage of all <keyword>switch</keyword>
statements).  Based on the visible form of the <file>.c</file> files.
Where <phrase>object</phrase> is a reference to a single object,
which may be an identifier, a member (e.g., <c_code>s.m</c_code>,
<c_code>s->m->n</c_code>, or <c_code>a[expr]</c_code>),
<phrase>func</phrase> is a function call,
<c_syntax>integer-constant</c_syntax> is an integer constant
expression, and <phrase>expression</phrase> represents all other
expressions.
</caption>
.E_TABLE


.TABLE if_releqlog_op
: c 1.9cm 2.0cm c 1.9cm 2.0cm
Operator, % Controlling Expression, % Occurrence of Operator, Operator, % Controlling Expression, % Occurrence of Operator
<keyword>==</keyword>, &zp;31.7&ze;, &zp;88.6&ze;, <keyword>>=</keyword>, &zp;3.5&ze;, &zp;76.8&ze;
<keyword>!=</keyword>, &zp;14.1&ze;, &zp;79.7&ze;, no relational/equality, &zp;47.5&ze;, &emdash;
<keyword><</keyword>, &zp;6.9&ze;, &zp;45.6&ze;, <keyword>||</keyword>, &zp;9.6&ze;, &zp;85.9&ze;
<keyword><=</keyword>, &zp;1.9&ze;, &zp;68.6&ze;, <keyword>&&</keyword>, &zp;14.5&ze;, &zp;82.3&ze;
<keyword>></keyword>, &zp;3.5&ze;, &zp;84.9&ze;, no logical operators, &zp;84.2&ze;, &emdash;
<caption>
Occurrence of equality, relational, and logical operators in the
conditional expression of an <keyword>if</keyword> statement (as a
percentage of all such controlling expressions and as a percentage of
the respective operator).  Based on the visible form of the
<file>.c</file> files.  The percentage of controlling expressions may
sum to more than 100% because more than one of the operators occurs
in the same expression.
</caption>
.E_TABLE


.FIG
selectperfunc
<caption>
Number of functions containing a given number of
<c_syntax>selection-statement</c_syntax>s.  Based on the translated
form of the books benchmark programs.
</caption>
.E_FIG


.FIG
selectnest
<caption>
Number of <c_syntax>selection-statement</c_syntax>s having a given
maximum nesting level for embedded C <book Engblom_98> (whose data
was multiplied by a constant to allow comparison; the data for
nesting depth 5 was interpolated) and the visible form of the
<file>.c</file> files.
</caption>
.E_FIG


<A NAME="1729">1</A>
C99 {ref switch, statement}

The controlling expression of a <keyword>switch</keyword> statement
shall have integer type.


.FIG
caseden
<caption>
<phrase>Density</phrase> of <keyword>case</keyword> label values
(calculated as (maximum <keyword>case</keyword> label value minus
minimum <keyword>case</keyword> label value minus one) divided by the
number of <keyword>case</keyword> labels associated with a
<keyword>switch</keyword> statement) and span of
<keyword>case</keyword> label values (calculated as (maximum
<keyword>case</keyword> label value minus minimum
<keyword>case</keyword> label value minus one)).  Based on the
translated form of the books benchmark programs and embedded results
from Engblom <book Engblom_98> (which were scaled, i.e., multiplied
by a constant, to allow comparison).  The results were scaled to
match the total count of <keyword>switch</keyword> statements that
included a <keyword>default</keyword> label.
</caption>
.E_FIG


.FIG
stmtcase
<caption>
Number of statements following (and not including) one or more
<keyword>case</keyword> or <keyword>default</keyword> labels
(statements from any nested <keyword>switch</keyword> statements did
not contribute towards the count of a label).  Based on the visible
form of the <file>.c</file> files.
</caption>
.E_FIG


.TABLE switch_cntrl_type
: l r l r
Type, %, Type, %
<keyword>int</keyword>, &zp;29.5&ze;, bit-field, &zp;3.1&ze;
<keyword>unsigned</keyword> <keyword>long</keyword>, &zp;18.7&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;2.8&ze;
<keyword>enum</keyword>, &zp;14.6&ze;, <keyword>short</keyword>, &zp;2.5&ze;
<keyword>unsigned</keyword> <keyword>char</keyword>, &zp;12.4&ze;, <keyword>long</keyword>, &zp;0.9&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;10.0&ze;, other-types, &zp;0.2&ze;
<keyword>char</keyword>, &zp;5.1&ze;, , 
<caption>
Occurrence of <keyword>switch</keyword> statements having a
controlling expression of the given type (as a percentage of all
<keyword>switch</keyword> statements).  Based on the translated form
of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1734">1</A>
C99 {ref switch statement, causes jump}

A <keyword>switch</keyword> statement causes control to jump to,
into, or past the statement that is the <i>switch body</i>, depending
on the value of a controlling expression, and on the presence of a
<keyword>default</keyword> label and the values of any
<keyword>case</keyword> labels on or in the switch body.


.TABLE switch_if
Processor Implementation, 2.5br LS, 4.5br LS, 8.5br LS, 2.5br IJ, 4.5br IJ, 8.5br IJ
SPARCstation&endash; IPC, 3.82, 5.53, 8.82, 2.61, 2.71, 2.76
SPARCstation&endash;5, 1.03, 1.65, 2.74, 0.63, 0.76, 0.76
SPARCstation&endash;20, 0.93, 1.60, 2.65, 0.87, 0.93, 0.94
UltraSPARC&endash;1, 0.50, 1.16, 1.56, 1.50, 1.51, 1.51
<caption>
Performance comparison (in seconds) of implementation techniques for
a series of <keyword>if</keyword> statements (containing in a loop
that iterated 10,000,000 times) using (1) linear search (LS), or (2)
indirect jump (IJ), for a variety of processors in the SPARC family.
<phrase>br</phrase> is the average number of branches per loop
iteration.  Based on Uh and Whalley <book Uh_99>.
</caption>
.E_TABLE


<A NAME="1744">5</A>
C99 {ref iteration statement, syntax}

.ASIS
<c_syntax>iteration-statement:</c_syntax>
                <keyword>while (</keyword> <c_syntax>expression</c_syntax> <keyword>)</keyword> <c_syntax>statement</c_syntax>
                <keyword>do</keyword> <c_syntax>statement</c_syntax> <keyword>while (</keyword> <c_syntax>expression</c_syntax> <keyword>) ;</keyword>
                <keyword>for (</keyword> <c_syntax>expression<sub>opt</sub></c_syntax> <keyword>;</keyword> <c_syntax>expression<sub>opt</sub></c_syntax> <keyword>;</keyword> <c_syntax>expression<sub>opt</sub></c_syntax> <keyword>)</keyword> <c_syntax>statement</c_syntax>
                <keyword>for (</keyword> <c_syntax>declaration expression<sub>opt</sub></c_syntax> <keyword>;</keyword> <c_syntax>expression<sub>opt</sub></c_syntax> <keyword>)</keyword> <c_syntax>statement</c_syntax>
.E_ASIS


.FIG
iterperfunc
<caption>
Number of function definitions containing the given number of
<c_syntax>iteration-statement</c_syntax>s.  Based on the translated
form of the books benchmark programs.
</caption>
.E_FIG


.FIG
loopnest
<caption>
Number of <c_syntax>iteration-statement</c_syntax>s having a
given maximum nesting level for embedded C <book Engblom_98> (whose
data was multiplied by a constant to allow comparison) and the
visible form of the <file>.c</file> files.
</caption>
.E_FIG


.TABLE for_header_cnt
: c r
Abstract Form of <keyword>for</keyword> loop header, %
assignment <keyword>;</keyword> object <keyword><</keyword> object <keyword>;</keyword> object <keyword>v++</keyword>, &zp;33.2&ze;
assignment <keyword>;</keyword> object <keyword><</keyword> <c_syntax>integer-constant</c_syntax> <keyword>;</keyword> object <keyword>v++</keyword>, &zp;11.3&ze;
assignment <keyword>;</keyword> object <keyword>;</keyword> assignment, &zp;7.0&ze;
assignment <keyword>;</keyword> object <keyword><</keyword> expression <keyword>;</keyword> object <keyword>v++</keyword>, &zp;3.3&ze;
assignment <keyword>;</keyword> object <keyword><</keyword> object <keyword>;</keyword> <keyword>++v</keyword> object, &zp;2.7&ze;
<keyword>;</keyword> <keyword>;</keyword>, &zp;2.5&ze;
assignment <keyword>;</keyword> object <keyword>!=</keyword> object <keyword>;</keyword> assignment, &zp;2.5&ze;
assignment <keyword>;</keyword> object <keyword><=</keyword> object <keyword>;</keyword> object <keyword>v++</keyword>, &zp;2.2&ze;
assignment <keyword>;</keyword> object <keyword>>=</keyword> <c_syntax>integer-constant</c_syntax> <keyword>;</keyword> object <keyword>v--</keyword>, &zp;1.6&ze;
assignment <keyword>;</keyword> object <keyword><</keyword> function-call <keyword>;</keyword> object <keyword>v++</keyword>, &zp;1.4&ze;
assignment <keyword>;</keyword> object <keyword><</keyword> object <keyword>;</keyword> object <keyword>v++</keyword> &comma; object <keyword>v++</keyword>, &zp;1.4&ze;
others, &zp;31.1&ze;
<caption>
Occurrence of various kinds of <keyword>for</keyword> statement
controlling expressions (as a percentage of all such expressions),
based on the visible form of the <file>.c</file> files.  Where
<phrase>object</phrase> is a reference to a single object, which may
be an identifier, a member (e.g., <c_code>s.m</c_code>,
<c_code>s->m->n</c_code>, or <c_code>a[expr]</c_code>);
<phrase>assignment</phrase> is an assignment expression,
<c_syntax>integer-constant</c_syntax> is an integer constant
expression, and <phrase>expression</phrase> represents all other
expressions.
</caption>
.E_TABLE


.TABLE while_cntrl
: c r c r
Abstract Form of Control Expression, %, Abstract Form of Control Expression, %
object, &zp;12.2&ze;, <keyword>*v</keyword> object, &zp;2.0&ze;
object <keyword>!=</keyword> object, &zp;7.0&ze;, assignment, &zp;1.8&ze;
<c_syntax>integer-constant</c_syntax>, &zp;6.2&ze;, <keyword>!</keyword> object, &zp;1.6&ze;
object <keyword><</keyword> object, &zp;4.7&ze;, <keyword>!</keyword> function-call, &zp;1.3&ze;
function-call, &zp;4.4&ze;, object <keyword>!=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.2&ze;
object <keyword>></keyword> <c_syntax>integer-constant</c_syntax>, &zp;4.0&ze;, object <keyword>v--</keyword> <keyword>></keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.1&ze;
object <keyword>v--</keyword>, &zp;3.2&ze;, <keyword>!</keyword> expression, &zp;1.0&ze;
assignment <keyword>!=</keyword> object, &zp;2.4&ze;, others, &zp;43.5&ze;
  expression, &zp;2.2&ze;,  , 
<caption>
Occurrence of various kinds of <keyword>while</keyword> statement
controlling expressions (as a percentage of all such statements).
Based on the visible form of the <file>.c</file> files.  Where
<phrase>object</phrase> is a reference to a single object, which may
be an identifier, a member (e.g., <c_code>s.m</c_code>,
<c_code>s->m->n</c_code>, or <c_code>a[expr]</c_code>);
<phrase>assignment</phrase> is an assignment expression,
<c_syntax>integer-constant</c_syntax> is an integer constant
expression, and <phrase>expression</phrase> represents all other
expressions.
</caption>
.E_TABLE


<A NAME="1752">1</A>
C99 {ref for, statement}

The statement

.ASIS
        <keyword>for (</keyword> <c_syntax>clause-1</c_syntax> <keyword>;</keyword> <c_syntax>expression-2</c_syntax> <keyword>;</keyword> <c_syntax>expression-3</c_syntax> <keyword>)</keyword> <c_syntax>statement</c_syntax>
.E_ASIS

behaves as follows:


.FIG
lcv
<caption>
Number of possible loop control variables appearing in
<c_syntax>expression-2</c_syntax> (square-box) after filtering
against the objects in <c_syntax>expression-3</c_syntax> (cross) and
after filtering against the objects in <c_syntax>clause-1</c_syntax>
(bullet).  Based on the visible form of the <file>.c</file> files.
</caption>
.E_FIG


.TABLE for_omit_expr
Components Omitted, Percentage
<c_syntax>clause-1</c_syntax>, &zp;6.8&ze;
<c_syntax>clause-1</c_syntax> <c_syntax>expr-2</c_syntax>, &zp;2.8&ze;
<c_syntax>clause-1</c_syntax> <c_syntax>expr-2</c_syntax> <c_syntax>expr-3</c_syntax>, &zp;2.7&ze;
<c_syntax>clause-1</c_syntax> <c_syntax>expr-3</c_syntax>, &zp;2.8&ze;
<c_syntax>expr-2</c_syntax>, &zp;3.6&ze;
<c_syntax>expr-2</c_syntax> <c_syntax>expr-3</c_syntax>, &zp;2.9&ze;
<c_syntax>expr-3</c_syntax>, &zp;4.5&ze;
<caption>
Occurrence of components omitted from <keyword>for</keyword>
statements (as a percentage of all <keyword>for</keyword> statements),
based on the visible form of the <file>.c</file> files.
</caption>
.E_TABLE


<A NAME="1759">3</A>
C99 {ref jump statement, syntax}

.ASIS
<c_syntax>jump-statement:</c_syntax>
                <keyword>goto</keyword> <c_syntax>identifier</c_syntax> <keyword>;
                continue ;
                break ;
                return</keyword> <c_syntax>expression<sub>opt</sub></c_syntax> <keyword>;</keyword>
.E_ASIS


.FIG
jumpperfunc
<caption>
Number of function definitions containing a given number of
<c_syntax>jump-statement</c_syntax>s.  Based on the translated form of
the books benchmark programs.
</caption>
.E_FIG


.FIG
brkcon
<caption>
Number of <keyword>break</keyword> and <keyword>continue</keyword>
statements per <c_syntax>iteration-statement</c_syntax>.  Based on the
visible form of the <file>.c</file> files.
</caption>
.E_FIG


.TABLE branch_kind
: l 2cm r r r r r r 2cm 1.5cm
Program, %Instructions Altering Control Flow, %CB, %UB, %IC, %PC, %Ret, %Oth, %Conditional Branch Taken, Instructions Between Branches
burg,     17.1,   74.1,   6.9,   0.0,   9.5,   9.5,   0.0,   68.8, &z;7.9
ditroff,  17.5,   76.3,   4.2,   0.1,   9.7,   9.8,   0.0,   58.1, &z;7.5
tex,      10.0,   75.9,  10.7,   0.0,   5.8,   5.8,   1.9,   57.5,  13.2
xfig,     17.5,   73.6,   7.7,   0.6,   8.6,   9.2,   0.3,   54.8, &z;7.8
xtex,     14.1,   78.2,   8.5,   0.2,   6.0,   6.2,   1.0,   53.3, &z;9.1
compress, 13.9,   88.5,   7.6,   0.0,   2.0,   2.0,   0.0,   68.3, &z;8.1
eqntott,  11.5,   93.5,   2.1,   1.5,   0.7,   2.2,   0.0,   90.3, &z;9.3
espresso, 17.1,   93.2,   1.9,   0.1,   2.3,   2.4,   0.1,   61.9, &z;6.3
gcc,      16.0,   78.9,   7.4,   0.4,   6.1,   6.5,   0.8,   59.4, &z;7.9
li,       17.7,   63.9,   8.7,   0.4,  12.9,  13.2,   0.9,   49.3, &z;8.9
sc,       22.3,   83.5,   3.9,   0.0,   6.3,   6.3,   0.0,   64.3, &z;5.4
Mean,     15.9,   80.0,   6.3,   0.3,   6.3,   6.6,   0.5,   62.4, &z;8.3
<caption>
Dynamic occurrence of different kinds of instructions that can change
the flow of control.  <phrase>%instructions altering control
flow</phrase> is expressed as a percentage of all executed
instructions.  All but the last row are expressed as percentages of
these, control flow altering, instructions only.  The kinds of
instructions that change control flow are: conditional branches
<phrase>CB</phrase>, unconditional branches <phrase>UB</phrase>,
indirect procedure calls <phrase>IC</phrase>, procedure calls
<phrase>PC</phrase>, procedure returns <phrase>Ret</phrase>, and
other breaks <phrase>Oth</phrase> (e.g., signals and
<keyword>switch</keyword> statements).  <phrase>Instructions between
branches</phrase> is the mean number of instructions between
conditional branches.  Based on Calder, Grunwald, and Zorn <book
Calder_95b>.
</caption>
.E_TABLE


.TABLE branch_often
: l r r r r r r r r r r r r r
Program,  10%, 20%, 30%, 40%, 50%, 60%,  70%,  80%,   90%,   95%,   99%,  100%,   Static count
burg,       1,   3,   5,   9,  19,  33,   58,   95,   135,   162,   268,   859,   1&comma;766
ditroff,    3,  11,  19,  28,  38,  50,   64,   91,   132,   201,   359,   867,   1&comma;974
tex,        3,   7,  15,  26,  39,  58,   89,  139,   259,   416,   788,   2&comma;369, 6&comma;050
xfig,       8,  31,  74, 138, 230, 356,  538,  814, 1&comma;441,   2&comma;060,   3&comma;352,   7&comma;476,   25&comma;224
xtex,       2,   8,  15,  22,  36,  63,  104,  225,   644, 1&comma;187,   2&comma;647,   6&comma;325,   21&comma;597
compress,   1,   2,   2,   3,   4,   5,    6,    8,    12,    14,    16,   230,   1&comma;124 
eqntott,    1,   1,   1,   2,   2,   2,    2,    3,    14,    42,    72,   466,   1&comma;536
espresso,   4,  10,  19,  30,  44,  63,   88,  121,   163,   221,   470,   1&comma;737,   4&comma;568
gcc,       13,  38,  77, 143, 245, 405,  641,  991, 1&comma;612,   2&comma;309,   3&comma;724,   7&comma;639,   16&comma;294
li,         2,   4,   7,  11,  16,  22,   29,   38,    52,    80,   128,   557,   2&comma;428 
sc,         2,   3,   4,   6,   9,  16,   30,   47,    76,   135,   353,   1&comma;465,   4&comma;478
Mean,       3,  10,  21,  38,  62,  97,  149,  233,   412,   620,   1&comma;107,   2&comma;726,   7&comma;912
<caption>
Number of static conditional branches sites that are responsible for
the quantile percentage of dynamically executed conditional branches.
For instance, 19 conditional branch sites are responsible for over
50% of the dynamically executed branches executed by
<tool>burg</tool>.  <phrase>Static count</phrase> is the total number
of conditional branch instructions in the program image.  Of the
17,565 static branch sites, 69 branches account for the execution of
50% of all dynamic conditional branches.  Not all branches will be
executed during each program execution because many branches are only
encountered during error conditions, or may reside in unreachable or
unused code.  Based on Calder, Grunwald, and Zorn <book Calder_95b>.
</caption>
.E_TABLE


<A NAME="1760">1</A>
C99 {ref jump statement, causes jump to}

A jump statement causes an unconditional jump to another place.


.FIG
gotodist
<caption>
Number of visible source lines between a <keyword>goto</keyword>
statement and its destination label (negative values denote backward
jumps).  Based on the translated form of the books benchmark programs.
</caption>
.E_FIG


.FIG
gotoscope
<caption>
Scope nesting level of <keyword>goto</keyword> and labeled statements
(nesting level 1 is the outermost block in a function definition),
and difference in scope levels between a <keyword>goto</keyword>
statement and its corresponding labeled statement (negative values
denote a jump to a less nested scope), based on the translated form
of the books benchmark programs.
</caption>
.E_FIG


<A NAME="1785">4</A>
C99 {ref translation unit, syntax} {ref external declaration, syntax}

.ASIS
<c_syntax>translation-unit:
                external-declaration
                translation-unit external-declaration</c_syntax>

<c_syntax>external-declaration:
                function-definition
                declaration</c_syntax>
.E_ASIS


.FIG
extcount
<caption>
Number of <c_syntax>external-declaration</c_syntax>s and
<c_syntax>function-definition</c_syntax>s declared during the
translation of the books benchmark programs (rounded to the nearest
fifty and excluding identifiers declared in any system headers that
are <keyword>#include</keyword>d).
</caption>
.E_FIG


.FIG
calluse
<caption>
Number of functions defined in each translation unit and percentage
of functions that are called within the translation unit that defines
them.  Based on the translated form of the books benchmark programs.
</caption>
.E_FIG


<A NAME="1796">5</A>
C99 {ref function definition, syntax}

.ASIS
<c_syntax>function-definition:
          declaration-specifiers declarator declaration-list<sub>opt</sub> compound-statement

declaration-list:
          declaration
          declaration-list declaration</c_syntax>
.E_ASIS


.FIG
dogparse
<caption>
Parse, using the Story grammar, of the tale of a dog and piece of meat.
Adapted from Mandler and Johnson <book Mandler_77>.
</caption>
.E_FIG


.TABLE graesser80
Memory Test, Typical (30 mins), Atypical (30 mins), Typical (1 week), Atypical (1 week)
Recall (correct),        0.34, 0.32, 0.21, 0.04
Recall (incorrect),      0.17, 0.00, 0.15, 0.00
Recognition (correct),  0.79, 0.79, 0.80, 0.60
Recognition (incorrect), 0.59, 0.11, 0.69, 0.26
<caption>
Probability of subjects recalling or recognizing typical or
atypical actions present in stories read to them, at two time
intervals (30 minutes and 1 week) after hearing them.
Based on Graesser, Woll, Kowalski, and Smith <book Graesser_80b>.
</caption>
.E_TABLE


.FIG
dooling77
<caption>
Percentage of false-positive recognition errors for biographies
having varying degrees of thematic relatedness to the famous person,
in <phrase>before</phrase>, <phrase>after</phrase>,
<phrase>famous</phrase>, and <phrase>fictitious</phrase> groups.
Based on Dooling and Christiaansen <book Dooling_77>.
</caption>
.E_FIG


.FIG
duplines
<caption>
Number of different source files containing the same sequence of
physical lines (ignoring comments and blank lines) for sequences
having at least 4 and 8 lines.  Data created by processing the
<file>.c</file> files using <tool>Simian</tool> <book Redhill_04>.
</caption>
.E_FIG


.TABLE
: l 1.7cm 2.6cm 2.6cm
O/S pairs, Number of Clone Pairs, % of Lines Included in a Clone, % of Files Containing a Clone
FreeBSD/Linux, &z;1&comma;091, FreeBSD (&z;0.8) Linux (&z;0.9), FreeBSD (&z;3.1) Linux (&z;4.6)
FreeBSD/NetBSD, 25&comma;621, FreeBSD (18.6) NetBSD (15.2), FreeBSD (40.1) NetBSD (36.1)
Linux/NetBSD, &z;1&comma;000, Linux (&z;0.6) NetBSD (&z;0.6), Linux (&z;3.3) NetBSD (&z;2.1)
<caption>
Number of clones (the same sequence of 30 or more tokens, with all
identifiers treated as equivalent) detected by CCFinder between three
different operating systems (Linux, FreeBSD, and NetBSD).  Adapted
from Kamiya, Kusumoto, and Inoue <book Kamiya_02>.
</caption>
.E_TABLE


.TABLE cheng_dead_func
: l 1cm 1.4cm 1.4cm l 1cm 1.4cm 1.4cm
Benchmark, Lines of Code, Number of Functions, Uncalled Functions, Benchmark, Lines of Code, Number of Functions, Uncalled Functions
008.espresso, 14&comma;838,  &ptz;361,  46,    126.gcc,    205&comma;583, 2&comma;019, 187
023.eqntott,  12&comma;053, &ptz;&z;62, &z;2, 130.li,      &z2;7&comma;597,  &ptz;357,   &z2;1
072.sc,     &z;8&comma;639,  &ptz;179, &z;8, 132.ijpeg,    &z;29&comma;290,  &ptz;477,  &z;16
085.cc1,      90&comma;857, 1&comma;452, 51, 134.perl,     &z;26&comma;874,  &ptz;276,  &z;13
124.m88ksim,  19&comma;092,  &ptz;252,  13,    147.vortex, &z;67&comma;205,  &ptz;923, 295
<caption>
Static count of number of functions and uncalled functions in
SPECint95.  Adapted from Cheng <book Cheng_00>.
</caption>
.E_TABLE


.TABLE Calder95b2
: l r r r l r r r
Program,   Mean,    Leaf,   Non-Leaf, Program, Mean,   Leaf,   Non-Leaf
burg,      61.6,    30.6,   142.8, eqntott,  386.8,   402.8,   294.2
ditroff,   58.6,    72.3,    56.3, espresso, 244.9,   151.3,   526.5
tex,      173.2,    44.3,   205.4, gcc,       96.4,    30.1,   123.5
xfig,      61.9,    38.6,    74.8, li,        42.5,    31.9,    44.2
xtex,     114.9,    93.9,   136.5, sc,        71.1,    49.4,    80.1
compress, 368.4, 1&comma;360.2, 367.5, Mean, 152.8,   209.6,   186.5
<caption>
Mean number of instructions executed per function invocation.
Based on Calder, Grunwald, and Zorn <book Calder_95b>.
</caption>
.E_TABLE


.TABLE func_cntrl
   ,  Embedded,     SPECint95, Book benchmarks
Trivial (one basic block), 32.7,  16.2, 57.1
Non-looping, 47.9, 48.1, 18.1
Looping, 19.4, 35.7, 24.8
<caption>
Contents of function bodies (as a percentage of all bodies), for
embedded <file>.c</file> source <book Engblom_99a>, SPECint95, and
the translated form of the books benchmark programs.
</caption>
.E_TABLE


.FIG
numstmt
<caption>
Number of statements and visible source lines contained in function
definitions.  Based on the translated form of the book benchmark
programs.
</caption>
.E_FIG


.FIG
totobjuse
<caption>
Number of references (i.e., an access or modification) to all
objects, having various kinds of linkage, within individual function
definitions.  Based on the translated form of the books benchmark
programs.
</caption>
.E_FIG


.FIG
indobjuse
<caption>
Number of references (i.e., an access or modification) to the same
object, having various kinds of linkage, within individual function
definitions.  Based on the translated form of the books benchmark
programs.
</caption>
.E_FIG


<A NAME="1798">1</A>
C99 {ref function, definition return type}

The return type of a function shall be <keyword>void</keyword> or an
object type other than array type.


.TABLE
: l r r l r r
Type/Representation, Embedded, SPECint95, Type/Representation, Embedded, SPECint95
<keyword>void</keyword>,  59.4, 31.2, ptr-to &ellipsis;,  2.0, 17.1
unsigned 32 bit, 0.5,  2.2, signed 32 bit,   0.3, 48.4
unsigned 16 bit, 3.3,  0.0, signed 16 bit,   1.6,  0.2
unsigned 8 bit, 31.6,  0.5, signed 8 bit,    0.8,  0.0
<caption>
Occurrence of function return types (as a percentage of all return
types; signedness and number of bits appearing in value
representation form) appearing in the source of embedded applications
(5,597 function definitions) and the SPECint95 benchmark (2,713
function definitions).  A likely explanation of the greater use of
type <keyword>void</keyword> is the perceived performance issues
associated with returning values via the stack causing developers to
return values via objects at file scope.  Adapted from Engblom <book
Engblom_99a>.
</caption>
.E_TABLE


<A NAME="1806">1</A>
C99

The declarator in a function definition specifies the name of the
function being defined and the identifiers of its parameters.


.TABLE param_type
: l r l r l r l r
Type, %, Type, %, Type, %, Type, %
<keyword>struct</keyword> <keyword>*</keyword>, &zp;44.4&ze;, <keyword>void</keyword> <keyword>*</keyword>, &zp;3.4&ze;, <keyword>long</keyword>, &zp;1.6&ze;, <keyword>struct</keyword> <keyword>*</keyword> <keyword>*</keyword>, &zp;1.2&ze;
<keyword>int</keyword>, &zp;14.7&ze;, <keyword>union</keyword> <keyword>*</keyword>, &zp;3.1&ze;, <keyword>int</keyword> <keyword>*</keyword>, &zp;1.5&ze;, <keyword>enum</keyword>, &zp;1.2&ze;
other-types, &zp;6.8&ze;, <keyword>unsigned</keyword> <keyword>long</keyword>, &zp;2.7&ze;, <keyword>unsigned</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;1.4&ze;, <keyword>const</keyword> <keyword>char</keyword> <keyword>*</keyword>, &zp;1.1&ze;
<keyword>unsigned</keyword> <keyword>int</keyword>, &zp;5.1&ze;, <keyword>unsigned</keyword> <keyword>int</keyword> <keyword>*</keyword>, &zp;2.0&ze;, <keyword>char</keyword> <keyword>*</keyword> <keyword>*</keyword>, &zp;1.3&ze;, <keyword>long</keyword> <keyword>*</keyword>, &zp;1.0&ze;
<keyword>char</keyword> <keyword>*</keyword>, &zp;4.7&ze;, <keyword>unsigned</keyword> <keyword>char</keyword>, &zp;1.6&ze;, <keyword>unsigned</keyword> <keyword>short</keyword>, &zp;1.2&ze;, , 
<caption>
Occurrence of parameter types in function definitions (as a
percentage of the parameters in all such definitions).  Based on the
translated form of the books benchmark programs.
</caption>
.E_TABLE


<A NAME="1829">2</A>
C99 {ref preprocessor directives, syntax}

.ASIS
<c_syntax>preprocessing-file:
                group<sub>opt</sub>

group:
                group-part
                group group-part

group-part:
                if-section
                control-line
                text-line
                </c_syntax><keyword>#</keyword> <c_syntax>non-directive
if-section:
                if-group elif-groups<sub>opt</sub> else-group<sub>opt</sub> endif-line

if-group:</c_syntax>
                <keyword># if</keyword>     <c_syntax>constant-expression new-line group<sub>opt</sub></c_syntax>
                <keyword># ifdef</keyword>  <c_syntax>identifier new-line group<sub>opt</sub></c_syntax>
                <keyword># ifndef</keyword> <c_syntax>identifier new-line group<sub>opt</sub>

elif-groups:
                elif-group
                elif-groups elif-group

elif-group:</c_syntax>
                <keyword># elif</keyword>   <c_syntax>constant-expression new-line group<sub>opt</sub>

else-group:</c_syntax>
                <keyword># else</keyword>   <c_syntax>new-line group<sub>opt</sub>

endif-line:</c_syntax>
                <keyword># endif</keyword>  <c_syntax>new-line

control-line:</c_syntax>
                <keyword># include</keyword> <c_syntax>pp-tokens new-line</c_syntax>
                <keyword># define</keyword>  <c_syntax>identifier replacement-list new-line</c_syntax>
                <keyword># define</keyword>  <c_syntax>identifier lparen identifier-list<sub>opt</sub></c_syntax> <keyword>)</keyword>
                                                    <c_syntax>replacement-list</c_syntax> <c_syntax>new-line</c_syntax>
                <keyword># define</keyword>  <c_syntax>identifier lparen</c_syntax> <keyword>... )</keyword> <c_syntax>replacement-list new-line</c_syntax>
                <keyword># define</keyword>  <c_syntax>identifier lparen identifier-list</c_syntax> <keyword>, ... )</keyword>
                                                    <c_syntax>replacement-list</c_syntax> <c_syntax>new-line</c_syntax>
                <keyword># undef</keyword>   <c_syntax>identifier new-line</c_syntax>
                <keyword># line</keyword>    <c_syntax>pp-tokens new-line</c_syntax>
                <keyword># error</keyword>   <c_syntax>pp-tokens<sub>opt</sub> new-line</c_syntax>
                <keyword># pragma</keyword>  <c_syntax>pp-tokens<sub>opt</sub> new-line</c_syntax>
                <keyword>#</keyword>         <c_syntax>new-line

text-line:
                pp-tokens<sub>opt</sub> new-line

non-directive:
                pp-tokens new-line

lparen:</c_syntax>
                a <keyword>(</keyword> character not immediately preceded by white-space

<c_syntax>replacement-list:
                pp-tokens<sub>opt</sub>

pp-tokens:
                preprocessing-token
                pp-tokens preprocessing-token

new-line:
                the new-line character</c_syntax>
.E_ASIS


.FIG
hashindent
<caption>
Indentation of preprocessing directives (i.e., amount of white space
before the first <keyword>#</keyword> on a line, with tab characters
treated as eight space characters).  Based on the visible form of
<file>.c</file> and <file>.h</file> files.
</caption>
.E_FIG


.FIG
incdefline
<caption>
Relative location (i.e., 100*line_number/lines_in_file) of
<keyword>#include</keyword> and <keyword>#define</keyword> directives
in the visible source.
</caption>
.E_FIG


.TABLE direct_name
: l r r l r r
Directive Name, <file>.c</file> file, <file>.h</file> file, Directive Name, <file>.c</file> file, <file>.h</file> file
<keyword>#define</keyword>, &zp;19.9&ze;, &zp;75.0&ze;, <keyword>#if</keyword>, &zp;6.2&ze;, &zp;1.5&ze;
<keyword>#endif</keyword>, &zp;19.9&ze;, &zp;7.2&ze;, <keyword>##</keyword>, &zp;0.3&ze;, &zp;0.9&ze;
<keyword>#include</keyword>, &zp;28.6&ze;, &zp;4.1&ze;, <keyword>#elif</keyword>, &zp;0.2&ze;, &zp;0.2&ze;
<keyword>#ifndef</keyword>, &zp;2.4&ze;, &zp;3.2&ze;, <keyword>#pragma</keyword>, &zp;0.1&ze;, &zp;0.1&ze;
<keyword>#ifdef</keyword>, &zp;11.3&ze;, &zp;2.5&ze;, <keyword>#error</keyword>, &zp;0.2&ze;, &zp;0.1&ze;
<keyword>#else</keyword>, &zp;4.8&ze;, &zp;1.7&ze;, <keyword>#</keyword>, &zp;0.0&ze;, &zp;0.1&ze;
defined, &zp;3.6&ze;, &zp;1.7&ze;, <keyword>#line</keyword>, &zp;1.4&ze;, &zp;0.0&ze;
<keyword>#undef</keyword>, &zp;1.0&ze;, &zp;1.6&ze;, , , 
<caption>
Occurrence of preprocessor directive names and preprocessor operators
(as a percentage of all directive names and operators).  Based on the
visible form of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


<A NAME="1844">3</A>
C99 {ref #if, defined}

and it may contain unary operator expressions of the form

.ASIS
  <keyword>defined</keyword> <c_syntax>identifier</c_syntax>
.E_ASIS

or

.ASIS
  <keyword>defined (</keyword> <c_syntax>identifier</c_syntax> <keyword>)</keyword>
.E_ASIS

which evaluate to 1 if the identifier is currently defined as a macro
name (that is, if it is predefined or if it has been the subject of a
<keyword>#define</keyword> preprocessing directive without an
intervening <keyword>#undef</keyword> directive with the same subject
identifier), 0 if it is not.


.TABLE defined
: c r
Preprocessing Directive, %
<keyword>#if</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;15.7&ze;
<keyword>#if</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>||</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;5.8&ze;
<keyword>#if</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>&&</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;2.0&ze;
<keyword>#if</keyword> <keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;1.9&ze;
<keyword>#elif</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;1.9&ze;
<keyword>#if</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>&&</keyword> <keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;1.3&ze;
<keyword>#if</keyword> <keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>&&</keyword> <keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;0.9&ze;
<keyword>#if</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>||</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>||</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;0.8&ze;
<keyword>#if</keyword> defined identifier <keyword>||</keyword> defined identifier, &zp;0.5&ze;
<keyword>#if</keyword> <keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>&&</keyword> <keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>&&</keyword> <keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;0.3&ze;
others, &zp;5.3&ze;
<caption>
Occurrence of controlling expressions containing the
<keyword>defined</keyword> operator (as a percentage of all
<keyword>#if</keyword> and <keyword>#elif</keyword> preprocessing
directives).  The <keyword>#elif</keyword> token sequence was
followed by <keyword>defined</keyword> in 66.5% of <file>.c</file>
file occurrences (<file>.h</file> 75.5).  Based on the visible form
of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


<A NAME="1846">1</A>
C99

Preprocessing directives of the forms

.ASIS
  <keyword># if</keyword>   <c_syntax>constant-expression new-line group<sub>opt</sub></c_syntax>
  <keyword># elif</keyword> <c_syntax>constant-expression new-line group<sub>opt</sub></c_syntax>
.E_ASIS

check whether the controlling constant expression evaluates to nonzero.


.TABLE ppif_cntrl
: c r
Abstract Form of Control Expression, %
 identifier, &zp;26.5&ze;
<c_syntax>integer-constant</c_syntax>, &zp;20.3&ze;
defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;16.4&ze;
defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>||</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;6.0&ze;
identifier <keyword>==</keyword> identifier, &zp;2.4&ze;
identifier <keyword>></keyword> <c_syntax>integer-constant</c_syntax>, &zp;2.4&ze;
identifier <keyword>>=</keyword> function-call, &zp;2.1&ze;
defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>&&</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;2.0&ze;
<keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;2.0&ze;
defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>&&</keyword> <keyword>!</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;1.3&ze;
identifier <keyword>>=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.3&ze;
identifier <keyword>!=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.1&ze;
identifier <keyword><</keyword> function-call, &zp;1.1&ze;
<keyword>!</keyword> identifier, &zp;1.1&ze;
others, &zp;14.0&ze;
<caption>
Occurrence of common <keyword>#if</keyword> preprocessing directive
controlling expressions (as a percentage of all
<keyword>#if</keyword> directives).  Based on the visible form of the
<file>.c</file> files.  Where <c_syntax>integer-constant</c_syntax>
is an integer constant expression, and <phrase>function-call</phrase>
is an invocation of a function-like macro.
</caption>
.E_TABLE


.TABLE ppelif_cntrl
: c r
Abstract Form of Control Expression, %
defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;49.7&ze;
identifier <keyword>==</keyword> identifier, &zp;19.4&ze;
 defined identifier, &zp;6.6&ze;
defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>||</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;5.7&ze;
 identifier, &zp;4.7&ze;
defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>&&</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;2.6&ze;
identifier <keyword>==</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.9&ze;
identifier <keyword>>=</keyword> function-call, &zp;1.2&ze;
defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>||</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword> <keyword>||</keyword> defined <keyword>(</keyword> identifier <keyword>)</keyword>, &zp;1.2&ze;
identifier <keyword>>=</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.0&ze;
others, &zp;6.1&ze;
<caption>
Occurrence of common <keyword>#elif</keyword> preprocessing directive
controlling expressions (as a percentage of all
<keyword>#elif</keyword> directives).  Based on the visible form of
the <file>.c</file> files.  Where
<c_syntax>integer-constant</c_syntax> is an integer constant
expression, and <phrase>function-call</phrase> is a function-like
macro.
</caption>
.E_TABLE


<A NAME="1858">2</A>
C99

If it evaluates to false (zero), the group that it controls is
skipped: directives are processed only through the name that
determines the directive in order to keep track of the level of
nested conditionals;


.FIG
skipif
<caption>
Number of lines skipped in the top-level source file (i.e., the
contents of any included files are not counted) and the complete
translation unit (including the contents of any files
<keyword>#include</keyword>d more than once) during translation of
the books benchmark programs.
</caption>
.E_FIG


<A NAME="1864">1</A>
C99 {ref source file, inclusion}

A <keyword>#include</keyword> directive shall identify a header or
source file that can be processed by the implementation.


.FIG
unnecincl
<caption>
Number of <keyword>#include</keyword>s of
<c_syntax>header-name</c_syntax>s whose contents are not referenced
during translation.  Based on the translated form of the books
benchmark programs.
</caption>
.E_FIG


.FIG
numincl
<caption>
Number of <keyword>#include</keyword> directives (dashed lines
represents number of unique headers).  Based on the visible form of
the <file>.c</file> files.
</caption>
.E_FIG


.FIG
sameincl
<caption>
Number of <c_syntax>header-name</c_syntax>s in
<keyword>#include</keyword> directives specifying the same character
sequence.  Based on the visible form of the <file>.c</file> files for
various program build trees.
</caption>
.E_FIG


.TABLE include_hdr
: l r r c
Header Form, % Occurrence, % Uses Path, Number Absolute Paths
<h-char-sequence>, &zp;75.0&ze;, &zp;86.4&ze;, &zs;0&ze;
"q-char-sequence", &zp;25.0&ze;, &zp;17.2&ze;, &zs;0&ze;
<caption>
Occurrence of two forms of <c_syntax>header-name</c_syntax>s (as a
percentage of all <keyword>#include</keyword> directives), the
percentage of each kind that specifies a path to the header file, and
number of absolute paths specified.  Based on the visible form of the
<file>.c</file> files.
</caption>
.E_TABLE


<A NAME="1865">1</A>
C99 {ref #include, h-char-sequence}

A preprocessing directive of the form

.ASIS
  <keyword># include <</keyword><c_syntax>h-char-sequence</c_syntax><keyword>></keyword> <c_syntax>new-line</c_syntax>
.E_ASIS

searches a sequence of implementation-defined places for a header
identified uniquely by the specified sequence between the
<keyword><</keyword> and <keyword>></keyword> delimiters, and causes
the replacement of that directive by the entire contents of the
header.


.TABLE usr_include
: l r r r r r r
Information , Linux 2.0, AIX on RS/6000, HP/UX 9, SunOS 4, Solaris 2, ISO C
Number of headers,                 2&comma;006, 1&comma;514, 1&comma;264, 987, 1&comma;495, 24
macro definitions,                 10&comma;252, 18&comma;637, 13&comma;314, 11&comma;987, 10&comma;903, 446
identifiers with external linkage,  1&comma;672, 1&comma;542,   1&comma;935,   616,  1&comma;281, 487
identifiers with internal linkage,    80, 34,     2012,     0,     5, 0
tag declaration,                       716, 1&comma;088,    899,  1&comma;208,   945, 3
typedef name declared,              1&comma;024, 828,      15,   493,  1&comma;027, 55
<caption>
Number of various kinds of identifiers declared in the headers
contained in the <file>/usr/include</file> directory of various
translation environments.  Information was automatically extracted
and represents an approximate lower bound.  Versions of the
translation environments from approximately the same year (mid 1990s)
were used.  The counts for ISO C assumes that the minimum set of
required identifiers are declared and excludes the type generic
macros.
</caption>
.E_TABLE


<A NAME="1898">1</A>
C99 {ref macro, define object-like}

A preprocessing directive of the form

.ASIS
  <keyword># define</keyword> <c_syntax>identifier replacement-list new-line</c_syntax>
.E_ASIS

defines an <i>object-like macro</i> that causes each subsequent
instance of the macro name<sup>144)</sup> to be replaced by the
replacement list of preprocessing tokens that constitute the
remainder of the directive.


.TABLE rep_list_form
: l r l
Replacement List, %, Example
empty,              6.9, <c_code>#define DUMMY</c_code>
constant,          42&ptz;, <c_code>#define ARG_MAX 1000</c_code>
expression,        33&ptz;, <c_code>#define SHFT_UP(x) ((x) << 8)</c_code>
statement,          5.1, <c_code>#define TERMINATE goto func_end</c_code>
type,               2.1, <c_code>#define NODE_PTR void *</c_code>
syntactic,          0.5, <c_code>#define begin {</c_code>
symbol,             1.4, <c_code>#define ALLOC_STORAGE malloc</c_code>
unknown identifier, 6.9, <c_code>#define INTERN_BUF buffer</c_code>
other,              1.9, <c_code>#define OPTION -X=23</c_code>
<caption>
Detailed breakdown of the kinds of replacement lists occurring in
macro definitions.  Adapted from Ernst, Badros, and Notkin <book
Ernst_02>.
</caption>
.E_TABLE


.TABLE def_rep_list
: l r
Kind of Macro Defined and Abstract Form of its Replacement List, %
object-macro <c_syntax>integer-constant</c_syntax>, &zp;50.7&ze;
  object-macro identifier, &zp;5.9&ze;
  object-macro expression, &zp;5.8&ze;
  function-macro function-call, &zp;4.7&ze;
  object-macro function-call, &zp;3.7&ze;
object-macro <c_syntax>string-literal</c_syntax>, &zp;3.4&ze;
  function-macro expression, &zp;3.4&ze;
  object-macro, &zp;3.4&ze;
  object-macro constant-expression, &zp;2.0&ze;
  function-macro, &zp;1.7&ze;
others, &zp;15.4&ze;
<caption>
Occurrence of macro definitions and an abstract form of their
replacement list (as a percentage of all macro definitions).  Based
on the visible form of the <file>.c</file> and <file>.h</file> files.
Note that <phrase>function-call</phrase> may also be a macro
invocation.
</caption>
.E_TABLE


.FIG
macexpand
<caption>
Number of macro names expanded, excluding expansions occurring while
processing the contents of system headers, during translation of the
books benchmark programs.
</caption>
.E_FIG


<A NAME="1923">1</A>
C99 {ref ##, operator}

A <keyword>##</keyword> preprocessing token shall not occur at the
beginning or at the end of a replacement list for either form of
macro definition.


.TABLE hashhash
: l r
Preprocessing Token Sequence, %
identifier <keyword>##</keyword> identifier, &zp;70.2&ze;
<keyword>,</keyword> <keyword>##</keyword> identifier, &zp;24.2&ze;
identifier <keyword>##</keyword> identifier <keyword>##</keyword> identifier, &zp;15.7&ze;
others, &zp;4.8&ze;
<c_syntax>integer-constant</c_syntax> <keyword>##</keyword> identifier, &zp;1.8&ze;
<c_syntax>integer-constant</c_syntax> <keyword>##</keyword> identifier <keyword>##</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.0&ze;
identifier <keyword>##</keyword> <c_syntax>integer-constant</c_syntax>, &zp;1.0&ze;
<caption>
Occurrence of the <keyword>##</keyword> preprocessor operator (as a
percentage of all occurrences of that operator).  Based on the
visible form of the <file>.c</file> and <file>.h</file> files.  The
form <c_code>, ## identifier</c_code> is a <tool>gcc</tool> extension
(described in the Common implementations subclause).
</caption>
.E_TABLE


<A NAME="1926">1</A>
C99

For both object-like and function-like macro invocations, before the
replacement list is reexamined for more macro names to replace, each
instance of a <keyword>##</keyword> preprocessing token in the
replacement list (not from an argument) is deleted and the preceding
preprocessing token is concatenated with the following preprocessing
token.


.TABLE
: l 2cm 2cm 2cm 2cm 2.5cm
 , <c_syntax>identifier</c_syntax>, <c_syntax>pp-number</c_syntax>, <c_syntax>punctuator</c_syntax>, <c_syntax>string-literal</c_syntax>, <c_syntax>character-constant</c_syntax>
identifier, identifier, identifier or undefined, undefined, string-literal or undefined, character-constant or undefined
pp-number, pp-number, pp-number, pp-number or undefined, undefined, undefined
punctuator, pp-number or undefined, pp-number or undefined, punctuator or undefined, undefined, undefined
everything else, undefined, undefined, undefined, undefined, undefined
<caption>
Possible results of concatenating, using the <keyword>##</keyword>
operator, pairs of preprocessing tokens (the one appearing in the
left column followed by the one appearing in the top row) where the
result might be defined (<phrase>undefined</phrase> denotes undefined
behavior).
</caption>
.E_TABLE


<A NAME="1941">1</A>
C99 {ref #undef}

A preprocessing directive of the form

.ASIS
  <keyword># undef</keyword> <c_syntax>identifier new-line</c_syntax>
.E_ASIS

causes the specified identifier no longer to be defined as a macro name.


.TABLE undef_seq
: l r
Following Directive Sequences, %
, &zp;53.0&ze;
<keyword>#ifdef</keyword>, &zp;20.4&ze;
<keyword>#define</keyword>, &zp;16.2&ze;
others, &zp;4.8&ze;
<keyword>#define</keyword> <keyword>#undef</keyword>, &zp;2.7&ze;
#if(n)def, &zp;1.5&ze;
<keyword>#define</keyword> #undef-#define <keyword>#undef</keyword>, &zp;1.4&ze;
<caption>
Occurrence of different sequences of preprocessing directives (as a
percentage of all such sequences) that follow a
<keyword>#undef</keyword> and reference the same identifier (e.g.,
2.7% of the first occurrence of <keyword>#undef</keyword> are
followed by one or more <keyword>#define</keyword>s followed by one
or more <keyword>#undef</keyword>s).  Based on the visible form of
the <file>.c</file> files.
<keyword>#define</keyword> represents one or more
<keyword>#define</keyword> preprocessing directives.
<keyword>#undef</keyword> represents one or more
<keyword>#undef</keyword> preprocessing directives.
<keyword>#if[n]def</keyword> represents two or more
<keyword>#if</keyword>s and <keyword>#ifndef</keyword>s, in any order.
<keyword>#und-def</keyword> represents one or more pairs of
<keyword>#undef #define</keyword> preprocessing directives.
</caption>
.E_TABLE


<A NAME="1969">1</A>
C99 {ref macro name, predefined}

The following macro names<sup>148)</sup> shall be defined by the
implementation:


.TABLE predef_macro
: l r r l r r l r r
Predefined Macro, <file>.c</file> files, <file>.h</file> files, Predefined Macro, <file>.c</file> files, <file>.h</file> files, Predefined Macro, <file>.c</file> files, <file>.h</file> files
 __LINE__, &z2p;42.17&ze;, &z2p;43.47&ze;, __TIME__, &z2p;2.52&ze;, &z2p;0.00&ze;, __STDC_IEC_559__, &z2p;0.00&ze;, &z2p;0.00&ze;
 __FILE__, &z2p;36.31&ze;, &z2p;37.77&ze;, __STDC_VERSION__, &z2p;0.00&ze;, &z2p;0.00&ze;, __STDC_HOSTED__, &z2p;0.00&ze;, &z2p;0.00&ze;
 __STDC__, &z2p;15.77&ze;, &z2p;18.11&ze;, __STDC_ISO_10646__, &z2p;0.00&ze;, &z2p;0.00&ze;,  , , 
 __DATE__, &z2p;3.23&ze;, &z2p;0.65&ze;, __STDC_IEC_559_COMPLEX__, &z2p;0.00&ze;, &z2p;0.00&ze;,  , , 
<caption>
Occurrence of predefined macro names (as a percentage of all
predefined macro names; a total of 1,826).  Based on the visible form
of the <file>.c</file> and <file>.h</file> files.
</caption>
.E_TABLE


<A NAME="2022">x</A>


.TABLE lib_func_use
: l r l r l r l r
Function, %, Function, %, Function, %, Function, %
 fprintf, &z3p;1.468&ze;, memmove, &z3p;0.093&ze;, strstr, &z3p;0.028&ze;, ferror, &z3p;0.016&ze;
 sprintf, &z3p;0.978&ze;, fclose, &z3p;0.085&ze;, sin, &z3p;0.028&ze;, atof, &z3p;0.016&ze;
 printf, &z3p;0.902&ze;, strchr, &z3p;0.077&ze;, mblen, &z3p;0.028&ze;, strncat, &z3p;0.015&ze;
 strlen, &z3p;0.824&ze;, fopen, &z3p;0.077&ze;, realloc, &z3p;0.026&ze;, ftell, &z3p;0.015&ze;
 strcmp, &z3p;0.730&ze;, fabs, &z3p;0.065&ze;, memcmp, &z3p;0.021&ze;, tolower, &z3p;0.014&ze;
 strcpy, &z3p;0.533&ze;, signal, &z3p;0.045&ze;, fputs, &z3p;0.021&ze;, fscanf, &z3p;0.014&ze;
 free, &z3p;0.397&ze;, getenv, &z3p;0.045&ze;, strerror, &z3p;0.020&ze;, abort, &z3p;0.014&ze;
 memcpy, &z3p;0.324&ze;, abs, &z3p;0.044&ze;, cos, &z3p;0.020&ze;, qsort, &z3p;0.013&ze;
 memset, &z3p;0.321&ze;, perror, &z3p;0.040&ze;, strtok, &z3p;0.019&ze;, mbtowc, &z3p;0.013&ze;
 exit, &z3p;0.218&ze;, fwrite, &z3p;0.034&ze;, strrchr, &z3p;0.019&ze;, fseek, &z3p;0.013&ze;
 malloc, &z3p;0.201&ze;, fflush, &z3p;0.034&ze;, sqrt, &z3p;0.019&ze;, calloc, &z3p;0.013&ze;
 strncmp, &z3p;0.194&ze;, sscanf, &z3p;0.032&ze;, ungetc, &z3p;0.018&ze;, mbstowcs, &z3p;0.012&ze;
 strcat, &z3p;0.190&ze;, vsprintf, &z3p;0.031&ze;, floor, &z3p;0.017&ze;, feof, &z3p;0.012&ze;
 rand, &z3p;0.179&ze;, fread, &z3p;0.030&ze;, ceil, &z3p;0.017&ze;, atol, &z3p;0.012&ze;
 strncpy, &z3p;0.145&ze;, snprintf, &z3p;0.029&ze;, toupper, &z3p;0.016&ze;, wcstombs, &z3p;0.011&ze;
 atoi, &z3p;0.110&ze;, time, &z3p;0.028&ze;, fgets, &z3p;0.016&ze;,  , 
<caption>
Occurrence of calls to C library functions (as a percentage of all
calls).  Based on the translated form of the books benchmark programs.
</caption>
.E_TABLE


.TABLE
: l r r r r r l r r r r r
Programs,   main, libc,  libm, libots, libcurses, Programs,   main, libc,  libm, libots, libcurses
alvinn,    97.25,  2.12, 0.63,       ,  , li,        99.71,  0.29,     ,       , 
compress,  99.98,  0.02,     ,       ,  , m88ksim,   99.75,  0.03, &emdash;,   0.22, 
ditroff,   87.80, 12.20,     ,       ,  , perl,      70.70, 29.30,     ,       , 
ear,       90.33,  6.12, 3.55,       ,  , sc,        53.03, 18.42, &emdash;, &emdash;, 28.55
eqntott,   94.29,  5.71,     ,       ,  , vortex,    95.11,  4.89,     ,       , 
espresso,  93.93,  6.07,     ,       ,  , Mean,      90.15,  7.10, 0.35,   0.02,  2.38
go,        99.99,  0.01,     ,       ,  , , , , , , 
<caption>
Percentage of instructions executed in developer written code and
implementation libraries (main library <file>libc</file>, and maths
library <file>libm</file>) of C programs that do not use the X11
libraries.
Based on Calder, Grunwald, and Srivastava <book Calder_95c>.
</caption>
.E_TABLE


.TABLE
: l r r r r r r r r r
Programs,    main,  libc,  libm, libX11, libXaw, libXext, libXm, libXmu,   libXt
cbzone,     48.10, 11.80,  7.60,  32.14, &emdash;,       ,        ,       ,   0.36
ghostview,   3.38, 23.39, &emdash;,  20.93,  7.53,   0.02,        ,   0.08,  44.68
gs,         91.88,  4.99,  0.18,   2.93, &emdash;,       ,        ,       ,   0.02
xanim,      62.40, 29.96,  0.06,   4.36,  0.09,       ,        ,       ,   3.13
xfig,        4.95, 15.05,  0.15,  28.58,  9.84,       ,        ,   0.14,  41.30
xkeycaps,    6.47, 18.45,      ,  43.15,  3.70,    0.01,       ,   0.06,  28.15
xmgr,       22.95, 12.13,  0.04,  23.24, &emdash;,       ,   17.05, &emdash;,  24.60
xpaint,     14.11, 11.01, &emdash;,  25.43,  0.77,       ,        ,   0.02,  48.66
xpilot,     68.64, 24.24,  0.03,   7.09, &emdash;,       ,        ,       , 
xpool,      53.17,  0.26, 44.91,   1.65, &emdash;,       ,        ,       , 
xtex,       45.02, 23.86, &emdash;,  23.09,  2.95,       ,        ,   0.03,   5.05
xv,         74.07, 25.46,  0.01,   0.46, &emdash;,       ,        ,       , 
Mean,       41.26, 16.72,  4.41,  17.75,  2.07,   0.00,    1.42,   0.03,  16.33
<caption>
Percentage of instructions executed in developer written code and
implementation libraries of C programs that use the X11 libraries.
Based on Calder, Grunwald, and Srivastava <book Calder_95c>.
</caption>
.E_TABLE


<A NAME="2041">1</A>
C99

The standard headers are

<keyword><assert.h></keyword> <keyword><inttypes.h></keyword>
<keyword><signal.h></keyword> <keyword><stdlib.h></keyword>
<keyword><complex.h></keyword> <keyword><iso646.h></keyword>
<keyword><stdarg.h></keyword> <keyword><string.h></keyword>
<keyword><ctype.h></keyword> <keyword><limits.h></keyword>
<keyword><stdbool.h></keyword> <keyword><tgmath.h></keyword>
<keyword><errno.h></keyword> <keyword><locale.h></keyword>
<keyword><stddef.h></keyword> <keyword><time.h></keyword>
<keyword><fenv.h></keyword> <keyword><math.h></keyword>
<keyword><stdint.h></keyword> <keyword><wchar.h></keyword>
<keyword><float.h></keyword> <keyword><setjmp.h></keyword>
<keyword><stdio.h></keyword> <keyword><wctype.h></keyword>


.TABLE stdhdrh
: l r r l r r
Header name, <file>.c</file> file, <file>.h</file> file, Header name, <file>.c</file> file, <file>.h</file> file
 stdio.h, &zs;1424&ze;, &zs;175&ze;, signal.h, &zs;213&ze;, &zs;10&ze;
 stdlib.h, &zs;860&ze;, &zs;100&ze;, locale.h, &zs;23&ze;, &zs;7&ze;
 stddef.h, &zs;107&ze;, &zs;90&ze;, stdint.h, &zs;0&ze;, &zs;3&ze;
 string.h, &zs;828&ze;, &zs;83&ze;, inttypes.h, &zs;1&ze;, &zs;1&ze;
 errno.h, &zs;481&ze;, &zs;82&ze;, float.h, &zs;25&ze;, &zs;1&ze;
 setjmp.h, &zs;81&ze;, &zs;80&ze;, wctype.h, &zs;1&ze;, &zs;0&ze;
 stdarg.h, &zs;167&ze;, &zs;54&ze;, wchar.h, &zs;2&ze;, &zs;0&ze;
 time.h, &zs;185&ze;, &zs;47&ze;, tgmath.h, &zs;0&ze;, &zs;0&ze;
 ctype.h, &zs;291&ze;, &zs;35&ze;, stdbool.h, &zs;0&ze;, &zs;0&ze;
 limits.h, &zs;88&ze;, &zs;32&ze;, iso646.h, &zs;0&ze;, &zs;0&ze;
 assert.h, &zs;91&ze;, &zs;26&ze;, fenv.h, &zs;1&ze;, &zs;0&ze;
 math.h, &zs;246&ze;, &zs;21&ze;, complex.h, &zs;0&ze;, &zs;0&ze;
<caption>
Number of standard headers (in a <keyword>#include</keyword>
directive).  Based on the visible form of the <file>.c</file> and
<file>.h</file> files.
</caption>
.E_TABLE


<A NAME="2053">1</A>
C99 {ref reserved identifier} {ref identifier, reserved}

Each header declares or defines all identifiers listed in
its associated subclause, and optionally declares or defines
identifiers listed in its associated future library directions
subclause and identifiers which are always reserved either
for any use or for use as file scope identifiers.


.TABLE reserved_id
: 10cm r
Reserved spelling, Occurrences
Identifier&comma; starting with <phrase>&uu;</phrase>&comma; declared to have any form, 3&comma;071
Identifier&comma; starting with <phrase>_[A-Z]</phrase>&comma; declared to have any form, 10&comma;255
Identifier&comma; starting with <phrase>wcs[a-z]</phrase>&comma; declared to have any form, 1
Identifier&comma; with external  linkage&comma; defined in C99, 12
File scope identifier or tag, 6&comma;832
File scope identifier, 2
Macro name reserved when appropriate header is <keyword>#include</keyword>d, 6
Possible macro covered identifier, 144
Macro name starting with <phrase>E[A-Z]</phrase>, 339
Macro name starting with <phrase>SIG[A-Z]</phrase>, 2
Identifier&comma; starting with <phrase>is[a-z]</phrase>&comma; with external linkage (possibly macro covered), 47
Identifier&comma; starting with <phrase>mem[a-z]</phrase>&comma; with external linkage (possibly macro covered), 108
Identifier&comma; starting with <phrase>str[a-z]</phrase>&comma; with external linkage (possibly macro covered), 904
Identifier&comma; starting with <phrase>to[a-z]</phrase>&comma; with external linkage (possibly macro covered), 338
Identifier&comma; starting with <phrase>is[a-z]</phrase>&comma; with external linkage, 33
Identifier&comma; starting with <phrase>mem[a-z]</phrase>&comma; with external linkage, 7
Identifier&comma; starting with <phrase>str[a-z]</phrase>&comma; with external linkage, 28
Identifier&comma; starting with <phrase>to[a-z]</phrase>&comma; with external linkage, 62
<caption>
Number of developer declared identifiers (the contents of any header
was only counted once) whose spelling (the notation
<phrase>[a-z]</phrase> denotes a regular expression, i.e., a
character between <hlight>a</hlight> and <hlight>z</hlight>) is
reserved for use by the implementation or future revisions of the C
Standard.  Based on the translated form of the books benchmark
programs.  How many identifiers declared###
</caption>
.E_TABLE


<A NAME="2153">1</A>
C99 {ref ctype.h, header}

The header <ctype.h> declares several functions useful for
classifying and mapping characters.166)
In all cases the argument is an int, the value of which
shall be representable as an unsigned char or shall equal
the value of the macro EOF.
If the argument has any other value, the behavior is undefined.


.FIG
ctype
<caption>
Interrelationships between the character handling functions.
</caption>
.E_FIG


<A NAME="2814">1</A>
C99 {ref memory management, functions}

The order and contiguity of storage allocated by successive
calls to the calloc, malloc, and realloc functions is unspecified.
The pointer returned if the allocation succeeds is suitably
aligned so that it may be assigned to a pointer to any type
of object and then used to access such an object or an array
of such objects in the space allocated (until the space
is explicitly deallocated).
The lifetime of an allocated object extends from the allocation
until the deallocation.
Each such allocation shall yield a pointer to an object
disjoint from any other object.
The pointer returned points to the start (lowest byte address)
of the allocated space.
If the space cannot be allocated, a null pointer is returned.
If the size of the space requested is zero, the behavior
is implementation-defined: either a null pointer is returned,
or the behavior is as if the size were some nonzero value,
except that the returned pointer shall not be used to access
an object.


.TABLE
: l r r r l r r r
Program,  mallocs,  frees,   size, Program,  mallocs,  frees,   size
burg,      23&comma;098,   2&comma;895,    843.4, eqntott,      85,      0,  23&comma;981.6
ditroff,       0,      0,  &emdash;, espresso, 190&comma;386, 190&comma;077,    122.5
tex,          60,     32,   1&comma;727.1, gcc,        1&comma;043,    903,   1&comma;353.4
xfig,       7&comma;260,   4&comma;070,    193.6, li,           27,      0,   3&comma;407.5
xtex,       2&comma;944,   1&comma;131,    358.9, sc,         6&comma;985,   2&comma;419,     52.0
compress,      1,      0,     16.0, , , , 
<caption>
Memory management function usage.  <phrase>mallocs</phrase> is the
number of calls to the <c_func>malloc</c_func> library function,
<phrase>frees</phrase> the number of calls to the
<c_func>free</c_func> library function, and <phrase>size</phrase> the
mean number of bytes of the objects allocated.  Based on Calder,
Grunwald, and Zorn <book Calder_95b>.
</caption>
.E_TABLE


<A NAME="2860">15</A>
C99 {ref div, function} {ref ldiv, function} {ref lldiv, function}


.TABLE
: r r r r
numer,  denom,  quot,   rem
    7,      3,     2,     1
   -7,      3,    -2,    -1
    7,     -3,    -2,     1
   -7,     -3,     2,    -1
<caption>
Table 7.2: Results of div, ldiv and lldiv
</caption>
.E_TABLE

