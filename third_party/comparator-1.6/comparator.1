.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "COMPARATOR" 1 "" "" ""
.SH NAME
comparator, filterator \- fast location of common code in large source trees
.SH "SYNOPSIS"

.nf
\fBcomparator\fR [-c] [-C] [-d \fIdir\fR] [-o \fIfile\fR] [-r] [-s \fIshredsize\fR] [-w] [-v] [-x] path...
          \fBfilterator\fR [-d \fIdir\fR] [-n] [-s \fIminsize\fR] [-x]
.fi

.SH "DESCRIPTION"

.PP
comparator is a program for quickly finding common sections in two or more source-code trees. It's named after a now-obsolete astronomical instrument called a blink comparator that was used to find moving objects in starfield photos. These reports tend to be noisy; filterator is a postprocessor for comparator reports that can apply significance filtering.

.PP
comparator works by first chopping the specified trees into overlapping shreds (by default 3 lines long) and computing the MD5 hash of each shred. The resulting list of shreds is examined and all unique hashes are thrown out. Then comparator generates a report listing all cliques of lines with duplicate hashes, with overlapping ranges merged. The output format can (not by coincidence) be stepped through with the next-error function of Emacs.

.PP
A consequence of the method is that comparator will find common code segments wherever they are. It is insenstive to rearrangements of the source trees. With appropriate options, code can be normalized at input to ignore differences in whitespace and (in C code) brace placenent. An option to strip comments also exists

.PP
The program is capable of generating a hash list for a source code tree which can be used in place of the tree itself. Thus, it is possible to do comparisons with source trees without having access to the actual source code, providing someone who has access is willing to ship you a hash list. These hash lists are called &#8216;SCF files&#8217; and made with the extension \fI.scf\fR; the name stands for Source Comparison Format.

.PP
In its normal mode of operation, comparator expects two or more command-line arguments which are the root directories of the source-code trees to be compared, and generates a report to standard output. Progress messages are emitted to standard error. Some arguments may be the names of SCF files.

.PP
When given a single path argument which is a tree, the program generates an SCF hash list to standard output.

.PP
When the \fB-c\fR option is specified, the program generates a SCF file from each tree specified on the command line. The name of the resulting file is the argument name with \fI.scf\fR appended.

.PP
The \fB-o\fR directs output to a specified file. This may be used with \fB-c\fR to override the normal \fI.scf\fR convention, or simply as an alternative to ouput redirection when generating a final report.

.PP
The \fB-d\fR option changes current directory to the specified tree before walking down each argument path to generate hashes. This will be useful if you want to generate a report for trees in a directory other than your current, but want the filenames in the report to be relative.

.PP
The \fB-s\fR option changes the shred size. Smaller shred sizes are more sensitive to small code duplications, but produce correspondingly noisier output. Larger ones will suppress both noise and small similarities.

.PP
The \fB-w\fR causes all whitespace in the file (including blank lines) to be ignored for comparison purposes (line numbers in the output report will nevertheless be correct).

.PP
The \fB-C\fR implies \fB-w\fR and also applies C-language-specific normalization; { and } characters are removed. This is recommended for comparing C code; it prevents the comparison from being fooled by differences in indent style.

.PP
The \fB-r\fR option removes comments. This is only effective in conjunction with \fB-C\fR. In C files, ll // comments, but only "winged" /* comments with the start and end of comment on the same line are ignored; also, block /* comments are retained, but the beginning /* and ending */ are ignored, In other files, all # comments are removed.

.PP
The option \fB-v\fR enables progress and timing messages to standard error.

.PP
The \fB-x\fR enables some debugging output. It is for developers; if you need to understand it, read the code.

.PP
comparator uses a grotty heuristic for figuring out which files in a tree are eligible to be compared. Files with \fI.c\fR and \fI.h\fR extensions are always eligible. Files with \fI.o\fR or \fI~\fR extensions are always ignored. CVS, RCS, and SCCS directories are ignored. Other files are checked to see if the percentage of printable characters near the front of the file is above 90%.

.PP
filterator is a postprocessor for the SCF-B output of comparator that produces an actual code listing. By default, it throws away ranges that appear to be noise. The noise test for C files is to throw away whitespace, C syntax, #include lines and a few common macros and see if anything is left. The noise test for shell files throws away Bourne-shell keywords

.PP
The \fB-n\fR suppresses noise filtering. The \fB-d\fR acts as it does for comparator. The \fB-s\fR option sets the minimum size of overlap to be reported. Setting this to a slightly larger number than the comparator shred size is a useful way to filter out spurious matches; thus, while comparator defaults to a shred size of 3, filterator defaults to a minimum size of 5. The \fB-x\fR enables some debugging output. It is for developers; if you need to understand it, read the code.

.PP
Each filterator line beginning with % is the filename from which the following common span of lines is displayed filterator displays each span of lines, unnormalized, from the first file in the clique of matches that it can find and open.

.PP
Occasionally the filterator output looks as through the code has failed to properly merge two or more overlapping line ranges, When this happens, the ranges have different match sets; they may overlap in one tree, but not in others. A clue to this is the number of matches reported for each range.

.SH "AUTHOR"

.PP
Eric S. Raymond <esr@snark.thyrsus.com>. See ESR's home page at \fIhttp://www.catb.org/~esr/\fR for updates and other resources.

.SH "LIMITATIONS"

.PP
comparator does not attempt to do semantic analysis and catch relatively trivial changes like renaming of variables, etc. This is because comparator is designed not as a tool to detect plagiarism of ideas (the subject of patent law), but as a tool to detect copying of the expression of ideas (the subject of copyright law). Normalizing the code in excessively clever ways would trespass into the territory of ideas and tend to produce false positives.

.PP
The heuristic for eligible files can be fooled, though this is unlikely.

.PP
The use of MD5 hashes means there is a very small probability of false-positive matches between shreds -- 1 in 18,446,744,073,709,551,616, to be precise. (You will probably be struck by a meteor or spontaneously combust before this happens.) There is no possibility of false negatives.

.PP
This program handles a maximum of 65536 lines per file. A full integer line-number range would increase working-set size by 20%.

.PP
You will get spurious results if you mix \fI.scf\fR files with different shred sizes or normalizations, or with settings for these that conflict with the command-line options you have in effect for shredding source-code trees. The program does some sanity checking but will not prevent you from shooting yourself in the foot.

.PP
The implementation is O(n log n) in the size of the code trees and O(n2) in the number of common segments. The code for finding duplicate hashes uses a brute-force approach that relies on being able to allocate core for the entire hash list generated during processing. The results are almost ridiculously fast on machines with enough core (the author has observed speeds of up to two million lines of code compared per minute on a 1.8GHz Intel box), but machines with small memories will thrash their guts out as the VM subsystem tries to cope.

